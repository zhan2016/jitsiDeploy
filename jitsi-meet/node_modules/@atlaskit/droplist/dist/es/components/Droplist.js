import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import Layer from '@atlaskit/layer';
import Spinner from '@atlaskit/spinner';
import { ThemeProvider } from 'styled-components';
import { gridSize } from '@atlaskit/theme';
import Wrapper, { Content, SpinnerContainer, Trigger } from '../styled/Droplist';
import itemTheme from '../theme/item-theme';

var halfFocusRing = 1;
var dropOffset = '0 ' + gridSize() + 'px';

var Droplist = function (_Component) {
  _inherits(Droplist, _Component);

  function Droplist() {
    var _temp, _this, _ret;

    _classCallCheck(this, Droplist);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.componentDidMount = function () {
      _this.setContentWidth();
      // We use a captured event here to avoid a radio or checkbox dropdown item firing its
      // click event first, which would cause a re-render of the element and prevent Droplist
      // from detecting the actual source of this original click event.
      document.addEventListener('click', _this.handleClickOutside, true);
      document.addEventListener('keydown', _this.handleEsc);
    }, _this.componentDidUpdate = function () {
      if (_this.props.isOpen) {
        _this.setContentWidth();
      }
    }, _this.componentWillUnmount = function () {
      document.removeEventListener('click', _this.handleClickOutside, true);
      document.removeEventListener('keydown', _this.handleEsc);
    }, _this.setContentWidth = function () {
      var _this2 = _this,
          dropContentRef = _this2.dropContentRef,
          triggerRef = _this2.triggerRef;
      var shouldFitContainer = _this.props.shouldFitContainer;

      // We need to manually set the content width to match the trigger width
      // if props.shouldFitContainer is true

      if (shouldFitContainer && dropContentRef && triggerRef) {
        dropContentRef.style.width = triggerRef.offsetWidth - halfFocusRing * 2 + 'px';
      }
    }, _this.handleEsc = function (event) {
      if (event.key === 'Escape') {
        _this.close(event);
      }
    }, _this.handleClickOutside = function (event) {
      if (_this.props.isOpen) {
        var domNode = ReactDOM.findDOMNode(_this); // eslint-disable-line react/no-find-dom-node
        if (!domNode || event.target instanceof Node && !domNode.contains(event.target)) {
          _this.close(event);
        }
      }
    }, _this.close = function (event) {
      _this.props.onOpenChange({ isOpen: false, event: event });
    }, _this.handleContentRef = function (ref) {
      _this.dropContentRef = ref;

      // If the dropdown has just been opened, we focus on the containing element so the
      // user can tab to the first dropdown item. We will only receive this ref if isOpen
      // is true or null, so no need to check for truthiness here.
      if (ref) {
        ref.focus();
      }
    }, _this.handleTriggerRef = function (ref) {
      return _this.triggerRef = ref;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Droplist.prototype.getChildContext = function getChildContext() {
    return { shouldAllowMultilineItems: this.props.shouldAllowMultilineItems };
  };

  Droplist.prototype.render = function render() {
    var _props = this.props,
        appearance = _props.appearance,
        boundariesElement = _props.boundariesElement,
        children = _props.children,
        isLoading = _props.isLoading,
        isOpen = _props.isOpen,
        maxHeight = _props.maxHeight,
        onClick = _props.onClick,
        onKeyDown = _props.onKeyDown,
        position = _props.position,
        shouldFitContainer = _props.shouldFitContainer,
        shouldFlip = _props.shouldFlip,
        trigger = _props.trigger;


    var layerContent = isOpen ? React.createElement(
      Content,
      {
        'data-role': 'droplistContent',
        isTall: appearance === 'tall',
        innerRef: this.handleContentRef,
        maxHeight: maxHeight
      },
      isLoading ? React.createElement(
        SpinnerContainer,
        null,
        React.createElement(Spinner, { size: 'small' })
      ) : React.createElement(
        ThemeProvider,
        { theme: itemTheme },
        React.createElement(
          'div',
          null,
          children
        )
      )
    ) : null;

    return React.createElement(
      Wrapper,
      {
        fit: shouldFitContainer,
        onClick: onClick,
        onKeyDown: onKeyDown
      },
      React.createElement(
        Layer,
        {
          autoFlip: shouldFlip,
          boundariesElement: boundariesElement,
          content: layerContent,
          offset: dropOffset,
          position: position
        },
        React.createElement(
          Trigger,
          {
            fit: shouldFitContainer,
            innerRef: this.handleTriggerRef
          },
          trigger
        )
      )
    );
  };

  return Droplist;
}(Component);

Droplist.propTypes = {
  /**
    * Controls the appearance of the menu.
    * Default menu has scroll after its height exceeds the pre-defined amount.
    * Tall menu has no restrictions.
    */
  appearance: PropTypes.oneOf(['default', 'tall']),
  /** Value passed to the Layer component to determine when to reposition the droplist */
  boundariesElement: PropTypes.oneOf(['viewport', 'window', 'scrollParent']),
  /** Content that will be rendered inside the layer element. Should typically be
    * `DropdownItemGroup` or `DropdownItem`, or checkbox / radio variants of those. */
  children: PropTypes.node,
  /** If true, a Spinner is rendered instead of the items */
  isLoading: PropTypes.bool,
  /** Controls the open state of the drop list. */
  isOpen: PropTypes.bool,
  onClick: PropTypes.func,
  onKeyDown: PropTypes.func,
  onOpenChange: PropTypes.func,
  /** Position of the menu. See the documentation of @atlastkit/layer for more details. */
  position: PropTypes.string,
  /** Deprecated. Option to display multiline items when content is too long.
    * Instead of ellipsing the overflown text it causes item to flow over multiple lines.
    */
  shouldAllowMultilineItems: PropTypes.bool,
  /** Option to fit dropdown menu width to its parent width */
  shouldFitContainer: PropTypes.bool,
  /** Allows the dropdown menu to be placed on the opposite side of its trigger if it does not
    * fit in the viewport. */
  shouldFlip: PropTypes.bool,
  /** Controls the height at which scroll bars will appear on the drop list. */
  maxHeight: PropTypes.number,
  /** Content which will trigger the drop list to open and close. */
  trigger: PropTypes.node
};
Droplist.defaultProps = {
  appearance: 'default',
  boundariesElement: 'viewport',
  children: null,
  isLoading: false,
  isOpen: false,
  onClick: function onClick() {},
  onKeyDown: function onKeyDown() {},
  onOpenChange: function onOpenChange() {},
  position: 'bottom left',
  shouldAllowMultilineItems: false,
  shouldFitContainer: false,
  shouldFlip: true,
  trigger: null
};
Droplist.childContextTypes = {
  shouldAllowMultilineItems: PropTypes.bool
};
export default Droplist;