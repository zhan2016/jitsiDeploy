import _defineProperty from 'babel-runtime/helpers/defineProperty';
import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import find from 'array-find';
import { selectionCacheContext } from '../../util/contextNamespace';


var isItemInList = function isItemInList(itemList, itemId, groupId) {
  return Boolean(find(itemList, function (item) {
    return item.id === itemId && item.groupId === groupId;
  }));
};

var DropdownItemSelectionCache = function (_Component) {
  _inherits(DropdownItemSelectionCache, _Component);

  function DropdownItemSelectionCache() {
    var _temp, _this, _ret;

    _classCallCheck(this, DropdownItemSelectionCache);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
      lastCacheUpdate: 0
    }, _this.selectedItems = [], _this.alreadyDefaultedItems = [], _this.handleItemSelectionsChanged = function (groupId, newGroupSelections) {
      var newSelectedItems = [].concat(_toConsumableArray(_this.selectedItems.filter(function (item) {
        return item.groupId !== groupId;
      })), _toConsumableArray(newGroupSelections));

      _this.selectedItems = newSelectedItems;

      // We store selectedItems in an instance variable (this.selectedItems) instead of state,
      // because if multiple children update the cache at the same time it causes unexpected
      // behaviour due to the asynchronous behaviour of setState. So we need to trigger setState
      // with a different value to cause the children to be updated with their new selection values.
      _this.setState({ lastCacheUpdate: Date.now() });
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  // Need to store selectedItemValues in state rather than component instance property
  // to ensure that re-render happens down the tree via context when selectedItemValues
  // is updated.
  // eslint-disable-line react/sort-comp

  // If any radio/checkbox items have defaultSelected applied, we need to keep track of whether
  // each of those items has had it's state set to 'selected'. This is because when the dropdown
  // menu is closed and then opened again, all of the radio/checkbox items re-mount so they
  // try to again apply their defaultSelected status. defaultSelected should only be applied on
  // the initial mount, as users can change the value post-mount. Alternatively, products can use
  // the isSelected prop with the onClick handler to control the selected state manually if needed.


  // eslint-disable-line react/sort-comp

  DropdownItemSelectionCache.prototype.getChildContext = function getChildContext() {
    var _this2 = this;

    return _defineProperty({}, selectionCacheContext, {
      // This function returns true/false describing whether the supplied navigation item
      // (which must have a unique item and group ID) is currently selected - this is used
      // by radio and checkbox dropdown items to retreive their 'selected' state when they
      // re-mount, which happens when the dropdown is closed and then re-opened.
      isItemSelected: function isItemSelected(groupId, itemId) {
        return isItemInList(_this2.selectedItems, itemId, groupId);
      },
      itemsInGroup: function itemsInGroup(groupId) {
        return _this2.selectedItems.filter(function (item) {
          return item.groupId === groupId;
        });
      },
      itemSelectionsChanged: this.handleItemSelectionsChanged,
      hasItemAlreadyHadDefaultSelectedApplied: function hasItemAlreadyHadDefaultSelectedApplied(groupId, itemId) {
        return isItemInList(_this2.alreadyDefaultedItems, itemId, groupId);
      },
      markItemAsDefaultApplied: function markItemAsDefaultApplied(groupId, itemId) {
        _this2.alreadyDefaultedItems.push({ id: itemId, groupId: groupId });
      }
    });
  };

  DropdownItemSelectionCache.prototype.render = function render() {
    return React.createElement(
      'div',
      null,
      this.props.children
    );
  };

  return DropdownItemSelectionCache;
}(Component);

DropdownItemSelectionCache.propTypes = {
  children: PropTypes.node
};
DropdownItemSelectionCache.childContextTypes = _defineProperty({}, selectionCacheContext, PropTypes.shape({
  isItemSelected: PropTypes.func,
  itemsInGroup: PropTypes.func,
  itemSelectionsChanged: PropTypes.func
}));
export default DropdownItemSelectionCache;