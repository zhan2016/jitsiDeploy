import _extends from 'babel-runtime/helpers/extends';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import _PropTypes from 'prop-types';
import React, { Component } from 'react';
import { findDOMNode } from 'react-dom';
import uid from 'uid';
import Button from '@atlaskit/button';
import Droplist, { Item, Group } from '@atlaskit/droplist';
import ExpandIcon from '@atlaskit/icon/glyph/chevron-down';

import DropdownItemFocusManager from './context/DropdownItemFocusManager';
import DropdownItemClickManager from './context/DropdownItemClickManager';
import DropdownItemSelectionCache from './context/DropdownItemSelectionCache';
import WidthConstrainer from '../styled/WidthConstrainer';
import { KEY_DOWN, KEY_SPACE, KEY_ENTER } from '../util/keys';

var DropdownMenuStateless = function (_Component) {
  _inherits(DropdownMenuStateless, _Component);

  function DropdownMenuStateless() {
    var _temp, _this, _ret;

    _classCallCheck(this, DropdownMenuStateless);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
      id: uid()
    }, _this.componentDidMount = function () {
      if (_this.isUsingDeprecatedAPI()) {
        if (process.env.NODE_ENV !== 'test' && process.env.NODE_ENV !== 'production') {
          // eslint-disable-next-line no-console
          console.log('DropdownMenu.items is deprecated. Please switch to the declarative API.');
        }

        if (_this.domItemsList) {
          _this.focusFirstItem();
        }
      }
    }, _this.componentDidUpdate = function (prevProp) {
      if (_this.isUsingDeprecatedAPI() && _this.props.isOpen && !prevProp.isOpen) {
        _this.focusFirstItem();
      }
    }, _this.getNextFocusable = function (indexItem, available) {
      if (!_this.domItemsList) {
        return null;
      }

      var currentItem = typeof indexItem !== 'number' ? -1 : indexItem;
      var latestAvailable = typeof available !== 'number' ? currentItem : available;

      if (currentItem < _this.domItemsList.length - 1) {
        currentItem++;

        if (_this.domItemsList[currentItem].getAttribute('aria-hidden') !== 'true') {
          return currentItem;
        }

        return _this.getNextFocusable(currentItem, latestAvailable);
      }

      return latestAvailable;
    }, _this.getPrevFocusable = function (indexItem, available) {
      if (!_this.domItemsList) {
        return null;
      }

      var currentItem = typeof indexItem !== 'number' ? -1 : indexItem;
      var latestAvailable = typeof available !== 'number' ? currentItem : available;

      if (currentItem && currentItem > 0) {
        currentItem--;

        if (_this.domItemsList[currentItem].getAttribute('aria-hidden') !== 'true') {
          return currentItem;
        }

        return _this.getPrevFocusable(currentItem, latestAvailable);
      }

      return latestAvailable || currentItem;
    }, _this.focusFirstItem = function () {
      if (_this.sourceOfIsOpen === 'keydown') {
        _this.focusItem(_this.getNextFocusable());
      }
    }, _this.focusNextItem = function () {
      _this.focusItem(_this.getNextFocusable(_this.focusedItem));
    }, _this.focusPreviousItem = function () {
      _this.focusItem(_this.getPrevFocusable(_this.focusedItem));
    }, _this.focusItem = function (index) {
      if (!_this.domItemsList || !index) {
        return;
      }

      _this.focusedItem = index;
      _this.domItemsList[_this.focusedItem].focus();
    }, _this.isTargetChildItem = function (target) {
      if (!target) return false;

      var isDroplistItem = target.getAttribute('data-role') === 'droplistItem';

      // eslint-disable-next-line react/no-find-dom-node
      var thisDom = findDOMNode(_this);
      return isDroplistItem && thisDom ? thisDom.contains(target) : false;
    }, _this.handleKeyboardInteractionForClosed = function (event) {
      if (_this.props.isOpen) {
        return;
      }

      switch (event.key) {
        case KEY_DOWN:
        case KEY_SPACE:
        case KEY_ENTER:
          event.preventDefault();
          _this.open({ event: event, source: 'keydown' });
          break;
        default:
          break;
      }
    }, _this.handleKeyboardInteractionsDeprecated = function (event) {
      // KeyboardEvent.target is typed as an EventTarget but we need to access methods on it which
      // are specific to Element. Due limitations of the HTML spec flow doesn't know that an
      // EventTarget can have these methods, so we cast it to Element through Object. This is the
      // safest thing we can do in this situation.
      var target = event.target;
      if (_this.props.isOpen) {
        if (_this.isTargetChildItem(target)) {
          switch (event.key) {
            case 'ArrowUp':
              event.preventDefault();
              _this.focusPreviousItem();
              break;
            case 'ArrowDown':
              event.preventDefault();
              _this.focusNextItem();
              break;
            case 'Tab':
              event.preventDefault();
              _this.close({ event: event });
              break;
            default:
              break;
          }
        } else if (event.key === 'ArrowDown') {
          _this.sourceOfIsOpen = 'keydown';
          _this.focusFirstItem();
        } else if (event.key === 'Tab') {
          _this.close({ event: event });
        }
      } else {
        switch (event.key) {
          case KEY_DOWN:
          case KEY_SPACE:
          case KEY_ENTER:
            event.preventDefault();
            _this.open({ event: event, source: 'keydown' });
            break;
          default:
            break;
        }
      }
    }, _this.handleClickDeprecated = function (event) {
      var menuContainer = _this.domMenuContainer;
      // Casting target to Element. See comment in `handleKeyboardInteractionsDeprecated`.
      var target = event.target;
      if (!menuContainer || menuContainer && !menuContainer.contains(target)) {
        _this.toggle({ source: 'click', event: event });
      }
    }, _this.isUsingDeprecatedAPI = function () {
      return Boolean(_this.props.items.length);
    }, _this.handleClick = function (event) {
      if (_this.isUsingDeprecatedAPI()) {
        _this.handleClickDeprecated(event);
        return;
      }

      var _this2 = _this,
          triggerContainer = _this2.triggerContainer;
      // Casting target to Element. See comment in `handleKeyboardInteractionsDeprecated`.

      var target = event.target;
      if (triggerContainer && triggerContainer.contains(target)) {
        var isOpen = _this.props.isOpen;

        _this.sourceOfIsOpen = 'mouse';
        _this.props.onOpenChange({ isOpen: !isOpen, event: event });
      }
    }, _this.triggerContent = function () {
      var _this$props = _this.props,
          children = _this$props.children,
          trigger = _this$props.trigger,
          isOpen = _this$props.isOpen,
          triggerButtonProps = _this$props.triggerButtonProps,
          triggerType = _this$props.triggerType;

      var insideTriggerContent = _this.isUsingDeprecatedAPI() ? children : trigger;

      if (triggerType !== 'button') {
        return insideTriggerContent;
      }

      var triggerProps = _extends({}, triggerButtonProps);
      var defaultButtonProps = {
        ariaControls: _this.state.id,
        ariaExpanded: isOpen,
        ariaHaspopup: true,
        isSelected: isOpen
      };
      if (!triggerProps.iconAfter && !triggerProps.iconBefore) {
        triggerProps.iconAfter = React.createElement(ExpandIcon, { size: 'medium', label: '' });
      }
      return React.createElement(
        Button,
        _extends({}, defaultButtonProps, triggerProps),
        insideTriggerContent
      );
    }, _this.open = function (attrs) {
      _this.sourceOfIsOpen = attrs.source;
      _this.props.onOpenChange({ isOpen: true, event: attrs.event });
    }, _this.close = function (attrs) {
      _this.sourceOfIsOpen = null;
      _this.props.onOpenChange({ isOpen: false, event: attrs.event });
    }, _this.toggle = function (attrs) {
      if (attrs.source === 'keydown') return;

      if (_this.props.isOpen) {
        _this.close(attrs);
      } else {
        _this.open(attrs);
      }
    }, _this.handleItemClicked = function (event) {
      _this.props.onOpenChange({ isOpen: false, event: event });
    }, _this.renderTrigger = function () {
      var triggerContent = _this.triggerContent();
      return _this.isUsingDeprecatedAPI() ? triggerContent : React.createElement(
        'div',
        { ref: function ref(_ref) {
            _this.triggerContainer = _ref;
          } },
        triggerContent
      );
    }, _this.renderItems = function (items) {
      return items.map(function (item, itemIndex) {
        return React.createElement(
          Item,
          _extends({}, item, {
            key: itemIndex,
            onActivate: function onActivate(_ref2) {
              var event = _ref2.event;

              _this.props.onItemActivated({ item: item, event: event });
            }
          }),
          item.content
        );
      });
    }, _this.renderGroups = function (groups) {
      return groups.map(function (group, groupIndex) {
        return React.createElement(
          Group,
          { heading: group.heading, elemAfter: group.elemAfter, key: groupIndex },
          _this.renderItems(group.items)
        );
      });
    }, _this.renderDeprecated = function () {
      var _this$props2 = _this.props,
          items = _this$props2.items,
          shouldFitContainer = _this$props2.shouldFitContainer;
      var id = _this.state.id;


      return React.createElement(
        'div',
        {
          id: id,
          ref: function ref(_ref3) {
            _this.domMenuContainer = _ref3;
            _this.domItemsList = _ref3 ? _ref3.querySelectorAll('[data-role="droplistItem"]') : null;
          },
          role: 'menu',
          style: shouldFitContainer ? null : { maxWidth: 300 }
        },
        _this.renderGroups(items)
      );
    }, _temp), _possibleConstructorReturn(_this, _ret);
  } // eslint-disable-line react/sort-comp

  DropdownMenuStateless.prototype.render = function render() {
    var _props = this.props,
        appearance = _props.appearance,
        boundariesElement = _props.boundariesElement,
        children = _props.children,
        isLoading = _props.isLoading,
        isOpen = _props.isOpen,
        onOpenChange = _props.onOpenChange,
        position = _props.position,
        shouldAllowMultilineItems = _props.shouldAllowMultilineItems,
        shouldFitContainer = _props.shouldFitContainer,
        shouldFlip = _props.shouldFlip;
    var id = this.state.id;

    var isDeprecated = this.isUsingDeprecatedAPI();

    var deprecatedProps = isDeprecated ? {
      onKeyDown: this.handleKeyboardInteractionsDeprecated,
      shouldAllowMultilineItems: shouldAllowMultilineItems
    } : {
      onKeyDown: this.handleKeyboardInteractionForClosed
    };

    return React.createElement(
      DropdownItemSelectionCache,
      null,
      React.createElement(
        Droplist,
        _extends({
          appearance: appearance,
          boundariesElement: boundariesElement,
          isLoading: isLoading,
          isOpen: isOpen,
          onClick: this.handleClick,
          onOpenChange: onOpenChange,
          position: position,
          shouldFitContainer: shouldFitContainer,
          shouldFlip: shouldFlip,
          trigger: this.renderTrigger()
        }, deprecatedProps),
        isDeprecated ? this.renderDeprecated() : React.createElement(
          WidthConstrainer,
          {
            id: id,
            role: 'menu',
            shouldFitContainer: shouldFitContainer
          },
          React.createElement(
            DropdownItemClickManager,
            { onItemClicked: this.handleItemClicked },
            React.createElement(
              DropdownItemFocusManager,
              { autoFocus: this.sourceOfIsOpen === 'keydown' },
              children
            )
          )
        )
      )
    );
  };

  return DropdownMenuStateless;
}(Component);

DropdownMenuStateless.propTypes = {
  /**
    * Controls the appearance of the menu.
    * Default menu has scroll after its height exceeds the pre-defined amount.
    * Tall menu has no restrictions.
    */appearance: _PropTypes.oneOf(['default', 'tall']).isRequired /** Value passed to the Layer component to determine when to reposition the droplist */,
  boundariesElement: _PropTypes.oneOf(['viewport', 'window', 'scrollParent']).isRequired /** Content that will be rendered inside the layer element. Should typically be
                                                                                           * `DropdownItemGroup` or `DropdownItem`, or checkbox / radio variants of those. */,
  children: _PropTypes.any /** If true, a Spinner is rendered instead of the items */,
  isLoading: _PropTypes.bool.isRequired /** Controls the open state of the dropdown. */,
  isOpen: _PropTypes.bool.isRequired /** Deprecated. An array of groups. Every group must contain an array of items */,
  items: _PropTypes.arrayOf(_PropTypes.shape({
    elemAfter: _PropTypes.any,
    heading: _PropTypes.string,
    items: _PropTypes.arrayOf(_PropTypes.shape({
      content: _PropTypes.string,
      elemBefore: _PropTypes.any,
      href: _PropTypes.string,
      isDisabled: _PropTypes.bool,
      target: _PropTypes.oneOf(['_blank', '_self'])
    })).isRequired
  })).isRequired /** Deprecated. Called when an item is activated. Receives an object with the activated item. */,
  onItemActivated: _PropTypes.func.isRequired /** Position of the menu. See the documentation of @atlastkit/layer for more details. */,
  position: _PropTypes.string.isRequired /** Deprecated. Option to display multiline items when content is too long.
                                           * Instead of ellipsing the overflown text it causes item to flow over multiple lines.
                                           */,
  shouldAllowMultilineItems: _PropTypes.bool.isRequired /** Option to fit dropdown menu width to its parent width */,
  shouldFitContainer: _PropTypes.bool.isRequired /** Allows the dropdown menu to be placed on the opposite side of its trigger if it does not
                                                   * fit in the viewport. */,
  shouldFlip: _PropTypes.bool.isRequired /** Content which will trigger the dropdown menu to open and close. Use with `triggerType`
                                           * to easily get a button trigger. */,
  trigger: _PropTypes.oneOfType([_PropTypes.any, _PropTypes.string]) /** Props to pass through to the trigger button. See @atlaskit/button for allowed props. */,
  triggerButtonProps: _PropTypes.shape({}).isRequired /** Controls the type of trigger to be used for the dropdown menu. The default trigger allows
                                                        * you to supply your own trigger component. Setting this prop to `button` will render a
                                                        * Button component with an 'expand' icon, and the `trigger` prop contents inside the
                                                        * button. */,
  triggerType: _PropTypes.oneOf(['default', 'button']).isRequired,
  /** Called when the menu should be open/closed. Received an object with isOpen state. */onOpenChange: _PropTypes.func.isRequired
};
DropdownMenuStateless.defaultProps = {
  appearance: 'default',
  boundariesElement: 'viewport',
  isLoading: false,
  isOpen: false,
  items: [],
  onItemActivated: function onItemActivated() {},
  onOpenChange: function onOpenChange() {},
  position: 'bottom left',
  shouldAllowMultilineItems: false,
  shouldFitContainer: false,
  shouldFlip: true,
  triggerButtonProps: {},
  triggerType: 'default'
};
export default DropdownMenuStateless;