import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import _PropTypes from 'prop-types';
import React, { Component } from 'react';
import StatelessMenu from './DropdownMenuStateless';

var DropdownMenu = function (_Component) {
  _inherits(DropdownMenu, _Component);

  function DropdownMenu() {
    var _temp, _this, _ret;

    _classCallCheck(this, DropdownMenu);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
      isOpen: _this.props.defaultOpen,
      items: [].concat(_toConsumableArray(_this.props.items))
    }, _this.findActivatedGroup = function (item) {
      return _this.state.items.filter(function (group) {
        return group.items.indexOf(item) > -1;
      })[0];
    }, _this.handleItemActivation = function (attrs) {
      var activatedItem = attrs.item;
      var activatedGroup = _this.findActivatedGroup(activatedItem);
      var items = [].concat(_toConsumableArray(_this.state.items));

      switch (activatedItem.type) {
        case 'checkbox':
          activatedItem.isChecked = !activatedItem.isChecked;
          _this.props.onItemActivated({ item: activatedItem });
          _this.setState({ items: items });
          break;
        case 'radio':
          activatedGroup.items.forEach(function (i) {
            if (i === activatedItem) {
              i.isChecked = true;
            } else {
              i.isChecked = false;
            }
          });
          _this.props.onItemActivated({ item: activatedItem });
          _this.setState({ items: items });
          break;
        case 'link':
        default:
          _this.props.onItemActivated({ item: activatedItem });
          _this.close();
          break;
      }
    }, _this.handleOpenChange = function (attrs) {
      _this.setState({ isOpen: attrs.isOpen });
      _this.props.onOpenChange(attrs);
    }, _this.close = function () {
      _this.setState({ isOpen: false });
      _this.props.onOpenChange({ isOpen: false });
    }, _temp), _possibleConstructorReturn(_this, _ret);
  } // eslint-disable-line react/sort-comp

  DropdownMenu.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.items !== this.state.items) {
      this.setState({ items: [].concat(_toConsumableArray(nextProps.items)) });
    }
    if (nextProps.isOpen !== this.props.isOpen) {
      this.setState({ isOpen: nextProps.isOpen });
    }
  }; // eslint-disable-line

  DropdownMenu.prototype.render = function render() {
    var isOpen = this.state.isOpen;
    var _props = this.props,
        appearance = _props.appearance,
        boundariesElement = _props.boundariesElement,
        children = _props.children,
        isLoading = _props.isLoading,
        items = _props.items,
        position = _props.position,
        shouldAllowMultilineItems = _props.shouldAllowMultilineItems,
        shouldFitContainer = _props.shouldFitContainer,
        shouldFlip = _props.shouldFlip,
        trigger = _props.trigger,
        triggerButtonProps = _props.triggerButtonProps,
        triggerType = _props.triggerType;


    return React.createElement(
      StatelessMenu,
      {
        appearance: appearance,
        boundariesElement: boundariesElement,
        isOpen: isOpen,
        isLoading: isLoading,
        items: items,
        onItemActivated: this.handleItemActivation,
        onOpenChange: this.handleOpenChange,
        position: position,
        shouldAllowMultilineItems: shouldAllowMultilineItems,
        shouldFitContainer: shouldFitContainer,
        shouldFlip: shouldFlip,
        trigger: trigger,
        triggerButtonProps: triggerButtonProps,
        triggerType: triggerType
      },
      children
    );
  };

  return DropdownMenu;
}(Component);

DropdownMenu.propTypes = {
  /**
    * Controls the appearance of the menu.
    * Default menu has scroll after its height exceeds the pre-defined amount.
    * Tall menu has no restrictions.
    */appearance: _PropTypes.oneOf(['default', 'tall']).isRequired /** Value passed to the Layer component to determine when to reposition the droplist */,
  boundariesElement: _PropTypes.oneOf(['viewport', 'window', 'scrollParent']).isRequired /** Content that will be rendered inside the layer element. Should typically be
                                                                                           * `DropdownItemGroup` or `DropdownItem`, or checkbox / radio variants of those. */,
  children: _PropTypes.any /** If true, a Spinner is rendered instead of the items */,
  isLoading: _PropTypes.bool.isRequired /** Controls the open state of the dropdown. */,
  isOpen: _PropTypes.bool.isRequired /** Deprecated. An array of groups. Every group must contain an array of items */,
  items: _PropTypes.arrayOf(_PropTypes.shape({
    elemAfter: _PropTypes.any,
    heading: _PropTypes.string,
    items: _PropTypes.arrayOf(_PropTypes.shape({
      content: _PropTypes.string,
      elemBefore: _PropTypes.any,
      href: _PropTypes.string,
      isDisabled: _PropTypes.bool,
      target: _PropTypes.oneOf(['_blank', '_self'])
    })).isRequired
  })).isRequired /** Deprecated. Called when an item is activated. Receives an object with the activated item. */,
  onItemActivated: _PropTypes.func.isRequired /** Position of the menu. See the documentation of @atlastkit/layer for more details. */,
  position: _PropTypes.string.isRequired /** Deprecated. Option to display multiline items when content is too long.
                                           * Instead of ellipsing the overflown text it causes item to flow over multiple lines.
                                           */,
  shouldAllowMultilineItems: _PropTypes.bool.isRequired /** Option to fit dropdown menu width to its parent width */,
  shouldFitContainer: _PropTypes.bool.isRequired /** Allows the dropdown menu to be placed on the opposite side of its trigger if it does not
                                                   * fit in the viewport. */,
  shouldFlip: _PropTypes.bool.isRequired /** Content which will trigger the dropdown menu to open and close. Use with `triggerType`
                                           * to easily get a button trigger. */,
  trigger: _PropTypes.oneOfType([_PropTypes.any, _PropTypes.string]) /** Props to pass through to the trigger button. See @atlaskit/button for allowed props. */,
  triggerButtonProps: _PropTypes.shape({}).isRequired /** Controls the type of trigger to be used for the dropdown menu. The default trigger allows
                                                        * you to supply your own trigger component. Setting this prop to `button` will render a
                                                        * Button component with an 'expand' icon, and the `trigger` prop contents inside the
                                                        * button. */,
  triggerType: _PropTypes.oneOf(['default', 'button']).isRequired,
  /** Controls the initial open state of the dropdown. */defaultOpen: _PropTypes.bool.isRequired /** Called when the menu is open or closed. Received an object with isOpen state. */,
  onOpenChange: _PropTypes.func.isRequired
};
DropdownMenu.defaultProps = {
  appearance: 'default',
  boundariesElement: 'viewport',
  defaultOpen: false,
  isLoading: false,
  isOpen: false,
  items: [],
  onItemActivated: function onItemActivated() {},
  onOpenChange: function onOpenChange() {},
  position: 'bottom left',
  shouldAllowMultilineItems: false,
  shouldFitContainer: false,
  shouldFlip: true,
  triggerButtonProps: {},
  triggerType: 'default'
};
export default DropdownMenu;