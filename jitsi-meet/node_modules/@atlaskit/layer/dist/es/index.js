import _extends from 'babel-runtime/helpers/extends';
import _typeof from 'babel-runtime/helpers/typeof';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import PropTypes from 'prop-types';
import React, { PureComponent } from 'react';
import { akZIndexLayer } from '@atlaskit/util-shared-styles';
import Popper from '../popper.js/index.min';

import { POSITION_ATTRIBUTE_ENUM, getFlipBehavior, positionPropToPopperPosition } from './internal/helpers';
import ContentContainer from './styledContentContainer';
/* eslint-disable react/no-unused-prop-types */

var Layer = function (_PureComponent) {
  _inherits(Layer, _PureComponent);

  function Layer(props) {
    _classCallCheck(this, Layer);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.extractStyles = function (state) {
      if (state) {
        var popperHeight = state.offsets.popper.height;
        var left = Math.round(state.offsets.popper.left);
        // The offset position is sometimes an object and sometimes just a string...
        var cssPosition = _typeof(state.offsets.popper.position) === 'object' ? state.offsets.popper.position.position : state.offsets.popper.position;
        var top = _this.fixPositionTopUnderflow(state.offsets.popper.top, cssPosition);

        var originalHeight = _this.state.originalHeight || popperHeight;
        var maxHeight = _this.calculateMaxHeight(originalHeight, popperHeight, top, cssPosition);
        _this.setState({
          hasExtractedStyles: true,
          // position: fixed or absolute
          cssPosition: state.offsets.popper.position,
          transform: 'translate3d(' + left + 'px, ' + top + 'px, 0px)',
          // state.flipped is either true or undefined
          flipped: !!state.flipped,
          actualPosition: state.position,
          originalPosition: state.originalPosition,
          originalHeight: originalHeight,
          maxHeight: maxHeight
        });
      }
    };

    _this.state = {
      hasExtractedStyles: false,
      position: null,
      transform: null,
      flipped: false,
      actualPosition: null,
      // We set these default offsets to prevent a flash of popper content in the wrong position
      // which can cause incorrect height calculations. Popper will calculate these values
      offsets: {
        popper: {
          left: -9999,
          top: -9999
        }
      },
      originalPosition: null,
      // fix Safari parent width: https://product-fabric.atlassian.net/browse/ED-1784
      cssPosition: 'absolute',
      originalHeight: null,
      maxHeight: null
    };
    _this.extractStyles = _this.extractStyles.bind(_this);
    return _this;
  }

  Layer.prototype.componentDidMount = function componentDidMount() {
    this.applyPopper(this.props);
  };

  Layer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    this.applyPopper(nextProps);
  };

  Layer.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevState.flipped !== this.state.flipped) {
      this.props.onFlippedChange({
        flipped: this.state.flipped,
        actualPosition: this.state.actualPosition,
        originalPosition: this.state.originalPosition
      });
    }
  };

  Layer.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.popper) {
      this.popper.destroy();
    }
  };

  /* Calculate the max height of the popper if it's height is greater than the viewport to prevent
   * the bottom of the popper not being viewable.
   * Only works if the popper uses viewport as the boundary and has a fixed position ancestor.
   */


  Layer.prototype.calculateMaxHeight = function calculateMaxHeight(originalHeight, currentHeight, positionTop, cssPosition) {
    if (cssPosition !== 'fixed' || this.props.boundariesElement !== 'viewport') {
      return null;
    }

    var viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    return viewportHeight < originalHeight && currentHeight + positionTop >= viewportHeight - 50 ?
    // allow some spacing either side of viewport height
    viewportHeight - 12 : null;
  };

  /* Clamp fixed position to the window for fixed position poppers that flow off the top of the
   * window.
   * A fixed position popper is a popper who has an ancestor with position: fixed.
   *
   * It is too difficult to fix this for non-fixed position poppers without re-implementing popper's
   * offset functionality or fixing the issue upstream.
   */
  // eslint-disable-next-line class-methods-use-this


  Layer.prototype.fixPositionTopUnderflow = function fixPositionTopUnderflow(popperTop, cssPosition) {
    return popperTop >= 0 || cssPosition !== 'fixed' ? popperTop : 0;
  };

  Layer.prototype.applyPopper = function applyPopper(props) {
    if (!this.targetRef || !this.contentRef) {
      return;
    }

    if (this.popper) {
      this.popper.destroy();
    }

    // "new Popper(...)" operation is very expensive when called on virtual DOM.
    // This condition reduces the number of calls so we can run our tests faster
    // (time was reduced from 100s to 13s).
    if (!props.content) {
      return;
    }

    // we wrap our target in a div so that we can safely get a reference to it, but we pass the
    // actual target to popper
    var actualTarget = this.targetRef.firstChild;

    var popperOpts = {
      placement: positionPropToPopperPosition(props.position),
      onCreate: this.extractStyles,
      onUpdate: this.extractStyles,
      modifiers: {
        applyStyle: {
          enabled: false
        },
        hide: {
          enabled: false
        },
        offset: {
          enabled: true,
          offset: this.props.offset
        },
        flip: {
          enabled: !!this.props.autoFlip,
          flipVariations: true,
          boundariesElement: this.props.boundariesElement,
          padding: 0 },
        preventOverflow: {
          enabled: !!this.props.autoFlip,
          escapeWithReference: true
        }
      }
    };

    var flipBehavior = getFlipBehavior(props);
    if (flipBehavior) {
      popperOpts.modifiers.flip.behavior = flipBehavior;
    }

    this.popper = new Popper(actualTarget, this.contentRef, popperOpts);
  };

  Layer.prototype.render = function render() {
    var _this2 = this;

    var zIndex = this.props.zIndex;
    var _state = this.state,
        cssPosition = _state.cssPosition,
        transform = _state.transform,
        hasExtractedStyles = _state.hasExtractedStyles,
        maxHeight = _state.maxHeight;

    var opacity = hasExtractedStyles ? {} : { opacity: 0 };

    return React.createElement(
      'div',
      null,
      React.createElement(
        'div',
        { ref: function ref(_ref) {
            return _this2.targetRef = _ref;
          } },
        this.props.children
      ),
      React.createElement(
        ContentContainer,
        { maxHeight: maxHeight },
        React.createElement(
          'div',
          {
            ref: function ref(_ref2) {
              return _this2.contentRef = _ref2;
            },
            style: _extends({ top: 0, left: 0, position: cssPosition, transform: transform, zIndex: zIndex }, opacity)
          },
          this.props.content
        )
      )
    );
  };

  return Layer;
}(PureComponent);

/* eslint-enable react/no-unused-prop-types */


Layer.propTypes = {
  autoFlip: PropTypes.oneOfType([PropTypes.bool, PropTypes.arrayOf(PropTypes.oneOf(['top', 'right', 'bottom', 'left']))]),
  boundariesElement: PropTypes.oneOf(['viewport', 'window', 'scrollParent']),
  children: PropTypes.node,
  content: PropTypes.node,
  offset: PropTypes.string,
  onFlippedChange: PropTypes.func,
  position: PropTypes.oneOf(POSITION_ATTRIBUTE_ENUM.values),
  zIndex: PropTypes.number
};
Layer.defaultProps = {
  autoFlip: true,
  boundariesElement: 'viewport',
  children: null,
  content: null,
  offset: '0 0',
  onFlippedChange: function onFlippedChange() {},
  position: POSITION_ATTRIBUTE_ENUM.default,
  zIndex: akZIndexLayer
};
export default Layer;