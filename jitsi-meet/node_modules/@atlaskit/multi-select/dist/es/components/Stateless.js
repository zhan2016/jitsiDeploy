import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import PropTypes from 'prop-types';
import React, { PureComponent } from 'react';
import ReactDOM from 'react-dom';

import Droplist from '@atlaskit/droplist';
import { Label } from '@atlaskit/field-base';
import ExpandIcon from '@atlaskit/icon/glyph/expand';

import ItemShape from '../internal/ItemShape';
import GroupShape from '../internal/GroupShape';
import FooterShape from '../internal/FooterShape';
import { SelectWrapper } from '../styled/Stateless';
import Trigger from './Trigger';
import Footer from './Footer';
import { filterItems, getNextFocusable, getPrevFocusable, groupItems } from '../internal/sharedFunctions';
import renderGroups from './Groups';
import renderOptGroups from './Options';

var groupShape = GroupShape.propTypes;
var itemShape = ItemShape.propTypes;
var footerShape = FooterShape.propTypes;

// =============================================================
// NOTE: Duplicated in ./internal/appearances until docgen can follow imports.
// -------------------------------------------------------------
// DO NOT update values here without updating the other.
// =============================================================

var appearances = {
  values: ['default', 'subtle'],
  default: 'default'
};

var getAllValues = function getAllValues(selectedItems) {
  return selectedItems.map(function (item) {
    return item.value;
  });
};

/*

==============================+
COMPONENT CODE BEGINS HERE
==============================+

*/

var StatelessMultiSelect = function (_PureComponent) {
  _inherits(StatelessMultiSelect, _PureComponent);

  function StatelessMultiSelect() {
    var _temp, _this, _ret;

    _classCallCheck(this, StatelessMultiSelect);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = {
      isFocused: _this.props.isOpen || _this.props.shouldFocus,
      focusedItemIndex: null,
      groupedItems: groupItems(_this.props.items)
    }, _this.componentDidMount = function () {
      if (_this.state.isFocused && _this.inputNode) {
        _this.inputNode.focus();
      }
    }, _this.componentWillReceiveProps = function (nextProps) {
      if (_this.props.items !== nextProps.items) {
        _this.setState({ groupedItems: groupItems(nextProps.items) });
      }
    }, _this.componentDidUpdate = function (prevProps) {
      if (!prevProps.shouldFocus && _this.props.shouldFocus && _this.inputNode) {
        _this.inputNode.focus();
      }
    }, _this.onFocus = function () {
      if (!_this.props.isDisabled) {
        _this.setState({ isFocused: true });

        /**
         * Check if we're tabbing to the Remove button on a tag.
         * This is a hacky workaround for now and should be fixed when
         * we implement proper traversal for tags with the keyboard.
         *
         * @see {@link https://ecosystem.atlassian.net/browse/AK-2250}
         * @todo Implement traversal of tags with arrow keys, then remove this.
         */
        if (document.activeElement.tagName.toLowerCase() !== 'button') {
          _this.inputNode.focus();
        }
      }
    }, _this.onBlur = function () {
      if (!_this.props.isDisabled) {
        _this.setState({ isFocused: false });
      }
    }, _this.onOpenChange = function (attrs) {
      var target = attrs.event.target;
      // eslint-disable-next-line react/no-find-dom-node
      var tagGroup = ReactDOM.findDOMNode(_this.tagGroup);
      var tagGroupElements = tagGroup.children;
      var isInsideTagGroup = [].concat(_toConsumableArray(tagGroupElements)).some(function (node) {
        return node.contains(target) && node.tagName !== 'INPUT';
      });

      if (!isInsideTagGroup) {
        _this.props.onOpenChange(attrs);
      }

      if (attrs.isOpen) {
        tagGroup.querySelector('input').focus();
      }
    }, _this.getPlaceholder = function () {
      var _this$props = _this.props,
          isOpen = _this$props.isOpen,
          selectedItems = _this$props.selectedItems,
          placeholder = _this$props.placeholder;


      if (!isOpen && selectedItems.length === 0) {
        return placeholder;
      }

      return null;
    }, _this.getAllVisibleItems = function (groups) {
      var _this$props2 = _this.props,
          filterValue = _this$props2.filterValue,
          selectedItems = _this$props2.selectedItems;

      var allFilteredItems = [];
      groups.forEach(function (val) {
        var filteredItems = filterItems(val.items, filterValue, selectedItems);
        allFilteredItems = allFilteredItems.concat(filteredItems);
      });
      return allFilteredItems;
    }, _this.handleItemCreate = function (event) {
      var _this$props3 = _this.props,
          value = _this$props3.filterValue,
          items = _this$props3.items;

      if (value) {
        var allVisible = _this.getAllVisibleItems(items);
        var matchingElement = allVisible.filter(function (item) {
          return item.content === value;
        });
        if (!matchingElement.length) {
          _this.props.onNewItemCreated({ value: value });
        } else {
          _this.handleItemSelect(matchingElement[0], { event: event });
        }
      }
    }, _this.handleItemSelect = function (item, attrs) {
      if (!_this.isFooterFocused()) {
        // we short circuit above because when focusing on footer we don't have `item`.
        // We could look at adding item.disabled in the future though if required.
        if (!item.isDisabled) {
          _this.props.onOpenChange({ isOpen: false, event: attrs.event });
          _this.props.onSelected(item);
          _this.props.onFilterChange('');
          _this.setState({ focusedItemIndex: null });
        }
      } else if (_this.props.shouldAllowCreateItem) {
        _this.handleItemCreate(attrs.event);
      } else {
        // footer is focused and we dont have shouldAllowCreateItem so call the footer's onActivate
        _this.handleFooterActivate(attrs.event);
      }
    }, _this.handleItemRemove = function (item) {
      _this.props.onRemoved(item);
    }, _this.removeLatestItem = function () {
      if (_this.props.selectedItems.length) {
        var selectedItems = _this.props.selectedItems;
        _this.handleItemRemove(selectedItems[selectedItems.length - 1]);
      }
    }, _this.hasVisibleFooter = function () {
      var _this$props4 = _this.props,
          footer = _this$props4.footer,
          shouldAllowCreateItem = _this$props4.shouldAllowCreateItem,
          filterValue = _this$props4.filterValue;
      // This logic is interesting because we explicitly check !multiSelectContainer with footer
      // because if you have both turned on but you havent typed anything, there will be no footer

      return footer.content && !shouldAllowCreateItem || shouldAllowCreateItem && !!filterValue;
    }, _this.isFooterFocused = function () {
      var _this$state = _this.state,
          focusedItemIndex = _this$state.focusedItemIndex,
          groupedItems = _this$state.groupedItems;

      var selectableItems = _this.getAllVisibleItems(groupedItems);
      // if our selected index is outside of our array bounds, the footer should be selected
      return focusedItemIndex === selectableItems.length;
    }, _this.handleOnChange = function (event) {
      var value = event.target.value;

      if (value !== _this.props.filterValue) {
        // We want to get rid of the focus on the items when the shouldAllowCreateItem enabled.
        // When a user presses Enter multi-select should create a new value if nothing is focused, but
        // it still should allow to focus an item in the list and select it by pressing Enter
        // as normal multi-select does.
        if (_this.props.shouldAllowCreateItem) {
          _this.setState({ focusedItemIndex: null });
        }

        _this.props.onFilterChange(value);
        _this.onOpenChange({ event: event, isOpen: true });
      }
    }, _this.handleTriggerClick = function (event) {
      if (!_this.props.isDisabled) {
        _this.onOpenChange({ event: event, isOpen: true });
      }
    }, _this.handleFooterActivate = function (event) {
      var footer = _this.props.footer;

      if (footer.onActivate) {
        footer.onActivate(event);
      }
    }, _this.focusNextItem = function () {
      var filteredItems = _this.getAllVisibleItems(_this.props.items);
      var footerIsFocusable = _this.hasVisibleFooter();
      var focusedItemIndex = _this.state.focusedItemIndex;

      _this.setState({
        focusedItemIndex: getNextFocusable(focusedItemIndex, filteredItems.length, footerIsFocusable)
      });
    }, _this.focusPreviousItem = function () {
      var filteredItems = _this.getAllVisibleItems(_this.props.items);
      var footerIsFocusable = _this.hasVisibleFooter();
      var focusedItemIndex = _this.state.focusedItemIndex;

      _this.setState({
        focusedItemIndex: getPrevFocusable(focusedItemIndex, filteredItems.length, footerIsFocusable)
      });
    }, _this.handleKeyboardInteractions = function (event) {
      var _this$props5 = _this.props,
          isOpen = _this$props5.isOpen,
          items = _this$props5.items,
          filterValue = _this$props5.filterValue;
      var focusedItemIndex = _this.state.focusedItemIndex;


      var isSelectOpen = isOpen;
      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();
          if (!isSelectOpen) {
            _this.onOpenChange({ event: event, isOpen: true });
          }
          _this.focusNextItem();
          break;
        case 'ArrowUp':
          event.preventDefault();
          if (isSelectOpen) {
            _this.focusPreviousItem();
          }
          break;
        case 'Enter':
          if (isSelectOpen) {
            event.preventDefault();
            if (focusedItemIndex !== null) {
              _this.handleItemSelect(_this.getAllVisibleItems(items)[focusedItemIndex], { event: event });
            } else if (_this.props.shouldAllowCreateItem) {
              _this.handleItemCreate();
            }
          }
          break;
        case 'Backspace':
          if (!filterValue) {
            _this.removeLatestItem();
            _this.onOpenChange({ event: event, isOpen: true });
          }
          break;
        case 'Tab':
          // tabbing from within the multi select should move focus to the next form element
          // hence, we close the dropdown and clear the focusedItemIndex
          _this.onOpenChange({ event: event, isOpen: false });
          _this.setState({ focusedItemIndex: null });
          break;
        default:
          break;
      }
    }, _this.renderFooter = function () {
      var _this$props6 = _this.props,
          newValue = _this$props6.filterValue,
          shouldAllowCreateItem = _this$props6.shouldAllowCreateItem,
          footer = _this$props6.footer,
          createNewItemLabel = _this$props6.createNewItemLabel;

      if (shouldAllowCreateItem) {
        if (newValue) {
          return React.createElement(
            Footer,
            {
              appearance: footer.appearance,
              isFocused: _this.isFooterFocused(),
              newLabel: _this.props.createNewItemLabel,
              onClick: _this.handleItemCreate,
              shouldHideSeparator: !_this.getAllVisibleItems(_this.props.items).length
            },
            newValue,
            ' ',
            '(',
            createNewItemLabel,
            ')'
          );
        }
      } else if (footer.content) {
        return React.createElement(
          Footer,
          {
            appearance: footer.appearance,
            elemBefore: footer.elemBefore,
            isFocused: _this.isFooterFocused(),
            onClick: _this.handleFooterActivate,
            shouldHideSeparator: !_this.getAllVisibleItems(_this.props.items).length
          },
          footer.content
        );
      }
      return null;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  // This is used only to manipulate focus , it's okay to have state in this case.


  StatelessMultiSelect.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        appearance = _props.appearance,
        filterValue = _props.filterValue,
        id = _props.id,
        isDisabled = _props.isDisabled,
        isFirstChild = _props.isFirstChild,
        isInvalid = _props.isInvalid,
        invalidMessage = _props.invalidMessage,
        isLoading = _props.isLoading,
        isOpen = _props.isOpen,
        isRequired = _props.isRequired,
        label = _props.label,
        loadingMessage = _props.loadingMessage,
        name = _props.name,
        noMatchesFound = _props.noMatchesFound,
        position = _props.position,
        selectedItems = _props.selectedItems,
        shouldAllowCreateItem = _props.shouldAllowCreateItem,
        shouldFitContainer = _props.shouldFitContainer,
        shouldFlip = _props.shouldFlip;
    var _state = this.state,
        groupedItems = _state.groupedItems,
        isFocused = _state.isFocused,
        focusedItemIndex = _state.focusedItemIndex;


    return (
      // eslint-disable-next-line jsx-a11y/no-static-element-interactions
      React.createElement(
        SelectWrapper,
        {
          shouldFitContainer: shouldFitContainer,
          onKeyDown: this.handleKeyboardInteractions
        },
        React.createElement(
          'select',
          {
            disabled: isDisabled,
            id: id,
            multiple: true,
            name: name,
            readOnly: true,
            required: isRequired,
            style: { display: 'none' },
            value: getAllValues(selectedItems)
          },
          renderOptGroups(groupedItems)
        ),
        label ? React.createElement(Label, {
          htmlFor: id,
          isDisabled: isDisabled,
          isFirstChild: isFirstChild,
          isRequired: isRequired,
          label: label
        }) : null,
        React.createElement(
          Droplist,
          {
            appearance: this.hasVisibleFooter() ? 'tall' : 'default',
            isKeyboardInteractionDisabled: true,
            isOpen: isOpen,
            isTriggerDisabled: true,
            isTriggerNotTabbable: true,
            onOpenChange: this.onOpenChange,
            position: position,
            shouldFitContainer: true,
            shouldFlip: shouldFlip,
            trigger: React.createElement(Trigger, {
              appearance: appearance,
              filterValue: filterValue,
              handleItemRemove: this.handleItemRemove,
              handleOnChange: this.handleOnChange,
              handleTriggerClick: this.handleTriggerClick,
              inputNode: this.inputNode,
              inputRefFunction: function inputRefFunction(ref) {
                return _this2.inputNode = ref;
              },
              isDisabled: isDisabled,
              isFocused: isOpen || isFocused,
              isInvalid: isInvalid,
              invalidMessage: invalidMessage,
              isLoading: isLoading,
              isRequired: isRequired,
              onBlur: this.onBlur,
              onFocus: this.onFocus,
              placeholder: this.getPlaceholder(),
              selectedItems: selectedItems,
              tagGroup: this.tagGroup,
              tagGroupRefFunction: function tagGroupRefFunction(ref) {
                return _this2.tagGroup = ref;
              },
              icon: this.props.icon
            })
          },
          renderGroups({
            groups: groupedItems,
            hasFooter: this.hasVisibleFooter(),
            filterValue: filterValue,
            selectedItems: selectedItems,
            noMatchesFound: noMatchesFound,
            focusedItemIndex: focusedItemIndex,
            handleItemSelect: this.handleItemSelect,
            shouldAllowCreateItem: shouldAllowCreateItem,
            isLoading: isLoading,
            loadingMessage: loadingMessage
          }),
          this.renderFooter()
        )
      )
    );
  };

  return StatelessMultiSelect;
}(PureComponent);

StatelessMultiSelect.propTypes = {
  /** Subtle items do not have a background color. */
  appearance: PropTypes.oneOf(appearances.values),
  /** Message to display in footer after the name of the new item. Only applicable if
   * shouldAllowCreateItem prop is set to true. Default: 'New item'*/
  createNewItemLabel: PropTypes.string,
  /** Value to be used when filtering the items. Compared against "item's filterValues". */
  filterValue: PropTypes.string,
  /** Element to show after the list of item. Accepts an object of the specific shape */
  footer: PropTypes.shape(footerShape),
  /** id property to be passed down to the html select component. */
  id: PropTypes.string,
  /** message to show on the dialog when isInvalid is true */
  invalidMessage: PropTypes.node,
  /** Sets whether the select is selectable. Changes hover state. */
  isDisabled: PropTypes.bool,
  /** controls the top margin of the label component rendered. */
  isFirstChild: PropTypes.bool,
  /** Sets whether the field will become focused. */
  shouldFocus: PropTypes.bool,
  /** Set whether there is an error with the selection. Sets an orange border
  and shows the warning icon. */
  isInvalid: PropTypes.bool,
  /** Sets whether the field is loading data. The same property is used
   * for either initial fetch (when no options are available) as well for
   * subsequent loading of more options. The component reacts accordingly
   * based on the `items` provided.
   */
  isLoading: PropTypes.bool,
  /** Sets whether the Select dropdown is open. */
  isOpen: PropTypes.bool,
  /** Sets whether form including select can be submitted without an option
  being made. */
  isRequired: PropTypes.bool,
  /** An array of objects, each one of which must have an array of items, and
  may have a heading. All items should have content and value properties, with
  content being the displayed text. */
  items: PropTypes.oneOfType([PropTypes.shape(groupShape), PropTypes.arrayOf(PropTypes.shape(itemShape))]),
  /** Label to be displayed above select. */
  label: PropTypes.string,
  /** Message to be displayed when the component is set to its loading state.
  The message might be displayed differently depending on whether or not
  there are items already being rendered. */
  loadingMessage: PropTypes.string,
  /** Mesage to display in any group in items if there are no items in it,
  including if there is one item that has been selected. */
  noMatchesFound: PropTypes.string,
  /** name property to be passed to the html select element. */
  name: PropTypes.string,
  /** Handler to be called when the filtered items changes.*/
  onFilterChange: PropTypes.func,
  /** Handler to be called when a new item is created.
   * Only applicable when the shouldAllowCreateItem is set to true.*/
  onNewItemCreated: PropTypes.func,
  /** Handler called when the select is opened or closed. Called with an object
  that has both the event, and the new isOpen state. */
  onOpenChange: PropTypes.func,
  /** Handler called when a selection is made, with the item chosen. */
  onSelected: PropTypes.func,
  /** Function to be called by the tags representing a selected item. Passed to
  the `onAfterRemoveAction` on the Tag. */
  onRemoved: PropTypes.func,
  /** Text to be shown within the select when no item is selected. */
  placeholder: PropTypes.string,
  /** Where the select dropdown should be displayed relative to the field position. */
  position: PropTypes.string,
  /** Array of selected items */
  selectedItems: PropTypes.arrayOf(PropTypes.shape(itemShape)),
  /** Sets whether the field should be constrained to the width of its trigger */
  shouldFitContainer: PropTypes.bool,
  /** Set whether the dropdown should flip its position when there is not enough
  room in its default position. */
  shouldFlip: PropTypes.bool,
  /** Sets whether a new item could be created and added to the list by pressing Enter
   * inside the autocomplete field. If set to true then no additional footer from the 'footer'
   * property would be rendered.*/
  shouldAllowCreateItem: PropTypes.bool,
  /**
   * Icon to display at the right end of the multi-select
   */
  icon: PropTypes.node
};
StatelessMultiSelect.defaultProps = {
  appearance: appearances.default,
  createNewItemLabel: 'New item',
  filterValue: '',
  footer: {},
  shouldFocus: false,
  shouldFlip: true,
  isLoading: false,
  isOpen: false,
  items: [],
  label: '',
  loadingMessage: 'Receiving information',
  noMatchesFound: 'No matches found',
  onFilterChange: function onFilterChange() {},
  onOpenChange: function onOpenChange() {},
  onSelected: function onSelected() {},
  onRemoved: function onRemoved() {},
  position: 'bottom left',
  selectedItems: [],
  shouldAllowCreateItem: false,
  icon: React.createElement(ExpandIcon, { label: '' })
};
export default StatelessMultiSelect;