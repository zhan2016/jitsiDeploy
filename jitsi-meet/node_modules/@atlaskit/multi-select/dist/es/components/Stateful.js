import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import PropTypes from 'prop-types';
import React, { PureComponent } from 'react';
import uid from 'uid';
import ExpandIcon from '@atlaskit/icon/glyph/expand';

import ItemShape from '../internal/ItemShape';
import GroupShape from '../internal/GroupShape';
import FooterShape from '../internal/FooterShape';
import MultiSelectStateless from './Stateless';

var itemShape = ItemShape.propTypes;
var groupShape = GroupShape.propTypes;
var footerShape = FooterShape.propTypes;

// =============================================================
// NOTE: Duplicated in ./internal/appearances until docgen can follow imports.
// -------------------------------------------------------------
// DO NOT update values here without updating the other.
// =============================================================

var appearances = {
  values: ['default', 'subtle'],
  default: 'default'
};

var MultiSelect = function (_PureComponent) {
  _inherits(MultiSelect, _PureComponent);

  function MultiSelect() {
    var _temp, _this, _ret;

    _classCallCheck(this, MultiSelect);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = {
      isOpen: _this.props.isDefaultOpen,
      selectedItems: _this.props.defaultSelected,
      filterValue: '',
      items: _this.props.items
    }, _this.selectItem = function (item) {
      var selectedItems = [].concat(_toConsumableArray(_this.state.selectedItems), [item]);
      _this.setState({ selectedItems: selectedItems });
      _this.props.onSelectedChange({ items: selectedItems, action: 'select', changed: item });
    }, _this.removeItem = function (item) {
      var selectedItems = _this.state.selectedItems.filter(function (i) {
        return i.value !== item.value;
      });
      _this.setState({ selectedItems: selectedItems });
      _this.props.onSelectedChange({ items: selectedItems, action: 'remove', changed: item });
    }, _this.selectedChange = function (item) {
      if (_this.state.selectedItems.some(function (i) {
        return i.value === item.value;
      })) {
        _this.removeItem(item);
      } else {
        _this.selectItem(item);
      }
    }, _this.handleFilterChange = function (value) {
      _this.props.onFilterChange(value);
      _this.setState({ filterValue: value });
    }, _this.handleOpenChange = function (attrs) {
      if (_this.state.isOpen !== attrs.isOpen) {
        _this.props.onOpenChange(attrs);
      }
      _this.setState({ isOpen: attrs.isOpen });
    }, _this.handleNewItemCreate = function (_ref) {
      var textValue = _ref.value;
      var _this$state = _this.state,
          items = _this$state.items,
          selectedItems = _this$state.selectedItems;

      var id = uid();
      var newItem = { value: id, content: textValue };
      var newItemsArray = [].concat(_toConsumableArray(items));
      newItemsArray[newItemsArray.length - 1].items.push(newItem);

      _this.setState({
        items: newItemsArray,
        selectedItems: [].concat(_toConsumableArray(selectedItems), [newItem]),
        filterValue: ''
      });
      _this.props.onNewItemCreated({ value: textValue, item: newItem });
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  MultiSelect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.items !== this.state.items) {
      this.setState({ items: [].concat(_toConsumableArray(nextProps.items)) });
    }
  };

  MultiSelect.prototype.render = function render() {
    var _props = this.props,
        appearance = _props.appearance,
        createNewItemLabel = _props.createNewItemLabel,
        footer = _props.footer,
        id = _props.id,
        isDisabled = _props.isDisabled,
        isFirstChild = _props.isFirstChild,
        isInvalid = _props.isInvalid,
        invalidMessage = _props.invalidMessage,
        isRequired = _props.isRequired,
        label = _props.label,
        name = _props.name,
        noMatchesFound = _props.noMatchesFound,
        placeholder = _props.placeholder,
        position = _props.position,
        shouldAllowCreateItem = _props.shouldAllowCreateItem,
        shouldFitContainer = _props.shouldFitContainer,
        shouldFocus = _props.shouldFocus,
        shouldFlip = _props.shouldFlip,
        icon = _props.icon;
    var _state = this.state,
        filterValue = _state.filterValue,
        isOpen = _state.isOpen,
        items = _state.items,
        selectedItems = _state.selectedItems;


    return React.createElement(MultiSelectStateless, {
      appearance: appearance,
      createNewItemLabel: createNewItemLabel,
      filterValue: filterValue,
      footer: footer,
      id: id,
      isDisabled: isDisabled,
      isFirstChild: isFirstChild,
      isInvalid: isInvalid,
      invalidMessage: invalidMessage,
      isOpen: isOpen,
      isRequired: isRequired,
      items: items,
      label: label,
      name: name,
      noMatchesFound: noMatchesFound,
      onFilterChange: this.handleFilterChange,
      onNewItemCreated: this.handleNewItemCreate,
      onOpenChange: this.handleOpenChange,
      onRemoved: this.selectedChange,
      onSelected: this.selectedChange,
      placeholder: placeholder,
      position: position,
      selectedItems: selectedItems,
      shouldAllowCreateItem: shouldAllowCreateItem,
      shouldFitContainer: shouldFitContainer,
      shouldFocus: shouldFocus,
      shouldFlip: shouldFlip,
      icon: icon
    });
  };

  return MultiSelect;
}(PureComponent);

MultiSelect.propTypes = {
  /** Subtle items do not have a background color. */
  appearance: PropTypes.oneOf(appearances.values),
  /** Message to display in footer after the name of the new item. Only applicable if
   * shouldAllowCreateItem prop is set to true. */
  createNewItemLabel: PropTypes.string,
  /** An array of items that will be selected on component mount. */
  defaultSelected: PropTypes.arrayOf(PropTypes.shape(itemShape)),
  /** Element to show after the list of item. Accepts an object of a specific shape */
  footer: PropTypes.shape(footerShape),
  /** id property to be passed down to the html select component. */
  id: PropTypes.string,
  /** message to show on the dialog when isInvalid is true */
  invalidMessage: PropTypes.node,
  /** Sets whether the select is selectable. Changes hover state. */
  isDisabled: PropTypes.bool,
  /** controls the top margin of the label component rendered. */
  isFirstChild: PropTypes.bool,
  /** Sets whether the field will become focused. */
  shouldFocus: PropTypes.bool,
  /** Set whether the component should be open on mount. */
  isDefaultOpen: PropTypes.bool,
  /** Sets whether form including select can be submitted without an option
  being made. */
  isRequired: PropTypes.bool,
  /** Set whether there is an error with the selection. Sets an orange border
  and shows the warning icon. */
  isInvalid: PropTypes.bool,
  /** An array of objects, each one of which must have an array of items, and
  may have a heading. All items should have content and value properties, with
  content being the displayed text. */
  items: PropTypes.oneOfType([PropTypes.shape(groupShape), PropTypes.arrayOf(PropTypes.shape(itemShape))]), /** Label to be displayed above select. */
  label: PropTypes.string,
  /** name property to be passed to the html select element. */
  name: PropTypes.string,
  /** Mesage to display in any group in items if there are no items in it,
  including if there is one item that has been selected. */
  noMatchesFound: PropTypes.string,
  /** Handler to be called when the filtered items changes.*/
  onFilterChange: PropTypes.func,
  /** Handler to be called when a new item is created.
   * Only applicable when the shouldAllowCreateItem is set to true.*/
  onNewItemCreated: PropTypes.func,
  /** Handler to be called on select change. */
  onSelectedChange: PropTypes.func,
  /** Handler called when the select is opened or closed. Called with an object
  that has both the event, and the new isOpen state. */
  onOpenChange: PropTypes.func,
  /** Text to be shown within the select when no item is selected. */
  placeholder: PropTypes.string,
  /** Where the select dropdown should be displayed relative to the field position. */
  position: PropTypes.string,
  /** Sets whether the field should be constrained to the width of its trigger */
  shouldFitContainer: PropTypes.bool,
  /** Set whether the dropdown should flip its position when there is not enough
  room in its default position. */
  shouldFlip: PropTypes.bool,
  /** Sets whether a new item could be created and added to the list by pressing Enter
   * inside the autocomplete field */
  shouldAllowCreateItem: PropTypes.bool,
  /**
   * Icon to display at the right end of the multi-select
   */
  icon: PropTypes.node
};
MultiSelect.defaultProps = {
  appearance: appearances.default,
  createNewItemLabel: 'New item',
  defaultSelected: [],
  shouldFocus: false,
  shouldFlip: true,
  isRequired: false,
  items: [],
  label: '',
  onFilterChange: function onFilterChange() {},
  onNewItemCreated: function onNewItemCreated() {},
  onOpenChange: function onOpenChange() {},
  onSelectedChange: function onSelectedChange() {},
  position: 'bottom left',
  shouldAllowCreateItem: false,
  icon: React.createElement(ExpandIcon, { label: '' })
};
export default MultiSelect;