import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import _taggedTemplateLiteral from 'babel-runtime/helpers/taggedTemplateLiteral';

var _templateObject = _taggedTemplateLiteral(['&,&:hover,&:active,&:focus{', '}'], ['&,&:hover,&:active,&:focus{', '}']),
    _templateObject2 = _taggedTemplateLiteral(['', ''], ['', '']),
    _templateObject3 = _taggedTemplateLiteral(['a&{ ', ' }'], ['a&{ ', ' }']);

import React, { Component, PropTypes } from 'react';
import styled from 'styled-components';

import getButtonProps from './getButtonProps';
import CustomComponentProxy from './CustomComponentProxy';
import getButtonStyles from '../styled/getButtonStyles';
import ButtonContent from '../styled/ButtonContent';
import ButtonWrapper from '../styled/ButtonWrapper';
import IconWrapper from '../styled/IconWrapper';

var createStyledComponent = {
  custom: function custom() {
    // Override pseudo-state specificity.
    // This is necessary because we don't know what DOM element the custom component will render.
    var component = styled(CustomComponentProxy)(_templateObject, getButtonStyles);
    component.displayName = 'StyledCustomComponent';
    return component;
  },
  button: function button() {
    var component = styled.button(_templateObject2, getButtonStyles);
    component.displayName = 'StyledButton';
    return component;
  },
  link: function link() {
    // Target the <a> here to override a:hover specificity.
    var component = styled.a(_templateObject3, getButtonStyles);
    component.displayName = 'StyledLink';
    return component;
  },
  span: function span() {
    var component = styled.span(_templateObject2, getButtonStyles);
    component.displayName = 'StyledSpan';
    return component;
  }
};

var Button = function (_Component) {
  _inherits(Button, _Component);

  function Button() {
    var _temp, _this, _ret;

    _classCallCheck(this, Button);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
      isActive: false,
      isFocus: false,
      isHover: false
    }, _this.onMouseEnter = function () {
      return _this.setState({ isHover: true });
    }, _this.onMouseLeave = function () {
      return _this.setState({ isHover: false, isActive: false });
    }, _this.onMouseDown = function (e) {
      e.preventDefault();
      _this.setState({ isActive: true });
    }, _this.onMouseUp = function () {
      return _this.setState({ isActive: false });
    }, _this.onFocus = function () {
      return _this.setState({ isFocus: true });
    }, _this.onBlur = function () {
      return _this.setState({ isFocus: false });
    }, _this.styledComponents = {}, _temp), _possibleConstructorReturn(_this, _ret);
  }
  /* eslint-disable react/no-unused-prop-types */


  Button.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (this.props.component !== nextProps.component) {
      delete this.styledComponents.custom;
    }
  };

  Button.prototype.getCachedStyledComponent = function getCachedStyledComponent(type) {
    if (!this.styledComponents[type]) {
      this.styledComponents[type] = createStyledComponent[type]();
    }
    return this.styledComponents[type];
  };

  Button.prototype.getStyledComponent = function getStyledComponent() {
    if (this.props.component) {
      return this.getCachedStyledComponent('custom');
    }

    if (this.props.href) {
      if (this.props.isDisabled) {
        return this.getCachedStyledComponent('span');
      }

      return this.getCachedStyledComponent('link');
    }

    return this.getCachedStyledComponent('button');
  };

  Button.prototype.render = function render() {
    var _props = this.props,
        children = _props.children,
        iconBefore = _props.iconBefore,
        iconAfter = _props.iconAfter,
        shouldFitContainer = _props.shouldFitContainer;


    var buttonProps = getButtonProps(this);
    var StyledComponent = this.getStyledComponent();

    var iconIsOnlyChild = iconBefore && !iconAfter && !children || iconAfter && !iconBefore && !children;

    return React.createElement(
      StyledComponent,
      buttonProps,
      React.createElement(
        ButtonWrapper,
        { fit: shouldFitContainer },
        iconBefore ? React.createElement(
          IconWrapper,
          { spacing: buttonProps.spacing, isOnlyChild: iconIsOnlyChild },
          iconBefore
        ) : null,
        children ? React.createElement(
          ButtonContent,
          {
            followsIcon: Boolean(iconBefore),
            spacing: buttonProps.spacing
          },
          children
        ) : null,
        iconAfter ? React.createElement(
          IconWrapper,
          { spacing: buttonProps.spacing, isOnlyChild: iconIsOnlyChild },
          iconAfter
        ) : null
      )
    );
  };

  return Button;
}(Component);

Button.propTypes = {
  /** The base styling to apply to the button. */
  appearance: PropTypes.oneOf(['default', 'link', 'primary', 'subtle', 'subtle-link']),
  /** Pass aria-controls to underlying html button. */
  ariaControls: PropTypes.string,
  /** Pass aria-expanded to underlying html button. */
  ariaExpanded: PropTypes.bool,
  /** Pass aria-haspopup to underlying html button. */
  ariaHaspopup: PropTypes.bool,
  /** This button's child nodes. */
  children: PropTypes.node,
  /** Add a classname to the button. */
  className: PropTypes.string,
  /** A custom component to use instead of the default button. */
  component: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  /** Name property of a linked form that the button submits when clicked. */
  form: PropTypes.string,
  /** Provides a url for buttons being used as a link. */
  href: PropTypes.string,
  /** Places an icon within the button, after the button's text. */
  iconAfter: PropTypes.element,
  /** Places an icon within the button, before the button's text. */
  iconBefore: PropTypes.element,
  /** Provide a unique id to the button. */
  id: PropTypes.string,
  /** Set if the button is disabled. */
  isDisabled: PropTypes.bool,
  /** Change the style to indicate the button is selected. */
  isSelected: PropTypes.bool,
  /** Handler to be called on click. */
  onClick: PropTypes.func,
  /** Set the amount of padding in the button. */
  spacing: PropTypes.oneOf(['compact', 'default', 'none']),
  /** Assign specific tabIndex order to the underlying html button. */
  tabIndex: PropTypes.number,
  /** Pass target down to a link within the button component, if a href is provided. */
  target: PropTypes.string,
  /** Change the default styling. */
  theme: PropTypes.oneOf(['dark', 'default']),
  /** Set whether it is a button or a form submission. */
  type: PropTypes.oneOf(['button', 'submit']),
  /** Option to fit button width to its parent width */
  shouldFitContainer: PropTypes.bool
};
Button.defaultProps = {
  appearance: 'default',
  isDisabled: false,
  isSelected: false,
  spacing: 'default',
  tabIndex: null,
  theme: 'default',
  type: 'button',
  shouldFitContainer: false
};
export default Button;