import _extends from 'babel-runtime/helpers/extends';
import _typeof from 'babel-runtime/helpers/typeof';
import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import _PropTypes from 'prop-types';
import React, { Component } from 'react';

import { validIconSizes, propsOmittedFromClickData } from './constants';
import Presence from './Presence';
import Image from './AvatarImage';
import Status from './Status';

import Outer, { PresenceWrapper, StatusWrapper } from '../styled/Avatar';
import { getInnerStyles } from '../styled/utils';
import Tooltip from '../styled/Tooltip';

import { omit } from '../utils';
import { getProps, getStyledComponent } from '../helpers';
import { mapProps, withPseudoState } from '../hoc';

export var AvatarDefaultProps = {
  appearance: 'circle',
  enableTooltip: true,
  size: 'medium'
};

var Avatar = function (_Component) {
  _inherits(Avatar, _Component);

  function Avatar() {
    var _temp, _this, _ret;

    _classCallCheck(this, Avatar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.cache = {}, _this.blur = function (e) {
      if (_this.node.blur) _this.node.blur(e);
    }, _this.focus = function (e) {
      if (_this.node.focus) _this.node.focus(e);
    }, _this.guardedClick = function (event) {
      var _this$props = _this.props,
          isDisabled = _this$props.isDisabled,
          onClick = _this$props.onClick;


      if (isDisabled || typeof onClick !== 'function') return;

      var item = omit.apply(undefined, [_this.props].concat(_toConsumableArray(propsOmittedFromClickData)));

      onClick({ item: item, event: event });
    }, _this.renderIcon = function () {
      var _this$props2 = _this.props,
          appearance = _this$props2.appearance,
          borderColor = _this$props2.borderColor,
          presence = _this$props2.presence,
          size = _this$props2.size,
          status = _this$props2.status;

      var showPresence = !!presence;
      var showStatus = !!status;

      // add warnings for various invalid states
      if (!validIconSizes.includes(size) && (showPresence || showStatus)) {
        console.warn('Avatar size "' + String(size) + '" does NOT support ' + (showPresence ? 'presence' : 'status'));
        return null;
      }
      if (showPresence && showStatus) {
        console.warn('Avatar supports `presence` OR `status` properties, not both.');
        return null;
      }

      var indicator = void 0;

      if (showPresence) {
        var customPresenceNode = (typeof presence === 'undefined' ? 'undefined' : _typeof(presence)) === 'object' ? presence : null;

        indicator = React.createElement(
          PresenceWrapper,
          { appearance: appearance, size: size },
          React.createElement(
            Presence,
            {
              borderColor: borderColor,
              presence: !customPresenceNode && presence,
              size: size
            },
            customPresenceNode
          )
        );
      } else if (showStatus) {
        indicator = React.createElement(
          StatusWrapper,
          { appearance: appearance, size: size },
          React.createElement(Status, {
            status: status,
            borderColor: borderColor,
            size: size
          })
        );
      }

      return indicator;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  } // eslint-disable-line react/sort-comp


  Avatar.prototype.getCachedComponent = function getCachedComponent(type) {
    if (!this.cache[type]) {
      this.cache[type] = getStyledComponent[type](getInnerStyles);
    }
    return this.cache[type];
  };

  Avatar.prototype.getStyledComponent = function getStyledComponent() {
    var _props = this.props,
        component = _props.component,
        href = _props.href,
        onClick = _props.onClick;

    var node = 'span';

    if (component) node = 'custom';else if (href) node = 'link';else if (onClick) node = 'button';

    return this.getCachedComponent(node);
  };

  // expose blur/focus to consumers via ref


  // disallow click on disabled avatars
  // only return avatar data properties


  // enforce status / presence rules
  /* eslint-disable no-console */


  /* eslint-enable no-console */

  Avatar.prototype.render = function render() {
    var _this2 = this;

    var _props2 = this.props,
        appearance = _props2.appearance,
        enableTooltip = _props2.enableTooltip,
        isHover = _props2.isHover,
        onClick = _props2.onClick,
        name = _props2.name,
        size = _props2.size,
        src = _props2.src,
        stackIndex = _props2.stackIndex;

    // Since we augment the onClick handler below we can't use the
    // same type definition that we do for the Avatar's onClick prop

    // distill props from context, props, and state
    var props = getProps(this);

    // provide element type based on props
    var Inner = this.getStyledComponent();

    // augment the onClick handler
    props.onClick = onClick && this.guardedClick;

    return React.createElement(
      Outer,
      { size: size, stackIndex: stackIndex },
      React.createElement(
        Inner,
        _extends({ innerRef: function innerRef(r) {
            return _this2.node = r;
          } }, props),
        React.createElement(Image, {
          alt: name,
          appearance: appearance,
          size: size,
          src: src
        })
      ),
      enableTooltip && isHover && name ? React.createElement(
        Tooltip,
        null,
        name
      ) : null,
      this.renderIcon()
    );
  };

  return Avatar;
}(Component);

/**
*  1. Higher order components seem to ignore default properties. Mapping
*     `appearance` explicity here circumvents the issue.
*  2. The withPseudoState HOC should remain generic so rather than pass on
*     `enableTooltip` we map it to `isInteractive`.
*  3. Handle keyboard/mouse events and pass props to the wrapped component:
*     - isActive
*     - isFocus
*     - isHover
*/


Avatar.propTypes = {
  /** Indicates the shape of the avatar. Most avatars are circular, but square avatars
  can be used for 'container' objects. */appearance: _PropTypes.oneOf(['circle', 'square']) /** Used to override the default border color of the presence indicator.
                                                                                            Accepts any color argument that the border-color CSS property accepts. */,
  borderColor: _PropTypes.string /** A custom component to use instead of the default span. */,
  component: _PropTypes.any /** Display a tooltip on hover */,
  enableTooltip: _PropTypes.bool /** Provides a url for avatars being used as a link. */,
  href: _PropTypes.string /** Change the style to indicate the avatar is active. */,
  isActive: _PropTypes.bool /** Change the style to indicate the avatar is disabled. */,
  isDisabled: _PropTypes.bool /** Change the style to indicate the avatar is focused. */,
  isFocus: _PropTypes.bool /** Change the style to indicate the avatar is hovered. */,
  isHover: _PropTypes.bool /** Change the style to indicate the avatar is selected. */,
  isSelected: _PropTypes.bool /** Name will be displayed in a tooltip, also used by screen readers as fallback
                              content if the image fails to load. */,
  name: _PropTypes.string /** Indicates a user's online status by showing a small icon on the avatar.
                          Refer to presence values on the Presence component.
                          Alternatively accepts any React element. For best results, it is recommended to
                          use square content with height and width of 100%. */,
  presence: _PropTypes.oneOfType([_PropTypes.oneOf(['online', 'busy', 'offline']), _PropTypes.any]) /** Defines the size of the avatar */,
  size: _PropTypes.oneOf(['xsmall', 'small', 'medium', 'large', 'xlarge', 'xxlarge']).isRequired /** A url to load an image from (this can also be a base64 encoded image). */,
  src: _PropTypes.string /** Indicates contextual information by showing a small icon on the avatar.
                         Refer to status values on the Status component. */,
  status: _PropTypes.oneOf(['approved', 'declined', 'locked']) /** The index of where this avatar is in the group `stack`. */,
  stackIndex: _PropTypes.number /** Assign specific tabIndex order to the underlying node. */,
  tabIndex: _PropTypes.number /** Pass target down to the anchor, if href is provided. */,
  target: _PropTypes.oneOf(['_blank', '_self']),
  /** Handler to be called on click. */onClick: _PropTypes.func
};
Avatar.defaultProps = AvatarDefaultProps;
export default mapProps({
  appearance: function appearance(props) {
    return props.appearance || Avatar.defaultProps.appearance;
  }, // 1
  isInteractive: function isInteractive(props) {
    return props.enableTooltip || Avatar.defaultProps.enableTooltip;
  } })(withPseudoState(Avatar)); // 3