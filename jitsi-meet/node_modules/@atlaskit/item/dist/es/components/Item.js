import _extends from 'babel-runtime/helpers/extends';
import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { Component } from 'react';
import PropTypes from 'prop-types';

import styledRootElement from '../styled/Item';
import { Before, After, Content, ContentWrapper, Description } from '../styled/ItemParts';

var Item = function (_Component) {
  _inherits(Item, _Component);

  function Item(props) {
    _classCallCheck(this, Item);

    // The type of element rendered at the root of render() can vary based on the `href`
    // and `linkComponent` props provided. We generate this component here to avoid re-
    // generating the component inside render(). This is for performance reasons, and also
    // allows us to avoid generating a new `ref` for the root element each render().
    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

    _this.setRef = function (ref) {
      _this.ref = ref;
    };

    _this.href = function () {
      return _this.props.isDisabled ? null : _this.props.href;
    };

    _this.rootComponent = styledRootElement({
      href: _this.href(),
      linkComponent: props.linkComponent
    });
    return _this;
  }

  // eslint-disable-next-line react/sort-comp


  Item.prototype.componentDidMount = function componentDidMount() {
    if (this.ref && this.props.autoFocus) {
      this.ref.focus();
    }
  };

  Item.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        _onClick = _props.onClick,
        _onKeyDown = _props.onKeyDown,
        isCompact = _props.isCompact,
        isDisabled = _props.isDisabled,
        isDragging = _props.isDragging,
        isHidden = _props.isHidden,
        isSelected = _props.isSelected,
        onMouseEnter = _props.onMouseEnter,
        onMouseLeave = _props.onMouseLeave,
        role = _props.role,
        dnd = _props.dnd,
        otherProps = _objectWithoutProperties(_props, ['onClick', 'onKeyDown', 'isCompact', 'isDisabled', 'isDragging', 'isHidden', 'isSelected', 'onMouseEnter', 'onMouseLeave', 'role', 'dnd']);

    var Root = this.rootComponent;

    var dragHandleProps = dnd && dnd.dragHandleProps || null;

    var patchedEventHandlers = {
      onClick: function onClick(event) {
        var original = function original() {
          if (!isDisabled && _onClick) {
            _onClick(event);
          }
        };

        if (!dragHandleProps || !dragHandleProps.onClick) {
          original();
          return;
        }

        // Drag and drop has its own disabled mechansim
        // So not checking for isDisabled
        dragHandleProps.onClick(event);

        // if default is prevent - do not fire the onClick prop
        if (event.defaultPrevented) {
          return;
        }

        original();
      },
      onMouseDown: function onMouseDown(event) {
        if (dragHandleProps && dragHandleProps.onMouseDown) {
          dragHandleProps.onMouseDown(event);
        }

        // We want to prevent the item from getting focus when clicked
        event.preventDefault();
      },
      onKeyDown: function onKeyDown(event) {
        var original = function original() {
          if (!isDisabled && _onKeyDown) {
            _onKeyDown(event);
          }
        };

        if (!dragHandleProps || !dragHandleProps.onKeyDown) {
          original();
          return;
        }

        dragHandleProps.onKeyDown(event);

        // if default is prevent - do not fire other handlers
        if (event.defaultPrevented) {
          return;
        }

        // not allowing keyboard events on the element while dragging
        if (isDragging) {
          return;
        }

        original();
      }
    };

    var patchedInnerRef = function patchedInnerRef(ref) {
      _this2.setRef(ref);

      if (dnd) {
        dnd.innerRef(ref);
      }
    };

    return React.createElement(
      Root,
      _extends({
        'aria-disabled': isDisabled,
        href: this.href(),
        isCompact: isCompact,
        isDisabled: isDisabled,
        isDragging: isDragging,
        isHidden: isHidden,
        isSelected: isSelected,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        role: role,
        tabIndex: isDisabled || isHidden || this.props.href ? null : 0,
        target: this.props.target,
        title: this.props.title,
        style: dnd ? dnd.draggableStyle : null,
        innerRef: patchedInnerRef
      }, dragHandleProps, patchedEventHandlers, otherProps),
      !!this.props.elemBefore && React.createElement(
        Before,
        { isCompact: isCompact },
        this.props.elemBefore
      ),
      React.createElement(
        ContentWrapper,
        null,
        React.createElement(
          Content,
          { allowMultiline: this.props.shouldAllowMultiline },
          this.props.children
        ),
        !!this.props.description && React.createElement(
          Description,
          {
            isCompact: this.props.isCompact,
            isDisabled: this.props.isDisabled
          },
          this.props.description
        )
      ),
      !!this.props.elemAfter && React.createElement(
        After,
        { isCompact: isCompact },
        this.props.elemAfter
      )
    );
  };

  return Item;
}(Component);

Item.propTypes = {
  /** Optional function to be used for rendering links. Receives `href` and possibly `target`
    * as props. */
  linkComponent: PropTypes.func,
  /** Main content to be shown inside the item. */
  children: PropTypes.node,
  /** Secondary text to be shown underneath the main content. */
  description: PropTypes.string,
  /** Drag and drop props provided by react-beautiful-dnd. Please do not use this unless
    * using react-beautiful-dnd */
  dnd: PropTypes.shape({
    draggableStyle: PropTypes.object,
    dragHandleProps: PropTypes.object,
    innerRef: PropTypes.func
  }),
  /** Content to be shown after the main content. Shown to the right of content (or to the left
    * in RTL mode). */
  elemAfter: PropTypes.node,
  /** Content to be shown before the main content. Shown to the left of content (or to the right
    * in RTL mode). */
  elemBefore: PropTypes.node,
  /** Link that the user will be redirected to when the item is clicked. If omitted, a
   *  non-hyperlink component will be rendered. */
  href: PropTypes.string,
  /** Causes the item to be rendered with reduced spacing. */
  isCompact: PropTypes.bool,
  /** Causes the item to appear in a disabled state and click behaviours will not be triggered. */
  isDisabled: PropTypes.bool,
  /** Used to apply correct dragging styles when also using react-beautiful-dnd. */
  isDragging: PropTypes.bool,
  /** Causes the item to still be rendered, but with `display: none` applied. */
  isHidden: PropTypes.bool,
  /** Causes the item to appear with a persistent selected background state. */
  isSelected: PropTypes.bool,
  /** Function to be called when the item is clicked, Receives the MouseEvent. */
  onClick: PropTypes.func,
  /** Function to be called when the item is pressed with a keyboard,
  * Receives the KeyboardEvent. */
  onKeyDown: PropTypes.func,
  /** Standard onmouseenter event */
  onMouseEnter: PropTypes.func,
  /** Standard onmouseleave event */
  onMouseLeave: PropTypes.func,
  /** Allows the role attribute of the item to be altered from it's default of
   *  `role="button"` */
  role: PropTypes.string,
  /** Allows the `children` content to break onto a new line, rather than truncating the
   *  content. */
  shouldAllowMultiline: PropTypes.bool,
  /** Target frame for item `href` link to be aimed at. */
  target: PropTypes.string,
  /** Standard browser title to be displayed on the item when hovered. */
  title: PropTypes.string,
  /** Whether the Item should attempt to gain browser focus when mounted */
  autoFocus: PropTypes.bool
};
Item.defaultProps = {
  autoFocus: false,
  description: '',
  isCompact: false,
  isDisabled: false,
  isHidden: false,
  role: 'button',
  shouldAllowMultiline: false
};
export default Item;