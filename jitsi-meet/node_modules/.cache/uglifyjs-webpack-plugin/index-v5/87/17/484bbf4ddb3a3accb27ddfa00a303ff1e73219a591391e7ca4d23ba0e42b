
62539e6ececb6823ed2b9dbf5f63af4c983c4ec2	{"key":"{\"uglify-es\":\"3.3.3\",\"uglifyjs-webpack-plugin\":\"1.1.2\",\"uglifyjs-webpack-plugin-options\":{\"test\":\"<RegExp>/\\\\.js$/i\",\"warningsFilter\":\"<Function>function () {\\n      return true;\\n    }\",\"extractComments\":true,\"sourceMap\":true,\"cache\":true,\"parallel\":true,\"uglifyOptions\":{\"output\":{\"comments\":false}}},\"path\":\"/srv/zwj.meet.com/build/do_external_connect.min.js\",\"input\":\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, {\\n/******/ \\t\\t\\t\\tconfigurable: false,\\n/******/ \\t\\t\\t\\tenumerable: true,\\n/******/ \\t\\t\\t\\tget: getter\\n/******/ \\t\\t\\t});\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"/libs/\\\";\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = 769);\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ 131:\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = parseURLParams;\\n\\n\\n/**\\n * Parses the query/search or fragment/hash parameters out of a specific URL and\\n * returns them as a JS object.\\n *\\n * @param {string} url - The URL to parse.\\n * @param {boolean} dontParse - If falsy, some transformations (for parsing the\\n * value as JSON) will be executed.\\n * @param {string} source - If {@code 'search'}, the parameters will parsed out\\n * of {@code url.search}; otherwise, out of {@code url.hash}.\\n * @returns {Object}\\n */\\nfunction parseURLParams(url) {\\n    var dontParse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n    var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hash';\\n\\n    var paramStr = source === 'search' ? url.search : url.hash;\\n    var params = {};\\n\\n    // eslint-disable-next-line newline-per-chained-call\\n    paramStr && paramStr.substr(1).split('&').forEach(function (part) {\\n        var param = part.split('=');\\n        var key = param[0];\\n\\n        if (!key) {\\n            return;\\n        }\\n\\n        var value = void 0;\\n\\n        try {\\n            value = param[1];\\n            if (!dontParse) {\\n                value = JSON.parse(decodeURIComponent(value).replace(/\\\\\\\\&/, '&'));\\n            }\\n        } catch (e) {\\n            var msg = 'Failed to parse URL parameter value: ' + String(value);\\n\\n            console.warn(msg, e);\\n            window.onerror && window.onerror(msg, null, null, null, e);\\n\\n            return;\\n        }\\n        params[key] = value;\\n    });\\n\\n    return params;\\n}\\n\\n/***/ }),\\n\\n/***/ 186:\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = getRoomName;\\n\\n\\n/**\\n * Builds and returns the room name.\\n *\\n * @returns {string}\\n */\\nfunction getRoomName() {\\n    var getroomnode = config.getroomnode;\\n\\n    var path = window.location.pathname;\\n    var roomName = void 0;\\n\\n    // Determine the room node from the URL.\\n    if (getroomnode && typeof getroomnode === 'function') {\\n        roomName = getroomnode.call(config, path);\\n    } else {\\n        // Fall back to the default strategy of making assumptions about how the\\n        // URL maps to the room (name). It currently assumes a deployment in\\n        // which the last non-directory component of the path (name) is the\\n        // room.\\n        roomName = path.substring(path.lastIndexOf('/') + 1).toLowerCase() || undefined;\\n    }\\n\\n    return roomName;\\n}\\n\\n/***/ }),\\n\\n/***/ 769:\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__react_features_base_config_getRoomName__ = __webpack_require__(186);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__react_features_base_config_parseURLParams__ = __webpack_require__(131);\\n/* global config, createConnectionExternally */\\n\\n\\n\\n\\n/**\\n * Implements external connect using createConnectionExternally function defined\\n * in external_connect.js for Jitsi Meet. Parses the room name and JSON Web\\n * Token (JWT) from the URL and executes createConnectionExternally.\\n *\\n * NOTE: If you are using lib-jitsi-meet without Jitsi Meet, you should use this\\n * file as reference only because the implementation is Jitsi Meet-specific.\\n *\\n * NOTE: For optimal results this file should be included right after\\n * external_connect.js.\\n */\\n\\nif (typeof createConnectionExternally === 'function') {\\n    // URL params have higher priority than config params.\\n    var url = Object(__WEBPACK_IMPORTED_MODULE_1__react_features_base_config_parseURLParams__[\\\"a\\\" /* default */])(window.location, true, 'hash')['config.externalConnectUrl'] || config.externalConnectUrl;\\n    var isRecorder = Object(__WEBPACK_IMPORTED_MODULE_1__react_features_base_config_parseURLParams__[\\\"a\\\" /* default */])(window.location, true, 'hash')['config.iAmRecorder'];\\n\\n    var roomName = void 0;\\n\\n    if (url && (roomName = Object(__WEBPACK_IMPORTED_MODULE_0__react_features_base_config_getRoomName__[\\\"a\\\" /* default */])()) && !isRecorder) {\\n        url += '?room=' + roomName;\\n\\n        var token = Object(__WEBPACK_IMPORTED_MODULE_1__react_features_base_config_parseURLParams__[\\\"a\\\" /* default */])(window.location, true, 'search').jwt;\\n\\n        if (token) {\\n            url += '&token=' + token;\\n        }\\n\\n        createConnectionExternally(url, function (connectionInfo) {\\n            // Sets that global variable to be used later by connect method\\n            // in connection.js.\\n            window.XMPPAttachInfo = {\\n                status: 'success',\\n                data: connectionInfo\\n            };\\n            checkForConnectHandlerAndConnect();\\n        }, errorCallback);\\n    } else {\\n        errorCallback();\\n    }\\n} else {\\n    errorCallback();\\n}\\n\\n/**\\n * Check if connect from connection.js was executed and executes the handler\\n * that is going to finish the connect work.\\n *\\n * @returns {void}\\n */\\nfunction checkForConnectHandlerAndConnect() {\\n    window.APP && window.APP.connect.status === 'ready' && window.APP.connect.handler();\\n}\\n\\n/**\\n * Implements a callback to be invoked if anything goes wrong.\\n *\\n * @param {Error} error - The specifics of what went wrong.\\n * @returns {void}\\n */\\nfunction errorCallback(error) {\\n    // The value of error is undefined if external connect is disabled.\\n    error && console.warn(error);\\n\\n    // Sets that global variable to be used later by connect method in\\n    // connection.js.\\n    window.XMPPAttachInfo = {\\n        status: 'error'\\n    };\\n    checkForConnectHandlerAndConnect();\\n}\\n\\n/***/ })\\n\\n/******/ });\"}","integrity":"sha512-tqi4QSADzlhIC4e0cHu5g7sVQQ/txJjutCMk3YmBvGzlqTDClWThw9XTHsCMMOq8DwybE/bxiLke3ZU9aFpQoA==","time":1514513087035,"size":12794}