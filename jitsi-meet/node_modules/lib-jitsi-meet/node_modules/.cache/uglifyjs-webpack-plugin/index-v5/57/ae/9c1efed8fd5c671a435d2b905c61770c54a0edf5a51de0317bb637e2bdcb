
dce02f66e62e96835a1612234be3185e1be97631	{"key":"{\"uglify-es\":\"3.3.3\",\"uglifyjs-webpack-plugin\":\"1.1.2\",\"uglifyjs-webpack-plugin-options\":{\"test\":\"<RegExp>/\\\\.js$/i\",\"warningsFilter\":\"<Function>function () {\\n      return true;\\n    }\",\"extractComments\":true,\"sourceMap\":true,\"cache\":true,\"parallel\":true,\"uglifyOptions\":{\"output\":{\"comments\":false}}},\"path\":\"/srv/zwj.meet.com/node_modules/lib-jitsi-meet/lib-jitsi-meet.min.js\",\"input\":\"(function webpackUniversalModuleDefinition(root, factory) {\\n\\tif(typeof exports === 'object' && typeof module === 'object')\\n\\t\\tmodule.exports = factory();\\n\\telse if(typeof define === 'function' && define.amd)\\n\\t\\tdefine([], factory);\\n\\telse if(typeof exports === 'object')\\n\\t\\texports[\\\"JitsiMeetJS\\\"] = factory();\\n\\telse\\n\\t\\troot[\\\"JitsiMeetJS\\\"] = factory();\\n})(typeof self !== 'undefined' ? self : this, function() {\\nreturn /******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, {\\n/******/ \\t\\t\\t\\tconfigurable: false,\\n/******/ \\t\\t\\t\\tenumerable: true,\\n/******/ \\t\\t\\t\\tget: getter\\n/******/ \\t\\t\\t});\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = 60);\\n/******/ })\\n/************************************************************************/\\n/******/ ([\\n/* 0 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* Copyright @ 2015 Atlassian Pty Ltd\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\nvar Logger = __webpack_require__(38);\\nvar LogCollector = __webpack_require__(66);\\n\\n/**\\n * Definition of the log method\\n * @name log_method\\n * @function\\n * @param {...*} log_args the arguments to be logged\\n */\\n/**\\n * The logger's transport type definition.\\n *\\n * @typedef {object} LoggerTransport\\n *\\n * @property {log_method} trace method called to log on {@link Logger.levels.TRACE} logging level\\n * @property {log_method} debug method called to log on {@link Logger.levels.DEBUG} logging level\\n * @property {log_method} info method called to log on {@link Logger.levels.INFO} logging level\\n * @property {log_method} log method called to log on {@link Logger.levels.LOG} logging level\\n * @property {log_method} warn method called to log on {@link Logger.levels.WARN} logging level\\n * @property {log_method} error method called to log on {@link Logger.levels.ERROR} logging level\\n */\\n\\n/**\\n * Map with the created loggers with ID.\\n */\\nvar idLoggers = {};\\n\\n/**\\n * Array with the loggers without id.\\n */\\nvar loggers = [];\\n\\n/**\\n * Log level for the lbrary.\\n */\\nvar curLevel = Logger.levels.TRACE;\\n\\n\\nmodule.exports = {\\n    /**\\n     * Adds given {@link LoggerTransport} instance to the list of global\\n     * transports which means that it'll be used by all {@link Logger}s\\n     * @param {LoggerTransport} transport\\n     */\\n    addGlobalTransport: function(transport) {\\n        Logger.addGlobalTransport(transport);\\n    },\\n    /**\\n     * Removes given {@link LoggerTransport} instance from the list of global\\n     * transports\\n     * @param {LoggerTransport} transport\\n     */\\n    removeGlobalTransport: function(transport) {\\n        Logger.removeGlobalTransport(transport);\\n    },\\n    /**\\n     * Creates new logger.\\n     * @arguments the same as Logger constructor\\n     */\\n    getLogger: function(id, transports, format) {\\n        var logger = new Logger(curLevel, id, transports, format);\\n        if(id) {\\n            idLoggers[id] = idLoggers[id] || [];\\n            idLoggers[id].push(logger);\\n        } else {\\n            loggers.push(logger);\\n        }\\n        return logger;\\n    },\\n    /**\\n     * Changes the log level for the existing loggers by id.\\n     * @param level the new log level.\\n     * @param id if specified the level will be changed only for loggers with the\\n     * same id. Otherwise the operation will affect all loggers that don't\\n     * have id.\\n     */\\n    setLogLevelById: function(level, id) {\\n        var l = id? (idLoggers[id] || []) : loggers;\\n        for(var i = 0; i < l.length; i++) {\\n            l[i].setLevel(level);\\n        }\\n    },\\n    /**\\n     * Changes the log level for all existing loggers.\\n     * @param level the new log level.\\n     */\\n    setLogLevel: function (level) {\\n        curLevel = level;\\n        var i = 0;\\n        for(; i < loggers.length; i++) {\\n            loggers[i].setLevel(level);\\n        }\\n\\n        for(var id in idLoggers) {\\n            var l = idLoggers[id] || [];\\n            for(i = 0; i < l.length; i++) {\\n                l[i].setLevel(level);\\n            }\\n        }\\n    },\\n    /**\\n     * The supported log levels.\\n     */\\n    levels: Logger.levels,\\n    /**\\n     * Exports the <tt>LogCollector</tt>.\\n     */\\n    LogCollector: LogCollector\\n};\\n\\n\\n/***/ }),\\n/* 1 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n\\n\\nvar browserVersion = void 0; // eslint-disable-line prefer-const\\n\\nvar currentBrowser = void 0;\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\nvar RTCBrowserType = {\\n\\n    RTC_BROWSER_CHROME: 'rtc_browser.chrome',\\n\\n    RTC_BROWSER_OPERA: 'rtc_browser.opera',\\n\\n    RTC_BROWSER_FIREFOX: 'rtc_browser.firefox',\\n\\n    RTC_BROWSER_IEXPLORER: 'rtc_browser.iexplorer',\\n\\n    RTC_BROWSER_EDGE: 'rtc_browser.edge',\\n\\n    RTC_BROWSER_SAFARI: 'rtc_browser.safari',\\n\\n    RTC_BROWSER_NWJS: 'rtc_browser.nwjs',\\n\\n    RTC_BROWSER_ELECTRON: 'rtc_browser.electron',\\n\\n    RTC_BROWSER_REACT_NATIVE: 'rtc_browser.react-native',\\n\\n    /**\\n     * Tells whether or not the <tt>MediaStream/tt> is removed from\\n     * the <tt>PeerConnection</tt> and disposed on video mute (in order to turn\\n     * off the camera device).\\n     * @return {boolean} <tt>true</tt> if the current browser supports this\\n     * strategy or <tt>false</tt> otherwise.\\n     */\\n    doesVideoMuteByStreamRemove: function doesVideoMuteByStreamRemove() {\\n        return !(RTCBrowserType.isFirefox() || RTCBrowserType.isEdge() || RTCBrowserType.isSafariWithWebrtc());\\n    },\\n\\n\\n    /**\\n     * Gets current browser type.\\n     * @returns {string}\\n     */\\n    getBrowserType: function getBrowserType() {\\n        return currentBrowser;\\n    },\\n\\n\\n    /**\\n     * Gets current browser name, split from the type.\\n     * @returns {string}\\n     */\\n    getBrowserName: function getBrowserName() {\\n        var isAndroid = navigator.userAgent.indexOf('Android') !== -1;\\n\\n        if (isAndroid) {\\n            return 'android';\\n        }\\n\\n        return currentBrowser.split('rtc_browser.')[1];\\n    },\\n\\n\\n    /**\\n     * Checks if current browser is Chrome.\\n     * @returns {boolean}\\n     */\\n    isChrome: function isChrome() {\\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_CHROME;\\n    },\\n\\n\\n    /**\\n     * Checks if current browser is Opera.\\n     * @returns {boolean}\\n     */\\n    isOpera: function isOpera() {\\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_OPERA;\\n    },\\n\\n\\n    /**\\n     * Checks if current browser is Firefox.\\n     * @returns {boolean}\\n     */\\n    isFirefox: function isFirefox() {\\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_FIREFOX;\\n    },\\n\\n\\n    /**\\n     * Checks if current browser is Internet Explorer.\\n     * @returns {boolean}\\n     */\\n    isIExplorer: function isIExplorer() {\\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_IEXPLORER;\\n    },\\n\\n\\n    /**\\n     * Checks if current browser is Microsoft Edge.\\n     * @returns {boolean}\\n     */\\n    isEdge: function isEdge() {\\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_EDGE;\\n    },\\n\\n\\n    /**\\n     * Checks if current browser is Safari.\\n     * @returns {boolean}\\n     */\\n    isSafari: function isSafari() {\\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_SAFARI;\\n    },\\n\\n\\n    /**\\n     * Checks if current browser is a Safari and a version of Safari that\\n     * supports native webrtc.\\n     *\\n     * @returns {boolean}\\n     */\\n    isSafariWithWebrtc: function isSafariWithWebrtc() {\\n        return RTCBrowserType.isSafari() && RTCBrowserType.getSafariVersion() >= 11;\\n    },\\n\\n\\n    /**\\n     * Checks if current environment is NWJS.\\n     * @returns {boolean}\\n     */\\n    isNWJS: function isNWJS() {\\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_NWJS;\\n    },\\n\\n\\n    /**\\n     * Checks if current environment is Electron.\\n     * @returns {boolean}\\n     */\\n    isElectron: function isElectron() {\\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_ELECTRON;\\n    },\\n\\n\\n    /**\\n     * Check whether or not the current browser support peer to peer connections\\n     * @return {boolean} <tt>true</tt> if p2p is supported or <tt>false</tt>\\n     * otherwise.\\n     */\\n    isP2PSupported: function isP2PSupported() {\\n        return !RTCBrowserType.isEdge();\\n    },\\n\\n\\n    /**\\n     * Checks if current environment is React Native.\\n     * @returns {boolean}\\n     */\\n    isReactNative: function isReactNative() {\\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_REACT_NATIVE;\\n    },\\n\\n\\n    /**\\n     * Checks if Temasys RTC plugin is used.\\n     * @returns {boolean}\\n     */\\n    isTemasysPluginUsed: function isTemasysPluginUsed() {\\n        // Temasys do not support Microsoft Edge:\\n        // http://support.temasys.com.sg/support/solutions/articles/\\n        // 5000654345-can-the-temasys-webrtc-plugin-be-used-with-microsoft-edge-\\n        return RTCBrowserType.isSafari() && !RTCBrowserType.isSafariWithWebrtc() || RTCBrowserType.isIExplorer() && RTCBrowserType.getIExplorerVersion() < 12;\\n    },\\n\\n\\n    /**\\n     * Returns whether or not the current browser should be using the new\\n     * getUserMedia flow, which utilizes the adapter shim. This method should\\n     * be temporary and used while migrating all browsers to use adapter and\\n     * the new getUserMedia.\\n     *\\n     * @returns {boolean}\\n     */\\n    usesNewGumFlow: function usesNewGumFlow() {\\n        return RTCBrowserType.isChrome() && RTCBrowserType.getChromeVersion() >= 61 || RTCBrowserType.isFirefox() || RTCBrowserType.isSafariWithWebrtc();\\n    },\\n\\n\\n    /**\\n     * Checks if the current browser triggers 'onmute'/'onunmute' events when\\n     * user's connection is interrupted and the video stops playback.\\n     * @returns {*|boolean} 'true' if the event is supported or 'false'\\n     * otherwise.\\n     */\\n    isVideoMuteOnConnInterruptedSupported: function isVideoMuteOnConnInterruptedSupported() {\\n        return RTCBrowserType.isChrome() || RTCBrowserType.isElectron();\\n    },\\n\\n\\n    /**\\n     * Returns Firefox version.\\n     * @returns {number|null}\\n     */\\n    getFirefoxVersion: function getFirefoxVersion() {\\n        return RTCBrowserType.isFirefox() ? browserVersion : null;\\n    },\\n\\n\\n    /**\\n     * Returns Chrome version.\\n     * @returns {number|null}\\n     */\\n    getChromeVersion: function getChromeVersion() {\\n        return RTCBrowserType.isChrome() ? browserVersion : null;\\n    },\\n\\n\\n    /**\\n     * Returns Opera version.\\n     * @returns {number|null}\\n     */\\n    getOperaVersion: function getOperaVersion() {\\n        return RTCBrowserType.isOpera() ? browserVersion : null;\\n    },\\n\\n\\n    /**\\n     * Returns Internet Explorer version.\\n     *\\n     * @returns {number|null}\\n     */\\n    getIExplorerVersion: function getIExplorerVersion() {\\n        return RTCBrowserType.isIExplorer() ? browserVersion : null;\\n    },\\n\\n\\n    /**\\n     * Returns Edge version.\\n     *\\n     * @returns {number|null}\\n     */\\n    getEdgeVersion: function getEdgeVersion() {\\n        return RTCBrowserType.isEdge() ? browserVersion : null;\\n    },\\n\\n\\n    /**\\n     * Returns Safari version.\\n     *\\n     * @returns {number|null}\\n     */\\n    getSafariVersion: function getSafariVersion() {\\n        return RTCBrowserType.isSafari ? browserVersion : null;\\n    },\\n    usesPlanB: function usesPlanB() {\\n        return !RTCBrowserType.usesUnifiedPlan();\\n    },\\n    usesUnifiedPlan: function usesUnifiedPlan() {\\n        return RTCBrowserType.isFirefox();\\n    },\\n\\n\\n    /**\\n     * Checks if the current browser reports upload and download bandwidth\\n     * statistics.\\n     * @return {boolean}\\n     */\\n    supportsBandwidthStatistics: function supportsBandwidthStatistics() {\\n        // FIXME bandwidth stats are currently not implemented for FF on our\\n        // side, but not sure if not possible ?\\n        return !RTCBrowserType.isFirefox() && !RTCBrowserType.isEdge();\\n    },\\n\\n\\n    /**\\n     * Checks if the current browser supports WebRTC datachannels.\\n     * @return {boolean}\\n     */\\n    supportsDataChannels: function supportsDataChannels() {\\n        // NOTE: Edge does not yet implement DataChannel.\\n        return !RTCBrowserType.isEdge();\\n    },\\n\\n\\n    /**\\n     * Checks if the current browser reports round trip time statistics for\\n     * the ICE candidate pair.\\n     * @return {boolean}\\n     */\\n    supportsRTTStatistics: function supportsRTTStatistics() {\\n        // Firefox does not seem to report RTT for ICE candidate pair:\\n        // eslint-disable-next-line max-len\\n        // https://www.w3.org/TR/webrtc-stats/#dom-rtcicecandidatepairstats-currentroundtriptime\\n        // It does report mozRTT for RTP streams, but at the time of this\\n        // writing it's value does not make sense most of the time\\n        // (is reported as 1):\\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1241066\\n        // For Chrome and others we rely on 'googRtt'.\\n        return !RTCBrowserType.isFirefox() && !RTCBrowserType.isEdge();\\n    },\\n\\n\\n    /**\\n     * Whether jitsi-meet supports simulcast on the current browser.\\n     * @returns {boolean}\\n     */\\n    supportsSimulcast: function supportsSimulcast() {\\n        return RTCBrowserType.isChrome() || RTCBrowserType.isFirefox() || RTCBrowserType.isElectron() || RTCBrowserType.isNWJS() || RTCBrowserType.isReactNative();\\n    },\\n    supportsRtx: function supportsRtx() {\\n        return !RTCBrowserType.isFirefox();\\n    },\\n    supportsRtpSender: function supportsRtpSender() {\\n        return RTCBrowserType.isFirefox();\\n    },\\n\\n\\n    /**\\n     * Returns whether or not the current browser can support capturing video,\\n     * be it camera or desktop, and displaying received video.\\n     *\\n     * @returns {boolean}\\n     */\\n    supportsVideo: function supportsVideo() {\\n        // Currently Safari using webrtc/adapter does not support video due in\\n        // part to Safari only supporting H264 and the bridge sending VP8.\\n        return !RTCBrowserType.isSafariWithWebrtc();\\n    }\\n};\\n\\n/**\\n * detectOpera() must be called before detectChrome() !!!\\n * otherwise Opera wil be detected as Chrome\\n */\\nfunction detectChrome() {\\n    if (navigator.webkitGetUserMedia) {\\n        currentBrowser = RTCBrowserType.RTC_BROWSER_CHROME;\\n\\n        // We can assume that user agent is chrome, because it's enforced when\\n        // 'ext' streaming method is set.\\n        var verMatch = navigator.userAgent.match(/chrome\\\\/(\\\\d+)\\\\./i);\\n        var ver = verMatch ? parseInt(verMatch[1], 10) : 'undefined';\\n\\n        logger.log('This appears to be Chrome, ver: ' + ver);\\n\\n        return ver;\\n    }\\n\\n    return null;\\n}\\n\\n/**\\n *\\n */\\nfunction detectOpera() {\\n    var userAgent = navigator.userAgent;\\n\\n    if (userAgent.match(/Opera|OPR/)) {\\n        currentBrowser = RTCBrowserType.RTC_BROWSER_OPERA;\\n        var version = userAgent.match(/(Opera|OPR) ?\\\\/?(\\\\d+)\\\\.?/)[2];\\n\\n        logger.info('This appears to be Opera, ver: ' + version);\\n\\n        return version;\\n    }\\n\\n    return null;\\n}\\n\\n/**\\n *\\n */\\nfunction detectFirefox() {\\n    if (navigator.mozGetUserMedia) {\\n        currentBrowser = RTCBrowserType.RTC_BROWSER_FIREFOX;\\n        var version = parseInt(navigator.userAgent.match(/Firefox\\\\/([0-9]+)\\\\./)[1], 10);\\n\\n        logger.log('This appears to be Firefox, ver: ' + version);\\n\\n        return version;\\n    }\\n\\n    return null;\\n}\\n\\n/**\\n *\\n */\\nfunction detectSafari() {\\n    if (/^((?!chrome).)*safari/i.test(navigator.userAgent)) {\\n        currentBrowser = RTCBrowserType.RTC_BROWSER_SAFARI;\\n\\n        var matchedVersionParts = navigator.userAgent.match(/version\\\\/(\\\\d+(\\\\.\\\\d+)?)/i);\\n        var versionString = matchedVersionParts && matchedVersionParts[1];\\n        var version = versionString ? parseInt(versionString, 10) : -1;\\n\\n        logger.info('This appears to be Safari, ver: ' + version);\\n\\n        return version;\\n    }\\n\\n    return null;\\n}\\n\\n/**\\n * Detects IE.\\n */\\nfunction detectIE() {\\n    var version = void 0;\\n    var ua = window.navigator.userAgent;\\n\\n    var msie = ua.indexOf('MSIE ');\\n\\n    if (msie > 0) {\\n        // IE 10 or older => return version number\\n        version = parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\\n    }\\n\\n    var trident = ua.indexOf('Trident/');\\n\\n    if (!version && trident > 0) {\\n        // IE 11 => return version number\\n        var rv = ua.indexOf('rv:');\\n\\n        version = parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\\n    }\\n\\n    if (version) {\\n        currentBrowser = RTCBrowserType.RTC_BROWSER_IEXPLORER;\\n        logger.info('This appears to be IExplorer, ver: ' + version);\\n    }\\n\\n    return version;\\n}\\n\\n/**\\n * Detects Edge.\\n */\\nfunction detectEdge() {\\n    var version = void 0;\\n    var ua = window.navigator.userAgent;\\n\\n    var edge = ua.indexOf('Edge/');\\n\\n    if (!version && edge > 0) {\\n        version = parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\\n    }\\n\\n    if (version) {\\n        currentBrowser = RTCBrowserType.RTC_BROWSER_EDGE;\\n        logger.info('This appears to be Edge, ver: ' + version);\\n    }\\n\\n    return version;\\n}\\n\\n/**\\n * Detects Electron environment.\\n */\\nfunction detectElectron() {\\n    var userAgent = navigator.userAgent;\\n\\n    if (userAgent.match(/Electron/)) {\\n        currentBrowser = RTCBrowserType.RTC_BROWSER_ELECTRON;\\n        var version = userAgent.match(/Electron\\\\/([\\\\d.]+)/)[1];\\n\\n        logger.info('This appears to be Electron, ver: ' + version);\\n\\n        return version;\\n    }\\n\\n    return null;\\n}\\n\\n/**\\n *\\n */\\nfunction detectNWJS() {\\n    var userAgent = navigator.userAgent;\\n\\n    if (userAgent.match(/JitsiMeetNW/)) {\\n        currentBrowser = RTCBrowserType.RTC_BROWSER_NWJS;\\n        var version = userAgent.match(/JitsiMeetNW\\\\/([\\\\d.]+)/)[1];\\n\\n        logger.info('This appears to be JitsiMeetNW, ver: ' + version);\\n\\n        return version;\\n    }\\n\\n    return null;\\n}\\n\\n/**\\n *\\n */\\nfunction detectReactNative() {\\n    var match = navigator.userAgent.match(/\\\\b(react[ \\\\t_-]*native)(?:\\\\/(\\\\S+))?/i);\\n    var version = void 0;\\n\\n    // If we're remote debugging a React Native app, it may be treated as\\n    // Chrome. Check navigator.product as well and always return some version\\n    // even if we can't get the real one.\\n\\n    if (match || navigator.product === 'ReactNative') {\\n        currentBrowser = RTCBrowserType.RTC_BROWSER_REACT_NATIVE;\\n        var name = void 0;\\n\\n        if (match && match.length > 2) {\\n            name = match[1];\\n            version = match[2];\\n        }\\n        name || (name = 'react-native');\\n        version || (version = 'unknown');\\n        console.info('This appears to be ' + name + ', ver: ' + version);\\n    } else {\\n        // We're not running in a React Native environment.\\n        version = null;\\n    }\\n\\n    return version;\\n}\\n\\n/**\\n *\\n */\\nfunction detectBrowser() {\\n    var version = void 0;\\n    var detectors = [detectReactNative, detectElectron, detectNWJS, detectOpera, detectChrome, detectFirefox, detectEdge, detectIE, detectSafari];\\n\\n    // Try all browser detectors\\n\\n    for (var i = 0; i < detectors.length; i++) {\\n        version = detectors[i]();\\n        if (version) {\\n            return version;\\n        }\\n    }\\n    logger.warn('Browser type defaults to Safari ver 1');\\n    currentBrowser = RTCBrowserType.RTC_BROWSER_SAFARI;\\n\\n    return 1;\\n}\\n\\nbrowserVersion = detectBrowser();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (RTCBrowserType);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/RTCBrowserType.js\\\"))\\n\\n/***/ }),\\n/* 2 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;/** File: strophe.js\\n *  A JavaScript library for writing XMPP clients.\\n *\\n *  This library uses either Bidirectional-streams Over Synchronous HTTP (BOSH)\\n *  to emulate a persistent, stateful, two-way connection to an XMPP server or\\n *  alternatively WebSockets.\\n *\\n *  More information on BOSH can be found in XEP 124.\\n *  For more information on XMPP-over WebSocket see this RFC:\\n *  http://tools.ietf.org/html/rfc7395\\n */\\n\\n/* All of the Strophe globals are defined in this special function below so\\n * that references to the globals become closures.  This will ensure that\\n * on page reload, these references will still be available to callbacks\\n * that are still executing.\\n */\\n\\n/* jshint ignore:start */\\n(function (root, factory) {\\n    if (true) {\\n        //Allow using this built library as an AMD module\\n        //in another project. That other project will only\\n        //see this AMD call, not the internal modules in\\n        //the closure below.\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n    } else {\\n        //Browser globals case.\\n        var wrapper = factory();\\n        root.Strophe        = wrapper.Strophe;\\n        root.$build         = wrapper.$build;\\n        root.$iq            = wrapper.$iq;\\n        root.$msg           = wrapper.$msg;\\n        root.$pres          = wrapper.$pres;\\n        root.SHA1           = wrapper.SHA1;\\n        root.MD5            = wrapper.MD5;\\n        root.b64_hmac_sha1  = wrapper.b64_hmac_sha1;\\n        root.b64_sha1       = wrapper.b64_sha1;\\n        root.str_hmac_sha1  = wrapper.str_hmac_sha1;\\n        root.str_sha1       = wrapper.str_sha1;\\n    }\\n}(this, function () {\\n    //almond, and your modules will be inlined here\\n/* jshint ignore:end */\\n/**\\n * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.\\n * Released under MIT license, http://github.com/requirejs/almond/LICENSE\\n */\\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\\n//be followed.\\n/*global setTimeout: false */\\n\\nvar requirejs, require, define;\\n(function (undef) {\\n    var main, req, makeMap, handlers,\\n        defined = {},\\n        waiting = {},\\n        config = {},\\n        defining = {},\\n        hasOwn = Object.prototype.hasOwnProperty,\\n        aps = [].slice,\\n        jsSuffixRegExp = /\\\\.js$/;\\n\\n    function hasProp(obj, prop) {\\n        return hasOwn.call(obj, prop);\\n    }\\n\\n    /**\\n     * Given a relative module name, like ./something, normalize it to\\n     * a real name that can be mapped to a path.\\n     * @param {String} name the relative name\\n     * @param {String} baseName a real name that the name arg is relative\\n     * to.\\n     * @returns {String} normalized name\\n     */\\n    function normalize(name, baseName) {\\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\\n            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,\\n            baseParts = baseName && baseName.split(\\\"/\\\"),\\n            map = config.map,\\n            starMap = (map && map['*']) || {};\\n\\n        //Adjust any relative paths.\\n        if (name) {\\n            name = name.split('/');\\n            lastIndex = name.length - 1;\\n\\n            // If wanting node ID compatibility, strip .js from end\\n            // of IDs. Have to do this here, and not in nameToUrl\\n            // because node allows either .js or non .js to map\\n            // to same file.\\n            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\\n                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\\n            }\\n\\n            // Starts with a '.' so need the baseName\\n            if (name[0].charAt(0) === '.' && baseParts) {\\n                //Convert baseName to array, and lop off the last part,\\n                //so that . matches that 'directory' and not name of the baseName's\\n                //module. For instance, baseName of 'one/two/three', maps to\\n                //'one/two/three.js', but we want the directory, 'one/two' for\\n                //this normalization.\\n                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\\n                name = normalizedBaseParts.concat(name);\\n            }\\n\\n            //start trimDots\\n            for (i = 0; i < name.length; i++) {\\n                part = name[i];\\n                if (part === '.') {\\n                    name.splice(i, 1);\\n                    i -= 1;\\n                } else if (part === '..') {\\n                    // If at the start, or previous value is still ..,\\n                    // keep them so that when converted to a path it may\\n                    // still work when converted to a path, even though\\n                    // as an ID it is less than ideal. In larger point\\n                    // releases, may be better to just kick out an error.\\n                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {\\n                        continue;\\n                    } else if (i > 0) {\\n                        name.splice(i - 1, 2);\\n                        i -= 2;\\n                    }\\n                }\\n            }\\n            //end trimDots\\n\\n            name = name.join('/');\\n        }\\n\\n        //Apply map config if available.\\n        if ((baseParts || starMap) && map) {\\n            nameParts = name.split('/');\\n\\n            for (i = nameParts.length; i > 0; i -= 1) {\\n                nameSegment = nameParts.slice(0, i).join(\\\"/\\\");\\n\\n                if (baseParts) {\\n                    //Find the longest baseName segment match in the config.\\n                    //So, do joins on the biggest to smallest lengths of baseParts.\\n                    for (j = baseParts.length; j > 0; j -= 1) {\\n                        mapValue = map[baseParts.slice(0, j).join('/')];\\n\\n                        //baseName segment has  config, find if it has one for\\n                        //this name.\\n                        if (mapValue) {\\n                            mapValue = mapValue[nameSegment];\\n                            if (mapValue) {\\n                                //Match, update name to the new value.\\n                                foundMap = mapValue;\\n                                foundI = i;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                if (foundMap) {\\n                    break;\\n                }\\n\\n                //Check for a star map match, but just hold on to it,\\n                //if there is a shorter segment match later in a matching\\n                //config, then favor over this star map.\\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\\n                    foundStarMap = starMap[nameSegment];\\n                    starI = i;\\n                }\\n            }\\n\\n            if (!foundMap && foundStarMap) {\\n                foundMap = foundStarMap;\\n                foundI = starI;\\n            }\\n\\n            if (foundMap) {\\n                nameParts.splice(0, foundI, foundMap);\\n                name = nameParts.join('/');\\n            }\\n        }\\n\\n        return name;\\n    }\\n\\n    function makeRequire(relName, forceSync) {\\n        return function () {\\n            //A version of a require function that passes a moduleName\\n            //value for items that may need to\\n            //look up paths relative to the moduleName\\n            var args = aps.call(arguments, 0);\\n\\n            //If first arg is not require('string'), and there is only\\n            //one arg, it is the array form without a callback. Insert\\n            //a null so that the following concat is correct.\\n            if (typeof args[0] !== 'string' && args.length === 1) {\\n                args.push(null);\\n            }\\n            return req.apply(undef, args.concat([relName, forceSync]));\\n        };\\n    }\\n\\n    function makeNormalize(relName) {\\n        return function (name) {\\n            return normalize(name, relName);\\n        };\\n    }\\n\\n    function makeLoad(depName) {\\n        return function (value) {\\n            defined[depName] = value;\\n        };\\n    }\\n\\n    function callDep(name) {\\n        if (hasProp(waiting, name)) {\\n            var args = waiting[name];\\n            delete waiting[name];\\n            defining[name] = true;\\n            main.apply(undef, args);\\n        }\\n\\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\\n            throw new Error('No ' + name);\\n        }\\n        return defined[name];\\n    }\\n\\n    //Turns a plugin!resource to [plugin, resource]\\n    //with the plugin being undefined if the name\\n    //did not have a plugin prefix.\\n    function splitPrefix(name) {\\n        var prefix,\\n            index = name ? name.indexOf('!') : -1;\\n        if (index > -1) {\\n            prefix = name.substring(0, index);\\n            name = name.substring(index + 1, name.length);\\n        }\\n        return [prefix, name];\\n    }\\n\\n    //Creates a parts array for a relName where first part is plugin ID,\\n    //second part is resource ID. Assumes relName has already been normalized.\\n    function makeRelParts(relName) {\\n        return relName ? splitPrefix(relName) : [];\\n    }\\n\\n    /**\\n     * Makes a name map, normalizing the name, and using a plugin\\n     * for normalization if necessary. Grabs a ref to plugin\\n     * too, as an optimization.\\n     */\\n    makeMap = function (name, relParts) {\\n        var plugin,\\n            parts = splitPrefix(name),\\n            prefix = parts[0],\\n            relResourceName = relParts[1];\\n\\n        name = parts[1];\\n\\n        if (prefix) {\\n            prefix = normalize(prefix, relResourceName);\\n            plugin = callDep(prefix);\\n        }\\n\\n        //Normalize according\\n        if (prefix) {\\n            if (plugin && plugin.normalize) {\\n                name = plugin.normalize(name, makeNormalize(relResourceName));\\n            } else {\\n                name = normalize(name, relResourceName);\\n            }\\n        } else {\\n            name = normalize(name, relResourceName);\\n            parts = splitPrefix(name);\\n            prefix = parts[0];\\n            name = parts[1];\\n            if (prefix) {\\n                plugin = callDep(prefix);\\n            }\\n        }\\n\\n        //Using ridiculous property names for space reasons\\n        return {\\n            f: prefix ? prefix + '!' + name : name, //fullName\\n            n: name,\\n            pr: prefix,\\n            p: plugin\\n        };\\n    };\\n\\n    function makeConfig(name) {\\n        return function () {\\n            return (config && config.config && config.config[name]) || {};\\n        };\\n    }\\n\\n    handlers = {\\n        require: function (name) {\\n            return makeRequire(name);\\n        },\\n        exports: function (name) {\\n            var e = defined[name];\\n            if (typeof e !== 'undefined') {\\n                return e;\\n            } else {\\n                return (defined[name] = {});\\n            }\\n        },\\n        module: function (name) {\\n            return {\\n                id: name,\\n                uri: '',\\n                exports: defined[name],\\n                config: makeConfig(name)\\n            };\\n        }\\n    };\\n\\n    main = function (name, deps, callback, relName) {\\n        var cjsModule, depName, ret, map, i, relParts,\\n            args = [],\\n            callbackType = typeof callback,\\n            usingExports;\\n\\n        //Use name if no relName\\n        relName = relName || name;\\n        relParts = makeRelParts(relName);\\n\\n        //Call the callback to define the module, if necessary.\\n        if (callbackType === 'undefined' || callbackType === 'function') {\\n            //Pull out the defined dependencies and pass the ordered\\n            //values to the callback.\\n            //Default to [require, exports, module] if no deps\\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\\n            for (i = 0; i < deps.length; i += 1) {\\n                map = makeMap(deps[i], relParts);\\n                depName = map.f;\\n\\n                //Fast path CommonJS standard dependencies.\\n                if (depName === \\\"require\\\") {\\n                    args[i] = handlers.require(name);\\n                } else if (depName === \\\"exports\\\") {\\n                    //CommonJS module spec 1.1\\n                    args[i] = handlers.exports(name);\\n                    usingExports = true;\\n                } else if (depName === \\\"module\\\") {\\n                    //CommonJS module spec 1.1\\n                    cjsModule = args[i] = handlers.module(name);\\n                } else if (hasProp(defined, depName) ||\\n                           hasProp(waiting, depName) ||\\n                           hasProp(defining, depName)) {\\n                    args[i] = callDep(depName);\\n                } else if (map.p) {\\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\\n                    args[i] = defined[depName];\\n                } else {\\n                    throw new Error(name + ' missing ' + depName);\\n                }\\n            }\\n\\n            ret = callback ? callback.apply(defined[name], args) : undefined;\\n\\n            if (name) {\\n                //If setting exports via \\\"module\\\" is in play,\\n                //favor that over return value and exports. After that,\\n                //favor a non-undefined return value over exports use.\\n                if (cjsModule && cjsModule.exports !== undef &&\\n                        cjsModule.exports !== defined[name]) {\\n                    defined[name] = cjsModule.exports;\\n                } else if (ret !== undef || !usingExports) {\\n                    //Use the return value from the function.\\n                    defined[name] = ret;\\n                }\\n            }\\n        } else if (name) {\\n            //May just be an object definition for the module. Only\\n            //worry about defining if have a module name.\\n            defined[name] = callback;\\n        }\\n    };\\n\\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\\n        if (typeof deps === \\\"string\\\") {\\n            if (handlers[deps]) {\\n                //callback in this case is really relName\\n                return handlers[deps](callback);\\n            }\\n            //Just return the module wanted. In this scenario, the\\n            //deps arg is the module name, and second arg (if passed)\\n            //is just the relName.\\n            //Normalize module name, if it contains . or ..\\n            return callDep(makeMap(deps, makeRelParts(callback)).f);\\n        } else if (!deps.splice) {\\n            //deps is a config object, not an array.\\n            config = deps;\\n            if (config.deps) {\\n                req(config.deps, config.callback);\\n            }\\n            if (!callback) {\\n                return;\\n            }\\n\\n            if (callback.splice) {\\n                //callback is an array, which means it is a dependency list.\\n                //Adjust args if there are dependencies\\n                deps = callback;\\n                callback = relName;\\n                relName = null;\\n            } else {\\n                deps = undef;\\n            }\\n        }\\n\\n        //Support require(['a'])\\n        callback = callback || function () {};\\n\\n        //If relName is a function, it is an errback handler,\\n        //so remove it.\\n        if (typeof relName === 'function') {\\n            relName = forceSync;\\n            forceSync = alt;\\n        }\\n\\n        //Simulate async callback;\\n        if (forceSync) {\\n            main(undef, deps, callback, relName);\\n        } else {\\n            //Using a non-zero value because of concern for what old browsers\\n            //do, and latest browsers \\\"upgrade\\\" to 4 if lower value is used:\\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\\n            //If want a value immediately, use require('id') instead -- something\\n            //that works in almond on the global level, but not guaranteed and\\n            //unlikely to work in other AMD implementations.\\n            setTimeout(function () {\\n                main(undef, deps, callback, relName);\\n            }, 4);\\n        }\\n\\n        return req;\\n    };\\n\\n    /**\\n     * Just drops the config on the floor, but returns req in case\\n     * the config return value is used.\\n     */\\n    req.config = function (cfg) {\\n        return req(cfg);\\n    };\\n\\n    /**\\n     * Expose module registry for debugging and tooling\\n     */\\n    requirejs._defined = defined;\\n\\n    define = function (name, deps, callback) {\\n        if (typeof name !== 'string') {\\n            throw new Error('See almond README: incorrect module build, no module name');\\n        }\\n\\n        //This module may not have dependencies\\n        if (!deps.splice) {\\n            //deps is not an array, so probably means\\n            //an object literal or factory function for\\n            //the value. Adjust args.\\n            callback = deps;\\n            deps = [];\\n        }\\n\\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\\n            waiting[name] = [name, deps, callback];\\n        }\\n    };\\n\\n    define.amd = {\\n        jQuery: true\\n    };\\n}());\\n\\ndefine(\\\"node_modules/almond/almond.js\\\", function(){});\\n\\n/*\\n    This program is distributed under the terms of the MIT license.\\n    Please see the LICENSE file for details.\\n\\n    Copyright 2006-2008, OGG, LLC\\n*/\\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\\n/* global define */\\n\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        define('strophe-polyfill',[], function () {\\n            return factory(root);\\n        });\\n    } else {\\n        // Browser globals\\n        return factory(root);\\n    }\\n}(this, function (root) {\\n\\n/** Function: Function.prototype.bind\\n *  Bind a function to an instance.\\n *\\n *  This Function object extension method creates a bound method similar\\n *  to those in Python.  This means that the 'this' object will point\\n *  to the instance you want.  See <MDC's bind() documentation at https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind>\\n *  and <Bound Functions and Function Imports in JavaScript at http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/>\\n *  for a complete explanation.\\n *\\n *  This extension already exists in some browsers (namely, Firefox 3), but\\n *  we provide it to support those that don't.\\n *\\n *  Parameters:\\n *    (Object) obj - The object that will become 'this' in the bound function.\\n *    (Object) argN - An option argument that will be prepended to the\\n *      arguments given for the function call\\n *\\n *  Returns:\\n *    The bound function.\\n */\\nif (!Function.prototype.bind) {\\n    Function.prototype.bind = function (obj /*, arg1, arg2, ... */) {\\n        var func = this;\\n        var _slice = Array.prototype.slice;\\n        var _concat = Array.prototype.concat;\\n        var _args = _slice.call(arguments, 1);\\n        return function () {\\n            return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)));\\n        };\\n    };\\n}\\n\\n/** Function: Array.isArray\\n *  This is a polyfill for the ES5 Array.isArray method.\\n */\\nif (!Array.isArray) {\\n    Array.isArray = function(arg) {\\n        return Object.prototype.toString.call(arg) === '[object Array]';\\n    };\\n}\\n\\n/** Function: Array.prototype.indexOf\\n *  Return the index of an object in an array.\\n *\\n *  This function is not supplied by some JavaScript implementations, so\\n *  we provide it if it is missing.  This code is from:\\n *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf\\n *\\n *  Parameters:\\n *    (Object) elt - The object to look for.\\n *    (Integer) from - The index from which to start looking. (optional).\\n *\\n *  Returns:\\n *    The index of elt in the array or -1 if not found.\\n */\\nif (!Array.prototype.indexOf) {\\n    Array.prototype.indexOf = function(elt /*, from*/) {\\n        var len = this.length;\\n        var from = Number(arguments[1]) || 0;\\n        from = (from < 0) ? Math.ceil(from) : Math.floor(from);\\n        if (from < 0) {\\n            from += len;\\n        }\\n\\n        for (; from < len; from++) {\\n            if (from in this && this[from] === elt) {\\n                return from;\\n            }\\n        }\\n        return -1;\\n    };\\n}\\n\\n/** Function: Array.prototype.forEach\\n *\\n *  This function is not available in IE < 9\\n *\\n *  See <forEach on developer.mozilla.org at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>\\n */\\nif (!Array.prototype.forEach) {\\n    Array.prototype.forEach = function(callback, thisArg) {\\n        var T, k;\\n        if (this === null) {\\n            throw new TypeError(' this is null or not defined');\\n        }\\n        // 1. Let O be the result of calling toObject() passing the\\n        // |this| value as the argument.\\n        var O = Object(this);\\n        // 2. Let lenValue be the result of calling the Get() internal\\n        // method of O with the argument \\\"length\\\".\\n        // 3. Let len be toUint32(lenValue).\\n        var len = O.length >>> 0;\\n        // 4. If isCallable(callback) is false, throw a TypeError exception.\\n        // See: http://es5.github.com/#x9.11\\n        if (typeof callback !== \\\"function\\\") {\\n            throw new TypeError(callback + ' is not a function');\\n        }\\n        // 5. If thisArg was supplied, let T be thisArg; else let\\n        // T be undefined.\\n        if (arguments.length > 1) {\\n            T = thisArg;\\n        }\\n        // 6. Let k be 0\\n        k = 0;\\n        // 7. Repeat, while k < len\\n        while (k < len) {\\n            var kValue;\\n            // a. Let Pk be ToString(k).\\n            //        This is implicit for LHS operands of the in operator\\n            // b. Let kPresent be the result of calling the HasProperty\\n            //        internal method of O with argument Pk.\\n            //        This step can be combined with c\\n            // c. If kPresent is true, then\\n            if (k in O) {\\n                // i. Let kValue be the result of calling the Get internal\\n                // method of O with argument Pk.\\n                kValue = O[k];\\n                // ii. Call the Call internal method of callback with T as\\n                // the this value and argument list containing kValue, k, and O.\\n                callback.call(T, kValue, k, O);\\n            }\\n            // d. Increase k by 1.\\n            k++;\\n        }\\n        // 8. return undefined\\n    };\\n}\\n\\n// This code was written by Tyler Akins and has been placed in the\\n// public domain.  It would be nice if you left this header intact.\\n// Base64 code from Tyler Akins -- http://rumkin.com\\nvar keyStr = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\\";\\nif (!root.btoa) {\\n    root.btoa = function (input) {\\n        /**\\n         * Encodes a string in base64\\n         * @param {String} input The string to encode in base64.\\n         */\\n        var output = \\\"\\\";\\n        var chr1, chr2, chr3;\\n        var enc1, enc2, enc3, enc4;\\n        var i = 0;\\n        do {\\n            chr1 = input.charCodeAt(i++);\\n            chr2 = input.charCodeAt(i++);\\n            chr3 = input.charCodeAt(i++);\\n\\n            enc1 = chr1 >> 2;\\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\\n            enc4 = chr3 & 63;\\n\\n            if (isNaN(chr2)) {\\n                enc2 = ((chr1 & 3) << 4);\\n                enc3 = enc4 = 64;\\n            } else if (isNaN(chr3)) {\\n                enc4 = 64;\\n            }\\n            output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +\\n                keyStr.charAt(enc3) + keyStr.charAt(enc4);\\n        } while (i < input.length);\\n        return output;\\n    };\\n}\\n\\nif (!root.atob) {\\n    root.atob = function (input) {\\n        /**\\n         * Decodes a base64 string.\\n         * @param {String} input The string to decode.\\n         */\\n        var output = \\\"\\\";\\n        var chr1, chr2, chr3;\\n        var enc1, enc2, enc3, enc4;\\n        var i = 0;\\n        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\\n        input = input.replace(/[^A-Za-z0-9\\\\+\\\\/\\\\=]/g, \\\"\\\");\\n        do {\\n            enc1 = keyStr.indexOf(input.charAt(i++));\\n            enc2 = keyStr.indexOf(input.charAt(i++));\\n            enc3 = keyStr.indexOf(input.charAt(i++));\\n            enc4 = keyStr.indexOf(input.charAt(i++));\\n\\n            chr1 = (enc1 << 2) | (enc2 >> 4);\\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\\n            chr3 = ((enc3 & 3) << 6) | enc4;\\n\\n            output = output + String.fromCharCode(chr1);\\n\\n            if (enc3 !== 64) {\\n                output = output + String.fromCharCode(chr2);\\n            }\\n            if (enc4 !== 64) {\\n                output = output + String.fromCharCode(chr3);\\n            }\\n        } while (i < input.length);\\n        return output;\\n    };\\n}\\n}));\\n\\n/*\\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\\n * in FIPS PUB 180-1\\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\\n * Distributed under the BSD License\\n * See http://pajhome.org.uk/crypt/md5 for details.\\n */\\n\\n/* jshint undef: true, unused: true:, noarg: true, latedef: false */\\n/* global define */\\n\\n/* Some functions and variables have been stripped for use with Strophe */\\n\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        define('strophe-sha1', [],function () {\\n            return factory();\\n        });\\n    } else {\\n        // Browser globals\\n        root.SHA1 = factory();\\n    }\\n}(this, function () {\\n\\n/*\\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\\n */\\nfunction core_sha1(x, len)\\n{\\n  /* append padding */\\n  x[len >> 5] |= 0x80 << (24 - len % 32);\\n  x[((len + 64 >> 9) << 4) + 15] = len;\\n\\n  var w = new Array(80);\\n  var a =  1732584193;\\n  var b = -271733879;\\n  var c = -1732584194;\\n  var d =  271733878;\\n  var e = -1009589776;\\n\\n  var i, j, t, olda, oldb, oldc, oldd, olde;\\n  for (i = 0; i < x.length; i += 16)\\n  {\\n    olda = a;\\n    oldb = b;\\n    oldc = c;\\n    oldd = d;\\n    olde = e;\\n\\n    for (j = 0; j < 80; j++)\\n    {\\n      if (j < 16) { w[j] = x[i + j]; }\\n      else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }\\n      t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\\n      e = d;\\n      d = c;\\n      c = rol(b, 30);\\n      b = a;\\n      a = t;\\n    }\\n\\n    a = safe_add(a, olda);\\n    b = safe_add(b, oldb);\\n    c = safe_add(c, oldc);\\n    d = safe_add(d, oldd);\\n    e = safe_add(e, olde);\\n  }\\n  return [a, b, c, d, e];\\n}\\n\\n/*\\n * Perform the appropriate triplet combination function for the current\\n * iteration\\n */\\nfunction sha1_ft(t, b, c, d)\\n{\\n  if (t < 20) { return (b & c) | ((~b) & d); }\\n  if (t < 40) { return b ^ c ^ d; }\\n  if (t < 60) { return (b & c) | (b & d) | (c & d); }\\n  return b ^ c ^ d;\\n}\\n\\n/*\\n * Determine the appropriate additive constant for the current iteration\\n */\\nfunction sha1_kt(t)\\n{\\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\\n         (t < 60) ? -1894007588 : -899497514;\\n}\\n\\n/*\\n * Calculate the HMAC-SHA1 of a key and some data\\n */\\nfunction core_hmac_sha1(key, data)\\n{\\n  var bkey = str2binb(key);\\n  if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * 8); }\\n\\n  var ipad = new Array(16), opad = new Array(16);\\n  for (var i = 0; i < 16; i++)\\n  {\\n    ipad[i] = bkey[i] ^ 0x36363636;\\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\\n  }\\n\\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);\\n  return core_sha1(opad.concat(hash), 512 + 160);\\n}\\n\\n/*\\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\\n * to work around bugs in some JS interpreters.\\n */\\nfunction safe_add(x, y)\\n{\\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\\n  return (msw << 16) | (lsw & 0xFFFF);\\n}\\n\\n/*\\n * Bitwise rotate a 32-bit number to the left.\\n */\\nfunction rol(num, cnt)\\n{\\n  return (num << cnt) | (num >>> (32 - cnt));\\n}\\n\\n/*\\n * Convert an 8-bit or 16-bit string to an array of big-endian words\\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\\n */\\nfunction str2binb(str)\\n{\\n  var bin = [];\\n  var mask = 255;\\n  for (var i = 0; i < str.length * 8; i += 8)\\n  {\\n    bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);\\n  }\\n  return bin;\\n}\\n\\n/*\\n * Convert an array of big-endian words to a string\\n */\\nfunction binb2str(bin)\\n{\\n  var str = \\\"\\\";\\n  var mask = 255;\\n  for (var i = 0; i < bin.length * 32; i += 8)\\n  {\\n    str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);\\n  }\\n  return str;\\n}\\n\\n/*\\n * Convert an array of big-endian words to a base-64 string\\n */\\nfunction binb2b64(binarray)\\n{\\n  var tab = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n  var str = \\\"\\\";\\n  var triplet, j;\\n  for (var i = 0; i < binarray.length * 4; i += 3)\\n  {\\n    triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |\\n              (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |\\n               ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\\n    for (j = 0; j < 4; j++)\\n    {\\n      if (i * 8 + j * 6 > binarray.length * 32) { str += \\\"=\\\"; }\\n      else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }\\n    }\\n  }\\n  return str;\\n}\\n\\n/*\\n * These are the functions you'll usually want to call\\n * They take string arguments and return either hex or base-64 encoded strings\\n */\\nreturn {\\n    b64_hmac_sha1:  function (key, data){ return binb2b64(core_hmac_sha1(key, data)); },\\n    b64_sha1:       function (s) { return binb2b64(core_sha1(str2binb(s),s.length * 8)); },\\n    binb2str:       binb2str,\\n    core_hmac_sha1: core_hmac_sha1,\\n    str_hmac_sha1:  function (key, data){ return binb2str(core_hmac_sha1(key, data)); },\\n    str_sha1:       function (s) { return binb2str(core_sha1(str2binb(s),s.length * 8)); },\\n};\\n}));\\n\\n/*\\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\\n * Digest Algorithm, as defined in RFC 1321.\\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\\n * Distributed under the BSD License\\n * See http://pajhome.org.uk/crypt/md5 for more info.\\n */\\n/*\\n * Everything that isn't used by Strophe has been stripped here!\\n */\\n\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        define('strophe-md5',[], function () {\\n            return factory();\\n        });\\n    } else {\\n        // Browser globals\\n        root.MD5 = factory();\\n    }\\n}(this, function () {\\n    /*\\n     * Add integers, wrapping at 2^32. This uses 16-bit operations internally\\n     * to work around bugs in some JS interpreters.\\n     */\\n    var safe_add = function (x, y) {\\n        var lsw = (x & 0xFFFF) + (y & 0xFFFF);\\n        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\\n        return (msw << 16) | (lsw & 0xFFFF);\\n    };\\n\\n    /*\\n     * Bitwise rotate a 32-bit number to the left.\\n     */\\n    var bit_rol = function (num, cnt) {\\n        return (num << cnt) | (num >>> (32 - cnt));\\n    };\\n\\n    /*\\n     * Convert a string to an array of little-endian words\\n     */\\n    var str2binl = function (str) {\\n        var bin = [];\\n        for(var i = 0; i < str.length * 8; i += 8)\\n        {\\n            bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);\\n        }\\n        return bin;\\n    };\\n\\n    /*\\n     * Convert an array of little-endian words to a string\\n     */\\n    var binl2str = function (bin) {\\n        var str = \\\"\\\";\\n        for(var i = 0; i < bin.length * 32; i += 8)\\n        {\\n            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);\\n        }\\n        return str;\\n    };\\n\\n    /*\\n     * Convert an array of little-endian words to a hex string.\\n     */\\n    var binl2hex = function (binarray) {\\n        var hex_tab = \\\"0123456789abcdef\\\";\\n        var str = \\\"\\\";\\n        for(var i = 0; i < binarray.length * 4; i++)\\n        {\\n            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +\\n                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);\\n        }\\n        return str;\\n    };\\n\\n    /*\\n     * These functions implement the four basic operations the algorithm uses.\\n     */\\n    var md5_cmn = function (q, a, b, x, s, t) {\\n        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);\\n    };\\n\\n    var md5_ff = function (a, b, c, d, x, s, t) {\\n        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\\n    };\\n\\n    var md5_gg = function (a, b, c, d, x, s, t) {\\n        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\\n    };\\n\\n    var md5_hh = function (a, b, c, d, x, s, t) {\\n        return md5_cmn(b ^ c ^ d, a, b, x, s, t);\\n    };\\n\\n    var md5_ii = function (a, b, c, d, x, s, t) {\\n        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\\n    };\\n\\n    /*\\n     * Calculate the MD5 of an array of little-endian words, and a bit length\\n     */\\n    var core_md5 = function (x, len) {\\n        /* append padding */\\n        x[len >> 5] |= 0x80 << ((len) % 32);\\n        x[(((len + 64) >>> 9) << 4) + 14] = len;\\n\\n        var a =  1732584193;\\n        var b = -271733879;\\n        var c = -1732584194;\\n        var d =  271733878;\\n\\n        var olda, oldb, oldc, oldd;\\n        for (var i = 0; i < x.length; i += 16)\\n        {\\n            olda = a;\\n            oldb = b;\\n            oldc = c;\\n            oldd = d;\\n\\n            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\\n            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\\n            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\\n            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\\n            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\\n            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\\n            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\\n            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\\n            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\\n            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\\n            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\\n            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\\n            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\\n            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\\n            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\\n            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\\n\\n            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\\n            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\\n            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\\n            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\\n            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\\n            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\\n            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\\n            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\\n            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\\n            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\\n            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\\n            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\\n            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\\n            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\\n            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\\n            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\\n\\n            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\\n            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\\n            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\\n            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\\n            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\\n            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\\n            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\\n            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\\n            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\\n            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\\n            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\\n            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\\n            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\\n            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\\n            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\\n            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\\n\\n            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\\n            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\\n            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\\n            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\\n            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\\n            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\\n            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\\n            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\\n            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\\n            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\\n            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\\n            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\\n            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\\n            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\\n            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\\n            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\\n\\n            a = safe_add(a, olda);\\n            b = safe_add(b, oldb);\\n            c = safe_add(c, oldc);\\n            d = safe_add(d, oldd);\\n        }\\n        return [a, b, c, d];\\n    };\\n\\n    var obj = {\\n        /*\\n         * These are the functions you'll usually want to call.\\n         * They take string arguments and return either hex or base-64 encoded\\n         * strings.\\n         */\\n        hexdigest: function (s) {\\n            return binl2hex(core_md5(str2binl(s), s.length * 8));\\n        },\\n\\n        hash: function (s) {\\n            return binl2str(core_md5(str2binl(s), s.length * 8));\\n        }\\n    };\\n    return obj;\\n}));\\n\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        define('strophe-utils',[], function () {\\n            return factory();\\n        });\\n    } else {\\n        // Browser globals\\n        root.stropheUtils = factory();\\n    }\\n}(this, function () {\\n\\n    var utils = {\\n\\n        utf16to8: function (str) {\\n            var i, c;\\n            var out = \\\"\\\";\\n            var len = str.length;\\n            for (i = 0; i < len; i++) {\\n                c = str.charCodeAt(i);\\n                if ((c >= 0x0000) && (c <= 0x007F)) {\\n                    out += str.charAt(i);\\n                } else if (c > 0x07FF) {\\n                    out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));\\n                    out += String.fromCharCode(0x80 | ((c >>  6) & 0x3F));\\n                    out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));\\n                } else {\\n                    out += String.fromCharCode(0xC0 | ((c >>  6) & 0x1F));\\n                    out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));\\n                }\\n            }\\n            return out;\\n        },\\n\\n        addCookies: function (cookies) {\\n            /* Parameters:\\n             *  (Object) cookies - either a map of cookie names\\n             *    to string values or to maps of cookie values.\\n             *\\n             * For example:\\n             * { \\\"myCookie\\\": \\\"1234\\\" }\\n             *\\n             * or:\\n             * { \\\"myCookie\\\": {\\n             *      \\\"value\\\": \\\"1234\\\",\\n             *      \\\"domain\\\": \\\".example.org\\\",\\n             *      \\\"path\\\": \\\"/\\\",\\n             *      \\\"expires\\\": expirationDate\\n             *      }\\n             *  }\\n             *\\n             *  These values get passed to Strophe.Connection via\\n             *   options.cookies\\n             */\\n            var cookieName, cookieObj, isObj, cookieValue, expires, domain, path;\\n            for (cookieName in (cookies || {})) {\\n                expires = '';\\n                domain = '';\\n                path = '';\\n                cookieObj = cookies[cookieName];\\n                isObj = typeof cookieObj === \\\"object\\\";\\n                cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));\\n                if (isObj) {\\n                    expires = cookieObj.expires ? \\\";expires=\\\"+cookieObj.expires : '';\\n                    domain = cookieObj.domain ? \\\";domain=\\\"+cookieObj.domain : '';\\n                    path = cookieObj.path ? \\\";path=\\\"+cookieObj.path : '';\\n                }\\n                document.cookie =\\n                    cookieName+'='+cookieValue + expires + domain + path;\\n            }\\n        }\\n    };\\n    return utils;\\n}));\\n\\n/*\\n    This program is distributed under the terms of the MIT license.\\n    Please see the LICENSE file for details.\\n\\n    Copyright 2006-2008, OGG, LLC\\n*/\\n\\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\\n/*global define, document, sessionStorage, setTimeout, clearTimeout, ActiveXObject, DOMParser, btoa, atob */\\n\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        define('strophe-core',[\\n            'strophe-sha1',\\n            'strophe-md5',\\n            'strophe-utils'\\n        ], function () {\\n            return factory.apply(this, arguments);\\n        });\\n    } else {\\n        // Browser globals\\n        var o = factory(root.SHA1, root.MD5, root.stropheUtils);\\n        root.Strophe =        o.Strophe;\\n        root.$build =         o.$build;\\n        root.$iq =            o.$iq;\\n        root.$msg =           o.$msg;\\n        root.$pres =          o.$pres;\\n        root.SHA1 =           o.SHA1;\\n        root.MD5 =            o.MD5;\\n        root.b64_hmac_sha1 =  o.SHA1.b64_hmac_sha1;\\n        root.b64_sha1 =       o.SHA1.b64_sha1;\\n        root.str_hmac_sha1 =  o.SHA1.str_hmac_sha1;\\n        root.str_sha1 =       o.SHA1.str_sha1;\\n    }\\n}(this, function (SHA1, MD5, utils) {\\n\\nvar Strophe;\\n\\n/** Function: $build\\n *  Create a Strophe.Builder.\\n *  This is an alias for 'new Strophe.Builder(name, attrs)'.\\n *\\n *  Parameters:\\n *    (String) name - The root element name.\\n *    (Object) attrs - The attributes for the root element in object notation.\\n *\\n *  Returns:\\n *    A new Strophe.Builder object.\\n */\\nfunction $build(name, attrs) { return new Strophe.Builder(name, attrs); }\\n\\n/** Function: $msg\\n *  Create a Strophe.Builder with a <message/> element as the root.\\n *\\n *  Parameters:\\n *    (Object) attrs - The <message/> element attributes in object notation.\\n *\\n *  Returns:\\n *    A new Strophe.Builder object.\\n */\\nfunction $msg(attrs) { return new Strophe.Builder(\\\"message\\\", attrs); }\\n\\n/** Function: $iq\\n *  Create a Strophe.Builder with an <iq/> element as the root.\\n *\\n *  Parameters:\\n *    (Object) attrs - The <iq/> element attributes in object notation.\\n *\\n *  Returns:\\n *    A new Strophe.Builder object.\\n */\\nfunction $iq(attrs) { return new Strophe.Builder(\\\"iq\\\", attrs); }\\n\\n/** Function: $pres\\n *  Create a Strophe.Builder with a <presence/> element as the root.\\n *\\n *  Parameters:\\n *    (Object) attrs - The <presence/> element attributes in object notation.\\n *\\n *  Returns:\\n *    A new Strophe.Builder object.\\n */\\nfunction $pres(attrs) { return new Strophe.Builder(\\\"presence\\\", attrs); }\\n\\n/** Class: Strophe\\n *  An object container for all Strophe library functions.\\n *\\n *  This class is just a container for all the objects and constants\\n *  used in the library.  It is not meant to be instantiated, but to\\n *  provide a namespace for library objects, constants, and functions.\\n */\\nStrophe = {\\n    /** Constant: VERSION */\\n    VERSION: \\\"1.2.14\\\",\\n\\n    /** Constants: XMPP Namespace Constants\\n     *  Common namespace constants from the XMPP RFCs and XEPs.\\n     *\\n     *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.\\n     *  NS.BOSH - BOSH namespace from XEP 206.\\n     *  NS.CLIENT - Main XMPP client namespace.\\n     *  NS.AUTH - Legacy authentication namespace.\\n     *  NS.ROSTER - Roster operations namespace.\\n     *  NS.PROFILE - Profile namespace.\\n     *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.\\n     *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.\\n     *  NS.MUC - Multi-User Chat namespace from XEP 45.\\n     *  NS.SASL - XMPP SASL namespace from RFC 3920.\\n     *  NS.STREAM - XMPP Streams namespace from RFC 3920.\\n     *  NS.BIND - XMPP Binding namespace from RFC 3920.\\n     *  NS.SESSION - XMPP Session namespace from RFC 3920.\\n     *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.\\n     *  NS.XHTML - XHTML body namespace from XEP 71.\\n     */\\n    NS: {\\n        HTTPBIND: \\\"http://jabber.org/protocol/httpbind\\\",\\n        BOSH: \\\"urn:xmpp:xbosh\\\",\\n        CLIENT: \\\"jabber:client\\\",\\n        AUTH: \\\"jabber:iq:auth\\\",\\n        ROSTER: \\\"jabber:iq:roster\\\",\\n        PROFILE: \\\"jabber:iq:profile\\\",\\n        DISCO_INFO: \\\"http://jabber.org/protocol/disco#info\\\",\\n        DISCO_ITEMS: \\\"http://jabber.org/protocol/disco#items\\\",\\n        MUC: \\\"http://jabber.org/protocol/muc\\\",\\n        SASL: \\\"urn:ietf:params:xml:ns:xmpp-sasl\\\",\\n        STREAM: \\\"http://etherx.jabber.org/streams\\\",\\n        FRAMING: \\\"urn:ietf:params:xml:ns:xmpp-framing\\\",\\n        BIND: \\\"urn:ietf:params:xml:ns:xmpp-bind\\\",\\n        SESSION: \\\"urn:ietf:params:xml:ns:xmpp-session\\\",\\n        VERSION: \\\"jabber:iq:version\\\",\\n        STANZAS: \\\"urn:ietf:params:xml:ns:xmpp-stanzas\\\",\\n        XHTML_IM: \\\"http://jabber.org/protocol/xhtml-im\\\",\\n        XHTML: \\\"http://www.w3.org/1999/xhtml\\\"\\n    },\\n\\n    /** Constants: XHTML_IM Namespace\\n     *  contains allowed tags, tag attributes, and css properties.\\n     *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.\\n     *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended\\n     *  allowed tags and their attributes.\\n     */\\n    XHTML: {\\n        tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],\\n        attributes: {\\n            'a':          ['href'],\\n            'blockquote': ['style'],\\n            'br':         [],\\n            'cite':       ['style'],\\n            'em':         [],\\n            'img':        ['src', 'alt', 'style', 'height', 'width'],\\n            'li':         ['style'],\\n            'ol':         ['style'],\\n            'p':          ['style'],\\n            'span':       ['style'],\\n            'strong':     [],\\n            'ul':         ['style'],\\n            'body':       []\\n        },\\n        css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],\\n        /** Function: XHTML.validTag\\n         *\\n         * Utility method to determine whether a tag is allowed\\n         * in the XHTML_IM namespace.\\n         *\\n         * XHTML tag names are case sensitive and must be lower case.\\n         */\\n        validTag: function(tag) {\\n            for (var i = 0; i < Strophe.XHTML.tags.length; i++) {\\n                if (tag === Strophe.XHTML.tags[i]) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        },\\n        /** Function: XHTML.validAttribute\\n         *\\n         * Utility method to determine whether an attribute is allowed\\n         * as recommended per XEP-0071\\n         *\\n         * XHTML attribute names are case sensitive and must be lower case.\\n         */\\n        validAttribute: function(tag, attribute) {\\n            if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {\\n                for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\\n                    if (attribute === Strophe.XHTML.attributes[tag][i]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        return false;\\n        },\\n        validCSS: function(style) {\\n            for (var i = 0; i < Strophe.XHTML.css.length; i++) {\\n                if (style === Strophe.XHTML.css[i]) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    },\\n\\n    /** Constants: Connection Status Constants\\n     *  Connection status constants for use by the connection handler\\n     *  callback.\\n     *\\n     *  Status.ERROR - An error has occurred\\n     *  Status.CONNECTING - The connection is currently being made\\n     *  Status.CONNFAIL - The connection attempt failed\\n     *  Status.AUTHENTICATING - The connection is authenticating\\n     *  Status.AUTHFAIL - The authentication attempt failed\\n     *  Status.CONNECTED - The connection has succeeded\\n     *  Status.DISCONNECTED - The connection has been terminated\\n     *  Status.DISCONNECTING - The connection is currently being terminated\\n     *  Status.ATTACHED - The connection has been attached\\n     *  Status.REDIRECT - The connection has been redirected\\n     *  Status.CONNTIMEOUT - The connection has timed out\\n     */\\n    Status: {\\n        ERROR: 0,\\n        CONNECTING: 1,\\n        CONNFAIL: 2,\\n        AUTHENTICATING: 3,\\n        AUTHFAIL: 4,\\n        CONNECTED: 5,\\n        DISCONNECTED: 6,\\n        DISCONNECTING: 7,\\n        ATTACHED: 8,\\n        REDIRECT: 9,\\n        CONNTIMEOUT: 10\\n    },\\n\\n    /** Constants: Log Level Constants\\n     *  Logging level indicators.\\n     *\\n     *  LogLevel.DEBUG - Debug output\\n     *  LogLevel.INFO - Informational output\\n     *  LogLevel.WARN - Warnings\\n     *  LogLevel.ERROR - Errors\\n     *  LogLevel.FATAL - Fatal errors\\n     */\\n    LogLevel: {\\n        DEBUG: 0,\\n        INFO: 1,\\n        WARN: 2,\\n        ERROR: 3,\\n        FATAL: 4\\n    },\\n\\n    /** PrivateConstants: DOM Element Type Constants\\n     *  DOM element types.\\n     *\\n     *  ElementType.NORMAL - Normal element.\\n     *  ElementType.TEXT - Text data element.\\n     *  ElementType.FRAGMENT - XHTML fragment element.\\n     */\\n    ElementType: {\\n        NORMAL: 1,\\n        TEXT: 3,\\n        CDATA: 4,\\n        FRAGMENT: 11\\n    },\\n\\n    /** PrivateConstants: Timeout Values\\n     *  Timeout values for error states.  These values are in seconds.\\n     *  These should not be changed unless you know exactly what you are\\n     *  doing.\\n     *\\n     *  TIMEOUT - Timeout multiplier. A waiting request will be considered\\n     *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.\\n     *      This defaults to 1.1, and with default wait, 66 seconds.\\n     *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where\\n     *      Strophe can detect early failure, it will consider the request\\n     *      failed if it doesn't return after\\n     *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.\\n     *      This defaults to 0.1, and with default wait, 6 seconds.\\n     */\\n    TIMEOUT: 1.1,\\n    SECONDARY_TIMEOUT: 0.1,\\n\\n    /** Function: addNamespace\\n     *  This function is used to extend the current namespaces in\\n     *  Strophe.NS.  It takes a key and a value with the key being the\\n     *  name of the new namespace, with its actual value.\\n     *  For example:\\n     *  Strophe.addNamespace('PUBSUB', \\\"http://jabber.org/protocol/pubsub\\\");\\n     *\\n     *  Parameters:\\n     *    (String) name - The name under which the namespace will be\\n     *      referenced under Strophe.NS\\n     *    (String) value - The actual namespace.\\n     */\\n    addNamespace: function (name, value) {\\n        Strophe.NS[name] = value;\\n    },\\n\\n    /** Function: forEachChild\\n     *  Map a function over some or all child elements of a given element.\\n     *\\n     *  This is a small convenience function for mapping a function over\\n     *  some or all of the children of an element.  If elemName is null, all\\n     *  children will be passed to the function, otherwise only children\\n     *  whose tag names match elemName will be passed.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The element to operate on.\\n     *    (String) elemName - The child element tag name filter.\\n     *    (Function) func - The function to apply to each child.  This\\n     *      function should take a single argument, a DOM element.\\n     */\\n    forEachChild: function (elem, elemName, func) {\\n        var i, childNode;\\n        for (i = 0; i < elem.childNodes.length; i++) {\\n            childNode = elem.childNodes[i];\\n            if (childNode.nodeType === Strophe.ElementType.NORMAL &&\\n                (!elemName || this.isTagEqual(childNode, elemName))) {\\n                func(childNode);\\n            }\\n        }\\n    },\\n\\n    /** Function: isTagEqual\\n     *  Compare an element's tag name with a string.\\n     *\\n     *  This function is case sensitive.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) el - A DOM element.\\n     *    (String) name - The element name.\\n     *\\n     *  Returns:\\n     *    true if the element's tag name matches _el_, and false\\n     *    otherwise.\\n     */\\n    isTagEqual: function (el, name) {\\n        return el.tagName === name;\\n    },\\n\\n    /** PrivateVariable: _xmlGenerator\\n     *  _Private_ variable that caches a DOM document to\\n     *  generate elements.\\n     */\\n    _xmlGenerator: null,\\n\\n    /** PrivateFunction: _makeGenerator\\n     *  _Private_ function that creates a dummy XML DOM document to serve as\\n     *  an element and text node generator.\\n     */\\n    _makeGenerator: function () {\\n        var doc;\\n        // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.\\n        // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be\\n                // less than 10 in the case of IE9 and below.\\n        if (document.implementation.createDocument === undefined ||\\n                        document.implementation.createDocument && document.documentMode && document.documentMode < 10) {\\n            doc = this._getIEXmlDom();\\n            doc.appendChild(doc.createElement('strophe'));\\n        } else {\\n            doc = document.implementation\\n                .createDocument('jabber:client', 'strophe', null);\\n        }\\n        return doc;\\n    },\\n\\n    /** Function: xmlGenerator\\n     *  Get the DOM document to generate elements.\\n     *\\n     *  Returns:\\n     *    The currently used DOM document.\\n     */\\n    xmlGenerator: function () {\\n        if (!Strophe._xmlGenerator) {\\n            Strophe._xmlGenerator = Strophe._makeGenerator();\\n        }\\n        return Strophe._xmlGenerator;\\n    },\\n\\n    /** PrivateFunction: _getIEXmlDom\\n     *  Gets IE xml doc object\\n     *\\n     *  Returns:\\n     *    A Microsoft XML DOM Object\\n     *  See Also:\\n     *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx\\n     */\\n    _getIEXmlDom : function() {\\n        var doc = null;\\n        var docStrings = [\\n            \\\"Msxml2.DOMDocument.6.0\\\",\\n            \\\"Msxml2.DOMDocument.5.0\\\",\\n            \\\"Msxml2.DOMDocument.4.0\\\",\\n            \\\"MSXML2.DOMDocument.3.0\\\",\\n            \\\"MSXML2.DOMDocument\\\",\\n            \\\"MSXML.DOMDocument\\\",\\n            \\\"Microsoft.XMLDOM\\\"\\n        ];\\n\\n        for (var d = 0; d < docStrings.length; d++) {\\n            if (doc === null) {\\n                try {\\n                    doc = new ActiveXObject(docStrings[d]);\\n                } catch (e) {\\n                    doc = null;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        return doc;\\n    },\\n\\n    /** Function: xmlElement\\n     *  Create an XML DOM element.\\n     *\\n     *  This function creates an XML DOM element correctly across all\\n     *  implementations. Note that these are not HTML DOM elements, which\\n     *  aren't appropriate for XMPP stanzas.\\n     *\\n     *  Parameters:\\n     *    (String) name - The name for the element.\\n     *    (Array|Object) attrs - An optional array or object containing\\n     *      key/value pairs to use as element attributes. The object should\\n     *      be in the format {'key': 'value'} or {key: 'value'}. The array\\n     *      should have the format [['key1', 'value1'], ['key2', 'value2']].\\n     *    (String) text - The text child data for the element.\\n     *\\n     *  Returns:\\n     *    A new XML DOM element.\\n     */\\n    xmlElement: function (name) {\\n        if (!name) { return null; }\\n\\n        var node = Strophe.xmlGenerator().createElement(name);\\n        // FIXME: this should throw errors if args are the wrong type or\\n        // there are more than two optional args\\n        var a, i, k;\\n        for (a = 1; a < arguments.length; a++) {\\n            var arg = arguments[a];\\n            if (!arg) { continue; }\\n            if (typeof(arg) === \\\"string\\\" ||\\n                typeof(arg) === \\\"number\\\") {\\n                node.appendChild(Strophe.xmlTextNode(arg));\\n            } else if (typeof(arg) === \\\"object\\\" &&\\n                       typeof(arg.sort) === \\\"function\\\") {\\n                for (i = 0; i < arg.length; i++) {\\n                    var attr = arg[i];\\n                    if (typeof(attr) === \\\"object\\\" &&\\n                        typeof(attr.sort) === \\\"function\\\" &&\\n                        attr[1] !== undefined &&\\n                        attr[1] !== null) {\\n                        node.setAttribute(attr[0], attr[1]);\\n                    }\\n                }\\n            } else if (typeof(arg) === \\\"object\\\") {\\n                for (k in arg) {\\n                    if (arg.hasOwnProperty(k)) {\\n                        if (arg[k] !== undefined &&\\n                            arg[k] !== null) {\\n                            node.setAttribute(k, arg[k]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return node;\\n    },\\n\\n    /*  Function: xmlescape\\n     *  Excapes invalid xml characters.\\n     *\\n     *  Parameters:\\n     *     (String) text - text to escape.\\n     *\\n     *  Returns:\\n     *      Escaped text.\\n     */\\n    xmlescape: function(text) {\\n        text = text.replace(/\\\\&/g, \\\"&amp;\\\");\\n        text = text.replace(/</g,  \\\"&lt;\\\");\\n        text = text.replace(/>/g,  \\\"&gt;\\\");\\n        text = text.replace(/'/g,  \\\"&apos;\\\");\\n        text = text.replace(/\\\"/g,  \\\"&quot;\\\");\\n        return text;\\n    },\\n\\n    /*  Function: xmlunescape\\n    *  Unexcapes invalid xml characters.\\n    *\\n    *  Parameters:\\n    *     (String) text - text to unescape.\\n    *\\n    *  Returns:\\n    *      Unescaped text.\\n    */\\n    xmlunescape: function(text) {\\n        text = text.replace(/\\\\&amp;/g, \\\"&\\\");\\n        text = text.replace(/&lt;/g,  \\\"<\\\");\\n        text = text.replace(/&gt;/g,  \\\">\\\");\\n        text = text.replace(/&apos;/g,  \\\"'\\\");\\n        text = text.replace(/&quot;/g,  \\\"\\\\\\\"\\\");\\n        return text;\\n    },\\n\\n    /** Function: xmlTextNode\\n     *  Creates an XML DOM text node.\\n     *\\n     *  Provides a cross implementation version of document.createTextNode.\\n     *\\n     *  Parameters:\\n     *    (String) text - The content of the text node.\\n     *\\n     *  Returns:\\n     *    A new XML DOM text node.\\n     */\\n    xmlTextNode: function (text) {\\n        return Strophe.xmlGenerator().createTextNode(text);\\n    },\\n\\n    /** Function: xmlHtmlNode\\n     *  Creates an XML DOM html node.\\n     *\\n     *  Parameters:\\n     *    (String) html - The content of the html node.\\n     *\\n     *  Returns:\\n     *    A new XML DOM text node.\\n     */\\n    xmlHtmlNode: function (html) {\\n        var node;\\n        //ensure text is escaped\\n        if (DOMParser) {\\n            var parser = new DOMParser();\\n            node = parser.parseFromString(html, \\\"text/xml\\\");\\n        } else {\\n            node = new ActiveXObject(\\\"Microsoft.XMLDOM\\\");\\n            node.async=\\\"false\\\";\\n            node.loadXML(html);\\n        }\\n        return node;\\n    },\\n\\n    /** Function: getText\\n     *  Get the concatenation of all text children of an element.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - A DOM element.\\n     *\\n     *  Returns:\\n     *    A String with the concatenated text of all text element children.\\n     */\\n    getText: function (elem) {\\n        if (!elem) { return null; }\\n\\n        var str = \\\"\\\";\\n        if (elem.childNodes.length === 0 && elem.nodeType === Strophe.ElementType.TEXT) {\\n            str += elem.nodeValue;\\n        }\\n\\n        for (var i = 0; i < elem.childNodes.length; i++) {\\n            if (elem.childNodes[i].nodeType === Strophe.ElementType.TEXT) {\\n                str += elem.childNodes[i].nodeValue;\\n            }\\n        }\\n\\n        return Strophe.xmlescape(str);\\n    },\\n\\n    /** Function: copyElement\\n     *  Copy an XML DOM element.\\n     *\\n     *  This function copies a DOM element and all its descendants and returns\\n     *  the new copy.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - A DOM element.\\n     *\\n     *  Returns:\\n     *    A new, copied DOM element tree.\\n     */\\n    copyElement: function (elem) {\\n        var i, el;\\n        if (elem.nodeType === Strophe.ElementType.NORMAL) {\\n            el = Strophe.xmlElement(elem.tagName);\\n\\n            for (i = 0; i < elem.attributes.length; i++) {\\n                el.setAttribute(elem.attributes[i].nodeName,\\n                                elem.attributes[i].value);\\n            }\\n\\n            for (i = 0; i < elem.childNodes.length; i++) {\\n                el.appendChild(Strophe.copyElement(elem.childNodes[i]));\\n            }\\n        } else if (elem.nodeType === Strophe.ElementType.TEXT) {\\n            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);\\n        }\\n        return el;\\n    },\\n\\n\\n    /** Function: createHtml\\n     *  Copy an HTML DOM element into an XML DOM.\\n     *\\n     *  This function copies a DOM element and all its descendants and returns\\n     *  the new copy.\\n     *\\n     *  Parameters:\\n     *    (HTMLElement) elem - A DOM element.\\n     *\\n     *  Returns:\\n     *    A new, copied DOM element tree.\\n     */\\n    createHtml: function (elem) {\\n        var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;\\n        if (elem.nodeType === Strophe.ElementType.NORMAL) {\\n            tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.\\n            if(Strophe.XHTML.validTag(tag)) {\\n                try {\\n                    el = Strophe.xmlElement(tag);\\n                    for(i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\\n                        attribute = Strophe.XHTML.attributes[tag][i];\\n                        value = elem.getAttribute(attribute);\\n                        if(typeof value === 'undefined' || value === null || value === '' || value === false || value === 0) {\\n                            continue;\\n                        }\\n                        if(attribute === 'style' && typeof value === 'object') {\\n                            if(typeof value.cssText !== 'undefined') {\\n                                value = value.cssText; // we're dealing with IE, need to get CSS out\\n                            }\\n                        }\\n                        // filter out invalid css styles\\n                        if(attribute === 'style') {\\n                            css = [];\\n                            cssAttrs = value.split(';');\\n                            for(j = 0; j < cssAttrs.length; j++) {\\n                                attr = cssAttrs[j].split(':');\\n                                cssName = attr[0].replace(/^\\\\s*/, \\\"\\\").replace(/\\\\s*$/, \\\"\\\").toLowerCase();\\n                                if(Strophe.XHTML.validCSS(cssName)) {\\n                                    cssValue = attr[1].replace(/^\\\\s*/, \\\"\\\").replace(/\\\\s*$/, \\\"\\\");\\n                                    css.push(cssName + ': ' + cssValue);\\n                                }\\n                            }\\n                            if(css.length > 0) {\\n                                value = css.join('; ');\\n                                el.setAttribute(attribute, value);\\n                            }\\n                        } else {\\n                            el.setAttribute(attribute, value);\\n                        }\\n                    }\\n\\n                    for (i = 0; i < elem.childNodes.length; i++) {\\n                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));\\n                    }\\n                } catch(e) { // invalid elements\\n                  el = Strophe.xmlTextNode('');\\n                }\\n            } else {\\n                el = Strophe.xmlGenerator().createDocumentFragment();\\n                for (i = 0; i < elem.childNodes.length; i++) {\\n                    el.appendChild(Strophe.createHtml(elem.childNodes[i]));\\n                }\\n            }\\n        } else if (elem.nodeType === Strophe.ElementType.FRAGMENT) {\\n            el = Strophe.xmlGenerator().createDocumentFragment();\\n            for (i = 0; i < elem.childNodes.length; i++) {\\n                el.appendChild(Strophe.createHtml(elem.childNodes[i]));\\n            }\\n        } else if (elem.nodeType === Strophe.ElementType.TEXT) {\\n            el = Strophe.xmlTextNode(elem.nodeValue);\\n        }\\n        return el;\\n    },\\n\\n    /** Function: escapeNode\\n     *  Escape the node part (also called local part) of a JID.\\n     *\\n     *  Parameters:\\n     *    (String) node - A node (or local part).\\n     *\\n     *  Returns:\\n     *    An escaped node (or local part).\\n     */\\n    escapeNode: function (node) {\\n        if (typeof node !== \\\"string\\\") { return node; }\\n        return node.replace(/^\\\\s+|\\\\s+$/g, '')\\n            .replace(/\\\\\\\\/g,  \\\"\\\\\\\\5c\\\")\\n            .replace(/ /g,   \\\"\\\\\\\\20\\\")\\n            .replace(/\\\\\\\"/g,  \\\"\\\\\\\\22\\\")\\n            .replace(/\\\\&/g,  \\\"\\\\\\\\26\\\")\\n            .replace(/\\\\'/g,  \\\"\\\\\\\\27\\\")\\n            .replace(/\\\\//g,  \\\"\\\\\\\\2f\\\")\\n            .replace(/:/g,   \\\"\\\\\\\\3a\\\")\\n            .replace(/</g,   \\\"\\\\\\\\3c\\\")\\n            .replace(/>/g,   \\\"\\\\\\\\3e\\\")\\n            .replace(/@/g,   \\\"\\\\\\\\40\\\");\\n    },\\n\\n    /** Function: unescapeNode\\n     *  Unescape a node part (also called local part) of a JID.\\n     *\\n     *  Parameters:\\n     *    (String) node - A node (or local part).\\n     *\\n     *  Returns:\\n     *    An unescaped node (or local part).\\n     */\\n    unescapeNode: function (node) {\\n        if (typeof node !== \\\"string\\\") { return node; }\\n        return node.replace(/\\\\\\\\20/g, \\\" \\\")\\n            .replace(/\\\\\\\\22/g, '\\\"')\\n            .replace(/\\\\\\\\26/g, \\\"&\\\")\\n            .replace(/\\\\\\\\27/g, \\\"'\\\")\\n            .replace(/\\\\\\\\2f/g, \\\"/\\\")\\n            .replace(/\\\\\\\\3a/g, \\\":\\\")\\n            .replace(/\\\\\\\\3c/g, \\\"<\\\")\\n            .replace(/\\\\\\\\3e/g, \\\">\\\")\\n            .replace(/\\\\\\\\40/g, \\\"@\\\")\\n            .replace(/\\\\\\\\5c/g, \\\"\\\\\\\\\\\");\\n    },\\n\\n    /** Function: getNodeFromJid\\n     *  Get the node portion of a JID String.\\n     *\\n     *  Parameters:\\n     *    (String) jid - A JID.\\n     *\\n     *  Returns:\\n     *    A String containing the node.\\n     */\\n    getNodeFromJid: function (jid) {\\n        if (jid.indexOf(\\\"@\\\") < 0) { return null; }\\n        return jid.split(\\\"@\\\")[0];\\n    },\\n\\n    /** Function: getDomainFromJid\\n     *  Get the domain portion of a JID String.\\n     *\\n     *  Parameters:\\n     *    (String) jid - A JID.\\n     *\\n     *  Returns:\\n     *    A String containing the domain.\\n     */\\n    getDomainFromJid: function (jid) {\\n        var bare = Strophe.getBareJidFromJid(jid);\\n        if (bare.indexOf(\\\"@\\\") < 0) {\\n            return bare;\\n        } else {\\n            var parts = bare.split(\\\"@\\\");\\n            parts.splice(0, 1);\\n            return parts.join('@');\\n        }\\n    },\\n\\n    /** Function: getResourceFromJid\\n     *  Get the resource portion of a JID String.\\n     *\\n     *  Parameters:\\n     *    (String) jid - A JID.\\n     *\\n     *  Returns:\\n     *    A String containing the resource.\\n     */\\n    getResourceFromJid: function (jid) {\\n        var s = jid.split(\\\"/\\\");\\n        if (s.length < 2) { return null; }\\n        s.splice(0, 1);\\n        return s.join('/');\\n    },\\n\\n    /** Function: getBareJidFromJid\\n     *  Get the bare JID from a JID String.\\n     *\\n     *  Parameters:\\n     *    (String) jid - A JID.\\n     *\\n     *  Returns:\\n     *    A String containing the bare JID.\\n     */\\n    getBareJidFromJid: function (jid) {\\n        return jid ? jid.split(\\\"/\\\")[0] : null;\\n    },\\n\\n    /** PrivateFunction: _handleError\\n     *  _Private_ function that properly logs an error to the console\\n     */\\n    _handleError: function (e) {\\n        if (typeof e.stack !== \\\"undefined\\\") {\\n            Strophe.fatal(e.stack);\\n        }\\n        if (e.sourceURL) {\\n            Strophe.fatal(\\\"error: \\\" + this.handler + \\\" \\\" + e.sourceURL + \\\":\\\" +\\n                          e.line + \\\" - \\\" + e.name + \\\": \\\" + e.message);\\n        } else if (e.fileName) {\\n            Strophe.fatal(\\\"error: \\\" + this.handler + \\\" \\\" +\\n                          e.fileName + \\\":\\\" + e.lineNumber + \\\" - \\\" +\\n                          e.name + \\\": \\\" + e.message);\\n        } else {\\n            Strophe.fatal(\\\"error: \\\" + e.message);\\n        }\\n    },\\n\\n    /** Function: log\\n     *  User overrideable logging function.\\n     *\\n     *  This function is called whenever the Strophe library calls any\\n     *  of the logging functions.  The default implementation of this\\n     *  function does nothing.  If client code wishes to handle the logging\\n     *  messages, it should override this with\\n     *  > Strophe.log = function (level, msg) {\\n     *  >   (user code here)\\n     *  > };\\n     *\\n     *  Please note that data sent and received over the wire is logged\\n     *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().\\n     *\\n     *  The different levels and their meanings are\\n     *\\n     *    DEBUG - Messages useful for debugging purposes.\\n     *    INFO - Informational messages.  This is mostly information like\\n     *      'disconnect was called' or 'SASL auth succeeded'.\\n     *    WARN - Warnings about potential problems.  This is mostly used\\n     *      to report transient connection errors like request timeouts.\\n     *    ERROR - Some error occurred.\\n     *    FATAL - A non-recoverable fatal error occurred.\\n     *\\n     *  Parameters:\\n     *    (Integer) level - The log level of the log message.  This will\\n     *      be one of the values in Strophe.LogLevel.\\n     *    (String) msg - The log message.\\n     */\\n    /* jshint ignore:start */\\n    log: function (level, msg) {\\n        return;\\n    },\\n    /* jshint ignore:end */\\n\\n    /** Function: debug\\n     *  Log a message at the Strophe.LogLevel.DEBUG level.\\n     *\\n     *  Parameters:\\n     *    (String) msg - The log message.\\n     */\\n    debug: function(msg) {\\n        this.log(this.LogLevel.DEBUG, msg);\\n    },\\n\\n    /** Function: info\\n     *  Log a message at the Strophe.LogLevel.INFO level.\\n     *\\n     *  Parameters:\\n     *    (String) msg - The log message.\\n     */\\n    info: function (msg) {\\n        this.log(this.LogLevel.INFO, msg);\\n    },\\n\\n    /** Function: warn\\n     *  Log a message at the Strophe.LogLevel.WARN level.\\n     *\\n     *  Parameters:\\n     *    (String) msg - The log message.\\n     */\\n    warn: function (msg) {\\n        this.log(this.LogLevel.WARN, msg);\\n    },\\n\\n    /** Function: error\\n     *  Log a message at the Strophe.LogLevel.ERROR level.\\n     *\\n     *  Parameters:\\n     *    (String) msg - The log message.\\n     */\\n    error: function (msg) {\\n        this.log(this.LogLevel.ERROR, msg);\\n    },\\n\\n    /** Function: fatal\\n     *  Log a message at the Strophe.LogLevel.FATAL level.\\n     *\\n     *  Parameters:\\n     *    (String) msg - The log message.\\n     */\\n    fatal: function (msg) {\\n        this.log(this.LogLevel.FATAL, msg);\\n    },\\n\\n    /** Function: serialize\\n     *  Render a DOM element and all descendants to a String.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - A DOM element.\\n     *\\n     *  Returns:\\n     *    The serialized element tree as a String.\\n     */\\n    serialize: function (elem) {\\n        var result;\\n\\n        if (!elem) { return null; }\\n\\n        if (typeof(elem.tree) === \\\"function\\\") {\\n            elem = elem.tree();\\n        }\\n\\n        var nodeName = elem.nodeName;\\n        var i, child;\\n\\n        if (elem.getAttribute(\\\"_realname\\\")) {\\n            nodeName = elem.getAttribute(\\\"_realname\\\");\\n        }\\n\\n        result = \\\"<\\\" + nodeName;\\n        for (i = 0; i < elem.attributes.length; i++) {\\n             if(elem.attributes[i].nodeName !== \\\"_realname\\\") {\\n               result += \\\" \\\" + elem.attributes[i].nodeName +\\n                   \\\"='\\\" + Strophe.xmlescape(elem.attributes[i].value) + \\\"'\\\";\\n             }\\n        }\\n\\n        if (elem.childNodes.length > 0) {\\n            result += \\\">\\\";\\n            for (i = 0; i < elem.childNodes.length; i++) {\\n                child = elem.childNodes[i];\\n                switch( child.nodeType ){\\n                  case Strophe.ElementType.NORMAL:\\n                    // normal element, so recurse\\n                    result += Strophe.serialize(child);\\n                    break;\\n                  case Strophe.ElementType.TEXT:\\n                    // text element to escape values\\n                    result += Strophe.xmlescape(child.nodeValue);\\n                    break;\\n                  case Strophe.ElementType.CDATA:\\n                    // cdata section so don't escape values\\n                    result += \\\"<![CDATA[\\\"+child.nodeValue+\\\"]]>\\\";\\n                }\\n            }\\n            result += \\\"</\\\" + nodeName + \\\">\\\";\\n        } else {\\n            result += \\\"/>\\\";\\n        }\\n\\n        return result;\\n    },\\n\\n    /** PrivateVariable: _requestId\\n     *  _Private_ variable that keeps track of the request ids for\\n     *  connections.\\n     */\\n    _requestId: 0,\\n\\n    /** PrivateVariable: Strophe.connectionPlugins\\n     *  _Private_ variable Used to store plugin names that need\\n     *  initialization on Strophe.Connection construction.\\n     */\\n    _connectionPlugins: {},\\n\\n    /** Function: addConnectionPlugin\\n     *  Extends the Strophe.Connection object with the given plugin.\\n     *\\n     *  Parameters:\\n     *    (String) name - The name of the extension.\\n     *    (Object) ptype - The plugin's prototype.\\n     */\\n    addConnectionPlugin: function (name, ptype) {\\n        Strophe._connectionPlugins[name] = ptype;\\n    }\\n};\\n\\n/** Class: Strophe.Builder\\n *  XML DOM builder.\\n *\\n *  This object provides an interface similar to JQuery but for building\\n *  DOM elements easily and rapidly.  All the functions except for toString()\\n *  and tree() return the object, so calls can be chained.  Here's an\\n *  example using the $iq() builder helper.\\n *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})\\n *  >     .c('query', {xmlns: 'strophe:example'})\\n *  >     .c('example')\\n *  >     .toString()\\n *\\n *  The above generates this XML fragment\\n *  > <iq to='you' from='me' type='get' id='1'>\\n *  >   <query xmlns='strophe:example'>\\n *  >     <example/>\\n *  >   </query>\\n *  > </iq>\\n *  The corresponding DOM manipulations to get a similar fragment would be\\n *  a lot more tedious and probably involve several helper variables.\\n *\\n *  Since adding children makes new operations operate on the child, up()\\n *  is provided to traverse up the tree.  To add two children, do\\n *  > builder.c('child1', ...).up().c('child2', ...)\\n *  The next operation on the Builder will be relative to the second child.\\n */\\n\\n/** Constructor: Strophe.Builder\\n *  Create a Strophe.Builder object.\\n *\\n *  The attributes should be passed in object notation.  For example\\n *  > var b = new Builder('message', {to: 'you', from: 'me'});\\n *  or\\n *  > var b = new Builder('messsage', {'xml:lang': 'en'});\\n *\\n *  Parameters:\\n *    (String) name - The name of the root element.\\n *    (Object) attrs - The attributes for the root element in object notation.\\n *\\n *  Returns:\\n *    A new Strophe.Builder.\\n */\\nStrophe.Builder = function (name, attrs) {\\n    // Set correct namespace for jabber:client elements\\n    if (name === \\\"presence\\\" || name === \\\"message\\\" || name === \\\"iq\\\") {\\n        if (attrs && !attrs.xmlns) {\\n            attrs.xmlns = Strophe.NS.CLIENT;\\n        } else if (!attrs) {\\n            attrs = {xmlns: Strophe.NS.CLIENT};\\n        }\\n    }\\n\\n    // Holds the tree being built.\\n    this.nodeTree = Strophe.xmlElement(name, attrs);\\n\\n    // Points to the current operation node.\\n    this.node = this.nodeTree;\\n};\\n\\nStrophe.Builder.prototype = {\\n    /** Function: tree\\n     *  Return the DOM tree.\\n     *\\n     *  This function returns the current DOM tree as an element object.  This\\n     *  is suitable for passing to functions like Strophe.Connection.send().\\n     *\\n     *  Returns:\\n     *    The DOM tree as a element object.\\n     */\\n    tree: function () {\\n        return this.nodeTree;\\n    },\\n\\n    /** Function: toString\\n     *  Serialize the DOM tree to a String.\\n     *\\n     *  This function returns a string serialization of the current DOM\\n     *  tree.  It is often used internally to pass data to a\\n     *  Strophe.Request object.\\n     *\\n     *  Returns:\\n     *    The serialized DOM tree in a String.\\n     */\\n    toString: function () {\\n        return Strophe.serialize(this.nodeTree);\\n    },\\n\\n    /** Function: up\\n     *  Make the current parent element the new current element.\\n     *\\n     *  This function is often used after c() to traverse back up the tree.\\n     *  For example, to add two children to the same element\\n     *  > builder.c('child1', {}).up().c('child2', {});\\n     *\\n     *  Returns:\\n     *    The Stophe.Builder object.\\n     */\\n    up: function () {\\n        this.node = this.node.parentNode;\\n        return this;\\n    },\\n\\n    /** Function: root\\n     *  Make the root element the new current element.\\n     *\\n     *  When at a deeply nested element in the tree, this function can be used\\n     *  to jump back to the root of the tree, instead of having to repeatedly\\n     *  call up().\\n     *\\n     *  Returns:\\n     *    The Stophe.Builder object.\\n     */\\n    root: function () {\\n        this.node = this.nodeTree;\\n        return this;\\n    },\\n\\n    /** Function: attrs\\n     *  Add or modify attributes of the current element.\\n     *\\n     *  The attributes should be passed in object notation.  This function\\n     *  does not move the current element pointer.\\n     *\\n     *  Parameters:\\n     *    (Object) moreattrs - The attributes to add/modify in object notation.\\n     *\\n     *  Returns:\\n     *    The Strophe.Builder object.\\n     */\\n    attrs: function (moreattrs) {\\n        for (var k in moreattrs) {\\n            if (moreattrs.hasOwnProperty(k)) {\\n                if (moreattrs[k] === undefined) {\\n                    this.node.removeAttribute(k);\\n                } else {\\n                    this.node.setAttribute(k, moreattrs[k]);\\n                }\\n            }\\n        }\\n        return this;\\n    },\\n\\n    /** Function: c\\n     *  Add a child to the current element and make it the new current\\n     *  element.\\n     *\\n     *  This function moves the current element pointer to the child,\\n     *  unless text is provided.  If you need to add another child, it\\n     *  is necessary to use up() to go back to the parent in the tree.\\n     *\\n     *  Parameters:\\n     *    (String) name - The name of the child.\\n     *    (Object) attrs - The attributes of the child in object notation.\\n     *    (String) text - The text to add to the child.\\n     *\\n     *  Returns:\\n     *    The Strophe.Builder object.\\n     */\\n    c: function (name, attrs, text) {\\n        var child = Strophe.xmlElement(name, attrs, text);\\n        this.node.appendChild(child);\\n        if (typeof text !== \\\"string\\\" && typeof text !==\\\"number\\\") {\\n            this.node = child;\\n        }\\n        return this;\\n    },\\n\\n    /** Function: cnode\\n     *  Add a child to the current element and make it the new current\\n     *  element.\\n     *\\n     *  This function is the same as c() except that instead of using a\\n     *  name and an attributes object to create the child it uses an\\n     *  existing DOM element object.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - A DOM element.\\n     *\\n     *  Returns:\\n     *    The Strophe.Builder object.\\n     */\\n    cnode: function (elem) {\\n        var impNode;\\n        var xmlGen = Strophe.xmlGenerator();\\n        try {\\n            impNode = (xmlGen.importNode !== undefined);\\n        } catch (e) {\\n            impNode = false;\\n        }\\n        var newElem = impNode ?\\n                      xmlGen.importNode(elem, true) :\\n                      Strophe.copyElement(elem);\\n        this.node.appendChild(newElem);\\n        this.node = newElem;\\n        return this;\\n    },\\n\\n    /** Function: t\\n     *  Add a child text element.\\n     *\\n     *  This *does not* make the child the new current element since there\\n     *  are no children of text elements.\\n     *\\n     *  Parameters:\\n     *    (String) text - The text data to append to the current element.\\n     *\\n     *  Returns:\\n     *    The Strophe.Builder object.\\n     */\\n    t: function (text) {\\n        var child = Strophe.xmlTextNode(text);\\n        this.node.appendChild(child);\\n        return this;\\n    },\\n\\n    /** Function: h\\n     *  Replace current element contents with the HTML passed in.\\n     *\\n     *  This *does not* make the child the new current element\\n     *\\n     *  Parameters:\\n     *    (String) html - The html to insert as contents of current element.\\n     *\\n     *  Returns:\\n     *    The Strophe.Builder object.\\n     */\\n    h: function (html) {\\n        var fragment = document.createElement('body');\\n\\n        // force the browser to try and fix any invalid HTML tags\\n        fragment.innerHTML = html;\\n\\n        // copy cleaned html into an xml dom\\n        var xhtml = Strophe.createHtml(fragment);\\n\\n        while(xhtml.childNodes.length > 0) {\\n            this.node.appendChild(xhtml.childNodes[0]);\\n        }\\n        return this;\\n    }\\n};\\n\\n/** PrivateClass: Strophe.Handler\\n *  _Private_ helper class for managing stanza handlers.\\n *\\n *  A Strophe.Handler encapsulates a user provided callback function to be\\n *  executed when matching stanzas are received by the connection.\\n *  Handlers can be either one-off or persistant depending on their\\n *  return value. Returning true will cause a Handler to remain active, and\\n *  returning false will remove the Handler.\\n *\\n *  Users will not use Strophe.Handler objects directly, but instead they\\n *  will use Strophe.Connection.addHandler() and\\n *  Strophe.Connection.deleteHandler().\\n */\\n\\n/** PrivateConstructor: Strophe.Handler\\n *  Create and initialize a new Strophe.Handler.\\n *\\n *  Parameters:\\n *    (Function) handler - A function to be executed when the handler is run.\\n *    (String) ns - The namespace to match.\\n *    (String) name - The element name to match.\\n *    (String) type - The element type to match.\\n *    (String) id - The element id attribute to match.\\n *    (String) from - The element from attribute to match.\\n *    (Object) options - Handler options\\n *\\n *  Returns:\\n *    A new Strophe.Handler object.\\n */\\nStrophe.Handler = function (handler, ns, name, type, id, from, options) {\\n    this.handler = handler;\\n    this.ns = ns;\\n    this.name = name;\\n    this.type = type;\\n    this.id = id;\\n    this.options = options || {'matchBareFromJid': false, 'ignoreNamespaceFragment': false};\\n    // BBB: Maintain backward compatibility with old `matchBare` option\\n    if (this.options.matchBare) {\\n        Strophe.warn('The \\\"matchBare\\\" option is deprecated, use \\\"matchBareFromJid\\\" instead.');\\n        this.options.matchBareFromJid = this.options.matchBare;\\n        delete this.options.matchBare;\\n    }\\n\\n    if (this.options.matchBareFromJid) {\\n        this.from = from ? Strophe.getBareJidFromJid(from) : null;\\n    } else {\\n        this.from = from;\\n    }\\n    // whether the handler is a user handler or a system handler\\n    this.user = true;\\n};\\n\\nStrophe.Handler.prototype = {\\n    /** PrivateFunction: getNamespace\\n     *  Returns the XML namespace attribute on an element.\\n     *  If `ignoreNamespaceFragment` was passed in for this handler, then the\\n     *  URL fragment will be stripped.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The XML element with the namespace.\\n     *\\n     *  Returns:\\n     *    The namespace, with optionally the fragment stripped.\\n     */\\n    getNamespace: function (elem) {\\n        var elNamespace = elem.getAttribute(\\\"xmlns\\\");\\n        if (elNamespace && this.options.ignoreNamespaceFragment) {\\n            elNamespace = elNamespace.split('#')[0];\\n        }\\n        return elNamespace;\\n    },\\n\\n    /** PrivateFunction: namespaceMatch\\n     *  Tests if a stanza matches the namespace set for this Strophe.Handler.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The XML element to test.\\n     *\\n     *  Returns:\\n     *    true if the stanza matches and false otherwise.\\n     */\\n    namespaceMatch: function (elem) {\\n        var nsMatch = false;\\n        if (!this.ns) {\\n            return true;\\n        } else {\\n            var that = this;\\n            Strophe.forEachChild(elem, null, function (elem) {\\n                if (that.getNamespace(elem) === that.ns) {\\n                    nsMatch = true;\\n                }\\n            });\\n            nsMatch = nsMatch || this.getNamespace(elem) === this.ns;\\n        }\\n        return nsMatch;\\n    },\\n\\n    /** PrivateFunction: isMatch\\n     *  Tests if a stanza matches the Strophe.Handler.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The XML element to test.\\n     *\\n     *  Returns:\\n     *    true if the stanza matches and false otherwise.\\n     */\\n    isMatch: function (elem) {\\n        var from = elem.getAttribute('from');\\n        if (this.options.matchBareFromJid) {\\n            from = Strophe.getBareJidFromJid(from);\\n        }\\n        var elem_type = elem.getAttribute(\\\"type\\\");\\n        if (this.namespaceMatch(elem) &&\\n            (!this.name || Strophe.isTagEqual(elem, this.name)) &&\\n            (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) !== -1 : elem_type === this.type)) &&\\n            (!this.id || elem.getAttribute(\\\"id\\\") === this.id) &&\\n            (!this.from || from === this.from)) {\\n                return true;\\n        }\\n        return false;\\n    },\\n\\n    /** PrivateFunction: run\\n     *  Run the callback on a matching stanza.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The DOM element that triggered the\\n     *      Strophe.Handler.\\n     *\\n     *  Returns:\\n     *    A boolean indicating if the handler should remain active.\\n     */\\n    run: function (elem) {\\n        var result = null;\\n        try {\\n            result = this.handler(elem);\\n        } catch (e) {\\n            Strophe._handleError(e);\\n            throw e;\\n        }\\n        return result;\\n    },\\n\\n    /** PrivateFunction: toString\\n     *  Get a String representation of the Strophe.Handler object.\\n     *\\n     *  Returns:\\n     *    A String.\\n     */\\n    toString: function () {\\n        return \\\"{Handler: \\\" + this.handler + \\\"(\\\" + this.name + \\\",\\\" +\\n            this.id + \\\",\\\" + this.ns + \\\")}\\\";\\n    }\\n};\\n\\n/** PrivateClass: Strophe.TimedHandler\\n *  _Private_ helper class for managing timed handlers.\\n *\\n *  A Strophe.TimedHandler encapsulates a user provided callback that\\n *  should be called after a certain period of time or at regular\\n *  intervals.  The return value of the callback determines whether the\\n *  Strophe.TimedHandler will continue to fire.\\n *\\n *  Users will not use Strophe.TimedHandler objects directly, but instead\\n *  they will use Strophe.Connection.addTimedHandler() and\\n *  Strophe.Connection.deleteTimedHandler().\\n */\\n\\n/** PrivateConstructor: Strophe.TimedHandler\\n *  Create and initialize a new Strophe.TimedHandler object.\\n *\\n *  Parameters:\\n *    (Integer) period - The number of milliseconds to wait before the\\n *      handler is called.\\n *    (Function) handler - The callback to run when the handler fires.  This\\n *      function should take no arguments.\\n *\\n *  Returns:\\n *    A new Strophe.TimedHandler object.\\n */\\nStrophe.TimedHandler = function (period, handler) {\\n    this.period = period;\\n    this.handler = handler;\\n    this.lastCalled = new Date().getTime();\\n    this.user = true;\\n};\\n\\nStrophe.TimedHandler.prototype = {\\n    /** PrivateFunction: run\\n     *  Run the callback for the Strophe.TimedHandler.\\n     *\\n     *  Returns:\\n     *    true if the Strophe.TimedHandler should be called again, and false\\n     *      otherwise.\\n     */\\n    run: function () {\\n        this.lastCalled = new Date().getTime();\\n        return this.handler();\\n    },\\n\\n    /** PrivateFunction: reset\\n     *  Reset the last called time for the Strophe.TimedHandler.\\n     */\\n    reset: function () {\\n        this.lastCalled = new Date().getTime();\\n    },\\n\\n    /** PrivateFunction: toString\\n     *  Get a string representation of the Strophe.TimedHandler object.\\n     *\\n     *  Returns:\\n     *    The string representation.\\n     */\\n    toString: function () {\\n        return \\\"{TimedHandler: \\\" + this.handler + \\\"(\\\" + this.period +\\\")}\\\";\\n    }\\n};\\n\\n/** Class: Strophe.Connection\\n *  XMPP Connection manager.\\n *\\n *  This class is the main part of Strophe.  It manages a BOSH or websocket\\n *  connection to an XMPP server and dispatches events to the user callbacks\\n *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1\\n *  and legacy authentication.\\n *\\n *  After creating a Strophe.Connection object, the user will typically\\n *  call connect() with a user supplied callback to handle connection level\\n *  events like authentication failure, disconnection, or connection\\n *  complete.\\n *\\n *  The user will also have several event handlers defined by using\\n *  addHandler() and addTimedHandler().  These will allow the user code to\\n *  respond to interesting stanzas or do something periodically with the\\n *  connection. These handlers will be active once authentication is\\n *  finished.\\n *\\n *  To send data to the connection, use send().\\n */\\n\\n/** Constructor: Strophe.Connection\\n *  Create and initialize a Strophe.Connection object.\\n *\\n *  The transport-protocol for this connection will be chosen automatically\\n *  based on the given service parameter. URLs starting with \\\"ws://\\\" or\\n *  \\\"wss://\\\" will use WebSockets, URLs starting with \\\"http://\\\", \\\"https://\\\"\\n *  or without a protocol will use BOSH.\\n *\\n *  To make Strophe connect to the current host you can leave out the protocol\\n *  and host part and just pass the path, e.g.\\n *\\n *  > var conn = new Strophe.Connection(\\\"/http-bind/\\\");\\n *\\n *  Options common to both Websocket and BOSH:\\n *  ------------------------------------------\\n *\\n *  cookies:\\n *\\n *  The *cookies* option allows you to pass in cookies to be added to the\\n *  document. These cookies will then be included in the BOSH XMLHttpRequest\\n *  or in the websocket connection.\\n *\\n *  The passed in value must be a map of cookie names and string values.\\n *\\n *  > { \\\"myCookie\\\": {\\n *  >     \\\"value\\\": \\\"1234\\\",\\n *  >     \\\"domain\\\": \\\".example.org\\\",\\n *  >     \\\"path\\\": \\\"/\\\",\\n *  >     \\\"expires\\\": expirationDate\\n *  >     }\\n *  > }\\n *\\n *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).\\n *  Those cookies need to be set under those domains, for example they can be\\n *  set server-side by making a XHR call to that domain to ask it to set any\\n *  necessary cookies.\\n *\\n *  mechanisms:\\n *\\n *  The *mechanisms* option allows you to specify the SASL mechanisms that this\\n *  instance of Strophe.Connection (and therefore your XMPP client) will\\n *  support.\\n *\\n *  The value must be an array of objects with Strophe.SASLMechanism\\n *  prototypes.\\n *\\n *  If nothing is specified, then the following mechanisms (and their\\n *  priorities) are registered:\\n *\\n *      OAUTHBEARER - 60\\n *      SCRAM-SHA1 - 50\\n *      DIGEST-MD5 - 40\\n *      PLAIN - 30\\n *      ANONYMOUS - 20\\n *      EXTERNAL - 10\\n *\\n *  WebSocket options:\\n *  ------------------\\n *\\n *  If you want to connect to the current host with a WebSocket connection you\\n *  can tell Strophe to use WebSockets through a \\\"protocol\\\" attribute in the\\n *  optional options parameter. Valid values are \\\"ws\\\" for WebSocket and \\\"wss\\\"\\n *  for Secure WebSocket.\\n *  So to connect to \\\"wss://CURRENT_HOSTNAME/xmpp-websocket\\\" you would call\\n *\\n *  > var conn = new Strophe.Connection(\\\"/xmpp-websocket/\\\", {protocol: \\\"wss\\\"});\\n *\\n *  Note that relative URLs _NOT_ starting with a \\\"/\\\" will also include the path\\n *  of the current site.\\n *\\n *  Also because downgrading security is not permitted by browsers, when using\\n *  relative URLs both BOSH and WebSocket connections will use their secure\\n *  variants if the current connection to the site is also secure (https).\\n *\\n *  BOSH options:\\n *  -------------\\n *\\n *  By adding \\\"sync\\\" to the options, you can control if requests will\\n *  be made synchronously or not. The default behaviour is asynchronous.\\n *  If you want to make requests synchronous, make \\\"sync\\\" evaluate to true.\\n *  > var conn = new Strophe.Connection(\\\"/http-bind/\\\", {sync: true});\\n *\\n *  You can also toggle this on an already established connection.\\n *  > conn.options.sync = true;\\n *\\n *  The *customHeaders* option can be used to provide custom HTTP headers to be\\n *  included in the XMLHttpRequests made.\\n *\\n *  The *keepalive* option can be used to instruct Strophe to maintain the\\n *  current BOSH session across interruptions such as webpage reloads.\\n *\\n *  It will do this by caching the sessions tokens in sessionStorage, and when\\n *  \\\"restore\\\" is called it will check whether there are cached tokens with\\n *  which it can resume an existing session.\\n *\\n *  The *withCredentials* option should receive a Boolean value and is used to\\n *  indicate wether cookies should be included in ajax requests (by default\\n *  they're not).\\n *  Set this value to true if you are connecting to a BOSH service\\n *  and for some reason need to send cookies to it.\\n *  In order for this to work cross-domain, the server must also enable\\n *  credentials by setting the Access-Control-Allow-Credentials response header\\n *  to \\\"true\\\". For most usecases however this setting should be false (which\\n *  is the default).\\n *  Additionally, when using Access-Control-Allow-Credentials, the\\n *  Access-Control-Allow-Origin header can't be set to the wildcard \\\"*\\\", but\\n *  instead must be restricted to actual domains.\\n *\\n *  The *contentType* option can be set to change the default Content-Type\\n *  of \\\"text/xml; charset=utf-8\\\", which can be useful to reduce the amount of\\n *  CORS preflight requests that are sent to the server.\\n *\\n *  Parameters:\\n *    (String) service - The BOSH or WebSocket service URL.\\n *    (Object) options - A hash of configuration options\\n *\\n *  Returns:\\n *    A new Strophe.Connection object.\\n */\\nStrophe.Connection = function (service, options) {\\n    // The service URL\\n    this.service = service;\\n    // Configuration options\\n    this.options = options || {};\\n    var proto = this.options.protocol || \\\"\\\";\\n\\n    // Select protocal based on service or options\\n    if (service.indexOf(\\\"ws:\\\") === 0 || service.indexOf(\\\"wss:\\\") === 0 ||\\n            proto.indexOf(\\\"ws\\\") === 0) {\\n        this._proto = new Strophe.Websocket(this);\\n    } else {\\n        this._proto = new Strophe.Bosh(this);\\n    }\\n\\n    /* The connected JID. */\\n    this.jid = \\\"\\\";\\n    /* the JIDs domain */\\n    this.domain = null;\\n    /* stream:features */\\n    this.features = null;\\n\\n    // SASL\\n    this._sasl_data = {};\\n    this.do_session = false;\\n    this.do_bind = false;\\n\\n    // handler lists\\n    this.timedHandlers = [];\\n    this.handlers = [];\\n    this.removeTimeds = [];\\n    this.removeHandlers = [];\\n    this.addTimeds = [];\\n    this.addHandlers = [];\\n    this.protocolErrorHandlers = {\\n        'HTTP': {},\\n        'websocket': {}\\n    };\\n\\n    this._idleTimeout = null;\\n    this._disconnectTimeout = null;\\n\\n    this.authenticated = false;\\n    this.connected = false;\\n    this.disconnecting = false;\\n    this.do_authentication = true;\\n    this.paused = false;\\n    this.restored = false;\\n\\n    this._data = [];\\n    this._uniqueId = 0;\\n\\n    this._sasl_success_handler = null;\\n    this._sasl_failure_handler = null;\\n    this._sasl_challenge_handler = null;\\n\\n    // Max retries before disconnecting\\n    this.maxRetries = 5;\\n\\n    // Call onIdle callback every 1/10th of a second\\n    // XXX: setTimeout should be called only with function expressions (23974bc1)\\n    this._idleTimeout = setTimeout(function() {\\n        this._onIdle();\\n    }.bind(this), 100);\\n\\n    utils.addCookies(this.options.cookies);\\n    this.registerSASLMechanisms(this.options.mechanisms);\\n\\n    // initialize plugins\\n    for (var k in Strophe._connectionPlugins) {\\n        if (Strophe._connectionPlugins.hasOwnProperty(k)) {\\n            var ptype = Strophe._connectionPlugins[k];\\n            // jslint complaints about the below line, but this is fine\\n            var F = function () {}; // jshint ignore:line\\n            F.prototype = ptype;\\n            this[k] = new F();\\n            this[k].init(this);\\n        }\\n    }\\n};\\n\\nStrophe.Connection.prototype = {\\n    /** Function: reset\\n     *  Reset the connection.\\n     *\\n     *  This function should be called after a connection is disconnected\\n     *  before that connection is reused.\\n     */\\n    reset: function () {\\n        this._proto._reset();\\n\\n        // SASL\\n        this.do_session = false;\\n        this.do_bind = false;\\n\\n        // handler lists\\n        this.timedHandlers = [];\\n        this.handlers = [];\\n        this.removeTimeds = [];\\n        this.removeHandlers = [];\\n        this.addTimeds = [];\\n        this.addHandlers = [];\\n\\n        this.authenticated = false;\\n        this.connected = false;\\n        this.disconnecting = false;\\n        this.restored = false;\\n\\n        this._data = [];\\n        this._requests = [];\\n        this._uniqueId = 0;\\n    },\\n\\n    /** Function: pause\\n     *  Pause the request manager.\\n     *\\n     *  This will prevent Strophe from sending any more requests to the\\n     *  server.  This is very useful for temporarily pausing\\n     *  BOSH-Connections while a lot of send() calls are happening quickly.\\n     *  This causes Strophe to send the data in a single request, saving\\n     *  many request trips.\\n     */\\n    pause: function () {\\n        this.paused = true;\\n    },\\n\\n    /** Function: resume\\n     *  Resume the request manager.\\n     *\\n     *  This resumes after pause() has been called.\\n     */\\n    resume: function () {\\n        this.paused = false;\\n    },\\n\\n    /** Function: getUniqueId\\n     *  Generate a unique ID for use in <iq/> elements.\\n     *\\n     *  All <iq/> stanzas are required to have unique id attributes.  This\\n     *  function makes creating these easy.  Each connection instance has\\n     *  a counter which starts from zero, and the value of this counter\\n     *  plus a colon followed by the suffix becomes the unique id. If no\\n     *  suffix is supplied, the counter is used as the unique id.\\n     *\\n     *  Suffixes are used to make debugging easier when reading the stream\\n     *  data, and their use is recommended.  The counter resets to 0 for\\n     *  every new connection for the same reason.  For connections to the\\n     *  same server that authenticate the same way, all the ids should be\\n     *  the same, which makes it easy to see changes.  This is useful for\\n     *  automated testing as well.\\n     *\\n     *  Parameters:\\n     *    (String) suffix - A optional suffix to append to the id.\\n     *\\n     *  Returns:\\n     *    A unique string to be used for the id attribute.\\n     */\\n    getUniqueId: function(suffix) {\\n        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\\n            var r = Math.random() * 16 | 0,\\n                v = c === 'x' ? r : r & 0x3 | 0x8;\\n            return v.toString(16);\\n        });\\n        if (typeof(suffix) === \\\"string\\\" || typeof(suffix) === \\\"number\\\") {\\n            return uuid + \\\":\\\" + suffix;\\n        } else {\\n            return uuid + \\\"\\\";\\n        }\\n    },\\n\\n    /** Function: addProtocolErrorHandler\\n     *  Register a handler function for when a protocol (websocker or HTTP)\\n     *  error occurs.\\n     *\\n     *  NOTE: Currently only HTTP errors for BOSH requests are handled.\\n     *  Patches that handle websocket errors would be very welcome.\\n     *\\n     *  Parameters:\\n     *    (String) protocol - 'HTTP' or 'websocket'\\n     *    (Integer) status_code - Error status code (e.g 500, 400 or 404)\\n     *    (Function) callback - Function that will fire on Http error\\n     *\\n     *  Example:\\n     *  function onError(err_code){\\n     *    //do stuff\\n     *  }\\n     *\\n     *  var conn = Strophe.connect('http://example.com/http-bind');\\n     *  conn.addProtocolErrorHandler('HTTP', 500, onError);\\n     *  // Triggers HTTP 500 error and onError handler will be called\\n     *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);\\n     */\\n    addProtocolErrorHandler: function(protocol, status_code, callback){\\n        this.protocolErrorHandlers[protocol][status_code] = callback;\\n    },\\n\\n\\n    /** Function: connect\\n     *  Starts the connection process.\\n     *\\n     *  As the connection process proceeds, the user supplied callback will\\n     *  be triggered multiple times with status updates.  The callback\\n     *  should take two arguments - the status code and the error condition.\\n     *\\n     *  The status code will be one of the values in the Strophe.Status\\n     *  constants.  The error condition will be one of the conditions\\n     *  defined in RFC 3920 or the condition 'strophe-parsererror'.\\n     *\\n     *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant\\n     *  for BOSH connections. Please see XEP 124 for a more detailed explanation\\n     *  of the optional parameters.\\n     *\\n     *  Parameters:\\n     *    (String) jid - The user's JID.  This may be a bare JID,\\n     *      or a full JID.  If a node is not supplied, SASL OAUTHBEARER or\\n     *      SASL ANONYMOUS authentication will be attempted (OAUTHBEARER will\\n     *      process the provided password value as an access token).\\n     *    (String) pass - The user's password.\\n     *    (Function) callback - The connect callback function.\\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\\n     *      time the server will wait before returning an empty result for\\n     *      a request.  The default setting of 60 seconds is recommended.\\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\\n     *      number of connections the server will hold at one time.  This\\n     *      should almost always be set to 1 (the default).\\n     *    (String) route - The optional route value.\\n     *    (String) authcid - The optional alternative authentication identity\\n     *      (username) if intending to impersonate another user.\\n     *      When using the SASL-EXTERNAL authentication mechanism, for example\\n     *      with client certificates, then the authcid value is used to\\n     *      determine whether an authorization JID (authzid) should be sent to\\n     *      the server. The authzid should not be sent to the server if the\\n     *      authzid and authcid are the same. So to prevent it from being sent\\n     *      (for example when the JID is already contained in the client\\n     *      certificate), set authcid to that same JID. See XEP-178 for more\\n     *      details.\\n     */\\n    connect: function (jid, pass, callback, wait, hold, route, authcid) {\\n        this.jid = jid;\\n        /** Variable: authzid\\n         *  Authorization identity.\\n         */\\n        this.authzid = Strophe.getBareJidFromJid(this.jid);\\n\\n        /** Variable: authcid\\n         *  Authentication identity (User name).\\n         */\\n        this.authcid = authcid || Strophe.getNodeFromJid(this.jid);\\n\\n        /** Variable: pass\\n         *  Authentication identity (User password).\\n         */\\n        this.pass = pass;\\n\\n        /** Variable: servtype\\n         *  Digest MD5 compatibility.\\n         */\\n        this.servtype = \\\"xmpp\\\";\\n\\n        this.connect_callback = callback;\\n        this.disconnecting = false;\\n        this.connected = false;\\n        this.authenticated = false;\\n        this.restored = false;\\n\\n        // parse jid for domain\\n        this.domain = Strophe.getDomainFromJid(this.jid);\\n\\n        this._changeConnectStatus(Strophe.Status.CONNECTING, null);\\n\\n        this._proto._connect(wait, hold, route);\\n    },\\n\\n    /** Function: attach\\n     *  Attach to an already created and authenticated BOSH session.\\n     *\\n     *  This function is provided to allow Strophe to attach to BOSH\\n     *  sessions which have been created externally, perhaps by a Web\\n     *  application.  This is often used to support auto-login type features\\n     *  without putting user credentials into the page.\\n     *\\n     *  Parameters:\\n     *    (String) jid - The full JID that is bound by the session.\\n     *    (String) sid - The SID of the BOSH session.\\n     *    (String) rid - The current RID of the BOSH session.  This RID\\n     *      will be used by the next request.\\n     *    (Function) callback The connect callback function.\\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\\n     *      time the server will wait before returning an empty result for\\n     *      a request.  The default setting of 60 seconds is recommended.\\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\\n     *      number of connections the server will hold at one time.  This\\n     *      should almost always be set to 1 (the default).\\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\\n     *      allowed range of request ids that are valid.  The default is 5.\\n     */\\n    attach: function (jid, sid, rid, callback, wait, hold, wind) {\\n        if (this._proto instanceof Strophe.Bosh) {\\n            this._proto._attach(jid, sid, rid, callback, wait, hold, wind);\\n        } else {\\n            throw {\\n                name: 'StropheSessionError',\\n                message: 'The \\\"attach\\\" method can only be used with a BOSH connection.'\\n            };\\n        }\\n    },\\n\\n    /** Function: restore\\n     *  Attempt to restore a cached BOSH session.\\n     *\\n     *  This function is only useful in conjunction with providing the\\n     *  \\\"keepalive\\\":true option when instantiating a new Strophe.Connection.\\n     *\\n     *  When \\\"keepalive\\\" is set to true, Strophe will cache the BOSH tokens\\n     *  RID (Request ID) and SID (Session ID) and then when this function is\\n     *  called, it will attempt to restore the session from those cached\\n     *  tokens.\\n     *\\n     *  This function must therefore be called instead of connect or attach.\\n     *\\n     *  For an example on how to use it, please see examples/restore.js\\n     *\\n     *  Parameters:\\n     *    (String) jid - The user's JID.  This may be a bare JID or a full JID.\\n     *    (Function) callback - The connect callback function.\\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\\n     *      time the server will wait before returning an empty result for\\n     *      a request.  The default setting of 60 seconds is recommended.\\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\\n     *      number of connections the server will hold at one time.  This\\n     *      should almost always be set to 1 (the default).\\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\\n     *      allowed range of request ids that are valid.  The default is 5.\\n     */\\n    restore: function (jid, callback, wait, hold, wind) {\\n        if (this._sessionCachingSupported()) {\\n            this._proto._restore(jid, callback, wait, hold, wind);\\n        } else {\\n            throw {\\n                name: 'StropheSessionError',\\n                message: 'The \\\"restore\\\" method can only be used with a BOSH connection.'\\n            };\\n        }\\n    },\\n\\n    /** PrivateFunction: _sessionCachingSupported\\n     * Checks whether sessionStorage and JSON are supported and whether we're\\n     * using BOSH.\\n     */\\n    _sessionCachingSupported: function () {\\n        if (this._proto instanceof Strophe.Bosh) {\\n            if (!JSON) { return false; }\\n            try {\\n                sessionStorage.setItem('_strophe_', '_strophe_');\\n                sessionStorage.removeItem('_strophe_');\\n            } catch (e) {\\n                return false;\\n            }\\n            return true;\\n        }\\n        return false;\\n    },\\n\\n    /** Function: xmlInput\\n     *  User overrideable function that receives XML data coming into the\\n     *  connection.\\n     *\\n     *  The default function does nothing.  User code can override this with\\n     *  > Strophe.Connection.xmlInput = function (elem) {\\n     *  >   (user code)\\n     *  > };\\n     *\\n     *  Due to limitations of current Browsers' XML-Parsers the opening and closing\\n     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\\n     *\\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\\n     *  <Strophe.Bosh.strip> if you want to strip this tag.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The XML data received by the connection.\\n     */\\n    /* jshint unused:false */\\n    xmlInput: function (elem) {\\n        return;\\n    },\\n    /* jshint unused:true */\\n\\n    /** Function: xmlOutput\\n     *  User overrideable function that receives XML data sent to the\\n     *  connection.\\n     *\\n     *  The default function does nothing.  User code can override this with\\n     *  > Strophe.Connection.xmlOutput = function (elem) {\\n     *  >   (user code)\\n     *  > };\\n     *\\n     *  Due to limitations of current Browsers' XML-Parsers the opening and closing\\n     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\\n     *\\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\\n     *  <Strophe.Bosh.strip> if you want to strip this tag.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The XMLdata sent by the connection.\\n     */\\n    /* jshint unused:false */\\n    xmlOutput: function (elem) {\\n        return;\\n    },\\n    /* jshint unused:true */\\n\\n    /** Function: rawInput\\n     *  User overrideable function that receives raw data coming into the\\n     *  connection.\\n     *\\n     *  The default function does nothing.  User code can override this with\\n     *  > Strophe.Connection.rawInput = function (data) {\\n     *  >   (user code)\\n     *  > };\\n     *\\n     *  Parameters:\\n     *    (String) data - The data received by the connection.\\n     */\\n    /* jshint unused:false */\\n    rawInput: function (data) {\\n        return;\\n    },\\n    /* jshint unused:true */\\n\\n    /** Function: rawOutput\\n     *  User overrideable function that receives raw data sent to the\\n     *  connection.\\n     *\\n     *  The default function does nothing.  User code can override this with\\n     *  > Strophe.Connection.rawOutput = function (data) {\\n     *  >   (user code)\\n     *  > };\\n     *\\n     *  Parameters:\\n     *    (String) data - The data sent by the connection.\\n     */\\n    /* jshint unused:false */\\n    rawOutput: function (data) {\\n        return;\\n    },\\n    /* jshint unused:true */\\n\\n    /** Function: nextValidRid\\n     *  User overrideable function that receives the new valid rid.\\n     *\\n     *  The default function does nothing. User code can override this with\\n     *  > Strophe.Connection.nextValidRid = function (rid) {\\n     *  >    (user code)\\n     *  > };\\n     *\\n     *  Parameters:\\n     *    (Number) rid - The next valid rid\\n     */\\n    /* jshint unused:false */\\n    nextValidRid: function (rid) {\\n        return;\\n    },\\n    /* jshint unused:true */\\n\\n    /** Function: send\\n     *  Send a stanza.\\n     *\\n     *  This function is called to push data onto the send queue to\\n     *  go out over the wire.  Whenever a request is sent to the BOSH\\n     *  server, all pending data is sent and the queue is flushed.\\n     *\\n     *  Parameters:\\n     *    (XMLElement |\\n     *     [XMLElement] |\\n     *     Strophe.Builder) elem - The stanza to send.\\n     */\\n    send: function (elem) {\\n        if (elem === null) { return ; }\\n        if (typeof(elem.sort) === \\\"function\\\") {\\n            for (var i = 0; i < elem.length; i++) {\\n                this._queueData(elem[i]);\\n            }\\n        } else if (typeof(elem.tree) === \\\"function\\\") {\\n            this._queueData(elem.tree());\\n        } else {\\n            this._queueData(elem);\\n        }\\n\\n        this._proto._send();\\n    },\\n\\n    /** Function: flush\\n     *  Immediately send any pending outgoing data.\\n     *\\n     *  Normally send() queues outgoing data until the next idle period\\n     *  (100ms), which optimizes network use in the common cases when\\n     *  several send()s are called in succession. flush() can be used to\\n     *  immediately send all pending data.\\n     */\\n    flush: function () {\\n        // cancel the pending idle period and run the idle function\\n        // immediately\\n        clearTimeout(this._idleTimeout);\\n        this._onIdle();\\n    },\\n\\n    /** Function: sendPresence\\n     *  Helper function to send presence stanzas. The main benefit is for\\n     *  sending presence stanzas for which you expect a responding presence\\n     *  stanza with the same id (for example when leaving a chat room).\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The stanza to send.\\n     *    (Function) callback - The callback function for a successful request.\\n     *    (Function) errback - The callback function for a failed or timed\\n     *      out request.  On timeout, the stanza will be null.\\n     *    (Integer) timeout - The time specified in milliseconds for a\\n     *      timeout to occur.\\n     *\\n     *  Returns:\\n     *    The id used to send the presence.\\n     */\\n    sendPresence: function(elem, callback, errback, timeout) {\\n        var timeoutHandler = null;\\n        var that = this;\\n        if (typeof(elem.tree) === \\\"function\\\") {\\n            elem = elem.tree();\\n        }\\n        var id = elem.getAttribute('id');\\n        if (!id) { // inject id if not found\\n            id = this.getUniqueId(\\\"sendPresence\\\");\\n            elem.setAttribute(\\\"id\\\", id);\\n        }\\n\\n        if (typeof callback === \\\"function\\\" || typeof errback === \\\"function\\\") {\\n            var handler = this.addHandler(function (stanza) {\\n                // remove timeout handler if there is one\\n                if (timeoutHandler) {\\n                    that.deleteTimedHandler(timeoutHandler);\\n                }\\n                var type = stanza.getAttribute('type');\\n                if (type === 'error') {\\n                    if (errback) {\\n                        errback(stanza);\\n                    }\\n                } else if (callback) {\\n                    callback(stanza);\\n                }\\n            }, null, 'presence', null, id);\\n\\n            // if timeout specified, set up a timeout handler.\\n            if (timeout) {\\n                timeoutHandler = this.addTimedHandler(timeout, function () {\\n                    // get rid of normal handler\\n                    that.deleteHandler(handler);\\n                    // call errback on timeout with null stanza\\n                    if (errback) {\\n                        errback(null);\\n                    }\\n                    return false;\\n                });\\n            }\\n        }\\n        this.send(elem);\\n        return id;\\n    },\\n\\n    /** Function: sendIQ\\n     *  Helper function to send IQ stanzas.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The stanza to send.\\n     *    (Function) callback - The callback function for a successful request.\\n     *    (Function) errback - The callback function for a failed or timed\\n     *      out request.  On timeout, the stanza will be null.\\n     *    (Integer) timeout - The time specified in milliseconds for a\\n     *      timeout to occur.\\n     *\\n     *  Returns:\\n     *    The id used to send the IQ.\\n    */\\n    sendIQ: function(elem, callback, errback, timeout) {\\n        var timeoutHandler = null;\\n        var that = this;\\n        if (typeof(elem.tree) === \\\"function\\\") {\\n            elem = elem.tree();\\n        }\\n        var id = elem.getAttribute('id');\\n        if (!id) { // inject id if not found\\n            id = this.getUniqueId(\\\"sendIQ\\\");\\n            elem.setAttribute(\\\"id\\\", id);\\n        }\\n\\n        if (typeof callback === \\\"function\\\" || typeof errback === \\\"function\\\") {\\n            var handler = this.addHandler(function (stanza) {\\n                // remove timeout handler if there is one\\n                if (timeoutHandler) {\\n                    that.deleteTimedHandler(timeoutHandler);\\n                }\\n                var iqtype = stanza.getAttribute('type');\\n                if (iqtype === 'result') {\\n                    if (callback) {\\n                        callback(stanza);\\n                    }\\n                } else if (iqtype === 'error') {\\n                    if (errback) {\\n                        errback(stanza);\\n                    }\\n                } else {\\n                    throw {\\n                        name: \\\"StropheError\\\",\\n                        message: \\\"Got bad IQ type of \\\" + iqtype\\n                    };\\n                }\\n            }, null, 'iq', ['error', 'result'], id);\\n\\n            // if timeout specified, set up a timeout handler.\\n            if (timeout) {\\n                timeoutHandler = this.addTimedHandler(timeout, function () {\\n                    // get rid of normal handler\\n                    that.deleteHandler(handler);\\n                    // call errback on timeout with null stanza\\n                    if (errback) {\\n                        errback(null);\\n                    }\\n                    return false;\\n                });\\n            }\\n        }\\n        this.send(elem);\\n        return id;\\n    },\\n\\n    /** PrivateFunction: _queueData\\n     *  Queue outgoing data for later sending.  Also ensures that the data\\n     *  is a DOMElement.\\n     */\\n    _queueData: function (element) {\\n        if (element === null ||\\n            !element.tagName ||\\n            !element.childNodes) {\\n            throw {\\n                name: \\\"StropheError\\\",\\n                message: \\\"Cannot queue non-DOMElement.\\\"\\n            };\\n        }\\n        this._data.push(element);\\n    },\\n\\n    /** PrivateFunction: _sendRestart\\n     *  Send an xmpp:restart stanza.\\n     */\\n    _sendRestart: function () {\\n        this._data.push(\\\"restart\\\");\\n        this._proto._sendRestart();\\n        // XXX: setTimeout should be called only with function expressions (23974bc1)\\n        this._idleTimeout = setTimeout(function() {\\n            this._onIdle();\\n        }.bind(this), 100);\\n    },\\n\\n    /** Function: addTimedHandler\\n     *  Add a timed handler to the connection.\\n     *\\n     *  This function adds a timed handler.  The provided handler will\\n     *  be called every period milliseconds until it returns false,\\n     *  the connection is terminated, or the handler is removed.  Handlers\\n     *  that wish to continue being invoked should return true.\\n     *\\n     *  Because of method binding it is necessary to save the result of\\n     *  this function if you wish to remove a handler with\\n     *  deleteTimedHandler().\\n     *\\n     *  Note that user handlers are not active until authentication is\\n     *  successful.\\n     *\\n     *  Parameters:\\n     *    (Integer) period - The period of the handler.\\n     *    (Function) handler - The callback function.\\n     *\\n     *  Returns:\\n     *    A reference to the handler that can be used to remove it.\\n     */\\n    addTimedHandler: function (period, handler) {\\n        var thand = new Strophe.TimedHandler(period, handler);\\n        this.addTimeds.push(thand);\\n        return thand;\\n    },\\n\\n    /** Function: deleteTimedHandler\\n     *  Delete a timed handler for a connection.\\n     *\\n     *  This function removes a timed handler from the connection.  The\\n     *  handRef parameter is *not* the function passed to addTimedHandler(),\\n     *  but is the reference returned from addTimedHandler().\\n     *\\n     *  Parameters:\\n     *    (Strophe.TimedHandler) handRef - The handler reference.\\n     */\\n    deleteTimedHandler: function (handRef) {\\n        // this must be done in the Idle loop so that we don't change\\n        // the handlers during iteration\\n        this.removeTimeds.push(handRef);\\n    },\\n\\n    /** Function: addHandler\\n     *  Add a stanza handler for the connection.\\n     *\\n     *  This function adds a stanza handler to the connection.  The\\n     *  handler callback will be called for any stanza that matches\\n     *  the parameters.  Note that if multiple parameters are supplied,\\n     *  they must all match for the handler to be invoked.\\n     *\\n     *  The handler will receive the stanza that triggered it as its argument.\\n     *  *The handler should return true if it is to be invoked again;\\n     *  returning false will remove the handler after it returns.*\\n     *\\n     *  As a convenience, the ns parameters applies to the top level element\\n     *  and also any of its immediate children.  This is primarily to make\\n     *  matching /iq/query elements easy.\\n     *\\n     *  Options\\n     *  ~~~~~~~\\n     *  With the options argument, you can specify boolean flags that affect how\\n     *  matches are being done.\\n     *\\n     *  Currently two flags exist:\\n     *\\n     *  - matchBareFromJid:\\n     *      When set to true, the from parameter and the\\n     *      from attribute on the stanza will be matched as bare JIDs instead\\n     *      of full JIDs. To use this, pass {matchBareFromJid: true} as the\\n     *      value of options. The default value for matchBareFromJid is false.\\n     *\\n     *  - ignoreNamespaceFragment:\\n     *      When set to true, a fragment specified on the stanza's namespace\\n     *      URL will be ignored when it's matched with the one configured for\\n     *      the handler.\\n     *\\n     *      This means that if you register like this:\\n     *      >   connection.addHandler(\\n     *      >       handler,\\n     *      >       'http://jabber.org/protocol/muc',\\n     *      >       null, null, null, null,\\n     *      >       {'ignoreNamespaceFragment': true}\\n     *      >   );\\n     *\\n     *      Then a stanza with XML namespace of\\n     *      'http://jabber.org/protocol/muc#user' will also be matched. If\\n     *      'ignoreNamespaceFragment' is false, then only stanzas with\\n     *      'http://jabber.org/protocol/muc' will be matched.\\n     *\\n     *  Deleting the handler\\n     *  ~~~~~~~~~~~~~~~~~~~~\\n     *  The return value should be saved if you wish to remove the handler\\n     *  with deleteHandler().\\n     *\\n     *  Parameters:\\n     *    (Function) handler - The user callback.\\n     *    (String) ns - The namespace to match.\\n     *    (String) name - The stanza name to match.\\n     *    (String|Array) type - The stanza type (or types if an array) to match.\\n     *    (String) id - The stanza id attribute to match.\\n     *    (String) from - The stanza from attribute to match.\\n     *    (String) options - The handler options\\n     *\\n     *  Returns:\\n     *    A reference to the handler that can be used to remove it.\\n     */\\n    addHandler: function (handler, ns, name, type, id, from, options) {\\n        var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);\\n        this.addHandlers.push(hand);\\n        return hand;\\n    },\\n\\n    /** Function: deleteHandler\\n     *  Delete a stanza handler for a connection.\\n     *\\n     *  This function removes a stanza handler from the connection.  The\\n     *  handRef parameter is *not* the function passed to addHandler(),\\n     *  but is the reference returned from addHandler().\\n     *\\n     *  Parameters:\\n     *    (Strophe.Handler) handRef - The handler reference.\\n     */\\n    deleteHandler: function (handRef) {\\n        // this must be done in the Idle loop so that we don't change\\n        // the handlers during iteration\\n        this.removeHandlers.push(handRef);\\n        // If a handler is being deleted while it is being added,\\n        // prevent it from getting added\\n        var i = this.addHandlers.indexOf(handRef);\\n        if (i >= 0) {\\n            this.addHandlers.splice(i, 1);\\n        }\\n    },\\n\\n    /** Function: registerSASLMechanisms\\n     *\\n     * Register the SASL mechanisms which will be supported by this instance of\\n     * Strophe.Connection (i.e. which this XMPP client will support).\\n     *\\n     *  Parameters:\\n     *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes\\n     *\\n     */\\n    registerSASLMechanisms: function (mechanisms) {\\n        this.mechanisms = {};\\n        mechanisms = mechanisms || [\\n            Strophe.SASLAnonymous,\\n            Strophe.SASLExternal,\\n            Strophe.SASLMD5,\\n            Strophe.SASLOAuthBearer,\\n            Strophe.SASLPlain,\\n            Strophe.SASLSHA1\\n        ];\\n        mechanisms.forEach(this.registerSASLMechanism.bind(this));\\n    },\\n\\n    /** Function: registerSASLMechanism\\n     *\\n     * Register a single SASL mechanism, to be supported by this client.\\n     *\\n     *  Parameters:\\n     *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype\\n     *\\n     */\\n    registerSASLMechanism: function (mechanism) {\\n        this.mechanisms[mechanism.prototype.name] = mechanism;\\n    },\\n\\n    /** Function: disconnect\\n     *  Start the graceful disconnection process.\\n     *\\n     *  This function starts the disconnection process.  This process starts\\n     *  by sending unavailable presence and sending BOSH body of type\\n     *  terminate.  A timeout handler makes sure that disconnection happens\\n     *  even if the BOSH server does not respond.\\n     *  If the Connection object isn't connected, at least tries to abort all pending requests\\n     *  so the connection object won't generate successful requests (which were already opened).\\n     *\\n     *  The user supplied connection callback will be notified of the\\n     *  progress as this process happens.\\n     *\\n     *  Parameters:\\n     *    (String) reason - The reason the disconnect is occuring.\\n     */\\n    disconnect: function (reason) {\\n        this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);\\n\\n        Strophe.info(\\\"Disconnect was called because: \\\" + reason);\\n        if (this.connected) {\\n            var pres = false;\\n            this.disconnecting = true;\\n            if (this.authenticated) {\\n                pres = $pres({\\n                    xmlns: Strophe.NS.CLIENT,\\n                    type: 'unavailable'\\n                });\\n            }\\n            // setup timeout handler\\n            this._disconnectTimeout = this._addSysTimedHandler(\\n                3000, this._onDisconnectTimeout.bind(this));\\n            this._proto._disconnect(pres);\\n        } else {\\n            Strophe.info(\\\"Disconnect was called before Strophe connected to the server\\\");\\n            this._proto._abortAllRequests();\\n            this._doDisconnect();\\n        }\\n    },\\n\\n    /** PrivateFunction: _changeConnectStatus\\n     *  _Private_ helper function that makes sure plugins and the user's\\n     *  callback are notified of connection status changes.\\n     *\\n     *  Parameters:\\n     *    (Integer) status - the new connection status, one of the values\\n     *      in Strophe.Status\\n     *    (String) condition - the error condition or null\\n     */\\n    _changeConnectStatus: function (status, condition) {\\n        // notify all plugins listening for status changes\\n        for (var k in Strophe._connectionPlugins) {\\n            if (Strophe._connectionPlugins.hasOwnProperty(k)) {\\n                var plugin = this[k];\\n                if (plugin.statusChanged) {\\n                    try {\\n                        plugin.statusChanged(status, condition);\\n                    } catch (err) {\\n                        Strophe.error(\\\"\\\" + k + \\\" plugin caused an exception \\\" +\\n                                      \\\"changing status: \\\" + err);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // notify the user's callback\\n        if (this.connect_callback) {\\n            try {\\n                this.connect_callback(status, condition);\\n            } catch (e) {\\n                Strophe._handleError(e);\\n                Strophe.error(\\n                    \\\"User connection callback caused an \\\"+\\\"exception: \\\"+e);\\n            }\\n        }\\n    },\\n\\n    /** PrivateFunction: _doDisconnect\\n     *  _Private_ function to disconnect.\\n     *\\n     *  This is the last piece of the disconnection logic.  This resets the\\n     *  connection and alerts the user's connection callback.\\n     */\\n    _doDisconnect: function (condition) {\\n        if (typeof this._idleTimeout === \\\"number\\\") {\\n            clearTimeout(this._idleTimeout);\\n        }\\n\\n        // Cancel Disconnect Timeout\\n        if (this._disconnectTimeout !== null) {\\n            this.deleteTimedHandler(this._disconnectTimeout);\\n            this._disconnectTimeout = null;\\n        }\\n\\n        Strophe.info(\\\"_doDisconnect was called\\\");\\n        this._proto._doDisconnect();\\n\\n        this.authenticated = false;\\n        this.disconnecting = false;\\n        this.restored = false;\\n\\n        // delete handlers\\n        this.handlers = [];\\n        this.timedHandlers = [];\\n        this.removeTimeds = [];\\n        this.removeHandlers = [];\\n        this.addTimeds = [];\\n        this.addHandlers = [];\\n\\n        // tell the parent we disconnected\\n        this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);\\n        this.connected = false;\\n    },\\n\\n    /** PrivateFunction: _dataRecv\\n     *  _Private_ handler to processes incoming data from the the connection.\\n     *\\n     *  Except for _connect_cb handling the initial connection request,\\n     *  this function handles the incoming data for all requests.  This\\n     *  function also fires stanza handlers that match each incoming\\n     *  stanza.\\n     *\\n     *  Parameters:\\n     *    (Strophe.Request) req - The request that has data ready.\\n     *    (string) req - The stanza a raw string (optiona).\\n     */\\n    _dataRecv: function (req, raw) {\\n        Strophe.info(\\\"_dataRecv called\\\");\\n        var elem = this._proto._reqToData(req);\\n        if (elem === null) { return; }\\n\\n        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\\n            if (elem.nodeName === this._proto.strip && elem.childNodes.length) {\\n                this.xmlInput(elem.childNodes[0]);\\n            } else {\\n                this.xmlInput(elem);\\n            }\\n        }\\n        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\\n            if (raw) {\\n                this.rawInput(raw);\\n            } else {\\n                this.rawInput(Strophe.serialize(elem));\\n            }\\n        }\\n\\n        // remove handlers scheduled for deletion\\n        var i, hand;\\n        while (this.removeHandlers.length > 0) {\\n            hand = this.removeHandlers.pop();\\n            i = this.handlers.indexOf(hand);\\n            if (i >= 0) {\\n                this.handlers.splice(i, 1);\\n            }\\n        }\\n\\n        // add handlers scheduled for addition\\n        while (this.addHandlers.length > 0) {\\n            this.handlers.push(this.addHandlers.pop());\\n        }\\n\\n        // handle graceful disconnect\\n        if (this.disconnecting && this._proto._emptyQueue()) {\\n            this._doDisconnect();\\n            return;\\n        }\\n\\n        var type = elem.getAttribute(\\\"type\\\");\\n        var cond, conflict;\\n        if (type !== null && type === \\\"terminate\\\") {\\n            // Don't process stanzas that come in after disconnect\\n            if (this.disconnecting) {\\n                return;\\n            }\\n\\n            // an error occurred\\n            cond = elem.getAttribute(\\\"condition\\\");\\n            conflict = elem.getElementsByTagName(\\\"conflict\\\");\\n            if (cond !== null) {\\n                if (cond === \\\"remote-stream-error\\\" && conflict.length > 0) {\\n                    cond = \\\"conflict\\\";\\n                }\\n                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\\n            } else {\\n                this._changeConnectStatus(Strophe.Status.CONNFAIL, \\\"unknown\\\");\\n            }\\n            this._doDisconnect(cond);\\n            return;\\n        }\\n\\n        // send each incoming stanza through the handler chain\\n        var that = this;\\n        Strophe.forEachChild(elem, null, function (child) {\\n            var i, newList;\\n            // process handlers\\n            newList = that.handlers;\\n            that.handlers = [];\\n            for (i = 0; i < newList.length; i++) {\\n                var hand = newList[i];\\n                // encapsulate 'handler.run' not to lose the whole handler list if\\n                // one of the handlers throws an exception\\n                try {\\n                    if (hand.isMatch(child) &&\\n                        (that.authenticated || !hand.user)) {\\n                        if (hand.run(child)) {\\n                            that.handlers.push(hand);\\n                        }\\n                    } else {\\n                        that.handlers.push(hand);\\n                    }\\n                } catch(e) {\\n                    // if the handler throws an exception, we consider it as false\\n                    Strophe.warn('Removing Strophe handlers due to uncaught exception: '+e.message);\\n                }\\n            }\\n        });\\n    },\\n\\n\\n    /** Attribute: mechanisms\\n     *  SASL Mechanisms available for Connection.\\n     */\\n    mechanisms: {},\\n\\n    /** PrivateFunction: _connect_cb\\n     *  _Private_ handler for initial connection request.\\n     *\\n     *  This handler is used to process the initial connection request\\n     *  response from the BOSH server. It is used to set up authentication\\n     *  handlers and start the authentication process.\\n     *\\n     *  SASL authentication will be attempted if available, otherwise\\n     *  the code will fall back to legacy authentication.\\n     *\\n     *  Parameters:\\n     *    (Strophe.Request) req - The current request.\\n     *    (Function) _callback - low level (xmpp) connect callback function.\\n     *      Useful for plugins with their own xmpp connect callback (when their)\\n     *      want to do something special).\\n     */\\n    _connect_cb: function (req, _callback, raw) {\\n        Strophe.info(\\\"_connect_cb was called\\\");\\n        this.connected = true;\\n\\n        var bodyWrap;\\n        try {\\n            bodyWrap = this._proto._reqToData(req);\\n        } catch (e) {\\n            if (e !== \\\"badformat\\\") { throw e; }\\n            this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');\\n            this._doDisconnect('bad-format');\\n        }\\n        if (!bodyWrap) { return; }\\n\\n        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\\n            if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {\\n                this.xmlInput(bodyWrap.childNodes[0]);\\n            } else {\\n                this.xmlInput(bodyWrap);\\n            }\\n        }\\n        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\\n            if (raw) {\\n                this.rawInput(raw);\\n            } else {\\n                this.rawInput(Strophe.serialize(bodyWrap));\\n            }\\n        }\\n\\n        var conncheck = this._proto._connect_cb(bodyWrap);\\n        if (conncheck === Strophe.Status.CONNFAIL) {\\n            return;\\n        }\\n\\n        // Check for the stream:features tag\\n        var hasFeatures;\\n        if (bodyWrap.getElementsByTagNameNS) {\\n            hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \\\"features\\\").length > 0;\\n        } else {\\n            hasFeatures = bodyWrap.getElementsByTagName(\\\"stream:features\\\").length > 0 ||\\n                            bodyWrap.getElementsByTagName(\\\"features\\\").length > 0;\\n        }\\n        if (!hasFeatures) {\\n            this._proto._no_auth_received(_callback);\\n            return;\\n        }\\n\\n        var matched = [], i, mech;\\n        var mechanisms = bodyWrap.getElementsByTagName(\\\"mechanism\\\");\\n        if (mechanisms.length > 0) {\\n            for (i = 0; i < mechanisms.length; i++) {\\n                mech = Strophe.getText(mechanisms[i]);\\n                if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);\\n            }\\n        }\\n        if (matched.length === 0) {\\n            if (bodyWrap.getElementsByTagName(\\\"auth\\\").length === 0) {\\n                // There are no matching SASL mechanisms and also no legacy\\n                // auth available.\\n                this._proto._no_auth_received(_callback);\\n                return;\\n            }\\n        }\\n        if (this.do_authentication !== false) {\\n            this.authenticate(matched);\\n        }\\n    },\\n\\n    /** Function: sortMechanismsByPriority\\n     *\\n     *  Sorts an array of objects with prototype SASLMechanism according to\\n     *  their priorities.\\n     *\\n     *  Parameters:\\n     *    (Array) mechanisms - Array of SASL mechanisms.\\n     *\\n     */\\n    sortMechanismsByPriority: function (mechanisms) {\\n        // Sorting mechanisms according to priority.\\n        var i, j, higher, swap;\\n        for (i = 0; i < mechanisms.length - 1; ++i) {\\n            higher = i;\\n            for (j = i + 1; j < mechanisms.length; ++j) {\\n                if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {\\n                    higher = j;\\n                }\\n            }\\n            if (higher !== i) {\\n                swap = mechanisms[i];\\n                mechanisms[i] = mechanisms[higher];\\n                mechanisms[higher] = swap;\\n            }\\n        }\\n        return mechanisms;\\n    },\\n\\n    /** PrivateFunction: _attemptSASLAuth\\n     *\\n     *  Iterate through an array of SASL mechanisms and attempt authentication\\n     *  with the highest priority (enabled) mechanism.\\n     *\\n     *  Parameters:\\n     *    (Array) mechanisms - Array of SASL mechanisms.\\n     *\\n     *  Returns:\\n     *    (Boolean) mechanism_found - true or false, depending on whether a\\n     *          valid SASL mechanism was found with which authentication could be\\n     *          started.\\n     */\\n    _attemptSASLAuth: function (mechanisms) {\\n        mechanisms = this.sortMechanismsByPriority(mechanisms || []);\\n        var i = 0, mechanism_found = false;\\n        for (i = 0; i < mechanisms.length; ++i) {\\n            if (!mechanisms[i].prototype.test(this)) {\\n                continue;\\n            }\\n            this._sasl_success_handler = this._addSysHandler(\\n                this._sasl_success_cb.bind(this), null,\\n                \\\"success\\\", null, null);\\n            this._sasl_failure_handler = this._addSysHandler(\\n                this._sasl_failure_cb.bind(this), null,\\n                \\\"failure\\\", null, null);\\n            this._sasl_challenge_handler = this._addSysHandler(\\n                this._sasl_challenge_cb.bind(this), null,\\n                \\\"challenge\\\", null, null);\\n\\n            this._sasl_mechanism = new mechanisms[i]();\\n            this._sasl_mechanism.onStart(this);\\n\\n            var request_auth_exchange = $build(\\\"auth\\\", {\\n                xmlns: Strophe.NS.SASL,\\n                mechanism: this._sasl_mechanism.name\\n            });\\n            if (this._sasl_mechanism.isClientFirst) {\\n                var response = this._sasl_mechanism.onChallenge(this, null);\\n                request_auth_exchange.t(btoa(response));\\n            }\\n            this.send(request_auth_exchange.tree());\\n            mechanism_found = true;\\n            break;\\n        }\\n        return mechanism_found;\\n    },\\n\\n    /** PrivateFunction: _attemptLegacyAuth\\n     *\\n     *  Attempt legacy (i.e. non-SASL) authentication.\\n     *\\n     */\\n    _attemptLegacyAuth: function () {\\n        if (Strophe.getNodeFromJid(this.jid) === null) {\\n            // we don't have a node, which is required for non-anonymous\\n            // client connections\\n            this._changeConnectStatus(\\n                Strophe.Status.CONNFAIL,\\n                'x-strophe-bad-non-anon-jid'\\n            );\\n            this.disconnect('x-strophe-bad-non-anon-jid');\\n        } else {\\n            // Fall back to legacy authentication\\n            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);\\n            this._addSysHandler(\\n                this._auth1_cb.bind(this),\\n                null, null, null, \\\"_auth_1\\\"\\n            );\\n            this.send($iq({\\n                    'type': \\\"get\\\",\\n                    'to': this.domain,\\n                    'id': \\\"_auth_1\\\"\\n                }).c(\\\"query\\\", {xmlns: Strophe.NS.AUTH})\\n                .c(\\\"username\\\", {}).t(Strophe.getNodeFromJid(this.jid))\\n                .tree());\\n        }\\n    },\\n\\n    /** Function: authenticate\\n     * Set up authentication\\n     *\\n     *  Continues the initial connection request by setting up authentication\\n     *  handlers and starting the authentication process.\\n     *\\n     *  SASL authentication will be attempted if available, otherwise\\n     *  the code will fall back to legacy authentication.\\n     *\\n     *  Parameters:\\n     *    (Array) matched - Array of SASL mechanisms supported.\\n     *\\n     */\\n    authenticate: function (matched) {\\n        if (!this._attemptSASLAuth(matched)) {\\n            this._attemptLegacyAuth();\\n        }\\n    },\\n\\n    /** PrivateFunction: _sasl_challenge_cb\\n     *  _Private_ handler for the SASL challenge\\n     *\\n     */\\n    _sasl_challenge_cb: function(elem) {\\n      var challenge = atob(Strophe.getText(elem));\\n      var response = this._sasl_mechanism.onChallenge(this, challenge);\\n      var stanza = $build('response', {\\n          'xmlns': Strophe.NS.SASL\\n      });\\n      if (response !== \\\"\\\") {\\n        stanza.t(btoa(response));\\n      }\\n      this.send(stanza.tree());\\n      return true;\\n    },\\n\\n    /** PrivateFunction: _auth1_cb\\n     *  _Private_ handler for legacy authentication.\\n     *\\n     *  This handler is called in response to the initial <iq type='get'/>\\n     *  for legacy authentication.  It builds an authentication <iq/> and\\n     *  sends it, creating a handler (calling back to _auth2_cb()) to\\n     *  handle the result\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The stanza that triggered the callback.\\n     *\\n     *  Returns:\\n     *    false to remove the handler.\\n     */\\n    /* jshint unused:false */\\n    _auth1_cb: function (elem) {\\n        // build plaintext auth iq\\n        var iq = $iq({type: \\\"set\\\", id: \\\"_auth_2\\\"})\\n            .c('query', {xmlns: Strophe.NS.AUTH})\\n            .c('username', {}).t(Strophe.getNodeFromJid(this.jid))\\n            .up()\\n            .c('password').t(this.pass);\\n\\n        if (!Strophe.getResourceFromJid(this.jid)) {\\n            // since the user has not supplied a resource, we pick\\n            // a default one here.  unlike other auth methods, the server\\n            // cannot do this for us.\\n            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';\\n        }\\n        iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));\\n\\n        this._addSysHandler(this._auth2_cb.bind(this), null,\\n                            null, null, \\\"_auth_2\\\");\\n        this.send(iq.tree());\\n        return false;\\n    },\\n    /* jshint unused:true */\\n\\n    /** PrivateFunction: _sasl_success_cb\\n     *  _Private_ handler for succesful SASL authentication.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The matching stanza.\\n     *\\n     *  Returns:\\n     *    false to remove the handler.\\n     */\\n    _sasl_success_cb: function (elem) {\\n        if (this._sasl_data[\\\"server-signature\\\"]) {\\n            var serverSignature;\\n            var success = atob(Strophe.getText(elem));\\n            var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\\n            var matches = success.match(attribMatch);\\n            if (matches[1] === \\\"v\\\") {\\n                serverSignature = matches[2];\\n            }\\n\\n            if (serverSignature !== this._sasl_data[\\\"server-signature\\\"]) {\\n              // remove old handlers\\n              this.deleteHandler(this._sasl_failure_handler);\\n              this._sasl_failure_handler = null;\\n              if (this._sasl_challenge_handler) {\\n                this.deleteHandler(this._sasl_challenge_handler);\\n                this._sasl_challenge_handler = null;\\n              }\\n\\n              this._sasl_data = {};\\n              return this._sasl_failure_cb(null);\\n            }\\n        }\\n        Strophe.info(\\\"SASL authentication succeeded.\\\");\\n\\n        if (this._sasl_mechanism) {\\n          this._sasl_mechanism.onSuccess();\\n        }\\n\\n        // remove old handlers\\n        this.deleteHandler(this._sasl_failure_handler);\\n        this._sasl_failure_handler = null;\\n        if (this._sasl_challenge_handler) {\\n            this.deleteHandler(this._sasl_challenge_handler);\\n            this._sasl_challenge_handler = null;\\n        }\\n\\n        var streamfeature_handlers = [];\\n        var wrapper = function(handlers, elem) {\\n            while (handlers.length) {\\n                this.deleteHandler(handlers.pop());\\n            }\\n            this._sasl_auth1_cb.bind(this)(elem);\\n            return false;\\n        };\\n        streamfeature_handlers.push(this._addSysHandler(function(elem) {\\n            wrapper.bind(this)(streamfeature_handlers, elem);\\n        }.bind(this), null, \\\"stream:features\\\", null, null));\\n        streamfeature_handlers.push(this._addSysHandler(function(elem) {\\n            wrapper.bind(this)(streamfeature_handlers, elem);\\n        }.bind(this), Strophe.NS.STREAM, \\\"features\\\", null, null));\\n\\n        // we must send an xmpp:restart now\\n        this._sendRestart();\\n\\n        return false;\\n    },\\n\\n    /** PrivateFunction: _sasl_auth1_cb\\n     *  _Private_ handler to start stream binding.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The matching stanza.\\n     *\\n     *  Returns:\\n     *    false to remove the handler.\\n     */\\n    _sasl_auth1_cb: function (elem) {\\n        // save stream:features for future usage\\n        this.features = elem;\\n        var i, child;\\n        for (i = 0; i < elem.childNodes.length; i++) {\\n            child = elem.childNodes[i];\\n            if (child.nodeName === 'bind') {\\n                this.do_bind = true;\\n            }\\n\\n            if (child.nodeName === 'session') {\\n                this.do_session = true;\\n            }\\n        }\\n\\n        if (!this.do_bind) {\\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\\n            return false;\\n        } else {\\n            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,\\n                                null, \\\"_bind_auth_2\\\");\\n\\n            var resource = Strophe.getResourceFromJid(this.jid);\\n            if (resource) {\\n                this.send($iq({type: \\\"set\\\", id: \\\"_bind_auth_2\\\"})\\n                          .c('bind', {xmlns: Strophe.NS.BIND})\\n                          .c('resource', {}).t(resource).tree());\\n            } else {\\n                this.send($iq({type: \\\"set\\\", id: \\\"_bind_auth_2\\\"})\\n                          .c('bind', {xmlns: Strophe.NS.BIND})\\n                          .tree());\\n            }\\n        }\\n        return false;\\n    },\\n\\n    /** PrivateFunction: _sasl_bind_cb\\n     *  _Private_ handler for binding result and session start.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The matching stanza.\\n     *\\n     *  Returns:\\n     *    false to remove the handler.\\n     */\\n    _sasl_bind_cb: function (elem) {\\n        if (elem.getAttribute(\\\"type\\\") === \\\"error\\\") {\\n            Strophe.info(\\\"SASL binding failed.\\\");\\n            var conflict = elem.getElementsByTagName(\\\"conflict\\\"), condition;\\n            if (conflict.length > 0) {\\n                condition = 'conflict';\\n            }\\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);\\n            return false;\\n        }\\n\\n        // TODO - need to grab errors\\n        var bind = elem.getElementsByTagName(\\\"bind\\\");\\n        var jidNode;\\n        if (bind.length > 0) {\\n            // Grab jid\\n            jidNode = bind[0].getElementsByTagName(\\\"jid\\\");\\n            if (jidNode.length > 0) {\\n                this.jid = Strophe.getText(jidNode[0]);\\n\\n                if (this.do_session) {\\n                    this._addSysHandler(this._sasl_session_cb.bind(this),\\n                                        null, null, null, \\\"_session_auth_2\\\");\\n\\n                    this.send($iq({type: \\\"set\\\", id: \\\"_session_auth_2\\\"})\\n                                  .c('session', {xmlns: Strophe.NS.SESSION})\\n                                  .tree());\\n                } else {\\n                    this.authenticated = true;\\n                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);\\n                }\\n            }\\n        } else {\\n            Strophe.info(\\\"SASL binding failed.\\\");\\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\\n            return false;\\n        }\\n    },\\n\\n    /** PrivateFunction: _sasl_session_cb\\n     *  _Private_ handler to finish successful SASL connection.\\n     *\\n     *  This sets Connection.authenticated to true on success, which\\n     *  starts the processing of user handlers.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The matching stanza.\\n     *\\n     *  Returns:\\n     *    false to remove the handler.\\n     */\\n    _sasl_session_cb: function (elem) {\\n        if (elem.getAttribute(\\\"type\\\") === \\\"result\\\") {\\n            this.authenticated = true;\\n            this._changeConnectStatus(Strophe.Status.CONNECTED, null);\\n        } else if (elem.getAttribute(\\\"type\\\") === \\\"error\\\") {\\n            Strophe.info(\\\"Session creation failed.\\\");\\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\\n            return false;\\n        }\\n        return false;\\n    },\\n\\n    /** PrivateFunction: _sasl_failure_cb\\n     *  _Private_ handler for SASL authentication failure.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The matching stanza.\\n     *\\n     *  Returns:\\n     *    false to remove the handler.\\n     */\\n    /* jshint unused:false */\\n    _sasl_failure_cb: function (elem) {\\n        // delete unneeded handlers\\n        if (this._sasl_success_handler) {\\n            this.deleteHandler(this._sasl_success_handler);\\n            this._sasl_success_handler = null;\\n        }\\n        if (this._sasl_challenge_handler) {\\n            this.deleteHandler(this._sasl_challenge_handler);\\n            this._sasl_challenge_handler = null;\\n        }\\n\\n        if(this._sasl_mechanism)\\n          this._sasl_mechanism.onFailure();\\n        this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\\n        return false;\\n    },\\n    /* jshint unused:true */\\n\\n    /** PrivateFunction: _auth2_cb\\n     *  _Private_ handler to finish legacy authentication.\\n     *\\n     *  This handler is called when the result from the jabber:iq:auth\\n     *  <iq/> stanza is returned.\\n     *\\n     *  Parameters:\\n     *    (XMLElement) elem - The stanza that triggered the callback.\\n     *\\n     *  Returns:\\n     *    false to remove the handler.\\n     */\\n    _auth2_cb: function (elem) {\\n        if (elem.getAttribute(\\\"type\\\") === \\\"result\\\") {\\n            this.authenticated = true;\\n            this._changeConnectStatus(Strophe.Status.CONNECTED, null);\\n        } else if (elem.getAttribute(\\\"type\\\") === \\\"error\\\") {\\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\\n            this.disconnect('authentication failed');\\n        }\\n        return false;\\n    },\\n\\n    /** PrivateFunction: _addSysTimedHandler\\n     *  _Private_ function to add a system level timed handler.\\n     *\\n     *  This function is used to add a Strophe.TimedHandler for the\\n     *  library code.  System timed handlers are allowed to run before\\n     *  authentication is complete.\\n     *\\n     *  Parameters:\\n     *    (Integer) period - The period of the handler.\\n     *    (Function) handler - The callback function.\\n     */\\n    _addSysTimedHandler: function (period, handler) {\\n        var thand = new Strophe.TimedHandler(period, handler);\\n        thand.user = false;\\n        this.addTimeds.push(thand);\\n        return thand;\\n    },\\n\\n    /** PrivateFunction: _addSysHandler\\n     *  _Private_ function to add a system level stanza handler.\\n     *\\n     *  This function is used to add a Strophe.Handler for the\\n     *  library code.  System stanza handlers are allowed to run before\\n     *  authentication is complete.\\n     *\\n     *  Parameters:\\n     *    (Function) handler - The callback function.\\n     *    (String) ns - The namespace to match.\\n     *    (String) name - The stanza name to match.\\n     *    (String) type - The stanza type attribute to match.\\n     *    (String) id - The stanza id attribute to match.\\n     */\\n    _addSysHandler: function (handler, ns, name, type, id) {\\n        var hand = new Strophe.Handler(handler, ns, name, type, id);\\n        hand.user = false;\\n        this.addHandlers.push(hand);\\n        return hand;\\n    },\\n\\n    /** PrivateFunction: _onDisconnectTimeout\\n     *  _Private_ timeout handler for handling non-graceful disconnection.\\n     *\\n     *  If the graceful disconnect process does not complete within the\\n     *  time allotted, this handler finishes the disconnect anyway.\\n     *\\n     *  Returns:\\n     *    false to remove the handler.\\n     */\\n    _onDisconnectTimeout: function () {\\n        Strophe.info(\\\"_onDisconnectTimeout was called\\\");\\n        this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);\\n        this._proto._onDisconnectTimeout();\\n        // actually disconnect\\n        this._doDisconnect();\\n        return false;\\n    },\\n\\n    /** PrivateFunction: _onIdle\\n     *  _Private_ handler to process events during idle cycle.\\n     *\\n     *  This handler is called every 100ms to fire timed handlers that\\n     *  are ready and keep poll requests going.\\n     */\\n    _onIdle: function () {\\n        var i, thand, since, newList;\\n\\n        // add timed handlers scheduled for addition\\n        // NOTE: we add before remove in the case a timed handler is\\n        // added and then deleted before the next _onIdle() call.\\n        while (this.addTimeds.length > 0) {\\n            this.timedHandlers.push(this.addTimeds.pop());\\n        }\\n\\n        // remove timed handlers that have been scheduled for deletion\\n        while (this.removeTimeds.length > 0) {\\n            thand = this.removeTimeds.pop();\\n            i = this.timedHandlers.indexOf(thand);\\n            if (i >= 0) {\\n                this.timedHandlers.splice(i, 1);\\n            }\\n        }\\n\\n        // call ready timed handlers\\n        var now = new Date().getTime();\\n        newList = [];\\n        for (i = 0; i < this.timedHandlers.length; i++) {\\n            thand = this.timedHandlers[i];\\n            if (this.authenticated || !thand.user) {\\n                since = thand.lastCalled + thand.period;\\n                if (since - now <= 0) {\\n                    if (thand.run()) {\\n                        newList.push(thand);\\n                    }\\n                } else {\\n                    newList.push(thand);\\n                }\\n            }\\n        }\\n        this.timedHandlers = newList;\\n\\n        clearTimeout(this._idleTimeout);\\n\\n        this._proto._onIdle();\\n\\n        // reactivate the timer only if connected\\n        if (this.connected) {\\n            // XXX: setTimeout should be called only with function expressions (23974bc1)\\n            this._idleTimeout = setTimeout(function() {\\n                this._onIdle();\\n            }.bind(this), 100);\\n        }\\n    }\\n};\\n\\n/** Class: Strophe.SASLMechanism\\n *\\n *  encapsulates SASL authentication mechanisms.\\n *\\n *  User code may override the priority for each mechanism or disable it completely.\\n *  See <priority> for information about changing priority and <test> for informatian on\\n *  how to disable a mechanism.\\n *\\n *  By default, all mechanisms are enabled and the priorities are\\n *\\n *      OAUTHBEARER - 60\\n *      SCRAM-SHA1 - 50\\n *      DIGEST-MD5 - 40\\n *      PLAIN - 30\\n *      ANONYMOUS - 20\\n *      EXTERNAL - 10\\n *\\n *  See: Strophe.Connection.addSupportedSASLMechanisms\\n */\\n\\n/**\\n * PrivateConstructor: Strophe.SASLMechanism\\n * SASL auth mechanism abstraction.\\n *\\n *  Parameters:\\n *    (String) name - SASL Mechanism name.\\n *    (Boolean) isClientFirst - If client should send response first without challenge.\\n *    (Number) priority - Priority.\\n *\\n *  Returns:\\n *    A new Strophe.SASLMechanism object.\\n */\\nStrophe.SASLMechanism = function(name, isClientFirst, priority) {\\n  /** PrivateVariable: name\\n   *  Mechanism name.\\n   */\\n  this.name = name;\\n  /** PrivateVariable: isClientFirst\\n   *  If client sends response without initial server challenge.\\n   */\\n  this.isClientFirst = isClientFirst;\\n  /** Variable: priority\\n   *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).\\n   *  Users may override this to prioritize mechanisms differently.\\n   *\\n   *  In the default configuration the priorities are\\n   *\\n   *  SCRAM-SHA1 - 40\\n   *  DIGEST-MD5 - 30\\n   *  Plain - 20\\n   *\\n   *  Example: (This will cause Strophe to choose the mechanism that the server sent first)\\n   *\\n   *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;\\n   *\\n   *  See <SASL mechanisms> for a list of available mechanisms.\\n   *\\n   */\\n  this.priority = priority;\\n};\\n\\nStrophe.SASLMechanism.prototype = {\\n  /**\\n   *  Function: test\\n   *  Checks if mechanism able to run.\\n   *  To disable a mechanism, make this return false;\\n   *\\n   *  To disable plain authentication run\\n   *  > Strophe.SASLPlain.test = function() {\\n   *  >   return false;\\n   *  > }\\n   *\\n   *  See <SASL mechanisms> for a list of available mechanisms.\\n   *\\n   *  Parameters:\\n   *    (Strophe.Connection) connection - Target Connection.\\n   *\\n   *  Returns:\\n   *    (Boolean) If mechanism was able to run.\\n   */\\n  /* jshint unused:false */\\n  test: function(connection) {\\n    return true;\\n  },\\n  /* jshint unused:true */\\n\\n  /** PrivateFunction: onStart\\n   *  Called before starting mechanism on some connection.\\n   *\\n   *  Parameters:\\n   *    (Strophe.Connection) connection - Target Connection.\\n   */\\n  onStart: function(connection) {\\n    this._connection = connection;\\n  },\\n\\n  /** PrivateFunction: onChallenge\\n   *  Called by protocol implementation on incoming challenge. If client is\\n   *  first (isClientFirst === true) challenge will be null on the first call.\\n   *\\n   *  Parameters:\\n   *    (Strophe.Connection) connection - Target Connection.\\n   *    (String) challenge - current challenge to handle.\\n   *\\n   *  Returns:\\n   *    (String) Mechanism response.\\n   */\\n  /* jshint unused:false */\\n  onChallenge: function(connection, challenge) {\\n    throw new Error(\\\"You should implement challenge handling!\\\");\\n  },\\n  /* jshint unused:true */\\n\\n  /** PrivateFunction: onFailure\\n   *  Protocol informs mechanism implementation about SASL failure.\\n   */\\n  onFailure: function() {\\n    this._connection = null;\\n  },\\n\\n  /** PrivateFunction: onSuccess\\n   *  Protocol informs mechanism implementation about SASL success.\\n   */\\n  onSuccess: function() {\\n    this._connection = null;\\n  }\\n};\\n\\n  /** Constants: SASL mechanisms\\n   *  Available authentication mechanisms\\n   *\\n   *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.\\n   *  Strophe.SASLPlain - SASL PLAIN authentication.\\n   *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication\\n   *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication\\n   *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication\\n   *  Strophe.SASLExternal - SASL EXTERNAL authentication\\n   */\\n\\n// Building SASL callbacks\\n\\n/** PrivateConstructor: SASLAnonymous\\n *  SASL ANONYMOUS authentication.\\n */\\nStrophe.SASLAnonymous = function() {};\\nStrophe.SASLAnonymous.prototype = new Strophe.SASLMechanism(\\\"ANONYMOUS\\\", false, 20);\\n\\nStrophe.SASLAnonymous.prototype.test = function(connection) {\\n    return connection.authcid === null;\\n};\\n\\n\\n/** PrivateConstructor: SASLPlain\\n *  SASL PLAIN authentication.\\n */\\nStrophe.SASLPlain = function() {};\\nStrophe.SASLPlain.prototype = new Strophe.SASLMechanism(\\\"PLAIN\\\", true, 30);\\n\\nStrophe.SASLPlain.prototype.test = function(connection) {\\n    return connection.authcid !== null;\\n};\\n\\nStrophe.SASLPlain.prototype.onChallenge = function(connection) {\\n    var auth_str = connection.authzid;\\n    auth_str = auth_str + \\\"\\\\u0000\\\";\\n    auth_str = auth_str + connection.authcid;\\n    auth_str = auth_str + \\\"\\\\u0000\\\";\\n    auth_str = auth_str + connection.pass;\\n    return utils.utf16to8(auth_str);\\n};\\n\\n\\n/** PrivateConstructor: SASLSHA1\\n *  SASL SCRAM SHA 1 authentication.\\n */\\nStrophe.SASLSHA1 = function() {};\\nStrophe.SASLSHA1.prototype = new Strophe.SASLMechanism(\\\"SCRAM-SHA-1\\\", true, 50);\\n\\nStrophe.SASLSHA1.prototype.test = function(connection) {\\n    return connection.authcid !== null;\\n};\\n\\nStrophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {\\n  var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);\\n  var auth_str = \\\"n=\\\" + utils.utf16to8(connection.authcid);\\n  auth_str += \\\",r=\\\";\\n  auth_str += cnonce;\\n  connection._sasl_data.cnonce = cnonce;\\n  connection._sasl_data[\\\"client-first-message-bare\\\"] = auth_str;\\n\\n  auth_str = \\\"n,,\\\" + auth_str;\\n\\n  this.onChallenge = function (connection, challenge) {\\n    var nonce, salt, iter, Hi, U, U_old, i, k, pass;\\n    var clientKey, serverKey, clientSignature;\\n    var responseText = \\\"c=biws,\\\";\\n    var authMessage = connection._sasl_data[\\\"client-first-message-bare\\\"] + \\\",\\\" +\\n      challenge + \\\",\\\";\\n    var cnonce = connection._sasl_data.cnonce;\\n    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\\n\\n    while (challenge.match(attribMatch)) {\\n      var matches = challenge.match(attribMatch);\\n      challenge = challenge.replace(matches[0], \\\"\\\");\\n      switch (matches[1]) {\\n      case \\\"r\\\":\\n        nonce = matches[2];\\n        break;\\n      case \\\"s\\\":\\n        salt = matches[2];\\n        break;\\n      case \\\"i\\\":\\n        iter = matches[2];\\n        break;\\n      }\\n    }\\n\\n    if (nonce.substr(0, cnonce.length) !== cnonce) {\\n      connection._sasl_data = {};\\n      return connection._sasl_failure_cb();\\n    }\\n\\n    responseText += \\\"r=\\\" + nonce;\\n    authMessage += responseText;\\n\\n    salt = atob(salt);\\n    salt += \\\"\\\\x00\\\\x00\\\\x00\\\\x01\\\";\\n\\n    pass = utils.utf16to8(connection.pass);\\n    Hi = U_old = SHA1.core_hmac_sha1(pass, salt);\\n    for (i = 1; i < iter; i++) {\\n      U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));\\n      for (k = 0; k < 5; k++) {\\n        Hi[k] ^= U[k];\\n      }\\n      U_old = U;\\n    }\\n    Hi = SHA1.binb2str(Hi);\\n\\n    clientKey = SHA1.core_hmac_sha1(Hi, \\\"Client Key\\\");\\n    serverKey = SHA1.str_hmac_sha1(Hi, \\\"Server Key\\\");\\n    clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);\\n    connection._sasl_data[\\\"server-signature\\\"] = SHA1.b64_hmac_sha1(serverKey, authMessage);\\n\\n    for (k = 0; k < 5; k++) {\\n      clientKey[k] ^= clientSignature[k];\\n    }\\n\\n    responseText += \\\",p=\\\" + btoa(SHA1.binb2str(clientKey));\\n    return responseText;\\n  }.bind(this);\\n\\n  return auth_str;\\n};\\n\\n\\n/** PrivateConstructor: SASLMD5\\n *  SASL DIGEST MD5 authentication.\\n */\\nStrophe.SASLMD5 = function() {};\\nStrophe.SASLMD5.prototype = new Strophe.SASLMechanism(\\\"DIGEST-MD5\\\", false, 40);\\n\\nStrophe.SASLMD5.prototype.test = function(connection) {\\n    return connection.authcid !== null;\\n};\\n\\n/** PrivateFunction: _quote\\n *  _Private_ utility function to backslash escape and quote strings.\\n *\\n *  Parameters:\\n *    (String) str - The string to be quoted.\\n *\\n *  Returns:\\n *    quoted string\\n */\\nStrophe.SASLMD5.prototype._quote = function (str) {\\n    return '\\\"' + str.replace(/\\\\\\\\/g, \\\"\\\\\\\\\\\\\\\\\\\").replace(/\\\"/g, '\\\\\\\\\\\"') + '\\\"';\\n    //\\\" end string workaround for emacs\\n};\\n\\nStrophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {\\n  var attribMatch = /([a-z]+)=(\\\"[^\\\"]+\\\"|[^,\\\"]+)(?:,|$)/;\\n  var cnonce = test_cnonce || MD5.hexdigest(\\\"\\\" + (Math.random() * 1234567890));\\n  var realm = \\\"\\\";\\n  var host = null;\\n  var nonce = \\\"\\\";\\n  var qop = \\\"\\\";\\n  var matches;\\n\\n  while (challenge.match(attribMatch)) {\\n    matches = challenge.match(attribMatch);\\n    challenge = challenge.replace(matches[0], \\\"\\\");\\n    matches[2] = matches[2].replace(/^\\\"(.+)\\\"$/, \\\"$1\\\");\\n    switch (matches[1]) {\\n    case \\\"realm\\\":\\n      realm = matches[2];\\n      break;\\n    case \\\"nonce\\\":\\n      nonce = matches[2];\\n      break;\\n    case \\\"qop\\\":\\n      qop = matches[2];\\n      break;\\n    case \\\"host\\\":\\n      host = matches[2];\\n      break;\\n    }\\n  }\\n\\n  var digest_uri = connection.servtype + \\\"/\\\" + connection.domain;\\n  if (host !== null) {\\n    digest_uri = digest_uri + \\\"/\\\" + host;\\n  }\\n\\n  var cred = utils.utf16to8(connection.authcid + \\\":\\\" + realm + \\\":\\\" + this._connection.pass);\\n  var A1 = MD5.hash(cred) + \\\":\\\" + nonce + \\\":\\\" + cnonce;\\n  var A2 = 'AUTHENTICATE:' + digest_uri;\\n\\n  var responseText = \\\"\\\";\\n  responseText += 'charset=utf-8,';\\n  responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';\\n  responseText += 'realm=' + this._quote(realm) + ',';\\n  responseText += 'nonce=' + this._quote(nonce) + ',';\\n  responseText += 'nc=00000001,';\\n  responseText += 'cnonce=' + this._quote(cnonce) + ',';\\n  responseText += 'digest-uri=' + this._quote(digest_uri) + ',';\\n  responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + \\\":\\\" +\\n                                              nonce + \\\":00000001:\\\" +\\n                                              cnonce + \\\":auth:\\\" +\\n                                              MD5.hexdigest(A2)) + \\\",\\\";\\n  responseText += 'qop=auth';\\n\\n  this.onChallenge = function () {\\n      return \\\"\\\";\\n  };\\n  return responseText;\\n};\\n\\n\\n/** PrivateConstructor: SASLOAuthBearer\\n *  SASL OAuth Bearer authentication.\\n */\\nStrophe.SASLOAuthBearer = function() {};\\nStrophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism(\\\"OAUTHBEARER\\\", true, 60);\\n\\nStrophe.SASLOAuthBearer.prototype.test = function(connection) {\\n    return connection.pass !== null;\\n};\\n\\nStrophe.SASLOAuthBearer.prototype.onChallenge = function(connection) {\\n    var auth_str = 'n,';\\n    if (connection.authcid !== null) {\\n      auth_str = auth_str + 'a=' + connection.authzid;\\n    }\\n    auth_str = auth_str + ',';\\n    auth_str = auth_str + \\\"\\\\u0001\\\";\\n    auth_str = auth_str + 'auth=Bearer ';\\n    auth_str = auth_str + connection.pass;\\n    auth_str = auth_str + \\\"\\\\u0001\\\";\\n    auth_str = auth_str + \\\"\\\\u0001\\\";\\n\\n    return utils.utf16to8(auth_str);\\n};\\n\\n\\n/** PrivateConstructor: SASLExternal\\n *  SASL EXTERNAL authentication.\\n *\\n *  The EXTERNAL mechanism allows a client to request the server to use\\n *  credentials established by means external to the mechanism to\\n *  authenticate the client. The external means may be, for instance,\\n *  TLS services.\\n */\\nStrophe.SASLExternal = function() {};\\nStrophe.SASLExternal.prototype = new Strophe.SASLMechanism(\\\"EXTERNAL\\\", true, 10);\\n\\nStrophe.SASLExternal.prototype.onChallenge = function(connection) {\\n    /** According to XEP-178, an authzid SHOULD NOT be presented when the\\n     * authcid contained or implied in the client certificate is the JID (i.e.\\n     * authzid) with which the user wants to log in as.\\n     *\\n     * To NOT send the authzid, the user should therefore set the authcid equal\\n     * to the JID when instantiating a new Strophe.Connection object.\\n     */\\n    return connection.authcid === connection.authzid ? '' : connection.authzid;\\n};\\n\\nreturn {\\n    'Strophe':         Strophe,\\n    '$build':          $build,\\n    '$iq':             $iq,\\n    '$msg':            $msg,\\n    '$pres':           $pres,\\n    'SHA1':            SHA1,\\n    'MD5':             MD5,\\n    'b64_hmac_sha1':   SHA1.b64_hmac_sha1,\\n    'b64_sha1':        SHA1.b64_sha1,\\n    'str_hmac_sha1':   SHA1.str_hmac_sha1,\\n    'str_sha1':        SHA1.str_sha1\\n};\\n}));\\n\\n/*\\n    This program is distributed under the terms of the MIT license.\\n    Please see the LICENSE file for details.\\n\\n    Copyright 2006-2008, OGG, LLC\\n*/\\n\\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\\n/* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */\\n\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        define('strophe-bosh',['strophe-core'], function (core) {\\n            return factory(\\n                core.Strophe,\\n                core.$build\\n            );\\n        });\\n    } else {\\n        // Browser globals\\n        return factory(Strophe, $build);\\n    }\\n}(this, function (Strophe, $build) {\\n\\n/** PrivateClass: Strophe.Request\\n *  _Private_ helper class that provides a cross implementation abstraction\\n *  for a BOSH related XMLHttpRequest.\\n *\\n *  The Strophe.Request class is used internally to encapsulate BOSH request\\n *  information.  It is not meant to be used from user's code.\\n */\\n\\n/** PrivateConstructor: Strophe.Request\\n *  Create and initialize a new Strophe.Request object.\\n *\\n *  Parameters:\\n *    (XMLElement) elem - The XML data to be sent in the request.\\n *    (Function) func - The function that will be called when the\\n *      XMLHttpRequest readyState changes.\\n *    (Integer) rid - The BOSH rid attribute associated with this request.\\n *    (Integer) sends - The number of times this same request has been sent.\\n */\\nStrophe.Request = function (elem, func, rid, sends) {\\n    this.id = ++Strophe._requestId;\\n    this.xmlData = elem;\\n    this.data = Strophe.serialize(elem);\\n    // save original function in case we need to make a new request\\n    // from this one.\\n    this.origFunc = func;\\n    this.func = func;\\n    this.rid = rid;\\n    this.date = NaN;\\n    this.sends = sends || 0;\\n    this.abort = false;\\n    this.dead = null;\\n\\n    this.age = function () {\\n        if (!this.date) { return 0; }\\n        var now = new Date();\\n        return (now - this.date) / 1000;\\n    };\\n    this.timeDead = function () {\\n        if (!this.dead) { return 0; }\\n        var now = new Date();\\n        return (now - this.dead) / 1000;\\n    };\\n    this.xhr = this._newXHR();\\n};\\n\\nStrophe.Request.prototype = {\\n    /** PrivateFunction: getResponse\\n     *  Get a response from the underlying XMLHttpRequest.\\n     *\\n     *  This function attempts to get a response from the request and checks\\n     *  for errors.\\n     *\\n     *  Throws:\\n     *    \\\"parsererror\\\" - A parser error occured.\\n     *    \\\"badformat\\\" - The entity has sent XML that cannot be processed.\\n     *\\n     *  Returns:\\n     *    The DOM element tree of the response.\\n     */\\n    getResponse: function () {\\n        var node = null;\\n        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {\\n            node = this.xhr.responseXML.documentElement;\\n            if (node.tagName === \\\"parsererror\\\") {\\n                Strophe.error(\\\"invalid response received\\\");\\n                Strophe.error(\\\"responseText: \\\" + this.xhr.responseText);\\n                Strophe.error(\\\"responseXML: \\\" +\\n                              Strophe.serialize(this.xhr.responseXML));\\n                throw \\\"parsererror\\\";\\n            }\\n        } else if (this.xhr.responseText) {\\n            Strophe.error(\\\"invalid response received\\\");\\n            Strophe.error(\\\"responseText: \\\" + this.xhr.responseText);\\n            throw \\\"badformat\\\";\\n        }\\n\\n        return node;\\n    },\\n\\n    /** PrivateFunction: _newXHR\\n     *  _Private_ helper function to create XMLHttpRequests.\\n     *\\n     *  This function creates XMLHttpRequests across all implementations.\\n     *\\n     *  Returns:\\n     *    A new XMLHttpRequest.\\n     */\\n    _newXHR: function () {\\n        var xhr = null;\\n        if (window.XMLHttpRequest) {\\n            xhr = new XMLHttpRequest();\\n            if (xhr.overrideMimeType) {\\n                xhr.overrideMimeType(\\\"text/xml; charset=utf-8\\\");\\n            }\\n        } else if (window.ActiveXObject) {\\n            xhr = new ActiveXObject(\\\"Microsoft.XMLHTTP\\\");\\n        }\\n        // use Function.bind() to prepend ourselves as an argument\\n        xhr.onreadystatechange = this.func.bind(null, this);\\n        return xhr;\\n    }\\n};\\n\\n/** Class: Strophe.Bosh\\n *  _Private_ helper class that handles BOSH Connections\\n *\\n *  The Strophe.Bosh class is used internally by Strophe.Connection\\n *  to encapsulate BOSH sessions. It is not meant to be used from user's code.\\n */\\n\\n/** File: bosh.js\\n *  A JavaScript library to enable BOSH in Strophejs.\\n *\\n *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)\\n *  to emulate a persistent, stateful, two-way connection to an XMPP server.\\n *  More information on BOSH can be found in XEP 124.\\n */\\n\\n/** PrivateConstructor: Strophe.Bosh\\n *  Create and initialize a Strophe.Bosh object.\\n *\\n *  Parameters:\\n *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.\\n *\\n *  Returns:\\n *    A new Strophe.Bosh object.\\n */\\nStrophe.Bosh = function(connection) {\\n    this._conn = connection;\\n    /* request id for body tags */\\n    this.rid = Math.floor(Math.random() * 4294967295);\\n    /* The current session ID. */\\n    this.sid = null;\\n\\n    // default BOSH values\\n    this.hold = 1;\\n    this.wait = 60;\\n    this.window = 5;\\n    this.errors = 0;\\n    this.inactivity = null;\\n\\n    this._requests = [];\\n};\\n\\nStrophe.Bosh.prototype = {\\n    /** Variable: strip\\n     *\\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag when\\n     *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.\\n     *  To strip this tag, User code can set <Strophe.Bosh.strip> to \\\"body\\\":\\n     *\\n     *  > Strophe.Bosh.prototype.strip = \\\"body\\\";\\n     *\\n     *  This will enable stripping of the body tag in both\\n     *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.\\n     */\\n    strip: null,\\n\\n    /** PrivateFunction: _buildBody\\n     *  _Private_ helper function to generate the <body/> wrapper for BOSH.\\n     *\\n     *  Returns:\\n     *    A Strophe.Builder with a <body/> element.\\n     */\\n    _buildBody: function () {\\n        var bodyWrap = $build('body', {\\n            rid: this.rid++,\\n            xmlns: Strophe.NS.HTTPBIND\\n        });\\n        if (this.sid !== null) {\\n            bodyWrap.attrs({sid: this.sid});\\n        }\\n        if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {\\n            this._cacheSession();\\n        }\\n        return bodyWrap;\\n    },\\n\\n    /** PrivateFunction: _reset\\n     *  Reset the connection.\\n     *\\n     *  This function is called by the reset function of the Strophe Connection\\n     */\\n    _reset: function () {\\n        this.rid = Math.floor(Math.random() * 4294967295);\\n        this.sid = null;\\n        this.errors = 0;\\n        if (this._conn._sessionCachingSupported()) {\\n            window.sessionStorage.removeItem('strophe-bosh-session');\\n        }\\n\\n        this._conn.nextValidRid(this.rid);\\n    },\\n\\n    /** PrivateFunction: _connect\\n     *  _Private_ function that initializes the BOSH connection.\\n     *\\n     *  Creates and sends the Request that initializes the BOSH connection.\\n     */\\n    _connect: function (wait, hold, route) {\\n        this.wait = wait || this.wait;\\n        this.hold = hold || this.hold;\\n        this.errors = 0;\\n\\n        // build the body tag\\n        var body = this._buildBody().attrs({\\n            to: this._conn.domain,\\n            \\\"xml:lang\\\": \\\"en\\\",\\n            wait: this.wait,\\n            hold: this.hold,\\n            content: \\\"text/xml; charset=utf-8\\\",\\n            ver: \\\"1.6\\\",\\n            \\\"xmpp:version\\\": \\\"1.0\\\",\\n            \\\"xmlns:xmpp\\\": Strophe.NS.BOSH\\n        });\\n\\n        if(route){\\n            body.attrs({\\n                route: route\\n            });\\n        }\\n\\n        var _connect_cb = this._conn._connect_cb;\\n\\n        this._requests.push(\\n            new Strophe.Request(body.tree(),\\n                                this._onRequestStateChange.bind(\\n                                    this, _connect_cb.bind(this._conn)),\\n                                body.tree().getAttribute(\\\"rid\\\")));\\n        this._throttledRequestHandler();\\n    },\\n\\n    /** PrivateFunction: _attach\\n     *  Attach to an already created and authenticated BOSH session.\\n     *\\n     *  This function is provided to allow Strophe to attach to BOSH\\n     *  sessions which have been created externally, perhaps by a Web\\n     *  application.  This is often used to support auto-login type features\\n     *  without putting user credentials into the page.\\n     *\\n     *  Parameters:\\n     *    (String) jid - The full JID that is bound by the session.\\n     *    (String) sid - The SID of the BOSH session.\\n     *    (String) rid - The current RID of the BOSH session.  This RID\\n     *      will be used by the next request.\\n     *    (Function) callback The connect callback function.\\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\\n     *      time the server will wait before returning an empty result for\\n     *      a request.  The default setting of 60 seconds is recommended.\\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\\n     *      number of connections the server will hold at one time.  This\\n     *      should almost always be set to 1 (the default).\\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\\n     *      allowed range of request ids that are valid.  The default is 5.\\n     */\\n    _attach: function (jid, sid, rid, callback, wait, hold, wind) {\\n        this._conn.jid = jid;\\n        this.sid = sid;\\n        this.rid = rid;\\n\\n        this._conn.connect_callback = callback;\\n\\n        this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);\\n\\n        this._conn.authenticated = true;\\n        this._conn.connected = true;\\n\\n        this.wait = wait || this.wait;\\n        this.hold = hold || this.hold;\\n        this.window = wind || this.window;\\n\\n        this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);\\n    },\\n\\n    /** PrivateFunction: _restore\\n     *  Attempt to restore a cached BOSH session\\n     *\\n     *  Parameters:\\n     *    (String) jid - The full JID that is bound by the session.\\n     *      This parameter is optional but recommended, specifically in cases\\n     *      where prebinded BOSH sessions are used where it's important to know\\n     *      that the right session is being restored.\\n     *    (Function) callback The connect callback function.\\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\\n     *      time the server will wait before returning an empty result for\\n     *      a request.  The default setting of 60 seconds is recommended.\\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\\n     *      number of connections the server will hold at one time.  This\\n     *      should almost always be set to 1 (the default).\\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\\n     *      allowed range of request ids that are valid.  The default is 5.\\n     */\\n    _restore: function (jid, callback, wait, hold, wind) {\\n        var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));\\n        if (typeof session !== \\\"undefined\\\" &&\\n                   session !== null &&\\n                   session.rid &&\\n                   session.sid &&\\n                   session.jid &&\\n                   (    typeof jid === \\\"undefined\\\" ||\\n                        jid === null ||\\n                        Strophe.getBareJidFromJid(session.jid) === Strophe.getBareJidFromJid(jid) ||\\n                        // If authcid is null, then it's an anonymous login, so\\n                        // we compare only the domains:\\n                        ((Strophe.getNodeFromJid(jid) === null) && (Strophe.getDomainFromJid(session.jid) === jid))\\n                    )\\n        ) {\\n            this._conn.restored = true;\\n            this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);\\n        } else {\\n            throw { name: \\\"StropheSessionError\\\", message: \\\"_restore: no restoreable session.\\\" };\\n        }\\n    },\\n\\n    /** PrivateFunction: _cacheSession\\n     *  _Private_ handler for the beforeunload event.\\n     *\\n     *  This handler is used to process the Bosh-part of the initial request.\\n     *  Parameters:\\n     *    (Strophe.Request) bodyWrap - The received stanza.\\n     */\\n    _cacheSession: function () {\\n        if (this._conn.authenticated) {\\n            if (this._conn.jid && this.rid && this.sid) {\\n                window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({\\n                    'jid': this._conn.jid,\\n                    'rid': this.rid,\\n                    'sid': this.sid\\n                }));\\n            }\\n        } else {\\n            window.sessionStorage.removeItem('strophe-bosh-session');\\n        }\\n    },\\n\\n    /** PrivateFunction: _connect_cb\\n     *  _Private_ handler for initial connection request.\\n     *\\n     *  This handler is used to process the Bosh-part of the initial request.\\n     *  Parameters:\\n     *    (Strophe.Request) bodyWrap - The received stanza.\\n     */\\n    _connect_cb: function (bodyWrap) {\\n        var typ = bodyWrap.getAttribute(\\\"type\\\");\\n        var cond, conflict;\\n        if (typ !== null && typ === \\\"terminate\\\") {\\n            // an error occurred\\n            cond = bodyWrap.getAttribute(\\\"condition\\\");\\n            Strophe.error(\\\"BOSH-Connection failed: \\\" + cond);\\n            conflict = bodyWrap.getElementsByTagName(\\\"conflict\\\");\\n            if (cond !== null) {\\n                if (cond === \\\"remote-stream-error\\\" && conflict.length > 0) {\\n                    cond = \\\"conflict\\\";\\n                }\\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\\n            } else {\\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \\\"unknown\\\");\\n            }\\n            this._conn._doDisconnect(cond);\\n            return Strophe.Status.CONNFAIL;\\n        }\\n\\n        // check to make sure we don't overwrite these if _connect_cb is\\n        // called multiple times in the case of missing stream:features\\n        if (!this.sid) {\\n            this.sid = bodyWrap.getAttribute(\\\"sid\\\");\\n        }\\n        var wind = bodyWrap.getAttribute('requests');\\n        if (wind) { this.window = parseInt(wind, 10); }\\n        var hold = bodyWrap.getAttribute('hold');\\n        if (hold) { this.hold = parseInt(hold, 10); }\\n        var wait = bodyWrap.getAttribute('wait');\\n        if (wait) { this.wait = parseInt(wait, 10); }\\n        var inactivity = bodyWrap.getAttribute('inactivity');\\n        if (inactivity) { this.inactivity = parseInt(inactivity, 10); }\\n    },\\n\\n    /** PrivateFunction: _disconnect\\n     *  _Private_ part of Connection.disconnect for Bosh\\n     *\\n     *  Parameters:\\n     *    (Request) pres - This stanza will be sent before disconnecting.\\n     */\\n    _disconnect: function (pres) {\\n        this._sendTerminate(pres);\\n    },\\n\\n    /** PrivateFunction: _doDisconnect\\n     *  _Private_ function to disconnect.\\n     *\\n     *  Resets the SID and RID.\\n     */\\n    _doDisconnect: function () {\\n        this.sid = null;\\n        this.rid = Math.floor(Math.random() * 4294967295);\\n        if (this._conn._sessionCachingSupported()) {\\n            window.sessionStorage.removeItem('strophe-bosh-session');\\n        }\\n\\n        this._conn.nextValidRid(this.rid);\\n    },\\n\\n    /** PrivateFunction: _emptyQueue\\n     * _Private_ function to check if the Request queue is empty.\\n     *\\n     *  Returns:\\n     *    True, if there are no Requests queued, False otherwise.\\n     */\\n    _emptyQueue: function () {\\n        return this._requests.length === 0;\\n    },\\n\\n    /** PrivateFunction: _callProtocolErrorHandlers\\n     *  _Private_ function to call error handlers registered for HTTP errors.\\n     *\\n     *  Parameters:\\n     *    (Strophe.Request) req - The request that is changing readyState.\\n     */\\n    _callProtocolErrorHandlers: function (req) {\\n        var reqStatus = this._getRequestStatus(req),\\n            err_callback;\\n        err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];\\n        if (err_callback) {\\n            err_callback.call(this, reqStatus);\\n        }\\n    },\\n\\n    /** PrivateFunction: _hitError\\n     *  _Private_ function to handle the error count.\\n     *\\n     *  Requests are resent automatically until their error count reaches\\n     *  5.  Each time an error is encountered, this function is called to\\n     *  increment the count and disconnect if the count is too high.\\n     *\\n     *  Parameters:\\n     *    (Integer) reqStatus - The request status.\\n     */\\n    _hitError: function (reqStatus) {\\n        this.errors++;\\n        Strophe.warn(\\\"request errored, status: \\\" + reqStatus +\\n                     \\\", number of errors: \\\" + this.errors);\\n        if (this.errors > 4) {\\n            this._conn._onDisconnectTimeout();\\n        }\\n    },\\n\\n    /** PrivateFunction: _no_auth_received\\n     *\\n     * Called on stream start/restart when no stream:features\\n     * has been received and sends a blank poll request.\\n     */\\n    _no_auth_received: function (_callback) {\\n        if (_callback) {\\n            _callback = _callback.bind(this._conn);\\n        } else {\\n            _callback = this._conn._connect_cb.bind(this._conn);\\n        }\\n        var body = this._buildBody();\\n        this._requests.push(\\n                new Strophe.Request(body.tree(),\\n                    this._onRequestStateChange.bind(\\n                        this, _callback.bind(this._conn)),\\n                    body.tree().getAttribute(\\\"rid\\\")));\\n        this._throttledRequestHandler();\\n    },\\n\\n    /** PrivateFunction: _onDisconnectTimeout\\n     *  _Private_ timeout handler for handling non-graceful disconnection.\\n     *\\n     *  Cancels all remaining Requests and clears the queue.\\n     */\\n    _onDisconnectTimeout: function () {\\n        this._abortAllRequests();\\n    },\\n\\n    /** PrivateFunction: _abortAllRequests\\n     *  _Private_ helper function that makes sure all pending requests are aborted.\\n     */\\n    _abortAllRequests: function _abortAllRequests() {\\n        var req;\\n        while (this._requests.length > 0) {\\n            req = this._requests.pop();\\n            req.abort = true;\\n            req.xhr.abort();\\n            // jslint complains, but this is fine. setting to empty func\\n            // is necessary for IE6\\n            req.xhr.onreadystatechange = function () {}; // jshint ignore:line\\n        }\\n    },\\n\\n    /** PrivateFunction: _onIdle\\n     *  _Private_ handler called by Strophe.Connection._onIdle\\n     *\\n     *  Sends all queued Requests or polls with empty Request if there are none.\\n     */\\n    _onIdle: function () {\\n        var data = this._conn._data;\\n        // if no requests are in progress, poll\\n        if (this._conn.authenticated && this._requests.length === 0 &&\\n            data.length === 0 && !this._conn.disconnecting) {\\n            Strophe.info(\\\"no requests during idle cycle, sending \\\" +\\n                         \\\"blank request\\\");\\n            data.push(null);\\n        }\\n\\n        if (this._conn.paused) {\\n            return;\\n        }\\n\\n        if (this._requests.length < 2 && data.length > 0) {\\n            var body = this._buildBody();\\n            for (var i = 0; i < data.length; i++) {\\n                if (data[i] !== null) {\\n                    if (data[i] === \\\"restart\\\") {\\n                        body.attrs({\\n                            to: this._conn.domain,\\n                            \\\"xml:lang\\\": \\\"en\\\",\\n                            \\\"xmpp:restart\\\": \\\"true\\\",\\n                            \\\"xmlns:xmpp\\\": Strophe.NS.BOSH\\n                        });\\n                    } else {\\n                        body.cnode(data[i]).up();\\n                    }\\n                }\\n            }\\n            delete this._conn._data;\\n            this._conn._data = [];\\n            this._requests.push(\\n                new Strophe.Request(body.tree(),\\n                                    this._onRequestStateChange.bind(\\n                                        this, this._conn._dataRecv.bind(this._conn)),\\n                                    body.tree().getAttribute(\\\"rid\\\")));\\n            this._throttledRequestHandler();\\n        }\\n\\n        if (this._requests.length > 0) {\\n            var time_elapsed = this._requests[0].age();\\n            if (this._requests[0].dead !== null) {\\n                if (this._requests[0].timeDead() >\\n                    Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {\\n                    this._throttledRequestHandler();\\n                }\\n            }\\n\\n            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {\\n                Strophe.warn(\\\"Request \\\" +\\n                             this._requests[0].id +\\n                             \\\" timed out, over \\\" + Math.floor(Strophe.TIMEOUT * this.wait) +\\n                             \\\" seconds since last activity\\\");\\n                this._throttledRequestHandler();\\n            }\\n        }\\n    },\\n\\n    /** PrivateFunction: _getRequestStatus\\n     *\\n     *  Returns the HTTP status code from a Strophe.Request\\n     *\\n     *  Parameters:\\n     *    (Strophe.Request) req - The Strophe.Request instance.\\n     *    (Integer) def - The default value that should be returned if no\\n     *          status value was found.\\n     */\\n    _getRequestStatus: function (req, def) {\\n        var reqStatus;\\n        if (req.xhr.readyState === 4) {\\n            try {\\n                reqStatus = req.xhr.status;\\n            } catch (e) {\\n                // ignore errors from undefined status attribute. Works\\n                // around a browser bug\\n                Strophe.error(\\n                    \\\"Caught an error while retrieving a request's status, \\\" +\\n                    \\\"reqStatus: \\\" + reqStatus);\\n            }\\n        }\\n        if (typeof(reqStatus) === \\\"undefined\\\") {\\n            reqStatus = typeof def === 'number' ? def : 0;\\n        }\\n        return reqStatus;\\n    },\\n\\n    /** PrivateFunction: _onRequestStateChange\\n     *  _Private_ handler for Strophe.Request state changes.\\n     *\\n     *  This function is called when the XMLHttpRequest readyState changes.\\n     *  It contains a lot of error handling logic for the many ways that\\n     *  requests can fail, and calls the request callback when requests\\n     *  succeed.\\n     *\\n     *  Parameters:\\n     *    (Function) func - The handler for the request.\\n     *    (Strophe.Request) req - The request that is changing readyState.\\n     */\\n    _onRequestStateChange: function (func, req) {\\n        Strophe.debug(\\\"request id \\\"+req.id+\\\".\\\"+req.sends+\\n                      \\\" state changed to \\\"+req.xhr.readyState);\\n        if (req.abort) {\\n            req.abort = false;\\n            return;\\n        }\\n        if (req.xhr.readyState !== 4) {\\n            // The request is not yet complete\\n            return;\\n        }\\n        var reqStatus = this._getRequestStatus(req);\\n        if (this.disconnecting && reqStatus >= 400) {\\n            this._hitError(reqStatus);\\n            this._callProtocolErrorHandlers(req);\\n            return;\\n        }\\n\\n        var valid_request = reqStatus > 0 && reqStatus < 500;\\n        var too_many_retries = req.sends > this._conn.maxRetries;\\n        if (valid_request || too_many_retries) {\\n            // remove from internal queue\\n            this._removeRequest(req);\\n            Strophe.debug(\\\"request id \\\"+req.id+\\\" should now be removed\\\");\\n        }\\n\\n        if (reqStatus === 200) {\\n            // request succeeded\\n            var reqIs0 = (this._requests[0] === req);\\n            var reqIs1 = (this._requests[1] === req);\\n            // if request 1 finished, or request 0 finished and request\\n            // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to\\n            // restart the other - both will be in the first spot, as the\\n            // completed request has been removed from the queue already\\n            if (reqIs1 ||\\n                (reqIs0 && this._requests.length > 0 &&\\n                    this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {\\n                this._restartRequest(0);\\n            }\\n            this._conn.nextValidRid(Number(req.rid) + 1);\\n            Strophe.debug(\\\"request id \\\"+req.id+\\\".\\\"+req.sends+\\\" got 200\\\");\\n            func(req); // call handler\\n            this.errors = 0;\\n        } else if (reqStatus === 0 ||\\n                   (reqStatus >= 400 && reqStatus < 600) ||\\n                   reqStatus >= 12000) {\\n            // request failed\\n            Strophe.error(\\\"request id \\\"+req.id+\\\".\\\"+req.sends+\\\" error \\\"+reqStatus+\\\" happened\\\");\\n            this._hitError(reqStatus);\\n            this._callProtocolErrorHandlers(req);\\n            if (reqStatus >= 400 && reqStatus < 500) {\\n                this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);\\n                this._conn._doDisconnect();\\n            }\\n        } else {\\n            Strophe.error(\\\"request id \\\"+req.id+\\\".\\\"+req.sends+\\\" error \\\"+reqStatus+\\\" happened\\\");\\n        }\\n\\n        if (!valid_request && !too_many_retries) {\\n            this._throttledRequestHandler();\\n        } else if (too_many_retries && !this._conn.connected) {\\n            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \\\"giving-up\\\");\\n        }\\n    },\\n\\n    /** PrivateFunction: _processRequest\\n     *  _Private_ function to process a request in the queue.\\n     *\\n     *  This function takes requests off the queue and sends them and\\n     *  restarts dead requests.\\n     *\\n     *  Parameters:\\n     *    (Integer) i - The index of the request in the queue.\\n     */\\n    _processRequest: function (i) {\\n        var self = this;\\n        var req = this._requests[i];\\n        var reqStatus = this._getRequestStatus(req, -1);\\n\\n        // make sure we limit the number of retries\\n        if (req.sends > this._conn.maxRetries) {\\n            this._conn._onDisconnectTimeout();\\n            return;\\n        }\\n\\n        var time_elapsed = req.age();\\n        var primaryTimeout = (!isNaN(time_elapsed) &&\\n                              time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));\\n        var secondaryTimeout = (req.dead !== null &&\\n                                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));\\n        var requestCompletedWithServerError = (req.xhr.readyState === 4 &&\\n                                               (reqStatus < 1 || reqStatus >= 500));\\n        if (primaryTimeout || secondaryTimeout ||\\n            requestCompletedWithServerError) {\\n            if (secondaryTimeout) {\\n                Strophe.error(\\\"Request \\\" + this._requests[i].id +\\n                              \\\" timed out (secondary), restarting\\\");\\n            }\\n            req.abort = true;\\n            req.xhr.abort();\\n            // setting to null fails on IE6, so set to empty function\\n            req.xhr.onreadystatechange = function () {};\\n            this._requests[i] = new Strophe.Request(req.xmlData,\\n                                                    req.origFunc,\\n                                                    req.rid,\\n                                                    req.sends);\\n            req = this._requests[i];\\n        }\\n\\n        if (req.xhr.readyState === 0) {\\n            Strophe.debug(\\\"request id \\\"+req.id+\\\".\\\"+req.sends+\\\" posting\\\");\\n\\n            try {\\n                var contentType = this._conn.options.contentType || \\\"text/xml; charset=utf-8\\\";\\n                req.xhr.open(\\\"POST\\\", this._conn.service, this._conn.options.sync ? false : true);\\n                if (typeof req.xhr.setRequestHeader !== 'undefined') {\\n                    // IE9 doesn't have setRequestHeader\\n                    req.xhr.setRequestHeader(\\\"Content-Type\\\", contentType);\\n                }\\n                if (this._conn.options.withCredentials) {\\n                    req.xhr.withCredentials = true;\\n                }\\n            } catch (e2) {\\n                Strophe.error(\\\"XHR open failed: \\\" + e2.toString());\\n                if (!this._conn.connected) {\\n                    this._conn._changeConnectStatus(\\n                            Strophe.Status.CONNFAIL, \\\"bad-service\\\");\\n                }\\n                this._conn.disconnect();\\n                return;\\n            }\\n\\n            // Fires the XHR request -- may be invoked immediately\\n            // or on a gradually expanding retry window for reconnects\\n            var sendFunc = function () {\\n                req.date = new Date();\\n                if (self._conn.options.customHeaders){\\n                    var headers = self._conn.options.customHeaders;\\n                    for (var header in headers) {\\n                        if (headers.hasOwnProperty(header)) {\\n                            req.xhr.setRequestHeader(header, headers[header]);\\n                        }\\n                    }\\n                }\\n                req.xhr.send(req.data);\\n            };\\n\\n            // Implement progressive backoff for reconnects --\\n            // First retry (send === 1) should also be instantaneous\\n            if (req.sends > 1) {\\n                // Using a cube of the retry number creates a nicely\\n                // expanding retry window\\n                var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),\\n                                       Math.pow(req.sends, 3)) * 1000;\\n                setTimeout(function() {\\n                    // XXX: setTimeout should be called only with function expressions (23974bc1)\\n                    sendFunc();\\n                }, backoff);\\n            } else {\\n                sendFunc();\\n            }\\n\\n            req.sends++;\\n\\n            if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {\\n                if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {\\n                    this._conn.xmlOutput(req.xmlData.childNodes[0]);\\n                } else {\\n                    this._conn.xmlOutput(req.xmlData);\\n                }\\n            }\\n            if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {\\n                this._conn.rawOutput(req.data);\\n            }\\n        } else {\\n            Strophe.debug(\\\"_processRequest: \\\" +\\n                          (i === 0 ? \\\"first\\\" : \\\"second\\\") +\\n                          \\\" request has readyState of \\\" +\\n                          req.xhr.readyState);\\n        }\\n    },\\n\\n    /** PrivateFunction: _removeRequest\\n     *  _Private_ function to remove a request from the queue.\\n     *\\n     *  Parameters:\\n     *    (Strophe.Request) req - The request to remove.\\n     */\\n    _removeRequest: function (req) {\\n        Strophe.debug(\\\"removing request\\\");\\n        var i;\\n        for (i = this._requests.length - 1; i >= 0; i--) {\\n            if (req === this._requests[i]) {\\n                this._requests.splice(i, 1);\\n            }\\n        }\\n        // IE6 fails on setting to null, so set to empty function\\n        req.xhr.onreadystatechange = function () {};\\n        this._throttledRequestHandler();\\n    },\\n\\n    /** PrivateFunction: _restartRequest\\n     *  _Private_ function to restart a request that is presumed dead.\\n     *\\n     *  Parameters:\\n     *    (Integer) i - The index of the request in the queue.\\n     */\\n    _restartRequest: function (i) {\\n        var req = this._requests[i];\\n        if (req.dead === null) {\\n            req.dead = new Date();\\n        }\\n\\n        this._processRequest(i);\\n    },\\n\\n    /** PrivateFunction: _reqToData\\n     * _Private_ function to get a stanza out of a request.\\n     *\\n     * Tries to extract a stanza out of a Request Object.\\n     * When this fails the current connection will be disconnected.\\n     *\\n     *  Parameters:\\n     *    (Object) req - The Request.\\n     *\\n     *  Returns:\\n     *    The stanza that was passed.\\n     */\\n    _reqToData: function (req) {\\n        try {\\n            return req.getResponse();\\n        } catch (e) {\\n            if (e !== \\\"parsererror\\\") { throw e; }\\n            this._conn.disconnect(\\\"strophe-parsererror\\\");\\n        }\\n    },\\n\\n    /** PrivateFunction: _sendTerminate\\n     *  _Private_ function to send initial disconnect sequence.\\n     *\\n     *  This is the first step in a graceful disconnect.  It sends\\n     *  the BOSH server a terminate body and includes an unavailable\\n     *  presence if authentication has completed.\\n     */\\n    _sendTerminate: function (pres) {\\n        Strophe.info(\\\"_sendTerminate was called\\\");\\n        var body = this._buildBody().attrs({type: \\\"terminate\\\"});\\n        if (pres) {\\n            body.cnode(pres.tree());\\n        }\\n        var req = new Strophe.Request(\\n            body.tree(),\\n            this._onRequestStateChange.bind(\\n            this, this._conn._dataRecv.bind(this._conn)),\\n            body.tree().getAttribute(\\\"rid\\\")\\n        );\\n        this._requests.push(req);\\n        this._throttledRequestHandler();\\n    },\\n\\n    /** PrivateFunction: _send\\n     *  _Private_ part of the Connection.send function for BOSH\\n     *\\n     * Just triggers the RequestHandler to send the messages that are in the queue\\n     */\\n    _send: function () {\\n        clearTimeout(this._conn._idleTimeout);\\n        this._throttledRequestHandler();\\n\\n        // XXX: setTimeout should be called only with function expressions (23974bc1)\\n        this._conn._idleTimeout = setTimeout(function() {\\n            this._onIdle();\\n        }.bind(this._conn), 100);\\n    },\\n\\n    /** PrivateFunction: _sendRestart\\n     *\\n     *  Send an xmpp:restart stanza.\\n     */\\n    _sendRestart: function () {\\n        this._throttledRequestHandler();\\n        clearTimeout(this._conn._idleTimeout);\\n    },\\n\\n    /** PrivateFunction: _throttledRequestHandler\\n     *  _Private_ function to throttle requests to the connection window.\\n     *\\n     *  This function makes sure we don't send requests so fast that the\\n     *  request ids overflow the connection window in the case that one\\n     *  request died.\\n     */\\n    _throttledRequestHandler: function () {\\n        if (!this._requests) {\\n            Strophe.debug(\\\"_throttledRequestHandler called with \\\" +\\n                          \\\"undefined requests\\\");\\n        } else {\\n            Strophe.debug(\\\"_throttledRequestHandler called with \\\" +\\n                          this._requests.length + \\\" requests\\\");\\n        }\\n\\n        if (!this._requests || this._requests.length === 0) {\\n            return;\\n        }\\n\\n        if (this._requests.length > 0) {\\n            this._processRequest(0);\\n        }\\n\\n        if (this._requests.length > 1 &&\\n            Math.abs(this._requests[0].rid -\\n                     this._requests[1].rid) < this.window) {\\n            this._processRequest(1);\\n        }\\n    }\\n};\\nreturn Strophe;\\n}));\\n\\n/*\\n    This program is distributed under the terms of the MIT license.\\n    Please see the LICENSE file for details.\\n\\n    Copyright 2006-2008, OGG, LLC\\n*/\\n\\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\\n/* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */\\n\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        define('strophe-websocket',['strophe-core'], function (core) {\\n            return factory(\\n                core.Strophe,\\n                core.$build\\n            );\\n        });\\n    } else {\\n        // Browser globals\\n        return factory(Strophe, $build);\\n    }\\n}(this, function (Strophe, $build) {\\n\\n/** Class: Strophe.WebSocket\\n *  _Private_ helper class that handles WebSocket Connections\\n *\\n *  The Strophe.WebSocket class is used internally by Strophe.Connection\\n *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.\\n */\\n\\n/** File: websocket.js\\n *  A JavaScript library to enable XMPP over Websocket in Strophejs.\\n *\\n *  This file implements XMPP over WebSockets for Strophejs.\\n *  If a Connection is established with a Websocket url (ws://...)\\n *  Strophe will use WebSockets.\\n *  For more information on XMPP-over-WebSocket see RFC 7395:\\n *  http://tools.ietf.org/html/rfc7395\\n *\\n *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)\\n */\\n\\n/** PrivateConstructor: Strophe.Websocket\\n *  Create and initialize a Strophe.WebSocket object.\\n *  Currently only sets the connection Object.\\n *\\n *  Parameters:\\n *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.\\n *\\n *  Returns:\\n *    A new Strophe.WebSocket object.\\n */\\nStrophe.Websocket = function(connection) {\\n    this._conn = connection;\\n    this.strip = \\\"wrapper\\\";\\n\\n    var service = connection.service;\\n    if (service.indexOf(\\\"ws:\\\") !== 0 && service.indexOf(\\\"wss:\\\") !== 0) {\\n        // If the service is not an absolute URL, assume it is a path and put the absolute\\n        // URL together from options, current URL and the path.\\n        var new_service = \\\"\\\";\\n\\n        if (connection.options.protocol === \\\"ws\\\" && window.location.protocol !== \\\"https:\\\") {\\n            new_service += \\\"ws\\\";\\n        } else {\\n            new_service += \\\"wss\\\";\\n        }\\n\\n        new_service += \\\"://\\\" + window.location.host;\\n\\n        if (service.indexOf(\\\"/\\\") !== 0) {\\n            new_service += window.location.pathname + service;\\n        } else {\\n            new_service += service;\\n        }\\n\\n        connection.service = new_service;\\n    }\\n};\\n\\nStrophe.Websocket.prototype = {\\n    /** PrivateFunction: _buildStream\\n     *  _Private_ helper function to generate the <stream> start tag for WebSockets\\n     *\\n     *  Returns:\\n     *    A Strophe.Builder with a <stream> element.\\n     */\\n    _buildStream: function () {\\n        return $build(\\\"open\\\", {\\n            \\\"xmlns\\\": Strophe.NS.FRAMING,\\n            \\\"to\\\": this._conn.domain,\\n            \\\"version\\\": '1.0'\\n        });\\n    },\\n\\n    /** PrivateFunction: _check_streamerror\\n     * _Private_ checks a message for stream:error\\n     *\\n     *  Parameters:\\n     *    (Strophe.Request) bodyWrap - The received stanza.\\n     *    connectstatus - The ConnectStatus that will be set on error.\\n     *  Returns:\\n     *     true if there was a streamerror, false otherwise.\\n     */\\n    _check_streamerror: function (bodyWrap, connectstatus) {\\n        var errors;\\n        if (bodyWrap.getElementsByTagNameNS) {\\n            errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \\\"error\\\");\\n        } else {\\n            errors = bodyWrap.getElementsByTagName(\\\"stream:error\\\");\\n        }\\n        if (errors.length === 0) {\\n            return false;\\n        }\\n        var error = errors[0];\\n\\n        var condition = \\\"\\\";\\n        var text = \\\"\\\";\\n\\n        var ns = \\\"urn:ietf:params:xml:ns:xmpp-streams\\\";\\n        for (var i = 0; i < error.childNodes.length; i++) {\\n            var e = error.childNodes[i];\\n            if (e.getAttribute(\\\"xmlns\\\") !== ns) {\\n                break;\\n            } if (e.nodeName === \\\"text\\\") {\\n                text = e.textContent;\\n            } else {\\n                condition = e.nodeName;\\n            }\\n        }\\n\\n        var errorString = \\\"WebSocket stream error: \\\";\\n\\n        if (condition) {\\n            errorString += condition;\\n        } else {\\n            errorString += \\\"unknown\\\";\\n        }\\n\\n        if (text) {\\n            errorString += \\\" - \\\" + text;\\n        }\\n\\n        Strophe.error(errorString);\\n\\n        // close the connection on stream_error\\n        this._conn._changeConnectStatus(connectstatus, condition);\\n        this._conn._doDisconnect();\\n        return true;\\n    },\\n\\n    /** PrivateFunction: _reset\\n     *  Reset the connection.\\n     *\\n     *  This function is called by the reset function of the Strophe Connection.\\n     *  Is not needed by WebSockets.\\n     */\\n    _reset: function () {\\n        return;\\n    },\\n\\n    /** PrivateFunction: _connect\\n     *  _Private_ function called by Strophe.Connection.connect\\n     *\\n     *  Creates a WebSocket for a connection and assigns Callbacks to it.\\n     *  Does nothing if there already is a WebSocket.\\n     */\\n    _connect: function () {\\n        // Ensure that there is no open WebSocket from a previous Connection.\\n        this._closeSocket();\\n\\n        // Create the new WobSocket\\n        this.socket = new WebSocket(this._conn.service, \\\"xmpp\\\");\\n        this.socket.onopen = this._onOpen.bind(this);\\n        this.socket.onerror = this._onError.bind(this);\\n        this.socket.onclose = this._onClose.bind(this);\\n        this.socket.onmessage = this._connect_cb_wrapper.bind(this);\\n    },\\n\\n    /** PrivateFunction: _connect_cb\\n     *  _Private_ function called by Strophe.Connection._connect_cb\\n     *\\n     * checks for stream:error\\n     *\\n     *  Parameters:\\n     *    (Strophe.Request) bodyWrap - The received stanza.\\n     */\\n    _connect_cb: function(bodyWrap) {\\n        var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);\\n        if (error) {\\n            return Strophe.Status.CONNFAIL;\\n        }\\n    },\\n\\n    /** PrivateFunction: _handleStreamStart\\n     * _Private_ function that checks the opening <open /> tag for errors.\\n     *\\n     * Disconnects if there is an error and returns false, true otherwise.\\n     *\\n     *  Parameters:\\n     *    (Node) message - Stanza containing the <open /> tag.\\n     */\\n    _handleStreamStart: function(message) {\\n        var error = false;\\n\\n        // Check for errors in the <open /> tag\\n        var ns = message.getAttribute(\\\"xmlns\\\");\\n        if (typeof ns !== \\\"string\\\") {\\n            error = \\\"Missing xmlns in <open />\\\";\\n        } else if (ns !== Strophe.NS.FRAMING) {\\n            error = \\\"Wrong xmlns in <open />: \\\" + ns;\\n        }\\n\\n        var ver = message.getAttribute(\\\"version\\\");\\n        if (typeof ver !== \\\"string\\\") {\\n            error = \\\"Missing version in <open />\\\";\\n        } else if (ver !== \\\"1.0\\\") {\\n            error = \\\"Wrong version in <open />: \\\" + ver;\\n        }\\n\\n        if (error) {\\n            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);\\n            this._conn._doDisconnect();\\n            return false;\\n        }\\n\\n        return true;\\n    },\\n\\n    /** PrivateFunction: _connect_cb_wrapper\\n     * _Private_ function that handles the first connection messages.\\n     *\\n     * On receiving an opening stream tag this callback replaces itself with the real\\n     * message handler. On receiving a stream error the connection is terminated.\\n     */\\n    _connect_cb_wrapper: function(message) {\\n        if (message.data.indexOf(\\\"<open \\\") === 0 || message.data.indexOf(\\\"<?xml\\\") === 0) {\\n            // Strip the XML Declaration, if there is one\\n            var data = message.data.replace(/^(<\\\\?.*?\\\\?>\\\\s*)*/, \\\"\\\");\\n            if (data === '') return;\\n\\n            var streamStart = new DOMParser().parseFromString(data, \\\"text/xml\\\").documentElement;\\n            this._conn.xmlInput(streamStart);\\n            this._conn.rawInput(message.data);\\n\\n            //_handleStreamSteart will check for XML errors and disconnect on error\\n            if (this._handleStreamStart(streamStart)) {\\n                //_connect_cb will check for stream:error and disconnect on error\\n                this._connect_cb(streamStart);\\n            }\\n        } else if (message.data.indexOf(\\\"<close \\\") === 0) { // <close xmlns=\\\"urn:ietf:params:xml:ns:xmpp-framing />\\n            this._conn.rawInput(message.data);\\n            this._conn.xmlInput(message);\\n            var see_uri = message.getAttribute(\\\"see-other-uri\\\");\\n            if (see_uri) {\\n                this._conn._changeConnectStatus(\\n                    Strophe.Status.REDIRECT,\\n                    \\\"Received see-other-uri, resetting connection\\\"\\n                );\\n                this._conn.reset();\\n                this._conn.service = see_uri;\\n                this._connect();\\n            } else {\\n                this._conn._changeConnectStatus(\\n                    Strophe.Status.CONNFAIL,\\n                    \\\"Received closing stream\\\"\\n                );\\n                this._conn._doDisconnect();\\n            }\\n        } else {\\n            var string = this._streamWrap(message.data);\\n            var elem = new DOMParser().parseFromString(string, \\\"text/xml\\\").documentElement;\\n            this.socket.onmessage = this._onMessage.bind(this);\\n            this._conn._connect_cb(elem, null, message.data);\\n        }\\n    },\\n\\n    /** PrivateFunction: _disconnect\\n     *  _Private_ function called by Strophe.Connection.disconnect\\n     *\\n     *  Disconnects and sends a last stanza if one is given\\n     *\\n     *  Parameters:\\n     *    (Request) pres - This stanza will be sent before disconnecting.\\n     */\\n    _disconnect: function (pres) {\\n        if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {\\n            if (pres) {\\n                this._conn.send(pres);\\n            }\\n            var close = $build(\\\"close\\\", { \\\"xmlns\\\": Strophe.NS.FRAMING });\\n            this._conn.xmlOutput(close);\\n            var closeString = Strophe.serialize(close);\\n            this._conn.rawOutput(closeString);\\n            try {\\n                this.socket.send(closeString);\\n            } catch (e) {\\n                Strophe.info(\\\"Couldn't send <close /> tag.\\\");\\n            }\\n        }\\n        this._conn._doDisconnect();\\n    },\\n\\n    /** PrivateFunction: _doDisconnect\\n     *  _Private_ function to disconnect.\\n     *\\n     *  Just closes the Socket for WebSockets\\n     */\\n    _doDisconnect: function () {\\n        Strophe.info(\\\"WebSockets _doDisconnect was called\\\");\\n        this._closeSocket();\\n    },\\n\\n    /** PrivateFunction _streamWrap\\n     *  _Private_ helper function to wrap a stanza in a <stream> tag.\\n     *  This is used so Strophe can process stanzas from WebSockets like BOSH\\n     */\\n    _streamWrap: function (stanza) {\\n        return \\\"<wrapper>\\\" + stanza + '</wrapper>';\\n    },\\n\\n\\n    /** PrivateFunction: _closeSocket\\n     *  _Private_ function to close the WebSocket.\\n     *\\n     *  Closes the socket if it is still open and deletes it\\n     */\\n    _closeSocket: function () {\\n        if (this.socket) { try {\\n            this.socket.close();\\n        } catch (e) {} }\\n        this.socket = null;\\n    },\\n\\n    /** PrivateFunction: _emptyQueue\\n     * _Private_ function to check if the message queue is empty.\\n     *\\n     *  Returns:\\n     *    True, because WebSocket messages are send immediately after queueing.\\n     */\\n    _emptyQueue: function () {\\n        return true;\\n    },\\n\\n    /** PrivateFunction: _onClose\\n     * _Private_ function to handle websockets closing.\\n     *\\n     * Nothing to do here for WebSockets\\n     */\\n    _onClose: function(e) {\\n        if(this._conn.connected && !this._conn.disconnecting) {\\n            Strophe.error(\\\"Websocket closed unexpectedly\\\");\\n            this._conn._doDisconnect();\\n        } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {\\n            // in case the onError callback was not called (Safari 10 does not\\n            // call onerror when the initial connection fails) we need to\\n            // dispatch a CONNFAIL status update to be consistent with the\\n            // behavior on other browsers.\\n            Strophe.error(\\\"Websocket closed unexcectedly\\\");\\n            this._conn._changeConnectStatus(\\n                Strophe.Status.CONNFAIL,\\n                \\\"The WebSocket connection could not be established or was disconnected.\\\"\\n            );\\n            this._conn._doDisconnect();\\n        } else {\\n            Strophe.info(\\\"Websocket closed\\\");\\n        }\\n    },\\n\\n    /** PrivateFunction: _no_auth_received\\n     *\\n     * Called on stream start/restart when no stream:features\\n     * has been received.\\n     */\\n    _no_auth_received: function (_callback) {\\n        Strophe.error(\\\"Server did not send any auth methods\\\");\\n        this._conn._changeConnectStatus(\\n            Strophe.Status.CONNFAIL,\\n            \\\"Server did not send any auth methods\\\"\\n        );\\n        if (_callback) {\\n            _callback = _callback.bind(this._conn);\\n            _callback();\\n        }\\n        this._conn._doDisconnect();\\n    },\\n\\n    /** PrivateFunction: _onDisconnectTimeout\\n     *  _Private_ timeout handler for handling non-graceful disconnection.\\n     *\\n     *  This does nothing for WebSockets\\n     */\\n    _onDisconnectTimeout: function () {},\\n\\n    /** PrivateFunction: _abortAllRequests\\n     *  _Private_ helper function that makes sure all pending requests are aborted.\\n     */\\n    _abortAllRequests: function () {},\\n\\n    /** PrivateFunction: _onError\\n     * _Private_ function to handle websockets errors.\\n     *\\n     * Parameters:\\n     * (Object) error - The websocket error.\\n     */\\n    _onError: function(error) {\\n        Strophe.error(\\\"Websocket error \\\" + error);\\n        this._conn._changeConnectStatus(\\n            Strophe.Status.CONNFAIL,\\n            \\\"The WebSocket connection could not be established or was disconnected.\\\"\\n        );\\n        this._disconnect();\\n    },\\n\\n    /** PrivateFunction: _onIdle\\n     *  _Private_ function called by Strophe.Connection._onIdle\\n     *\\n     *  sends all queued stanzas\\n     */\\n    _onIdle: function () {\\n        var data = this._conn._data;\\n        if (data.length > 0 && !this._conn.paused) {\\n            for (var i = 0; i < data.length; i++) {\\n                if (data[i] !== null) {\\n                    var stanza, rawStanza;\\n                    if (data[i] === \\\"restart\\\") {\\n                        stanza = this._buildStream().tree();\\n                    } else {\\n                        stanza = data[i];\\n                    }\\n                    rawStanza = Strophe.serialize(stanza);\\n                    this._conn.xmlOutput(stanza);\\n                    this._conn.rawOutput(rawStanza);\\n                    this.socket.send(rawStanza);\\n                }\\n            }\\n            this._conn._data = [];\\n        }\\n    },\\n\\n    /** PrivateFunction: _onMessage\\n     * _Private_ function to handle websockets messages.\\n     *\\n     * This function parses each of the messages as if they are full documents.\\n     * [TODO : We may actually want to use a SAX Push parser].\\n     *\\n     * Since all XMPP traffic starts with\\n     *  <stream:stream version='1.0'\\n     *                 xml:lang='en'\\n     *                 xmlns='jabber:client'\\n     *                 xmlns:stream='http://etherx.jabber.org/streams'\\n     *                 id='3697395463'\\n     *                 from='SERVER'>\\n     *\\n     * The first stanza will always fail to be parsed.\\n     *\\n     * Additionally, the seconds stanza will always be <stream:features> with\\n     * the stream NS defined in the previous stanza, so we need to 'force'\\n     * the inclusion of the NS in this stanza.\\n     *\\n     * Parameters:\\n     * (string) message - The websocket message.\\n     */\\n    _onMessage: function(message) {\\n        var elem, data;\\n        // check for closing stream\\n        var close = '<close xmlns=\\\"urn:ietf:params:xml:ns:xmpp-framing\\\" />';\\n        if (message.data === close) {\\n            this._conn.rawInput(close);\\n            this._conn.xmlInput(message);\\n            if (!this._conn.disconnecting) {\\n                this._conn._doDisconnect();\\n            }\\n            return;\\n        } else if (message.data.search(\\\"<open \\\") === 0) {\\n            // This handles stream restarts\\n            elem = new DOMParser().parseFromString(message.data, \\\"text/xml\\\").documentElement;\\n            if (!this._handleStreamStart(elem)) {\\n                return;\\n            }\\n        } else {\\n            data = this._streamWrap(message.data);\\n            elem = new DOMParser().parseFromString(data, \\\"text/xml\\\").documentElement;\\n        }\\n\\n        if (this._check_streamerror(elem, Strophe.Status.ERROR)) {\\n            return;\\n        }\\n\\n        //handle unavailable presence stanza before disconnecting\\n        if (this._conn.disconnecting &&\\n                elem.firstChild.nodeName === \\\"presence\\\" &&\\n                elem.firstChild.getAttribute(\\\"type\\\") === \\\"unavailable\\\") {\\n            this._conn.xmlInput(elem);\\n            this._conn.rawInput(Strophe.serialize(elem));\\n            // if we are already disconnecting we will ignore the unavailable stanza and\\n            // wait for the </stream:stream> tag before we close the connection\\n            return;\\n        }\\n        this._conn._dataRecv(elem, message.data);\\n    },\\n\\n    /** PrivateFunction: _onOpen\\n     * _Private_ function to handle websockets connection setup.\\n     *\\n     * The opening stream tag is sent here.\\n     */\\n    _onOpen: function() {\\n        Strophe.info(\\\"Websocket open\\\");\\n        var start = this._buildStream();\\n        this._conn.xmlOutput(start.tree());\\n\\n        var startString = Strophe.serialize(start);\\n        this._conn.rawOutput(startString);\\n        this.socket.send(startString);\\n    },\\n\\n    /** PrivateFunction: _reqToData\\n     * _Private_ function to get a stanza out of a request.\\n     *\\n     * WebSockets don't use requests, so the passed argument is just returned.\\n     *\\n     *  Parameters:\\n     *    (Object) stanza - The stanza.\\n     *\\n     *  Returns:\\n     *    The stanza that was passed.\\n     */\\n    _reqToData: function (stanza) {\\n        return stanza;\\n    },\\n\\n    /** PrivateFunction: _send\\n     *  _Private_ part of the Connection.send function for WebSocket\\n     *\\n     * Just flushes the messages that are in the queue\\n     */\\n    _send: function () {\\n        this._conn.flush();\\n    },\\n\\n    /** PrivateFunction: _sendRestart\\n     *\\n     *  Send an xmpp:restart stanza.\\n     */\\n    _sendRestart: function () {\\n        clearTimeout(this._conn._idleTimeout);\\n        this._conn._onIdle.bind(this._conn)();\\n    }\\n};\\nreturn Strophe;\\n}));\\n\\n(function(root){\\n    if(typeof define === 'function' && define.amd){\\n        define('strophe',[\\n            \\\"strophe-core\\\",\\n            \\\"strophe-bosh\\\",\\n            \\\"strophe-websocket\\\"\\n        ], function (wrapper) {\\n            return wrapper;\\n        });\\n    }\\n})(this);\\n\\n\\nrequire([\\\"strophe-polyfill\\\"]);\\n/* jshint ignore:start */\\n    //The modules for your project will be inlined above\\n    //this snippet. Ask almond to synchronously require the\\n    //module value for 'main' here and return it as the\\n    //value to use for the public API for the built file.\\n    return require('strophe');\\n}));\\n/* jshint ignore:end */\\n\\n\\n/***/ }),\\n/* 3 */\\n/***/ (function(module, exports) {\\n\\n/**\\n * This utility class defines custom onerror and onunhandledrejection functions.\\n * The custom error handlers respect the previously-defined error handlers.\\n * GlobalOnErrorHandler class provides utilities to add many custom error\\n * handlers and to execute the error handlers directly.\\n */\\n\\n/**\\n * List with global error handlers that will be executed.\\n */\\nvar handlers = [];\\n\\n// If an old handler exists, also fire its events.\\nvar oldOnErrorHandler = window.onerror;\\n\\n/**\\n * Custom error handler that calls the old global error handler and executes\\n * all handlers that were previously added.\\n */\\nfunction JitsiGlobalErrorHandler() {\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n        args[_key] = arguments[_key];\\n    }\\n\\n    handlers.forEach(function (handler) {\\n        return handler.apply(undefined, args);\\n    });\\n    oldOnErrorHandler && oldOnErrorHandler.apply(undefined, args);\\n}\\n\\n// If an old handler exists, also fire its events.\\nvar oldOnUnhandledRejection = window.onunhandledrejection;\\n\\n/**\\n * Custom handler that calls the old global handler and executes all handlers\\n * that were previously added. This handler handles rejected Promises.\\n */\\nfunction JitsiGlobalUnhandledRejection(event) {\\n    handlers.forEach(function (handler) {\\n        return handler(null, null, null, null, event.reason);\\n    });\\n    oldOnUnhandledRejection && oldOnUnhandledRejection(event);\\n}\\n\\n// Setting the custom error handlers.\\nwindow.onerror = JitsiGlobalErrorHandler;\\nwindow.onunhandledrejection = JitsiGlobalUnhandledRejection;\\n\\nvar GlobalOnErrorHandler = {\\n    /**\\n     * Adds new error handlers.\\n     * @param handler the new handler.\\n     */\\n    addHandler: function addHandler(handler) {\\n        handlers.push(handler);\\n    },\\n\\n\\n    /**\\n     * Calls the global error handler if there is one.\\n     * @param error the error to pass to the error handler\\n     */\\n    callErrorHandler: function callErrorHandler(error) {\\n        var errHandler = window.onerror;\\n\\n        if (!errHandler) {\\n            return;\\n        }\\n        errHandler(null, null, null, null, error);\\n    },\\n\\n\\n    /**\\n     * Calls the global rejection handler if there is one.\\n     * @param error the error to pass to the rejection handler.\\n     */\\n    callUnhandledRejectionHandler: function callUnhandledRejectionHandler(error) {\\n        var errHandler = window.onunhandledrejection;\\n\\n        if (!errHandler) {\\n            return;\\n        }\\n        errHandler(error);\\n    }\\n};\\n\\nmodule.exports = GlobalOnErrorHandler;\\n\\n/***/ }),\\n/* 4 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return AUDIO; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return VIDEO; });\\n/**\\n * The audio type.\\n */\\nvar AUDIO = 'audio';\\n\\n/**\\n * The video type.\\n */\\nvar VIDEO = 'video';\\n\\n/***/ }),\\n/* 5 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = Statistics;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events__ = __webpack_require__(16);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_events__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__AnalyticsAdapter__ = __webpack_require__(67);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CallStats__ = __webpack_require__(69);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__LocalStatsCollector__ = __webpack_require__(42);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__RTPStatsCollector__ = __webpack_require__(90);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__settings_Settings__ = __webpack_require__(19);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__util_ScriptUtil__ = __webpack_require__(44);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__util_ScriptUtil___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__util_ScriptUtil__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__JitsiTrackError__ = __webpack_require__(12);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__ = __webpack_require__(43);\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = __webpack_require__(0).getLogger(__filename);\\n\\n/**\\n * Stores all active {@link Statistics} instances.\\n * @type {Set<Statistics>}\\n */\\nvar _instances = void 0;\\n\\n/**\\n * True if callstats API is loaded\\n */\\nvar isCallstatsLoaded = false;\\n\\n/**\\n * Since callstats.io is a third party, we cannot guarantee the quality of their\\n * service. More specifically, their server may take noticeably long time to\\n * respond. Consequently, it is in our best interest (in the sense that the\\n * intergration of callstats.io is pretty important to us but not enough to\\n * allow it to prevent people from joining a conference) to (1) start\\n * downloading their API as soon as possible and (2) do the downloading\\n * asynchronously.\\n *\\n * @param {StatisticsOptions} options - Options to use for downloading and\\n * initializing callstats backend.\\n */\\nfunction loadCallStatsAPI(options) {\\n    if (!isCallstatsLoaded) {\\n        __WEBPACK_IMPORTED_MODULE_8__util_ScriptUtil___default.a.loadScript(options.customScriptUrl || 'https://api.callstats.io/static/callstats-ws.min.js',\\n        /* async */true,\\n        /* prepend */true,\\n        /* relativeURL */undefined,\\n        /* loadCallback */function () {\\n            return _initCallStatsBackend(options);\\n        });\\n        isCallstatsLoaded = true;\\n    }\\n}\\n\\n/**\\n * Initializes Callstats backend.\\n *\\n * @param {StatisticsOptions} options - The options to use for initializing\\n * callstats backend.\\n * @private\\n */\\nfunction _initCallStatsBackend(options) {\\n    if (__WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */].isBackendInitialized()) {\\n        return;\\n    }\\n\\n    var userName = __WEBPACK_IMPORTED_MODULE_7__settings_Settings__[\\\"a\\\" /* default */].callStatsUserName;\\n\\n    if (!__WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */].initBackend({\\n        callStatsID: options.callStatsID,\\n        callStatsSecret: options.callStatsSecret,\\n        userName: options.swapUserNameAndAlias ? options.callStatsAliasName : userName,\\n        aliasName: options.swapUserNameAndAlias ? userName : options.callStatsAliasName,\\n        applicationName: options.applicationName,\\n        getWiFiStatsMethod: options.getWiFiStatsMethod\\n    })) {\\n        logger.error('CallStats Backend initialization failed bad');\\n    }\\n}\\n\\n/**\\n * callstats strips any additional fields from Error except for \\\"name\\\", \\\"stack\\\",\\n * \\\"message\\\" and \\\"constraintName\\\". So we need to bundle additional information\\n * from JitsiTrackError into error passed to callstats to preserve valuable\\n * information about error.\\n * @param {JitsiTrackError} error\\n */\\nfunction formatJitsiTrackErrorForCallStats(error) {\\n    var err = new Error();\\n\\n    // Just copy original stack from error\\n    err.stack = error.stack;\\n\\n    // Combine name from error's name plus (possibly) name of original GUM error\\n    err.name = (error.name || 'Unknown error') + (error.gum && error.gum.error && error.gum.error.name ? ' - ' + error.gum.error.name : '');\\n\\n    // Put all constraints into this field. For constraint failed errors we will\\n    // still know which exactly constraint failed as it will be a part of\\n    // message.\\n    err.constraintName = error.gum && error.gum.constraints ? JSON.stringify(error.gum.constraints) : '';\\n\\n    // Just copy error's message.\\n    err.message = error.message;\\n\\n    return err;\\n}\\n\\n/**\\n * Init statistic options\\n * @param options\\n */\\nStatistics.init = function (options) {\\n    Statistics.audioLevelsEnabled = !options.disableAudioLevels;\\n\\n    if (typeof options.audioLevelsInterval === 'number') {\\n        Statistics.audioLevelsInterval = options.audioLevelsInterval;\\n    }\\n\\n    Statistics.disableThirdPartyRequests = options.disableThirdPartyRequests;\\n};\\n\\n/**\\n * The options to configure Statistics.\\n * @typedef {Object} StatisticsOptions\\n * @property {string} applicationName - The application name to pass to\\n * callstats.\\n * @property {string} callStatsAliasName - The alias name to use when\\n * initializing callstats.\\n * @property {string} callStatsConfIDNamespace - A namespace to prepend the\\n * callstats conference ID with.\\n * @property {string} callStatsID - Callstats credentials - the id.\\n * @property {string} callStatsSecret - Callstats credentials - the secret.\\n * @property {string} customScriptUrl - A custom lib url to use when downloading\\n * callstats library.\\n * @property {string} roomName - The room name we are currently in.\\n * @property {boolean} swapUserNameAndAlias - Whether to swap the places of\\n * username and alias when initiating callstats.\\n */\\n/**\\n *\\n * @param xmpp\\n * @param {StatisticsOptions} options - The options to use creating the\\n * Statistics.\\n */\\nfunction Statistics(xmpp, options) {\\n    /**\\n     * {@link RTPStats} mapped by {@link TraceablePeerConnection.id} which\\n     * collect RTP statistics for each peerconnection.\\n     * @type {Map<string, RTPStats}\\n     */\\n    this.rtpStatsMap = new Map();\\n    this.eventEmitter = new __WEBPACK_IMPORTED_MODULE_0_events___default.a();\\n    this.xmpp = xmpp;\\n    this.options = options || {};\\n\\n    this.callStatsIntegrationEnabled = this.options.callStatsID && this.options.callStatsSecret\\n\\n    // Even though AppID and AppSecret may be specified, the integration\\n    // of callstats.io may be disabled because of globally-disallowed\\n    // requests to any third parties.\\n    && Statistics.disableThirdPartyRequests !== true;\\n    if (this.callStatsIntegrationEnabled) {\\n        if (__WEBPACK_IMPORTED_MODULE_6__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isReactNative()) {\\n            _initCallStatsBackend(this.options);\\n        } else {\\n            loadCallStatsAPI(this.options);\\n        }\\n\\n        if (!this.options.callStatsConfIDNamespace) {\\n            logger.warn('\\\"callStatsConfIDNamespace\\\" is not defined');\\n        }\\n    }\\n\\n    /**\\n     * Stores {@link CallStats} instances for each\\n     * {@link TraceablePeerConnection} (one {@link CallStats} instance serves\\n     * one TPC). The instances are mapped by {@link TraceablePeerConnection.id}.\\n     * @type {Map<number, CallStats>}\\n     */\\n    this.callsStatsInstances = new Map();\\n\\n    Statistics.instances.add(this);\\n}\\nStatistics.audioLevelsEnabled = false;\\nStatistics.audioLevelsInterval = 200;\\nStatistics.disableThirdPartyRequests = false;\\nStatistics.analytics = __WEBPACK_IMPORTED_MODULE_2__AnalyticsAdapter__[\\\"a\\\" /* default */];\\n\\nObject.defineProperty(Statistics, 'instances', {\\n    /**\\n     * Returns the Set holding all active {@link Statistics} instances. Lazily\\n     * initializes the Set to allow any Set polyfills to be applied.\\n     * @type {Set<Statistics>}\\n     */\\n    get: function get() {\\n        if (!_instances) {\\n            _instances = new Set();\\n        }\\n\\n        return _instances;\\n    }\\n});\\n\\n/**\\n * Starts collecting RTP stats for given peerconnection.\\n * @param {TraceablePeerConnection} peerconnection\\n */\\nStatistics.prototype.startRemoteStats = function (peerconnection) {\\n    this.stopRemoteStats(peerconnection);\\n\\n    try {\\n        var rtpStats = new __WEBPACK_IMPORTED_MODULE_5__RTPStatsCollector__[\\\"a\\\" /* default */](peerconnection, Statistics.audioLevelsInterval, 2000, this.eventEmitter);\\n\\n        rtpStats.start(Statistics.audioLevelsEnabled);\\n        this.rtpStatsMap.set(peerconnection.id, rtpStats);\\n    } catch (e) {\\n        logger.error('Failed to start collecting remote statistics: ' + e);\\n    }\\n};\\n\\nStatistics.localStats = [];\\n\\nStatistics.startLocalStats = function (stream, callback) {\\n    if (!Statistics.audioLevelsEnabled) {\\n        return;\\n    }\\n    var localStats = new __WEBPACK_IMPORTED_MODULE_4__LocalStatsCollector__[\\\"a\\\" /* default */](stream, Statistics.audioLevelsInterval, callback);\\n\\n    this.localStats.push(localStats);\\n    localStats.start();\\n};\\n\\nStatistics.prototype.addAudioLevelListener = function (listener) {\\n    if (!Statistics.audioLevelsEnabled) {\\n        return;\\n    }\\n    this.eventEmitter.on(__WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__[\\\"a\\\" /* AUDIO_LEVEL */], listener);\\n};\\n\\nStatistics.prototype.removeAudioLevelListener = function (listener) {\\n    if (!Statistics.audioLevelsEnabled) {\\n        return;\\n    }\\n    this.eventEmitter.removeListener(__WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__[\\\"a\\\" /* AUDIO_LEVEL */], listener);\\n};\\n\\nStatistics.prototype.addBeforeDisposedListener = function (listener) {\\n    this.eventEmitter.on(__WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__[\\\"b\\\" /* BEFORE_DISPOSED */], listener);\\n};\\n\\nStatistics.prototype.removeBeforeDisposedListener = function (listener) {\\n    this.eventEmitter.removeListener(__WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__[\\\"b\\\" /* BEFORE_DISPOSED */], listener);\\n};\\n\\nStatistics.prototype.addConnectionStatsListener = function (listener) {\\n    this.eventEmitter.on(__WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__[\\\"d\\\" /* CONNECTION_STATS */], listener);\\n};\\n\\nStatistics.prototype.removeConnectionStatsListener = function (listener) {\\n    this.eventEmitter.removeListener(__WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__[\\\"d\\\" /* CONNECTION_STATS */], listener);\\n};\\n\\nStatistics.prototype.addByteSentStatsListener = function (listener) {\\n    this.eventEmitter.on(__WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__[\\\"c\\\" /* BYTE_SENT_STATS */], listener);\\n};\\n\\nStatistics.prototype.removeByteSentStatsListener = function (listener) {\\n    this.eventEmitter.removeListener(__WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__[\\\"c\\\" /* BYTE_SENT_STATS */], listener);\\n};\\n\\nStatistics.prototype.dispose = function () {\\n    try {\\n        // NOTE Before reading this please see the comment in stopCallStats...\\n        //\\n        // Here we prevent from emitting the event twice in case it will be\\n        // triggered from stopCallStats.\\n        // If the event is triggered from here it means that the logs will not\\n        // be submitted anyway (because there is no CallStats instance), but\\n        // we're doing that for the sake of some kind of consistency.\\n        if (!this.callsStatsInstances.size) {\\n            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__[\\\"b\\\" /* BEFORE_DISPOSED */]);\\n        }\\n        var _iteratorNormalCompletion = true;\\n        var _didIteratorError = false;\\n        var _iteratorError = undefined;\\n\\n        try {\\n            for (var _iterator = this.callsStatsInstances.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                var callStats = _step.value;\\n\\n                this.stopCallStats(callStats.tpc);\\n            }\\n        } catch (err) {\\n            _didIteratorError = true;\\n            _iteratorError = err;\\n        } finally {\\n            try {\\n                if (!_iteratorNormalCompletion && _iterator.return) {\\n                    _iterator.return();\\n                }\\n            } finally {\\n                if (_didIteratorError) {\\n                    throw _iteratorError;\\n                }\\n            }\\n        }\\n\\n        var _iteratorNormalCompletion2 = true;\\n        var _didIteratorError2 = false;\\n        var _iteratorError2 = undefined;\\n\\n        try {\\n            for (var _iterator2 = this.rtpStatsMap.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                var tpcId = _step2.value;\\n\\n                this._stopRemoteStats(tpcId);\\n            }\\n        } catch (err) {\\n            _didIteratorError2 = true;\\n            _iteratorError2 = err;\\n        } finally {\\n            try {\\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                    _iterator2.return();\\n                }\\n            } finally {\\n                if (_didIteratorError2) {\\n                    throw _iteratorError2;\\n                }\\n            }\\n        }\\n\\n        if (this.eventEmitter) {\\n            this.eventEmitter.removeAllListeners();\\n        }\\n    } finally {\\n        Statistics.instances.delete(this);\\n    }\\n};\\n\\nStatistics.stopLocalStats = function (stream) {\\n    if (!Statistics.audioLevelsEnabled) {\\n        return;\\n    }\\n\\n    for (var i = 0; i < Statistics.localStats.length; i++) {\\n        if (Statistics.localStats[i].stream === stream) {\\n            var localStats = Statistics.localStats.splice(i, 1);\\n\\n            localStats[0].stop();\\n            break;\\n        }\\n    }\\n};\\n\\n/**\\n * Stops remote RTP stats for given peerconnection ID.\\n * @param {string} tpcId {@link TraceablePeerConnection.id}\\n * @private\\n */\\nStatistics.prototype._stopRemoteStats = function (tpcId) {\\n    var rtpStats = this.rtpStatsMap.get(tpcId);\\n\\n    if (rtpStats) {\\n        rtpStats.stop();\\n        this.rtpStatsMap.delete(tpcId);\\n    }\\n};\\n\\n/**\\n * Stops collecting RTP stats for given peerconnection\\n * @param {TraceablePeerConnection} tpc\\n */\\nStatistics.prototype.stopRemoteStats = function (tpc) {\\n    this._stopRemoteStats(tpc.id);\\n};\\n\\n// CALSTATS METHODS\\n\\n/**\\n * Initializes the callstats.io API.\\n * @param {TraceablePeerConnection} tpc the {@link TraceablePeerConnection}\\n * instance for which CalStats will be started.\\n * @param {string} remoteUserID\\n */\\nStatistics.prototype.startCallStats = function (tpc, remoteUserID) {\\n    if (!this.callStatsIntegrationEnabled) {\\n        return;\\n    } else if (this.callsStatsInstances.has(tpc.id)) {\\n        logger.error('CallStats instance for ${tpc} exists already');\\n\\n        return;\\n    }\\n\\n    logger.info('Starting CallStats for ' + tpc + '...');\\n\\n    var newInstance = new __WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */](tpc, {\\n        confID: this._getCallStatsConfID(),\\n        remoteUserID: remoteUserID\\n    });\\n\\n    this.callsStatsInstances.set(tpc.id, newInstance);\\n};\\n\\n/**\\n * Obtains the list of *all* {@link CallStats} instances collected from every\\n * valid {@link Statistics} instance.\\n * @return {Set<CallStats>}\\n * @private\\n */\\nStatistics._getAllCallStatsInstances = function () {\\n    var csInstances = new Set();\\n\\n    var _iteratorNormalCompletion3 = true;\\n    var _didIteratorError3 = false;\\n    var _iteratorError3 = undefined;\\n\\n    try {\\n        for (var _iterator3 = Statistics.instances[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n            var statistics = _step3.value;\\n            var _iteratorNormalCompletion4 = true;\\n            var _didIteratorError4 = false;\\n            var _iteratorError4 = undefined;\\n\\n            try {\\n                for (var _iterator4 = statistics.callsStatsInstances.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n                    var cs = _step4.value;\\n\\n                    csInstances.add(cs);\\n                }\\n            } catch (err) {\\n                _didIteratorError4 = true;\\n                _iteratorError4 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n                        _iterator4.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError4) {\\n                        throw _iteratorError4;\\n                    }\\n                }\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError3 = true;\\n        _iteratorError3 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                _iterator3.return();\\n            }\\n        } finally {\\n            if (_didIteratorError3) {\\n                throw _iteratorError3;\\n            }\\n        }\\n    }\\n\\n    return csInstances;\\n};\\n\\n/**\\n * Constructs the CallStats conference ID based on the options currently\\n * configured in this instance.\\n * @return {string}\\n * @private\\n */\\nStatistics.prototype._getCallStatsConfID = function () {\\n    // The conference ID is case sensitive!!!\\n    return this.options.callStatsConfIDNamespace ? this.options.callStatsConfIDNamespace + '/' + this.options.roomName : this.options.roomName;\\n};\\n\\n/**\\n * Removes the callstats.io instances.\\n */\\nStatistics.prototype.stopCallStats = function (tpc) {\\n    var callStatsInstance = this.callsStatsInstances.get(tpc.id);\\n\\n    if (callStatsInstance) {\\n        // FIXME the original purpose of adding BEFORE_DISPOSED event was to be\\n        // able to submit the last log batch from jitsi-meet to CallStats. After\\n        // recent changes we dispose the CallStats earlier\\n        // (before Statistics.dispose), so we need to emit this event here to\\n        // give this last chance for final log batch submission.\\n        //\\n        // Eventually there should be a separate module called \\\"log storage\\\"\\n        // which should emit proper events when it's underlying\\n        // CallStats instance is going away.\\n        if (this.callsStatsInstances.size === 1) {\\n            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_10__service_statistics_Events__[\\\"b\\\" /* BEFORE_DISPOSED */]);\\n        }\\n        this.callsStatsInstances.delete(tpc.id);\\n\\n        // The fabric needs to be terminated when being stopped\\n        callStatsInstance.sendTerminateEvent();\\n    }\\n};\\n\\n/**\\n * Returns true if the callstats integration is enabled, otherwise returns\\n * false.\\n *\\n * @returns true if the callstats integration is enabled, otherwise returns\\n * false.\\n */\\nStatistics.prototype.isCallstatsEnabled = function () {\\n    return this.callStatsIntegrationEnabled;\\n};\\n\\n/**\\n * Logs either resume or hold event for the given peer connection.\\n * @param {TraceablePeerConnection} tpc the connection for which event will be\\n * reported\\n * @param {boolean} isResume true for resume or false for hold\\n */\\nStatistics.prototype.sendConnectionResumeOrHoldEvent = function (tpc, isResume) {\\n    var instance = this.callsStatsInstances.get(tpc.id);\\n\\n    if (instance) {\\n        instance.sendResumeOrHoldEvent(isResume);\\n    }\\n};\\n\\n/**\\n * Notifies CallStats and analytics (if present) for ice connection failed\\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\\n */\\nStatistics.prototype.sendIceConnectionFailedEvent = function (tpc) {\\n    var instance = this.callsStatsInstances.get(tpc.id);\\n\\n    if (instance) {\\n        instance.sendIceConnectionFailedEvent();\\n    }\\n    Statistics.analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"r\\\" /* ICE_FAILED */]);\\n};\\n\\n/**\\n * Notifies CallStats for mute events\\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\\n * @param {boolean} muted true for muted and false for not muted\\n * @param {String} type \\\"audio\\\"/\\\"video\\\"\\n */\\nStatistics.prototype.sendMuteEvent = function (tpc, muted, type) {\\n    var instance = tpc && this.callsStatsInstances.get(tpc.id);\\n\\n    __WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */].sendMuteEvent(muted, type, instance);\\n};\\n\\n/**\\n * Notifies CallStats for screen sharing events\\n * @param start {boolean} true for starting screen sharing and\\n * false for not stopping\\n * @param {string|null} ssrc - optional ssrc value, used only when\\n * starting screen sharing.\\n */\\nStatistics.prototype.sendScreenSharingEvent = function (start, ssrc) {\\n    var _iteratorNormalCompletion5 = true;\\n    var _didIteratorError5 = false;\\n    var _iteratorError5 = undefined;\\n\\n    try {\\n        for (var _iterator5 = this.callsStatsInstances.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\\n            var cs = _step5.value;\\n\\n            cs.sendScreenSharingEvent(start, ssrc);\\n        }\\n    } catch (err) {\\n        _didIteratorError5 = true;\\n        _iteratorError5 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\\n                _iterator5.return();\\n            }\\n        } finally {\\n            if (_didIteratorError5) {\\n                throw _iteratorError5;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Notifies the statistics module that we are now the dominant speaker of the\\n * conference.\\n */\\nStatistics.prototype.sendDominantSpeakerEvent = function () {\\n    var _iteratorNormalCompletion6 = true;\\n    var _didIteratorError6 = false;\\n    var _iteratorError6 = undefined;\\n\\n    try {\\n        for (var _iterator6 = this.callsStatsInstances.values()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\\n            var cs = _step6.value;\\n\\n            cs.sendDominantSpeakerEvent();\\n        }\\n    } catch (err) {\\n        _didIteratorError6 = true;\\n        _iteratorError6 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\\n                _iterator6.return();\\n            }\\n        } finally {\\n            if (_didIteratorError6) {\\n                throw _iteratorError6;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Notifies about active device.\\n * @param {{deviceList: {String:String}}} devicesData - list of devices with\\n *      their data\\n */\\nStatistics.sendActiveDeviceListEvent = function (devicesData) {\\n    var globalSet = Statistics._getAllCallStatsInstances();\\n\\n    if (globalSet.size) {\\n        var _iteratorNormalCompletion7 = true;\\n        var _didIteratorError7 = false;\\n        var _iteratorError7 = undefined;\\n\\n        try {\\n            for (var _iterator7 = globalSet[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\\n                var cs = _step7.value;\\n\\n                __WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */].sendActiveDeviceListEvent(devicesData, cs);\\n            }\\n        } catch (err) {\\n            _didIteratorError7 = true;\\n            _iteratorError7 = err;\\n        } finally {\\n            try {\\n                if (!_iteratorNormalCompletion7 && _iterator7.return) {\\n                    _iterator7.return();\\n                }\\n            } finally {\\n                if (_didIteratorError7) {\\n                    throw _iteratorError7;\\n                }\\n            }\\n        }\\n    } else {\\n        __WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */].sendActiveDeviceListEvent(devicesData, null);\\n    }\\n};\\n\\n/* eslint-disable max-params */\\n\\n/**\\n * Lets the underlying statistics module know where is given SSRC rendered by\\n * providing renderer tag ID.\\n * @param {TraceablePeerConnection} tpc the connection to which the stream\\n * belongs to\\n * @param {number} ssrc the SSRC of the stream\\n * @param {boolean} isLocal\\n * @param {string} userId\\n * @param {string} usageLabel  meaningful usage label of this stream like\\n *        'microphone', 'camera' or 'screen'.\\n * @param {string} containerId the id of media 'audio' or 'video' tag which\\n *        renders the stream.\\n */\\nStatistics.prototype.associateStreamWithVideoTag = function (tpc, ssrc, isLocal, userId, usageLabel, containerId) {\\n    var instance = this.callsStatsInstances.get(tpc.id);\\n\\n    if (instance) {\\n        instance.associateStreamWithVideoTag(ssrc, isLocal, userId, usageLabel, containerId);\\n    }\\n};\\n\\n/* eslint-enable max-params */\\n\\n/**\\n * Notifies CallStats that getUserMedia failed.\\n *\\n * @param {Error} e error to send\\n */\\nStatistics.sendGetUserMediaFailed = function (e) {\\n    var error = e instanceof __WEBPACK_IMPORTED_MODULE_9__JitsiTrackError__[\\\"a\\\" /* default */] ? formatJitsiTrackErrorForCallStats(e) : e;\\n    var globalSet = Statistics._getAllCallStatsInstances();\\n\\n    if (globalSet.size) {\\n        var _iteratorNormalCompletion8 = true;\\n        var _didIteratorError8 = false;\\n        var _iteratorError8 = undefined;\\n\\n        try {\\n            for (var _iterator8 = globalSet[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\\n                var cs = _step8.value;\\n\\n                __WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */].sendGetUserMediaFailed(error, cs);\\n            }\\n        } catch (err) {\\n            _didIteratorError8 = true;\\n            _iteratorError8 = err;\\n        } finally {\\n            try {\\n                if (!_iteratorNormalCompletion8 && _iterator8.return) {\\n                    _iterator8.return();\\n                }\\n            } finally {\\n                if (_didIteratorError8) {\\n                    throw _iteratorError8;\\n                }\\n            }\\n        }\\n    } else {\\n        __WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */].sendGetUserMediaFailed(error, null);\\n    }\\n};\\n\\n/**\\n * Notifies CallStats that peer connection failed to create offer.\\n *\\n * @param {Error} e error to send\\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\\n */\\nStatistics.prototype.sendCreateOfferFailed = function (e, tpc) {\\n    var instance = this.callsStatsInstances.get(tpc.id);\\n\\n    if (instance) {\\n        instance.sendCreateOfferFailed(e);\\n    }\\n};\\n\\n/**\\n * Notifies CallStats that peer connection failed to create answer.\\n *\\n * @param {Error} e error to send\\n * @param {TraceablePeerConnection} tpc connection on which failure occured.\\n */\\nStatistics.prototype.sendCreateAnswerFailed = function (e, tpc) {\\n    var instance = this.callsStatsInstances.get(tpc.id);\\n\\n    if (instance) {\\n        instance.sendCreateAnswerFailed(e);\\n    }\\n};\\n\\n/**\\n * Notifies CallStats that peer connection failed to set local description.\\n *\\n * @param {Error} e error to send\\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\\n */\\nStatistics.prototype.sendSetLocalDescFailed = function (e, tpc) {\\n    var instance = this.callsStatsInstances.get(tpc.id);\\n\\n    if (instance) {\\n        instance.sendSetLocalDescFailed(e);\\n    }\\n};\\n\\n/**\\n * Notifies CallStats that peer connection failed to set remote description.\\n *\\n * @param {Error} e error to send\\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\\n */\\nStatistics.prototype.sendSetRemoteDescFailed = function (e, tpc) {\\n    var instance = this.callsStatsInstances.get(tpc.id);\\n\\n    if (instance) {\\n        instance.sendSetRemoteDescFailed(e);\\n    }\\n};\\n\\n/**\\n * Notifies CallStats that peer connection failed to add ICE candidate.\\n *\\n * @param {Error} e error to send\\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\\n */\\nStatistics.prototype.sendAddIceCandidateFailed = function (e, tpc) {\\n    var instance = this.callsStatsInstances.get(tpc.id);\\n\\n    if (instance) {\\n        instance.sendAddIceCandidateFailed(e);\\n    }\\n};\\n\\n/**\\n * Adds to CallStats an application log.\\n *\\n * @param {String} m a log message to send or an {Error} object to be reported\\n */\\nStatistics.sendLog = function (m) {\\n    var globalSubSet = new Set();\\n\\n    // FIXME we don't want to duplicate logs over P2P instance, but\\n    // here we should go over instances and call this method for each\\n    // unique conference ID rather than selecting the first one.\\n    // We don't have such use case though, so leaving as is for now.\\n    var _iteratorNormalCompletion9 = true;\\n    var _didIteratorError9 = false;\\n    var _iteratorError9 = undefined;\\n\\n    try {\\n        for (var _iterator9 = Statistics.instances[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\\n            var stats = _step9.value;\\n\\n            if (stats.callsStatsInstances.size) {\\n                globalSubSet.add(stats.callsStatsInstances.values().next().value);\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError9 = true;\\n        _iteratorError9 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion9 && _iterator9.return) {\\n                _iterator9.return();\\n            }\\n        } finally {\\n            if (_didIteratorError9) {\\n                throw _iteratorError9;\\n            }\\n        }\\n    }\\n\\n    if (globalSubSet.size) {\\n        var _iteratorNormalCompletion10 = true;\\n        var _didIteratorError10 = false;\\n        var _iteratorError10 = undefined;\\n\\n        try {\\n            for (var _iterator10 = globalSubSet[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\\n                var csPerStats = _step10.value;\\n\\n                __WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */].sendApplicationLog(m, csPerStats);\\n            }\\n        } catch (err) {\\n            _didIteratorError10 = true;\\n            _iteratorError10 = err;\\n        } finally {\\n            try {\\n                if (!_iteratorNormalCompletion10 && _iterator10.return) {\\n                    _iterator10.return();\\n                }\\n            } finally {\\n                if (_didIteratorError10) {\\n                    throw _iteratorError10;\\n                }\\n            }\\n        }\\n    } else {\\n        __WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */].sendApplicationLog(m, null);\\n    }\\n};\\n\\n/**\\n * Sends the given feedback through CallStats.\\n *\\n * @param overall an integer between 1 and 5 indicating the user feedback\\n * @param detailed detailed feedback from the user. Not yet used\\n */\\nStatistics.prototype.sendFeedback = function (overall, detailed) {\\n    __WEBPACK_IMPORTED_MODULE_3__CallStats__[\\\"a\\\" /* default */].sendFeedback(this._getCallStatsConfID(), overall, detailed);\\n    Statistics.analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"j\\\" /* FEEDBACK */], {\\n        value: overall,\\n        detailed: detailed\\n    });\\n};\\n\\nStatistics.LOCAL_JID = __webpack_require__(92).LOCAL_JID;\\n\\n/**\\n * Reports global error to CallStats.\\n *\\n * @param {Error} error\\n */\\nStatistics.reportGlobalError = function (error) {\\n    if (error instanceof __WEBPACK_IMPORTED_MODULE_9__JitsiTrackError__[\\\"a\\\" /* default */] && error.gum) {\\n        Statistics.sendGetUserMediaFailed(error);\\n    } else {\\n        Statistics.sendLog(error);\\n    }\\n};\\n\\n/**\\n * Sends event to analytics and callstats.\\n * @param {string} eventName the event name.\\n * @param {Object} data the data to be sent.\\n */\\nStatistics.sendEventToAll = function (eventName, data) {\\n    this.analytics.sendEvent(eventName, data);\\n    Statistics.sendLog(JSON.stringify({\\n        name: eventName,\\n        data: data\\n    }));\\n};\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/statistics/statistics.js\\\"))\\n\\n/***/ }),\\n/* 6 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AUTH_STATUS_CHANGED\\\", function() { return AUTH_STATUS_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AVAILABLE_DEVICES_CHANGED\\\", function() { return AVAILABLE_DEVICES_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AVATAR_CHANGED\\\", function() { return AVATAR_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BEFORE_STATISTICS_DISPOSED\\\", function() { return BEFORE_STATISTICS_DISPOSED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONFERENCE_ERROR\\\", function() { return CONFERENCE_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONFERENCE_FAILED\\\", function() { return CONFERENCE_FAILED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONFERENCE_JOINED\\\", function() { return CONFERENCE_JOINED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONFERENCE_LEFT\\\", function() { return CONFERENCE_LEFT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONNECTION_INTERRUPTED\\\", function() { return CONNECTION_INTERRUPTED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONNECTION_RESTORED\\\", function() { return CONNECTION_RESTORED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DATA_CHANNEL_OPENED\\\", function() { return DATA_CHANNEL_OPENED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DISPLAY_NAME_CHANGED\\\", function() { return DISPLAY_NAME_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DOMINANT_SPEAKER_CHANGED\\\", function() { return DOMINANT_SPEAKER_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DTMF_SUPPORT_CHANGED\\\", function() { return DTMF_SUPPORT_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ENDPOINT_MESSAGE_RECEIVED\\\", function() { return ENDPOINT_MESSAGE_RECEIVED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"JVB121_STATUS\\\", function() { return JVB121_STATUS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"KICKED\\\", function() { return KICKED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LAST_N_ENDPOINTS_CHANGED\\\", function() { return LAST_N_ENDPOINTS_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LOCK_STATE_CHANGED\\\", function() { return LOCK_STATE_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MESSAGE_RECEIVED\\\", function() { return MESSAGE_RECEIVED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PARTICIPANT_CONN_STATUS_CHANGED\\\", function() { return PARTICIPANT_CONN_STATUS_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PARTCIPANT_FEATURES_CHANGED\\\", function() { return PARTCIPANT_FEATURES_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PARTICIPANT_PROPERTY_CHANGED\\\", function() { return PARTICIPANT_PROPERTY_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"P2P_STATUS\\\", function() { return P2P_STATUS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PHONE_NUMBER_CHANGED\\\", function() { return PHONE_NUMBER_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RECORDER_STATE_CHANGED\\\", function() { return RECORDER_STATE_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VIDEO_SIP_GW_AVAILABILITY_CHANGED\\\", function() { return VIDEO_SIP_GW_AVAILABILITY_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VIDEO_SIP_GW_SESSION_STATE_CHANGED\\\", function() { return VIDEO_SIP_GW_SESSION_STATE_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"START_MUTED_POLICY_CHANGED\\\", function() { return START_MUTED_POLICY_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"STARTED_MUTED\\\", function() { return STARTED_MUTED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SUBJECT_CHANGED\\\", function() { return SUBJECT_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SUSPEND_DETECTED\\\", function() { return SUSPEND_DETECTED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TALK_WHILE_MUTED\\\", function() { return TALK_WHILE_MUTED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRACK_ADDED\\\", function() { return TRACK_ADDED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRACK_AUDIO_LEVEL_CHANGED\\\", function() { return TRACK_AUDIO_LEVEL_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRACK_MUTE_CHANGED\\\", function() { return TRACK_MUTE_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRACK_REMOVED\\\", function() { return TRACK_REMOVED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRANSCRIPTION_STATUS_CHANGED\\\", function() { return TRANSCRIPTION_STATUS_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"USER_JOINED\\\", function() { return USER_JOINED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"USER_LEFT\\\", function() { return USER_LEFT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"USER_ROLE_CHANGED\\\", function() { return USER_ROLE_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"USER_STATUS_CHANGED\\\", function() { return USER_STATUS_CHANGED; });\\n/**\\n * The events for the conference.\\n */\\n\\n/**\\n * Indicates that authentication status changed.\\n */\\nvar AUTH_STATUS_CHANGED = 'conference.auth_status_changed';\\n\\n/**\\n * Indicates that available devices changed.\\n */\\nvar AVAILABLE_DEVICES_CHANGED = 'conference.availableDevicesChanged';\\n\\n/**\\n * A participant avatar has changed.\\n */\\nvar AVATAR_CHANGED = 'conference.avatarChanged';\\n\\n/**\\n * Fired just before the statistics module is disposed and it's the last chance\\n * to submit some logs to the statistics service (ex. CallStats if enabled),\\n * before it's disconnected.\\n */\\nvar BEFORE_STATISTICS_DISPOSED = 'conference.beforeStatisticsDisposed';\\n\\n/**\\n * Indicates that an error occured.\\n */\\nvar CONFERENCE_ERROR = 'conference.error';\\n\\n/**\\n * Indicates that conference failed.\\n */\\nvar CONFERENCE_FAILED = 'conference.failed';\\n\\n/**\\n * Indicates that conference has been joined. The event does NOT provide any\\n * parameters to its listeners.\\n */\\nvar CONFERENCE_JOINED = 'conference.joined';\\n\\n/**\\n * Indicates that conference has been left.\\n */\\nvar CONFERENCE_LEFT = 'conference.left';\\n\\n/**\\n * Indicates that the connection to the conference has been interrupted for some\\n * reason.\\n */\\nvar CONNECTION_INTERRUPTED = 'conference.connectionInterrupted';\\n\\n/**\\n * Indicates that the connection to the conference has been restored.\\n */\\nvar CONNECTION_RESTORED = 'conference.connectionRestored';\\n\\n/**\\n * A connection to the video bridge's data channel has been established.\\n */\\nvar DATA_CHANNEL_OPENED = 'conference.dataChannelOpened';\\n\\n/**\\n * A user has changed it display name\\n */\\nvar DISPLAY_NAME_CHANGED = 'conference.displayNameChanged';\\n\\n/**\\n * The dominant speaker was changed.\\n */\\nvar DOMINANT_SPEAKER_CHANGED = 'conference.dominantSpeaker';\\n\\n/**\\n * Indicates that DTMF support changed.\\n */\\nvar DTMF_SUPPORT_CHANGED = 'conference.dtmfSupportChanged';\\n\\n/**\\n * Indicates that a message from another participant is received on data\\n * channel.\\n */\\nvar ENDPOINT_MESSAGE_RECEIVED = 'conference.endpoint_message_received';\\n\\n/**\\n * NOTE This is lib-jitsi-meet internal event and can be removed at any time !\\n *\\n * Event emitted when conference transits, between one to one and multiparty JVB\\n * conference. If the conference switches to P2P it's neither one to one nor\\n * a multiparty JVB conference, but P2P (the status argument of this event will\\n * be <tt>false</tt>).\\n *\\n * The first argument is a boolean which carries the previous value and\\n * the seconds argument is a boolean with the new status. The event is emitted\\n * only if the previous and the new values are different.\\n *\\n * @type {string}\\n */\\nvar JVB121_STATUS = 'conference.jvb121Status';\\n\\n/**\\n * You are kicked from the conference.\\n */\\nvar KICKED = 'conferenece.kicked';\\n\\n/**\\n * The Last N set is changed.\\n *\\n * @param {Array<string>|null} leavingEndpointIds the ids of all the endpoints\\n * which are leaving Last N\\n * @param {Array<string>|null} enteringEndpointIds the ids of all the endpoints\\n * which are entering Last N\\n */\\nvar LAST_N_ENDPOINTS_CHANGED = 'conference.lastNEndpointsChanged';\\n\\n/**\\n * Indicates that the room has been locked or unlocked.\\n */\\nvar LOCK_STATE_CHANGED = 'conference.lock_state_changed';\\n\\n/**\\n * New text message was received.\\n */\\nvar MESSAGE_RECEIVED = 'conference.messageReceived';\\n\\n/**\\n * Event fired when JVB sends notification about interrupted/restored user's\\n * ICE connection status or we detect local problem with the video track.\\n * First argument is the ID of the participant and\\n * the seconds is a string indicating if the connection is currently\\n * - active - the connection is active\\n * - inactive - the connection is inactive, was intentionally interrupted by\\n * the bridge\\n * - interrupted - a network problem occurred\\n * - restoring - the connection was inactive and is restoring now\\n *\\n * The current status value can be obtained by calling\\n * JitsiParticipant.getConnectionStatus().\\n */\\nvar PARTICIPANT_CONN_STATUS_CHANGED = 'conference.participant_conn_status_changed';\\n\\n/**\\n * Indicates that the features of the participant has been changed.\\n */\\nvar PARTCIPANT_FEATURES_CHANGED = 'conference.partcipant_features_changed';\\n\\n/**\\n * Indicates that a the value of a specific property of a specific participant\\n * has changed.\\n */\\nvar PARTICIPANT_PROPERTY_CHANGED = 'conference.participant_property_changed';\\n\\n/**\\n * Indicates that the conference has switched between JVB and P2P connections.\\n * The first argument of this event is a <tt>boolean</tt> which when set to\\n * <tt>true</tt> means that the conference is running on the P2P connection.\\n */\\nvar P2P_STATUS = 'conference.p2pStatus';\\n\\n/**\\n * Indicates that phone number changed.\\n */\\nvar PHONE_NUMBER_CHANGED = 'conference.phoneNumberChanged';\\n\\n/**\\n * Indicates that recording state changed.\\n */\\nvar RECORDER_STATE_CHANGED = 'conference.recorderStateChanged';\\n\\n/**\\n * Indicates that video SIP GW state changed.\\n * @param {VideoSIPGWConstants} status.\\n */\\nvar VIDEO_SIP_GW_AVAILABILITY_CHANGED = 'conference.videoSIPGWAvailabilityChanged';\\n\\n/**\\n * Indicates that video SIP GW Session state changed.\\n * @param {options} event - {\\n *     {string} address,\\n *     {VideoSIPGWConstants} oldState,\\n *     {VideoSIPGWConstants} newState,\\n *     {string} displayName}\\n * }.\\n */\\nvar VIDEO_SIP_GW_SESSION_STATE_CHANGED = 'conference.videoSIPGWSessionStateChanged';\\n\\n/**\\n * Indicates that start muted settings changed.\\n */\\nvar START_MUTED_POLICY_CHANGED = 'conference.start_muted_policy_changed';\\n\\n/**\\n * Indicates that the local user has started muted.\\n */\\nvar STARTED_MUTED = 'conference.started_muted';\\n\\n/**\\n * Indicates that subject of the conference has changed.\\n */\\nvar SUBJECT_CHANGED = 'conference.subjectChanged';\\n\\n/**\\n * Indicates that DTMF support changed.\\n */\\nvar SUSPEND_DETECTED = 'conference.suspendDetected';\\n\\n/**\\n * Event indicates that local user is talking while he muted himself\\n */\\nvar TALK_WHILE_MUTED = 'conference.talk_while_muted';\\n\\n/**\\n * A new media track was added to the conference. The event provides the\\n * following parameters to its listeners:\\n *\\n * @param {JitsiTrack} track the added JitsiTrack\\n */\\nvar TRACK_ADDED = 'conference.trackAdded';\\n\\n/**\\n * Audio levels of a media track ( attached to the conference) was changed.\\n */\\nvar TRACK_AUDIO_LEVEL_CHANGED = 'conference.audioLevelsChanged';\\n\\n/**\\n * A media track ( attached to the conference) mute status was changed.\\n */\\nvar TRACK_MUTE_CHANGED = 'conference.trackMuteChanged';\\n\\n/**\\n * The media track was removed from the conference. The event provides the\\n * following parameters to its listeners:\\n *\\n * @param {JitsiTrack} track the removed JitsiTrack\\n */\\nvar TRACK_REMOVED = 'conference.trackRemoved';\\n\\n/**\\n * Notifies for transcription status changes. The event provides the\\n * following parameters to its listeners:\\n *\\n * @param {String} status - The new status.\\n */\\nvar TRANSCRIPTION_STATUS_CHANGED = 'conference.transcriptionStatusChanged';\\n\\n/**\\n * A new user joinned the conference.\\n */\\nvar USER_JOINED = 'conference.userJoined';\\n\\n/**\\n * A user has left the conference.\\n */\\nvar USER_LEFT = 'conference.userLeft';\\n\\n/**\\n * User role changed.\\n */\\nvar USER_ROLE_CHANGED = 'conference.roleChanged';\\n\\n/**\\n * User status changed.\\n */\\nvar USER_STATUS_CHANGED = 'conference.statusChanged';\\n\\n/***/ }),\\n/* 7 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"C\\\", function() { return _CONNECTION_TIMES_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"D\\\", function() { return _ICE_CHECKING_DURATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"E\\\", function() { return _ICE_CONNECTION_STATE_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"F\\\", function() { return _ICE_ESTABLISHMENT_DURATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"G\\\", function() { return _ICE_GATHERING_DURATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"H\\\", function() { return _NO_DATA_FROM_SOURCE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"I\\\", function() { return _TRACK_UNMUTE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"J\\\", function() { return _TTFM_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return AVG_RTP_STATS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return BRIDGE_DOWN; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"c\\\", function() { return CONFERENCE_ERROR_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"f\\\", function() { return CONNECTION_INTERRUPTED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"d\\\", function() { return CONNECTION_DISCONNECTED_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"e\\\", function() { return CONNECTION_FAILED_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"g\\\", function() { return CONNECTION_RESTORED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"h\\\", function() { return DATA_CHANNEL_OPEN; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"i\\\", function() { return DEVICE_LIST; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"j\\\", function() { return FEEDBACK; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"k\\\", function() { return FOCUS_LEFT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"l\\\", function() { return GET_USER_MEDIA_DEVICE_NOT_FOUND_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"n\\\", function() { return GET_USER_MEDIA_FAIL_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"m\\\", function() { return GET_USER_MEDIA_FAILED_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"o\\\", function() { return GET_USER_MEDIA_SUCCESS_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"p\\\", function() { return GET_USER_MEDIA_USER_CANCEL_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"q\\\", function() { return ICE_ESTABLISHMENT_DURATION_DIFF; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"r\\\", function() { return ICE_FAILED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"s\\\", function() { return P2P_ESTABLISHED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"t\\\", function() { return P2P_FAILED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"u\\\", function() { return P2P_SWITCH_TO_JVB; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"v\\\", function() { return REMOTELY_MUTED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"w\\\", function() { return SESSION_INITIATE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"x\\\", function() { return SESSION_INITIATE_RECEIVED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"z\\\", function() { return SESSION_TERMINATE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"y\\\", function() { return SESSION_RESTART; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"A\\\", function() { return TRANSPORT_REPLACE_START; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"B\\\", function() { return TRANSPORT_REPLACE_SUCCESS; });\\n/**\\n * Note that an event's own properties and its permanent properties are\\n * are merged in one object. Because of this an event should never use\\n * properties with names that are already used by permanent properties\\n * (unless the intention is to override a permanent property). Here is a\\n * (non-exhaustive) list of currently know permanent properties:\\n *\\n * abtestSuspendVideo\\n * browserName\\n * callstatsname\\n * crossRegion\\n * forceJvb121\\n * region\\n * roomName\\n * shard\\n * size\\n * userAgent\\n * userRegion\\n *\\n * The naming convention for the constants below uses \\\"_\\\" as a prefix or\\n * suffix to indicate that known usage of the constant prepends or appends\\n * a string to the name of the event.\\n */\\n\\n/**\\n * Properties: value\\n *\\n * TODO: document, reformat\\n *\\n * Full event names (uncertain):\\n * conference.muc.joined (???)\\n * conference.sharingDesktop.start (???)\\n * conference.sharingDesktop.stop (???)\\n * xmpp.attached (???)\\n * xmpp.attaching (???)\\n * xmpp.connected (???)\\n * xmpp.connecting (???)\\n * xmpp.session-initiate (???)\\n */\\nvar _CONNECTION_TIMES_ = '';\\n\\n/**\\n * TODO: document, reformat (group together with other ICE events)\\n *\\n * Known full event names:\\n * ice.initiator.checksDuration\\n * ice.responder.checksDuration\\n * p2p.ice.initiator.checksDuration\\n * p2p.ice.responder.checksDuration\\n *\\n * Properties: value\\n */\\nvar _ICE_CHECKING_DURATION = 'checksDuration';\\n\\n/**\\n * TODO: document, reformat\\n *\\n * Known full event names:\\n * ice.checking\\n * ice.closed\\n * ice.completed\\n * ice.connected\\n * ice.disconnected\\n * ice.failed\\n * p2p.ice.checking\\n * p2p.ice.closed\\n * p2p.ice.completed\\n * p2p.ice.connected\\n * p2p.ice.disconnected\\n * p2p.ice.failed\\n *\\n * Properties: value\\n */\\nvar _ICE_CONNECTION_STATE_ = 'ice';\\n\\n/**\\n * TODO: document, reformat (group together with other ICE events)\\n *\\n * Known full event names:\\n * ice.initiator.establishmentDuration\\n * ice.responder.establishmentDuration\\n * p2p.ice.initiator.establishmentDuration\\n * p2p.ice.responder.establishmentDuration\\n *\\n * Properties: value\\n */\\nvar _ICE_ESTABLISHMENT_DURATION = 'establishmentDuration';\\n\\n/**\\n * TODO: document, reformat\\n *\\n * Known full event names:\\n * ice.initiator.gatheringDuration\\n * ice.responder.gatheringDuration\\n * p2p.ice.initiator.gatheringDuration\\n * p2p.ice.responder.gatheringDuration\\n *\\n * Properties: value\\n */\\nvar _ICE_GATHERING_DURATION = 'gatheringDuration';\\n\\n/**\\n * TODO: document, reformat\\n *\\n * Known full event names:\\n * audio.no_data_from_source\\n * video.no_data_from_source\\n */\\nvar _NO_DATA_FROM_SOURCE = 'no_data_from_source';\\n\\n/**\\n * TODO: document, reformat\\n *\\n * Known full event names:\\n * audio.track_unmute\\n * video.track_unmute\\n */\\nvar _TRACK_UNMUTE = 'track_unmute';\\n\\n/**\\n * TODO: document, reformat\\n *\\n * TTMF: Time To First Media\\n *\\n * Known full event names:\\n * audio.ttfm\\n * video.ttfm\\n * audio.ttfm.muted\\n * video.ttfm.muted\\n */\\nvar _TTFM_ = 'ttfm';\\n\\n/**\\n * All average RTP stats are currently reported under 1 event name, but with\\n * different properties that allows to distinguish between a P2P call, a\\n * call relayed through TURN or the JVB, and multiparty vs 1:1.\\n * Example structure of an \\\"avg.rtp.stats\\\" analytics event:\\n *\\n * {\\n     *   p2p: true,\\n     *   conferenceSize: 2,\\n     *   localCandidateType: \\\"relay\\\",\\n     *   remoteCandidateType: \\\"relay\\\",\\n     *   transportType: \\\"udp\\\",\\n     *\\n     *   \\\"stat_avg_rtt\\\": {\\n     *     value: 200,\\n     *     samples: [ 100, 200, 300 ]\\n     *   },\\n     *   \\\"stat_avg_packetloss_total\\\": {\\n     *     value: 10,\\n     *     samples: [ 5, 10, 15]\\n     *   }\\n     * }\\n *\\n * Note that the samples array is currently emitted for debug purposes only\\n * and can be removed anytime soon from the structure.\\n *\\n * Also not all values are always present in \\\"avg.rtp.stats\\\", some of the\\n * values are obtained and calculated as part of different process/event\\n * pipe. For example {@link ConnectionAvgStats} instances are doing the\\n * reports for each {@link TraceablePeerConnection} and work independently\\n * from the main stats pipe.\\n */\\nvar AVG_RTP_STATS = 'avg.rtp.stats';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document, deprecate?\\n */\\nvar BRIDGE_DOWN = 'conference.bridgeDown';\\n\\n/**\\n * Properties: none\\n *\\n * Known full event names:\\n * conference.error.p2pSessionAcceptTimeout\\n * conference.error.sessionAcceptTimeout\\n *\\n * TODO: document, reformat\\n */\\nvar CONFERENCE_ERROR_ = 'conference.error';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document\\n */\\nvar CONNECTION_INTERRUPTED = 'connection.interrupted';\\n\\n/**\\n * Properties: none\\n *\\n * Known full event names: NONE\\n *\\n * TODO: document, reformat?, deprecate?\\n */\\nvar CONNECTION_DISCONNECTED_ = 'connection.disconnected';\\n\\n/**\\n * Properties: label\\n *\\n * Known full event names:\\n * connection.failed.connection.droppedError\\n * connection.failed.connection.otherError\\n * connection.failed.connection.passwordRequired\\n *\\n * TODO: document, reformat\\n */\\nvar CONNECTION_FAILED_ = 'connection.failed';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document\\n */\\nvar CONNECTION_RESTORED = 'connection.restored';\\n\\n/**\\n * Properties: value\\n *\\n * TODO: document, deprecate (is it the same as the one which is part of\\n * CONNECTION_TIMES?)\\n */\\nvar DATA_CHANNEL_OPEN = 'conference.dataChannel.open';\\n\\n/**\\n * TODO: document, reformat\\n */\\nvar DEVICE_LIST = 'devices.deviceList';\\n\\n/**\\n * User feedback event.\\n * Properties: value, detailed\\n *\\n * TODO: document\\n */\\nvar FEEDBACK = 'feedback.rating';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document\\n */\\nvar FOCUS_LEFT = 'conference.focusLeft';\\n\\n/**\\n * Properties: none\\n *\\n * Known full event names:\\n * getUserMedia.deviceNotFound.audio\\n * getUserMedia.deviceNotFound.audio.video\\n * getUserMedia.deviceNotFound.video\\n * getUserMedia.deviceNotFound.screen\\n *\\n * TODO: document, reformat, merge with GET_USER_MEDIA_FAILED?\\n */\\nvar GET_USER_MEDIA_DEVICE_NOT_FOUND_ = 'getUserMedia.deviceNotFound';\\n\\n/**\\n * Properties: none\\n *\\n * Known full event names:\\n * getUserMedia.fail.resolution.180\\n * getUserMedia.fail.resolution.360\\n * getUserMedia.fail.resolution.640\\n * getUserMedia.fail.resolution.720\\n * getUserMedia.fail.resolution.960\\n *\\n * TODO: reformat, merge with GET_USER_MEDIA_FAILED\\n */\\nvar GET_USER_MEDIA_FAIL_ = 'getUserMedia.fail';\\n\\n/**\\n * Properties: value\\n *\\n * Known full event names:\\n * getUserMedia.failed.Error\\n * getUserMedia.failed.TypeError\\n * getUserMedia.failed.audio.TypeError\\n * getUserMedia.failed.audio.gum.general\\n * getUserMedia.failed.audio.gum.permission_denied\\n * getUserMedia.failed.audio.track.no_data_from_source\\n * getUserMedia.failed.audio.video.180.gum.general\\n * getUserMedia.failed.audio.video.360.gum.general\\n * getUserMedia.failed.audio.video.360.gum.permission_denied\\n * getUserMedia.failed.audio.video.360.track.no_data_from_source\\n * getUserMedia.failed.audio.video.720.TypeError\\n * getUserMedia.failed.audio.video.720.gum.constraint_failed\\n * getUserMedia.failed.audio.video.720.gum.general\\n * getUserMedia.failed.audio.video.720.gum.permission_denied\\n * getUserMedia.failed.audio.video.720.track.no_data_from_source\\n * getUserMedia.failed.audio.video.960.gum.permission_denied\\n * getUserMedia.failed.audio.video.undefined.gum.general\\n * getUserMedia.failed.desktop.TypeError\\n * getUserMedia.failed.desktop.gum.chrome_extension_generic_error\\n * getUserMedia.failed.desktop.gum.chrome_extension_installation_error\\n * getUserMedia.failed.desktop.gum.chrome_extension_user_gesture_required\\n * getUserMedia.failed.desktop.gum.general\\n * getUserMedia.failed.desktop.track.no_data_from_source\\n * getUserMedia.failed.gum.chrome_extension_generic_error\\n * getUserMedia.failed.gum.chrome_extension_installation_error\\n * getUserMedia.failed.gum.constraint_failed\\n * getUserMedia.failed.gum.firefox_extension_needed\\n * getUserMedia.failed.gum.general\\n * getUserMedia.failed.gum.permission_denied\\n * getUserMedia.failed.undefined\\n * getUserMedia.failed.video.360.gum.permission_denied\\n * getUserMedia.failed.video.720.TypeError\\n * getUserMedia.failed.video.720.gum.constraint_failed\\n * getUserMedia.failed.video.720.gum.general\\n * getUserMedia.failed.video.720.gum.permission_denied\\n * getUserMedia.failed.video.720.track.no_data_from_source\\n * getUserMedia.failed.video.undefined.TypeError\\n * getUserMedia.failed.video.undefined.gum.general\\n * getUserMedia.failed.video.undefined.track.no_data_from_source\\n *\\n * TODO: reformat\\n */\\nvar GET_USER_MEDIA_FAILED_ = 'getUserMedia.failed';\\n\\n/**\\n * Properties: value\\n *\\n * Known full event names:\\n * getUserMedia.success\\n * getUserMedia.success.audio\\n * getUserMedia.success.audio.video.180\\n * getUserMedia.success.audio.video.300\\n * getUserMedia.success.audio.video.360\\n * getUserMedia.success.audio.video.720\\n * getUserMedia.success.audio.video.960\\n * getUserMedia.success.audio.video.undefined\\n * getUserMedia.success.desktop\\n * getUserMedia.success.video.180\\n * getUserMedia.success.video.360\\n * getUserMedia.success.video.720\\n * getUserMedia.success.video.960\\n * getUserMedia.success.video.undefined\\n *\\n * TODO: document, reformat\\n */\\nvar GET_USER_MEDIA_SUCCESS_ = 'getUserMedia.success';\\n\\n/**\\n * Properties: none\\n *\\n * Known full event names:\\n * getUserMedia.userCancel.extensionInstall\\n *\\n * TODO: document, reformat\\n */\\nvar GET_USER_MEDIA_USER_CANCEL_ = 'getUserMedia.userCancel';\\n\\n/**\\n * Properties: value\\n *\\n * The \\\"value\\\" property contains the difference in milliseconds between\\n * the ICE establishment time for the P2P and JVB connections (e.g. a value\\n * of 10 would indicate that the P2P was 10ms slower than JVB).\\n */\\nvar ICE_ESTABLISHMENT_DURATION_DIFF = 'ice.establishmentDurationDiff';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document\\n * TODO: do we need this in addition to _ICE_CONNECTION_STATE?\\n */\\nvar ICE_FAILED = 'connection.ice_failed';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document\\n */\\nvar P2P_ESTABLISHED = 'p2p.established';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document\\n */\\nvar P2P_FAILED = 'p2p.failed';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document\\n */\\nvar P2P_SWITCH_TO_JVB = 'p2p.switch_to_jvb';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document\\n */\\nvar REMOTELY_MUTED = 'conference.remotelyMuted';\\n\\n/**\\n * Properties: value\\n *\\n * TODO: document\\n *\\n * The \\\"value\\\" property contains the delay in milliseconds between joining\\n * the MUC and receiving a Jingle session-initiate from Jicofo (but not\\n * P2P).\\n */\\nvar SESSION_INITIATE = 'session.initiate';\\n\\n/**\\n * Properties: value\\n *\\n * TODO: document\\n */\\nvar SESSION_INITIATE_RECEIVED = 'xmpp.session-initiate';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document\\n */\\nvar SESSION_TERMINATE = 'session.terminate';\\n\\n/**\\n * Properties: none\\n *\\n * TODO: document\\n */\\nvar SESSION_RESTART = 'session.restart';\\n\\n/**\\n * Properties: value\\n *\\n * TODO: document\\n */\\nvar TRANSPORT_REPLACE_START = 'xmpp.transport-replace.start';\\n\\n/**\\n * Properties: value\\n *\\n * TODO: document\\n */\\nvar TRANSPORT_REPLACE_SUCCESS = 'xmpp.transport-replace.success';\\n\\n/***/ }),\\n/* 8 */\\n/***/ (function(module, exports) {\\n\\nvar XMPPEvents = {\\n  /**\\n   * Indicates error while adding ice candidate.\\n   */\\n  ADD_ICE_CANDIDATE_FAILED: 'xmpp.add_ice_candidate_failed',\\n\\n  // Designates an event indicating that the focus has asked us to mute our\\n  // audio.\\n  AUDIO_MUTED_BY_FOCUS: 'xmpp.audio_muted_by_focus',\\n  AUTHENTICATION_REQUIRED: 'xmpp.authentication_required',\\n  BRIDGE_DOWN: 'xmpp.bridge_down',\\n\\n  /**\\n   * Triggered when 'session-accept' is received from the responder.\\n   */\\n  CALL_ACCEPTED: 'xmpp.callaccepted.jingle',\\n\\n  // Designates an event indicating that an offer (e.g. Jingle\\n  // session-initiate) was received.\\n  CALL_INCOMING: 'xmpp.callincoming.jingle',\\n\\n  // Triggered when Jicofo kills our media session, this can happen while\\n  // we're still in the MUC, when it decides to terminate the media session.\\n  // For example when the session is idle for too long, because we're the only\\n  // person in the conference room.\\n  CALL_ENDED: 'xmpp.callended.jingle',\\n  CHAT_ERROR_RECEIVED: 'xmpp.chat_error_received',\\n  CONFERENCE_SETUP_FAILED: 'xmpp.conference_setup_failed',\\n\\n  /**\\n   * This event is triggered when the ICE connects for the first time.\\n   */\\n  CONNECTION_ESTABLISHED: 'xmpp.connection.connected',\\n\\n  // Designates an event indicating that the connection to the XMPP server\\n  // failed.\\n  CONNECTION_FAILED: 'xmpp.connection.failed',\\n\\n  // Designates an event indicating that the media (ICE) connection was\\n  // interrupted. This should go to the RTC module.\\n  CONNECTION_INTERRUPTED: 'xmpp.connection.interrupted',\\n\\n  // Designates an event indicating that the media (ICE) connection was\\n  // restored. This should go to the RTC module.\\n  CONNECTION_RESTORED: 'xmpp.connection.restored',\\n\\n  // Designates an event indicating that the media (ICE) connection failed.\\n  // This should go to the RTC module.\\n  CONNECTION_ICE_FAILED: 'xmpp.connection.ice.failed',\\n\\n  // Designates an event indicating that the display name of a participant\\n  // has changed.\\n  DISPLAY_NAME_CHANGED: 'xmpp.display_name_changed',\\n\\n  /**\\n   * Chat room instance have been added to Strophe.emuc plugin.\\n   */\\n  EMUC_ROOM_ADDED: 'xmpp.emuc_room_added',\\n\\n  /**\\n   * Chat room instance have been removed from Strophe.emuc plugin.\\n   */\\n  EMUC_ROOM_REMOVED: 'xmpp.emuc_room_removed',\\n  ETHERPAD: 'xmpp.etherpad',\\n  FOCUS_DISCONNECTED: 'xmpp.focus_disconnected',\\n  FOCUS_LEFT: 'xmpp.focus_left',\\n  GRACEFUL_SHUTDOWN: 'xmpp.graceful_shutdown',\\n\\n  /**\\n   * Event fired when 'transport-replace' Jingle message has been received,\\n   * before the new offer is set on the PeerConnection.\\n   */\\n  ICE_RESTARTING: 'rtc.ice_restarting',\\n\\n  /* Event fired when XMPP error is returned to any request, it is meant to be\\n   * used to report 'signaling' errors to CallStats\\n   *\\n   * {\\n   *   code: {XMPP error code}\\n   *   reason: {XMPP error condition}\\n   *   source = request.tree()\\n   *   session = {JingleSession instance}\\n   * }\\n   */\\n  JINGLE_ERROR: 'xmpp.jingle_error',\\n\\n  // Event fired when we have failed to set initial offer\\n  JINGLE_FATAL_ERROR: 'xmpp.jingle_fatal_error',\\n\\n  // Designates an event indicating that we were kicked from the XMPP MUC.\\n  KICKED: 'xmpp.kicked',\\n\\n  // Designates an event indicating that our role in the XMPP MUC has changed.\\n  LOCAL_ROLE_CHANGED: 'xmpp.localrole_changed',\\n\\n  // Designates an event indicating that an XMPP message in the MUC was\\n  // received.\\n  MESSAGE_RECEIVED: 'xmpp.message_received',\\n\\n  // Designates an event indicating that the XMPP MUC was destroyed.\\n  MUC_DESTROYED: 'xmpp.muc_destroyed',\\n\\n  // Designates an event indicating that we have joined the XMPP MUC.\\n  MUC_JOINED: 'xmpp.muc_joined',\\n\\n  // Designates an event indicating that a participant joined the XMPP MUC.\\n  MUC_MEMBER_JOINED: 'xmpp.muc_member_joined',\\n\\n  // Designates an event indicating that a participant left the XMPP MUC.\\n  MUC_MEMBER_LEFT: 'xmpp.muc_member_left',\\n\\n  // Designates an event indicating that local participant left the muc\\n  MUC_LEFT: 'xmpp.muc_left',\\n\\n  // Designates an event indicating that the MUC role of a participant has\\n  // changed.\\n  MUC_ROLE_CHANGED: 'xmpp.muc_role_changed',\\n\\n  // Designates an event indicating that the MUC has been locked or unlocked.\\n  MUC_LOCK_CHANGED: 'xmpp.muc_lock_changed',\\n\\n  // Designates an event indicating that a participant in the XMPP MUC has\\n  // advertised that they have audio muted (or unmuted).\\n  PARTICIPANT_AUDIO_MUTED: 'xmpp.audio_muted',\\n\\n  // Designates an event indicating that a participant in the XMPP MUC has\\n  // advertised that they have video muted (or unmuted).\\n  PARTICIPANT_VIDEO_MUTED: 'xmpp.video_muted',\\n\\n  // Designates an event indicating that the video type (e.g. 'camera' or\\n  // 'screen') for a participant has changed.\\n  // Note: currently this event fires every time we receive presence from\\n  // someone (regardless of whether or not the \\\"video type\\\" changed).\\n  PARTICIPANT_VIDEO_TYPE_CHANGED: 'xmpp.video_type',\\n\\n  /**\\n   * Indicates that the features of the participant has been changed.\\n   */\\n  PARTCIPANT_FEATURES_CHANGED: 'xmpp.partcipant_features_changed',\\n  PASSWORD_REQUIRED: 'xmpp.password_required',\\n  PEERCONNECTION_READY: 'xmpp.peerconnection_ready',\\n\\n  /**\\n   * Indicates that phone number changed.\\n   */\\n  PHONE_NUMBER_CHANGED: 'conference.phoneNumberChanged',\\n  PRESENCE_STATUS: 'xmpp.presence_status',\\n  PROMPT_FOR_LOGIN: 'xmpp.prompt_for_login',\\n\\n  // xmpp is connected and obtained user media\\n  READY_TO_JOIN: 'xmpp.ready_to_join',\\n\\n  /**\\n   * Indicates that recording state changed.\\n   */\\n  RECORDER_STATE_CHANGED: 'xmpp.recorderStateChanged',\\n\\n  // Designates an event indicating that we received statistics from a\\n  // participant in the MUC.\\n  REMOTE_STATS: 'xmpp.remote_stats',\\n  RESERVATION_ERROR: 'xmpp.room_reservation_error',\\n  ROOM_CONNECT_ERROR: 'xmpp.room_connect_error',\\n  ROOM_CONNECT_NOT_ALLOWED_ERROR: 'xmpp.room_connect_error.not_allowed',\\n  ROOM_JOIN_ERROR: 'xmpp.room_join_error',\\n\\n  /**\\n   * Indicates that max users limit has been reached.\\n   */\\n  ROOM_MAX_USERS_ERROR: 'xmpp.room_max_users_error',\\n\\n  // Designates an event indicating that we sent an XMPP message to the MUC.\\n  SENDING_CHAT_MESSAGE: 'xmpp.sending_chat_message',\\n\\n  /**\\n   * Event fired when we do not get our 'session-accept' acknowledged by\\n   * Jicofo. It most likely means that there is serious problem with our\\n   * connection or XMPP server and we should reload the conference.\\n   *\\n   * We have seen that to happen in BOSH requests race condition when the BOSH\\n   * request table containing the 'session-accept' was discarded by Prosody.\\n   * Jicofo does send the RESULT immediately without any condition, so missing\\n   * packets means that most likely it has never seen our IQ.\\n   */\\n  SESSION_ACCEPT_TIMEOUT: 'xmpp.session_accept_timeout',\\n\\n  // Designates an event indicating that we should join the conference with\\n  // audio and/or video muted.\\n  START_MUTED_FROM_FOCUS: 'xmpp.start_muted_from_focus',\\n\\n  // Designates an event indicating that the subject of the XMPP MUC has\\n  // changed.\\n  SUBJECT_CHANGED: 'xmpp.subject_changed',\\n\\n  // FIXME: how does it belong to XMPP ? - it's detected by the PeerConnection\\n  // suspending detected\\n  SUSPEND_DETECTED: 'xmpp.suspend_detected',\\n\\n  /**\\n   * Notifies for transcription status changes. The event provides the\\n   * following parameters to its listeners:\\n   *\\n   * @param {String} status - The new status.\\n   */\\n  TRANSCRIPTION_STATUS_CHANGED: 'xmpp.transcription_status_changed',\\n\\n  /**\\n   * Event fired when 'transport-info' with new ICE candidates is received.\\n   */\\n  TRANSPORT_INFO: 'xmpp.transportinfo.jingle',\\n\\n  /**\\n   * Indicates that video SIP GW state changed.\\n   *\\n   * @param {VideoSIPGWConstants} status - Any of the following statuses:\\n   * STATUS_BUSY, STATUS_AVAILABLE or STATUS_UNDEFINED.\\n   */\\n  VIDEO_SIP_GW_AVAILABILITY_CHANGED: 'xmpp.videoSIPGWAvailabilityChanged',\\n\\n  /**\\n   * Indicates that video SIP GW Session state changed.\\n   * The statuses are any of the following statuses:\\n   * STATE_ON, STATE_OFF, STATE_PENDING, STATE_RETRYING, STATE_FAILED.\\n   * {@see VideoSIPGWConstants}\\n   *\\n   * @param {options} event - {address, oldState, newState, displayName}.\\n   */\\n  VIDEO_SIP_GW_SESSION_STATE_CHANGED: 'xmpp.videoSIPGWSessionStateChanged',\\n\\n  // Designates an event indicating that the local ICE connection state has\\n  // changed.\\n  ICE_CONNECTION_STATE_CHANGED: 'xmpp.ice_connection_state_changed',\\n\\n  /**\\n   * Event which is emitted when the body in an XMPP message in the MUC\\n   * contains JSON\\n   */\\n  JSON_MESSAGE_RECEIVED: 'xmmp.json_message_received'\\n};\\n\\nmodule.exports = XMPPEvents;\\n\\n/***/ }),\\n/* 9 */\\n/***/ (function(module, exports) {\\n\\nvar RTCEvents = {\\n  /**\\n   * Indicates error while create answer call.\\n   */\\n  CREATE_ANSWER_FAILED: 'rtc.create_answer_failed',\\n\\n  /**\\n   * Indicates error while create offer call.\\n   */\\n  CREATE_OFFER_FAILED: 'rtc.create_offer_failed',\\n  RTC_READY: 'rtc.ready',\\n  DATA_CHANNEL_OPEN: 'rtc.data_channel_open',\\n  ENDPOINT_CONN_STATUS_CHANGED: 'rtc.endpoint_conn_status_changed',\\n  DOMINANT_SPEAKER_CHANGED: 'rtc.dominant_speaker_changed',\\n  LASTN_ENDPOINT_CHANGED: 'rtc.lastn_endpoint_changed',\\n\\n  /**\\n   * Event emitted when {@link RTC.setLastN} method is called to update with\\n   * the new value set.\\n   * The first argument is the value passed to {@link RTC.setLastN}.\\n   */\\n  LASTN_VALUE_CHANGED: 'rtc.lastn_value_changed',\\n\\n  /**\\n   * Event emitted when ssrc for a local track is extracted and stored\\n   * in {@link TraceablePeerConnection}.\\n   * @param {JitsiLocalTrack} track which ssrc was updated\\n   * @param {string} ssrc that was stored\\n   */\\n  LOCAL_TRACK_SSRC_UPDATED: 'rtc.local_track_ssrc_updated',\\n\\n  AVAILABLE_DEVICES_CHANGED: 'rtc.available_devices_changed',\\n  TRACK_ATTACHED: 'rtc.track_attached',\\n\\n  /**\\n   * Event fired when we remote track is added to the conference.\\n   * 1st event argument is the added <tt>JitsiRemoteTrack</tt> instance.\\n   **/\\n  REMOTE_TRACK_ADDED: 'rtc.remote_track_added',\\n\\n  // FIXME get rid of this event in favour of NO_DATA_FROM_SOURCE event\\n  // (currently implemented for local tracks only)\\n  REMOTE_TRACK_MUTE: 'rtc.remote_track_mute',\\n\\n  /**\\n   * Indicates that the remote track has been removed from the conference.\\n   * 1st event argument is the removed {@link JitsiRemoteTrack} instance.\\n   */\\n  REMOTE_TRACK_REMOVED: 'rtc.remote_track_removed',\\n\\n  // FIXME get rid of this event in favour of NO_DATA_FROM_SOURCE event\\n  // (currently implemented for local tracks only)\\n  REMOTE_TRACK_UNMUTE: 'rtc.remote_track_unmute',\\n\\n  /**\\n   * Indicates error while set local description.\\n   */\\n  SET_LOCAL_DESCRIPTION_FAILED: 'rtc.set_local_description_failed',\\n\\n  /**\\n   * Indicates error while set remote description.\\n   */\\n  SET_REMOTE_DESCRIPTION_FAILED: 'rtc.set_remote_description_failed',\\n  AUDIO_OUTPUT_DEVICE_CHANGED: 'rtc.audio_output_device_changed',\\n  DEVICE_LIST_CHANGED: 'rtc.device_list_changed',\\n  DEVICE_LIST_AVAILABLE: 'rtc.device_list_available',\\n\\n  /**\\n   * Indicates that a message from another participant is received on\\n   * data channel.\\n   */\\n  ENDPOINT_MESSAGE_RECEIVED: 'rtc.endpoint_message_received',\\n\\n  /**\\n   * Designates an event indicating that the local ICE username fragment of\\n   * the jingle session has changed.\\n   * The first argument of the vent is <tt>TraceablePeerConnection</tt> which\\n   * is the source of the event.\\n   * The second argument is the actual \\\"ufrag\\\" string.\\n   */\\n  LOCAL_UFRAG_CHANGED: 'rtc.local_ufrag_changed',\\n\\n  /**\\n   * Designates an event indicating that the local ICE username fragment of\\n   * the jingle session has changed.\\n   * The first argument of the vent is <tt>TraceablePeerConnection</tt> which\\n   * is the source of the event.\\n   * The second argument is the actual \\\"ufrag\\\" string.\\n   */\\n  REMOTE_UFRAG_CHANGED: 'rtc.remote_ufrag_changed'\\n};\\n\\nmodule.exports = RTCEvents;\\n\\n/***/ }),\\n/* 10 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events__ = __webpack_require__(16);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_events__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n/**\\n * The class implements basic event operations - add/remove listener.\\n * NOTE: The purpose of the class is to be extended in order to add\\n * this functionality to other classes.\\n */\\n\\nvar Listenable = function () {\\n  /**\\n   * Creates new instance.\\n   * @param {EventEmitter} eventEmitter\\n   * @constructor\\n   */\\n  function Listenable() {\\n    var eventEmitter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new __WEBPACK_IMPORTED_MODULE_0_events___default.a();\\n\\n    _classCallCheck(this, Listenable);\\n\\n    this.eventEmitter = eventEmitter;\\n\\n    // aliases for addListener/removeListener\\n    this.addEventListener = this.on = this.addListener;\\n    this.removeEventListener = this.off = this.removeListener;\\n  }\\n\\n  /**\\n   * Adds new listener.\\n   * @param {String} eventName the name of the event\\n   * @param {Function} listener the listener.\\n   */\\n\\n\\n  _createClass(Listenable, [{\\n    key: 'addListener',\\n    value: function addListener(eventName, listener) {\\n      this.eventEmitter.addListener(eventName, listener);\\n    }\\n\\n    /**\\n     * Removes listener.\\n     * @param {String} eventName the name of the event that triggers the\\n     * listener\\n     * @param {Function} listener the listener.\\n     */\\n\\n  }, {\\n    key: 'removeListener',\\n    value: function removeListener(eventName, listener) {\\n      this.eventEmitter.removeListener(eventName, listener);\\n    }\\n  }]);\\n\\n  return Listenable;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (Listenable);\\n\\n/***/ }),\\n/* 11 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n\\nvar logDisabled_ = true;\\nvar deprecationWarnings_ = true;\\n\\n// Utility methods.\\nvar utils = {\\n  disableLog: function(bool) {\\n    if (typeof bool !== 'boolean') {\\n      return new Error('Argument type: ' + typeof bool +\\n          '. Please use a boolean.');\\n    }\\n    logDisabled_ = bool;\\n    return (bool) ? 'adapter.js logging disabled' :\\n        'adapter.js logging enabled';\\n  },\\n\\n  /**\\n   * Disable or enable deprecation warnings\\n   * @param {!boolean} bool set to true to disable warnings.\\n   */\\n  disableWarnings: function(bool) {\\n    if (typeof bool !== 'boolean') {\\n      return new Error('Argument type: ' + typeof bool +\\n          '. Please use a boolean.');\\n    }\\n    deprecationWarnings_ = !bool;\\n    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\\n  },\\n\\n  log: function() {\\n    if (typeof window === 'object') {\\n      if (logDisabled_) {\\n        return;\\n      }\\n      if (typeof console !== 'undefined' && typeof console.log === 'function') {\\n        console.log.apply(console, arguments);\\n      }\\n    }\\n  },\\n\\n  /**\\n   * Shows a deprecation warning suggesting the modern and spec-compatible API.\\n   */\\n  deprecated: function(oldMethod, newMethod) {\\n    if (!deprecationWarnings_) {\\n      return;\\n    }\\n    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\\n        ' instead.');\\n  },\\n\\n  /**\\n   * Extract browser version out of the provided user agent string.\\n   *\\n   * @param {!string} uastring userAgent string.\\n   * @param {!string} expr Regular expression used as match criteria.\\n   * @param {!number} pos position in the version string to be returned.\\n   * @return {!number} browser version.\\n   */\\n  extractVersion: function(uastring, expr, pos) {\\n    var match = uastring.match(expr);\\n    return match && match.length >= pos && parseInt(match[pos], 10);\\n  },\\n\\n  /**\\n   * Browser detector.\\n   *\\n   * @return {object} result containing browser and version\\n   *     properties.\\n   */\\n  detectBrowser: function(window) {\\n    var navigator = window && window.navigator;\\n\\n    // Returned result object.\\n    var result = {};\\n    result.browser = null;\\n    result.version = null;\\n\\n    // Fail early if it's not a browser\\n    if (typeof window === 'undefined' || !window.navigator) {\\n      result.browser = 'Not a browser.';\\n      return result;\\n    }\\n\\n    // Firefox.\\n    if (navigator.mozGetUserMedia) {\\n      result.browser = 'firefox';\\n      result.version = this.extractVersion(navigator.userAgent,\\n          /Firefox\\\\/(\\\\d+)\\\\./, 1);\\n    } else if (navigator.webkitGetUserMedia) {\\n      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now\\n      if (window.webkitRTCPeerConnection) {\\n        result.browser = 'chrome';\\n        result.version = this.extractVersion(navigator.userAgent,\\n          /Chrom(e|ium)\\\\/(\\\\d+)\\\\./, 2);\\n      } else { // Safari (in an unpublished version) or unknown webkit-based.\\n        if (navigator.userAgent.match(/Version\\\\/(\\\\d+).(\\\\d+)/)) {\\n          result.browser = 'safari';\\n          result.version = this.extractVersion(navigator.userAgent,\\n            /AppleWebKit\\\\/(\\\\d+)\\\\./, 1);\\n        } else { // unknown webkit-based browser.\\n          result.browser = 'Unsupported webkit-based browser ' +\\n              'with GUM support but no WebRTC support.';\\n          return result;\\n        }\\n      }\\n    } else if (navigator.mediaDevices &&\\n        navigator.userAgent.match(/Edge\\\\/(\\\\d+).(\\\\d+)$/)) { // Edge.\\n      result.browser = 'edge';\\n      result.version = this.extractVersion(navigator.userAgent,\\n          /Edge\\\\/(\\\\d+).(\\\\d+)$/, 2);\\n    } else if (navigator.mediaDevices &&\\n        navigator.userAgent.match(/AppleWebKit\\\\/(\\\\d+)\\\\./)) {\\n        // Safari, with webkitGetUserMedia removed.\\n      result.browser = 'safari';\\n      result.version = this.extractVersion(navigator.userAgent,\\n          /AppleWebKit\\\\/(\\\\d+)\\\\./, 1);\\n    } else { // Default fallthrough: not supported.\\n      result.browser = 'Not a supported browser.';\\n      return result;\\n    }\\n\\n    return result;\\n  },\\n\\n};\\n\\n// Export.\\nmodule.exports = {\\n  log: utils.log,\\n  deprecated: utils.deprecated,\\n  disableLog: utils.disableLog,\\n  disableWarnings: utils.disableWarnings,\\n  extractVersion: utils.extractVersion,\\n  shimCreateObjectURL: utils.shimCreateObjectURL,\\n  detectBrowser: utils.detectBrowser.bind(utils)\\n};\\n\\n\\n/***/ }),\\n/* 12 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__ = __webpack_require__(17);\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\n\\n\\nvar TRACK_ERROR_TO_MESSAGE_MAP = {};\\n\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"UNSUPPORTED_RESOLUTION\\\"]] = 'Video resolution is not supported: ';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"FIREFOX_EXTENSION_NEEDED\\\"]] = 'Firefox extension is not installed';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"CHROME_EXTENSION_INSTALLATION_ERROR\\\"]] = 'Failed to install Chrome extension';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"CHROME_EXTENSION_USER_GESTURE_REQUIRED\\\"]] = 'Failed to install Chrome extension - installations can only be initiated' + ' by a user gesture.';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"CHROME_EXTENSION_USER_CANCELED\\\"]] = 'User canceled Chrome\\\\'s screen sharing prompt';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"CHROME_EXTENSION_GENERIC_ERROR\\\"]] = 'Unknown error from Chrome extension';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"ELECTRON_DESKTOP_PICKER_ERROR\\\"]] = 'Unkown error from desktop picker';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"ELECTRON_DESKTOP_PICKER_NOT_FOUND\\\"]] = 'Failed to detect desktop picker';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"GENERAL\\\"]] = 'Generic getUserMedia error';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"PERMISSION_DENIED\\\"]] = 'User denied permission to use device(s): ';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"NOT_FOUND\\\"]] = 'Requested device(s) was/were not found: ';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"CONSTRAINT_FAILED\\\"]] = 'Constraint could not be satisfied: ';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"TRACK_IS_DISPOSED\\\"]] = 'Track has been already disposed';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"TRACK_NO_STREAM_FOUND\\\"]] = 'Track does not have an associated Media Stream';\\nTRACK_ERROR_TO_MESSAGE_MAP[__WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"NO_DATA_FROM_SOURCE\\\"]] = 'The track has stopped receiving data from it\\\\'s source';\\n\\n// FIXME: Using prototype inheritance because otherwise instanceof is not\\n// working properly (see https://github.com/babel/babel/issues/3083)\\n\\n/**\\n *\\n * Represents an error that occurred to a JitsiTrack. Can represent various\\n * types of errors. For error descriptions (@see JitsiTrackErrors).\\n *\\n * @extends Error\\n *\\n *\\n * @constructor\\n * @param {Object|string} error - error object or error name\\n * @param {Object|string} (options) - getUserMedia constraints object or\\n * error message\\n * @param {('audio'|'video'|'desktop'|'screen'|'audiooutput')[]} (devices) -\\n * list of getUserMedia requested devices\\n */\\nfunction JitsiTrackError(error, options, devices) {\\n    if ((typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object' && typeof error.name !== 'undefined') {\\n        /**\\n         * Additional information about original getUserMedia error\\n         * and constraints.\\n         * @type {{\\n         *     error: Object,\\n         *     constraints: Object,\\n         *     devices: Array.<'audio'|'video'|'desktop'|'screen'>\\n         * }}\\n         */\\n        this.gum = {\\n            error: error,\\n            constraints: options,\\n            devices: devices && Array.isArray(devices) ? devices.slice(0) : undefined\\n        };\\n\\n        switch (error.name) {\\n            case 'NotAllowedError':\\n            case 'PermissionDeniedError':\\n            case 'SecurityError':\\n                this.name = __WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"PERMISSION_DENIED\\\"];\\n                this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + (this.gum.devices || []).join(', ');\\n                break;\\n            case 'DevicesNotFoundError':\\n            case 'NotFoundError':\\n                this.name = __WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"NOT_FOUND\\\"];\\n                this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + (this.gum.devices || []).join(', ');\\n                break;\\n            case 'ConstraintNotSatisfiedError':\\n            case 'OverconstrainedError':\\n                {\\n                    var constraintName = error.constraintName || error.constraint;\\n\\n                    if (options && options.video && (!devices || devices.indexOf('video') > -1) && (constraintName === 'minWidth' || constraintName === 'maxWidth' || constraintName === 'minHeight' || constraintName === 'maxHeight' || constraintName === 'width' || constraintName === 'height')) {\\n                        this.name = __WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"UNSUPPORTED_RESOLUTION\\\"];\\n                        this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + getResolutionFromFailedConstraint(constraintName, options);\\n                    } else {\\n                        this.name = __WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"CONSTRAINT_FAILED\\\"];\\n                        this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + error.constraintName;\\n                    }\\n                    break;\\n                }\\n\\n            default:\\n                this.name = __WEBPACK_IMPORTED_MODULE_0__JitsiTrackErrors__[\\\"GENERAL\\\"];\\n                this.message = error.message || TRACK_ERROR_TO_MESSAGE_MAP[this.name];\\n                break;\\n        }\\n    } else if (typeof error === 'string') {\\n        if (TRACK_ERROR_TO_MESSAGE_MAP[error]) {\\n            this.name = error;\\n            this.message = options || TRACK_ERROR_TO_MESSAGE_MAP[error];\\n        } else {\\n            // this is some generic error that do not fit any of our\\n            // pre-defined errors, so don't give it any specific name, just\\n            // store message\\n            this.message = error;\\n        }\\n    } else {\\n        throw new Error('Invalid arguments');\\n    }\\n\\n    this.stack = error.stack || new Error().stack;\\n}\\n\\nJitsiTrackError.prototype = Object.create(Error.prototype);\\nJitsiTrackError.prototype.constructor = JitsiTrackError;\\n\\n/**\\n * Gets failed resolution constraint from corresponding object.\\n * @param {string} failedConstraintName\\n * @param {Object} constraints\\n * @returns {string|number}\\n */\\nfunction getResolutionFromFailedConstraint(failedConstraintName, constraints) {\\n    if (constraints && constraints.video && constraints.video.mandatory) {\\n        switch (failedConstraintName) {\\n            case 'width':\\n                return constraints.video.mandatory.minWidth;\\n            case 'height':\\n                return constraints.video.mandatory.minHeight;\\n            default:\\n                return constraints.video.mandatory[failedConstraintName] || '';\\n        }\\n    }\\n\\n    return '';\\n}\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (JitsiTrackError);\\n\\n/***/ }),\\n/* 13 */\\n/***/ (function(module, exports) {\\n\\n/* global module */\\n/**\\n * Enumeration of the video types\\n * @type {{CAMERA: string, DESKTOP: string}}\\n */\\nvar VideoType = {\\n  /**\\n   * The camera video type.\\n   */\\n  CAMERA: 'camera',\\n\\n  /**\\n   * The desktop video type.\\n   */\\n  DESKTOP: 'desktop'\\n};\\n\\nmodule.exports = VideoType;\\n\\n/***/ }),\\n/* 14 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_RandomUtil__ = __webpack_require__(20);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_RandomUtil___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__util_RandomUtil__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__RTC_RTCBrowserType__ = __webpack_require__(1);\\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n\\n\\n\\nvar SDPUtil = {\\n    filterSpecialChars: function filterSpecialChars(text) {\\n        // XXX Neither one of the falsy values (e.g. null, undefined, false,\\n        // \\\"\\\", etc.) \\\"contain\\\" special chars.\\n        // eslint-disable-next-line no-useless-escape\\n        return text ? text.replace(/[\\\\\\\\\\\\/\\\\{,\\\\}\\\\+]/g, '') : text;\\n    },\\n    iceparams: function iceparams(mediadesc, sessiondesc) {\\n        var data = null;\\n        var pwd = void 0,\\n            ufrag = void 0;\\n\\n        if ((ufrag = SDPUtil.findLine(mediadesc, 'a=ice-ufrag:', sessiondesc)) && (pwd = SDPUtil.findLine(mediadesc, 'a=ice-pwd:', sessiondesc))) {\\n            data = {\\n                ufrag: SDPUtil.parseICEUfrag(ufrag),\\n                pwd: SDPUtil.parseICEPwd(pwd)\\n            };\\n        }\\n\\n        return data;\\n    },\\n    parseICEUfrag: function parseICEUfrag(line) {\\n        return line.substring(12);\\n    },\\n    buildICEUfrag: function buildICEUfrag(frag) {\\n        return 'a=ice-ufrag:' + frag;\\n    },\\n    parseICEPwd: function parseICEPwd(line) {\\n        return line.substring(10);\\n    },\\n    buildICEPwd: function buildICEPwd(pwd) {\\n        return 'a=ice-pwd:' + pwd;\\n    },\\n    parseMID: function parseMID(line) {\\n        return line.substring(6);\\n    },\\n    parseMLine: function parseMLine(line) {\\n        var data = {};\\n        var parts = line.substring(2).split(' ');\\n\\n        data.media = parts.shift();\\n        data.port = parts.shift();\\n        data.proto = parts.shift();\\n        if (parts[parts.length - 1] === '') {\\n            // trailing whitespace\\n            parts.pop();\\n        }\\n        data.fmt = parts;\\n\\n        return data;\\n    },\\n    buildMLine: function buildMLine(mline) {\\n        return 'm=' + mline.media + ' ' + mline.port + ' ' + mline.proto + ' ' + mline.fmt.join(' ');\\n    },\\n    parseRTPMap: function parseRTPMap(line) {\\n        var data = {};\\n        var parts = line.substring(9).split(' ');\\n\\n        data.id = parts.shift();\\n        parts = parts[0].split('/');\\n        data.name = parts.shift();\\n        data.clockrate = parts.shift();\\n        data.channels = parts.length ? parts.shift() : '1';\\n\\n        return data;\\n    },\\n\\n\\n    /**\\n     * Parses SDP line \\\"a=sctpmap:...\\\" and extracts SCTP port from it.\\n     * @param line eg. \\\"a=sctpmap:5000 webrtc-datachannel\\\"\\n     * @returns [SCTP port number, protocol, streams]\\n     */\\n    parseSCTPMap: function parseSCTPMap(line) {\\n        var parts = line.substring(10).split(' ');\\n        var sctpPort = parts[0];\\n        var protocol = parts[1];\\n\\n        // Stream count is optional\\n        var streamCount = parts.length > 2 ? parts[2] : null;\\n\\n        return [sctpPort, protocol, streamCount]; // SCTP port\\n    },\\n    buildRTPMap: function buildRTPMap(el) {\\n        var line = 'a=rtpmap:' + el.getAttribute('id') + ' ' + el.getAttribute('name') + '/' + el.getAttribute('clockrate');\\n\\n        if (el.getAttribute('channels') && el.getAttribute('channels') !== '1') {\\n            line += '/' + el.getAttribute('channels');\\n        }\\n\\n        return line;\\n    },\\n    parseCrypto: function parseCrypto(line) {\\n        var data = {};\\n        var parts = line.substring(9).split(' ');\\n\\n        data.tag = parts.shift();\\n        data['crypto-suite'] = parts.shift();\\n        data['key-params'] = parts.shift();\\n        if (parts.length) {\\n            data['session-params'] = parts.join(' ');\\n        }\\n\\n        return data;\\n    },\\n    parseFingerprint: function parseFingerprint(line) {\\n        // RFC 4572\\n        var data = {};\\n        var parts = line.substring(14).split(' ');\\n\\n        data.hash = parts.shift();\\n        data.fingerprint = parts.shift();\\n\\n        // TODO assert that fingerprint satisfies 2UHEX *(\\\":\\\" 2UHEX) ?\\n        return data;\\n    },\\n    parseFmtp: function parseFmtp(line) {\\n        var data = [];\\n        var parts = line.split(' ');\\n\\n        parts.shift();\\n        parts = parts.join(' ').split(';');\\n        for (var i = 0; i < parts.length; i++) {\\n            var key = parts[i].split('=')[0];\\n\\n            while (key.length && key[0] === ' ') {\\n                key = key.substring(1);\\n            }\\n            var value = parts[i].split('=')[1];\\n\\n            if (key && value) {\\n                data.push({ name: key,\\n                    value: value });\\n            } else if (key) {\\n                // rfc 4733 (DTMF) style stuff\\n                data.push({ name: '',\\n                    value: key });\\n            }\\n        }\\n\\n        return data;\\n    },\\n    parseICECandidate: function parseICECandidate(line) {\\n        var candidate = {};\\n        var elems = line.split(' ');\\n\\n        candidate.foundation = elems[0].substring(12);\\n        candidate.component = elems[1];\\n        candidate.protocol = elems[2].toLowerCase();\\n        candidate.priority = elems[3];\\n        candidate.ip = elems[4];\\n        candidate.port = elems[5];\\n\\n        // elems[6] => \\\"typ\\\"\\n        candidate.type = elems[7];\\n        candidate.generation = 0; // default value, may be overwritten below\\n        for (var i = 8; i < elems.length; i += 2) {\\n            switch (elems[i]) {\\n                case 'raddr':\\n                    candidate['rel-addr'] = elems[i + 1];\\n                    break;\\n                case 'rport':\\n                    candidate['rel-port'] = elems[i + 1];\\n                    break;\\n                case 'generation':\\n                    candidate.generation = elems[i + 1];\\n                    break;\\n                case 'tcptype':\\n                    candidate.tcptype = elems[i + 1];\\n                    break;\\n                default:\\n                    // TODO\\n                    logger.log('parseICECandidate not translating \\\"' + elems[i] + '\\\" = \\\"' + elems[i + 1] + '\\\"');\\n            }\\n        }\\n        candidate.network = '1';\\n\\n        // not applicable to SDP -- FIXME: should be unique, not just random\\n        // eslint-disable-next-line newline-per-chained-call\\n        candidate.id = Math.random().toString(36).substr(2, 10);\\n\\n        return candidate;\\n    },\\n    buildICECandidate: function buildICECandidate(cand) {\\n        var line = ['a=candidate:' + cand.foundation, cand.component, cand.protocol, cand.priority, cand.ip, cand.port, 'typ', cand.type].join(' ');\\n\\n        line += ' ';\\n        switch (cand.type) {\\n            case 'srflx':\\n            case 'prflx':\\n            case 'relay':\\n                if (cand.hasOwnAttribute('rel-addr') && cand.hasOwnAttribute('rel-port')) {\\n                    line += 'raddr';\\n                    line += ' ';\\n                    line += cand['rel-addr'];\\n                    line += ' ';\\n                    line += 'rport';\\n                    line += ' ';\\n                    line += cand['rel-port'];\\n                    line += ' ';\\n                }\\n                break;\\n        }\\n        if (cand.hasOwnAttribute('tcptype')) {\\n            line += 'tcptype';\\n            line += ' ';\\n            line += cand.tcptype;\\n            line += ' ';\\n        }\\n        line += 'generation';\\n        line += ' ';\\n        line += cand.hasOwnAttribute('generation') ? cand.generation : '0';\\n\\n        return line;\\n    },\\n    parseSSRC: function parseSSRC(desc) {\\n        // proprietary mapping of a=ssrc lines\\n        // TODO: see \\\"Jingle RTP Source Description\\\" by Juberti and P. Thatcher\\n        // on google docs and parse according to that\\n        var data = new Map();\\n        var lines = desc.split('\\\\r\\\\n');\\n\\n        for (var i = 0; i < lines.length; i++) {\\n            if (lines[i].substring(0, 7) === 'a=ssrc:') {\\n                // FIXME: Use regex to smartly find the ssrc.\\n                var ssrc = lines[i].split('a=ssrc:')[1].split(' ')[0];\\n\\n                if (!data.get(ssrc)) {\\n                    data.set(ssrc, []);\\n                }\\n\\n                data.get(ssrc).push(lines[i]);\\n            }\\n        }\\n\\n        return data;\\n    },\\n    parseRTCPFB: function parseRTCPFB(line) {\\n        var parts = line.substr(10).split(' ');\\n        var data = {};\\n\\n        data.pt = parts.shift();\\n        data.type = parts.shift();\\n        data.params = parts;\\n\\n        return data;\\n    },\\n    parseExtmap: function parseExtmap(line) {\\n        var parts = line.substr(9).split(' ');\\n        var data = {};\\n\\n        data.value = parts.shift();\\n        if (data.value.indexOf('/') === -1) {\\n            data.direction = 'both';\\n        } else {\\n            data.direction = data.value.substr(data.value.indexOf('/') + 1);\\n            data.value = data.value.substr(0, data.value.indexOf('/'));\\n        }\\n        data.uri = parts.shift();\\n        data.params = parts;\\n\\n        return data;\\n    },\\n    findLine: function findLine(haystack, needle, sessionpart) {\\n        var lines = haystack.split('\\\\r\\\\n');\\n\\n        for (var i = 0; i < lines.length; i++) {\\n            if (lines[i].substring(0, needle.length) === needle) {\\n                return lines[i];\\n            }\\n        }\\n        if (!sessionpart) {\\n            return false;\\n        }\\n\\n        // search session part\\n        lines = sessionpart.split('\\\\r\\\\n');\\n        for (var j = 0; j < lines.length; j++) {\\n            if (lines[j].substring(0, needle.length) === needle) {\\n                return lines[j];\\n            }\\n        }\\n\\n        return false;\\n    },\\n    findLines: function findLines(haystack, needle, sessionpart) {\\n        var lines = haystack.split('\\\\r\\\\n');\\n        var needles = [];\\n\\n        for (var i = 0; i < lines.length; i++) {\\n            if (lines[i].substring(0, needle.length) === needle) {\\n                needles.push(lines[i]);\\n            }\\n        }\\n        if (needles.length || !sessionpart) {\\n            return needles;\\n        }\\n\\n        // search session part\\n        lines = sessionpart.split('\\\\r\\\\n');\\n        for (var j = 0; j < lines.length; j++) {\\n            if (lines[j].substring(0, needle.length) === needle) {\\n                needles.push(lines[j]);\\n            }\\n        }\\n\\n        return needles;\\n    },\\n    candidateToJingle: function candidateToJingle(line) {\\n        // a=candidate:2979166662 1 udp 2113937151 192.168.2.100 57698 typ host\\n        // generation 0\\n        //      <candidate component=... foundation=... generation=... id=...\\n        // ip=... network=... port=... priority=... protocol=... type=.../>\\n        if (line.indexOf('candidate:') === 0) {\\n            // eslint-disable-next-line no-param-reassign\\n            line = 'a=' + line;\\n        } else if (line.substring(0, 12) !== 'a=candidate:') {\\n            logger.log('parseCandidate called with a line that is not a candidate' + ' line');\\n            logger.log(line);\\n\\n            return null;\\n        }\\n        if (line.substring(line.length - 2) === '\\\\r\\\\n') {\\n            // chomp it\\n            // eslint-disable-next-line no-param-reassign\\n            line = line.substring(0, line.length - 2);\\n        }\\n        var candidate = {};\\n        var elems = line.split(' ');\\n\\n        if (elems[6] !== 'typ') {\\n            logger.log('did not find typ in the right place');\\n            logger.log(line);\\n\\n            return null;\\n        }\\n        candidate.foundation = elems[0].substring(12);\\n        candidate.component = elems[1];\\n        candidate.protocol = elems[2].toLowerCase();\\n        candidate.priority = elems[3];\\n        candidate.ip = elems[4];\\n        candidate.port = elems[5];\\n\\n        // elems[6] => \\\"typ\\\"\\n        candidate.type = elems[7];\\n\\n        candidate.generation = '0'; // default, may be overwritten below\\n        for (var i = 8; i < elems.length; i += 2) {\\n            switch (elems[i]) {\\n                case 'raddr':\\n                    candidate['rel-addr'] = elems[i + 1];\\n                    break;\\n                case 'rport':\\n                    candidate['rel-port'] = elems[i + 1];\\n                    break;\\n                case 'generation':\\n                    candidate.generation = elems[i + 1];\\n                    break;\\n                case 'tcptype':\\n                    candidate.tcptype = elems[i + 1];\\n                    break;\\n                default:\\n                    // TODO\\n                    logger.log('not translating \\\"' + elems[i] + '\\\" = \\\"' + elems[i + 1] + '\\\"');\\n            }\\n        }\\n        candidate.network = '1';\\n\\n        // not applicable to SDP -- FIXME: should be unique, not just random\\n        // eslint-disable-next-line newline-per-chained-call\\n        candidate.id = Math.random().toString(36).substr(2, 10);\\n\\n        return candidate;\\n    },\\n    candidateFromJingle: function candidateFromJingle(cand) {\\n        var line = 'a=candidate:';\\n\\n        line += cand.getAttribute('foundation');\\n        line += ' ';\\n        line += cand.getAttribute('component');\\n        line += ' ';\\n\\n        var protocol = cand.getAttribute('protocol');\\n\\n        // use tcp candidates for FF\\n\\n        if (__WEBPACK_IMPORTED_MODULE_2__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isFirefox() && protocol.toLowerCase() === 'ssltcp') {\\n            protocol = 'tcp';\\n        }\\n\\n        line += protocol; // .toUpperCase(); // chrome M23 doesn't like this\\n        line += ' ';\\n        line += cand.getAttribute('priority');\\n        line += ' ';\\n        line += cand.getAttribute('ip');\\n        line += ' ';\\n        line += cand.getAttribute('port');\\n        line += ' ';\\n        line += 'typ';\\n        line += ' ' + cand.getAttribute('type');\\n        line += ' ';\\n        switch (cand.getAttribute('type')) {\\n            case 'srflx':\\n            case 'prflx':\\n            case 'relay':\\n                if (cand.getAttribute('rel-addr') && cand.getAttribute('rel-port')) {\\n                    line += 'raddr';\\n                    line += ' ';\\n                    line += cand.getAttribute('rel-addr');\\n                    line += ' ';\\n                    line += 'rport';\\n                    line += ' ';\\n                    line += cand.getAttribute('rel-port');\\n                    line += ' ';\\n                }\\n                break;\\n        }\\n        if (protocol.toLowerCase() === 'tcp') {\\n            line += 'tcptype';\\n            line += ' ';\\n            line += cand.getAttribute('tcptype');\\n            line += ' ';\\n        }\\n        line += 'generation';\\n        line += ' ';\\n        line += cand.getAttribute('generation') || '0';\\n\\n        return line + '\\\\r\\\\n';\\n    },\\n\\n\\n    /**\\n     * Parse the 'most' primary video ssrc from the given m line\\n     * @param {object} mLine object as parsed from transform.parse\\n     * @return {number} the primary video ssrc from the given m line\\n     */\\n    parsePrimaryVideoSsrc: function parsePrimaryVideoSsrc(videoMLine) {\\n        var numSsrcs = videoMLine.ssrcs.map(function (ssrcInfo) {\\n            return ssrcInfo.id;\\n        }).filter(function (ssrc, index, array) {\\n            return array.indexOf(ssrc) === index;\\n        }).length;\\n        var numGroups = videoMLine.ssrcGroups && videoMLine.ssrcGroups.length || 0;\\n\\n        if (numSsrcs > 1 && numGroups === 0) {\\n            // Ambiguous, can't figure out the primary\\n            return;\\n        }\\n        var primarySsrc = null;\\n\\n        if (numSsrcs === 1) {\\n            primarySsrc = videoMLine.ssrcs[0].id;\\n        } else if (numSsrcs === 2) {\\n            // Can figure it out if there's an FID group\\n            var fidGroup = videoMLine.ssrcGroups.find(function (group) {\\n                return group.semantics === 'FID';\\n            });\\n\\n            if (fidGroup) {\\n                primarySsrc = fidGroup.ssrcs.split(' ')[0];\\n            }\\n        } else if (numSsrcs >= 3) {\\n            // Can figure it out if there's a sim group\\n            var simGroup = videoMLine.ssrcGroups.find(function (group) {\\n                return group.semantics === 'SIM';\\n            });\\n\\n            if (simGroup) {\\n                primarySsrc = simGroup.ssrcs.split(' ')[0];\\n            }\\n        }\\n\\n        return primarySsrc;\\n    },\\n\\n\\n    /**\\n     * Generate an ssrc\\n     * @returns {number} an ssrc\\n     */\\n    generateSsrc: function generateSsrc() {\\n        return __WEBPACK_IMPORTED_MODULE_1__util_RandomUtil___default.a.randomInt(1, 0xffffffff);\\n    },\\n\\n\\n    /**\\n     * Get an attribute for the given ssrc with the given attributeName\\n     *  from the given mline\\n     * @param {object} mLine an mLine object as parsed from transform.parse\\n     * @param {number} ssrc the ssrc for which an attribtue is desired\\n     * @param {string} attributeName the name of the desired attribute\\n     * @returns {string} the value corresponding to the given ssrc\\n     *  and attributeName\\n     */\\n    getSsrcAttribute: function getSsrcAttribute(mLine, ssrc, attributeName) {\\n        for (var i = 0; i < mLine.ssrcs.length; ++i) {\\n            var ssrcLine = mLine.ssrcs[i];\\n\\n            if (ssrcLine.id === ssrc && ssrcLine.attribute === attributeName) {\\n                return ssrcLine.value;\\n            }\\n        }\\n    },\\n\\n\\n    /**\\n     * Parses the ssrcs from the group sdp line and\\n     *  returns them as a list of numbers\\n     * @param {object} the ssrcGroup object as parsed from\\n     *  sdp-transform\\n     * @returns {list<number>} a list of the ssrcs in the group\\n     *  parsed as numbers\\n     */\\n    parseGroupSsrcs: function parseGroupSsrcs(ssrcGroup) {\\n        return ssrcGroup.ssrcs.split(' ').map(function (ssrcStr) {\\n            return parseInt(ssrcStr, 10);\\n        });\\n    },\\n\\n\\n    /**\\n     * Get the mline of the given type from the given sdp\\n     * @param {object} sdp sdp as parsed from transform.parse\\n     * @param {string} type the type of the desired mline (e.g. \\\"video\\\")\\n     * @returns {object} a media object\\n     */\\n    getMedia: function getMedia(sdp, type) {\\n        return sdp.media.find(function (m) {\\n            return m.type === type;\\n        });\\n    },\\n\\n\\n    /**\\n     * Extracts the ICE username fragment from an SDP string.\\n     * @param {string} sdp the SDP in raw text format\\n     */\\n    getUfrag: function getUfrag(sdp) {\\n        var ufragLines = sdp.split('\\\\n').filter(function (line) {\\n            return line.startsWith('a=ice-ufrag:');\\n        });\\n\\n        if (ufragLines.length > 0) {\\n            return ufragLines[0].substr('a=ice-ufrag:'.length);\\n        }\\n    },\\n\\n\\n    /**\\n     * Sets the given codecName as the preferred codec by\\n     *  moving it to the beginning of the payload types\\n     *  list (modifies the given mline in place).  If there\\n     *  are multiple options within the same codec (multiple h264\\n     *  profiles, for instance), this will prefer the first one\\n     *  that is found.\\n     * @param {object} videoMLine the video mline object from\\n     *  an sdp as parsed by transform.parse\\n     * @param {string} codecName the name of the preferred codec\\n     */\\n    preferVideoCodec: function preferVideoCodec(videoMLine, codecName) {\\n        var payloadType = null;\\n\\n        if (!videoMLine || !codecName) {\\n            return;\\n        }\\n\\n        for (var i = 0; i < videoMLine.rtp.length; ++i) {\\n            var rtp = videoMLine.rtp[i];\\n\\n            if (rtp.codec && rtp.codec.toLowerCase() === codecName.toLowerCase()) {\\n                payloadType = rtp.payload;\\n                break;\\n            }\\n        }\\n        if (payloadType) {\\n            // Call toString() on payloads to get around an issue within\\n            // SDPTransform that sets payloads as a number, instead of a string,\\n            // when there is only one payload.\\n            var payloadTypes = videoMLine.payloads.toString().split(' ').map(function (p) {\\n                return parseInt(p, 10);\\n            });\\n            var payloadIndex = payloadTypes.indexOf(payloadType);\\n\\n            payloadTypes.splice(payloadIndex, 1);\\n            payloadTypes.unshift(payloadType);\\n            videoMLine.payloads = payloadTypes.join(' ');\\n        }\\n    },\\n\\n\\n    /**\\n     * Strips the given codec from the given mline. All related RTX payload\\n     * types are also stripped. If the resulting mline would have no codecs,\\n     * it's disabled.\\n     *\\n     * @param {object} videoMLine the video mline object from an sdp as parsed\\n     * by transform.parse.\\n     * @param {string} codecName the name of the codec which will be stripped.\\n     */\\n    stripVideoCodec: function stripVideoCodec(videoMLine, codecName) {\\n        if (!videoMLine || !codecName) {\\n            return;\\n        }\\n\\n        var removePts = [];\\n\\n        var _iteratorNormalCompletion = true;\\n        var _didIteratorError = false;\\n        var _iteratorError = undefined;\\n\\n        try {\\n            for (var _iterator = videoMLine.rtp[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                var rtp = _step.value;\\n\\n                if (rtp.codec && rtp.codec.toLowerCase() === codecName.toLowerCase()) {\\n                    removePts.push(rtp.payload);\\n                }\\n            }\\n        } catch (err) {\\n            _didIteratorError = true;\\n            _iteratorError = err;\\n        } finally {\\n            try {\\n                if (!_iteratorNormalCompletion && _iterator.return) {\\n                    _iterator.return();\\n                }\\n            } finally {\\n                if (_didIteratorError) {\\n                    throw _iteratorError;\\n                }\\n            }\\n        }\\n\\n        if (removePts.length > 0) {\\n            // We also need to remove the payload types that are related to RTX\\n            // for the codecs we want to disable.\\n            var rtxApts = removePts.map(function (item) {\\n                return 'apt=' + item;\\n            });\\n            var rtxPts = videoMLine.fmtp.filter(function (item) {\\n                return rtxApts.indexOf(item.config) !== -1;\\n            });\\n\\n            removePts.push.apply(removePts, _toConsumableArray(rtxPts.map(function (item) {\\n                return item.payload;\\n            })));\\n\\n            // Call toString() on payloads to get around an issue within\\n            // SDPTransform that sets payloads as a number, instead of a string,\\n            // when there is only one payload.\\n            var allPts = videoMLine.payloads.toString().split(' ').map(Number);\\n            var keepPts = allPts.filter(function (pt) {\\n                return removePts.indexOf(pt) === -1;\\n            });\\n\\n            if (keepPts.length === 0) {\\n                // There are no other video codecs, disable the stream.\\n                videoMLine.port = 0;\\n                videoMLine.direction = 'inactive';\\n                videoMLine.payloads = '*';\\n            } else {\\n                videoMLine.payloads = keepPts.join(' ');\\n            }\\n\\n            videoMLine.rtp = videoMLine.rtp.filter(function (item) {\\n                return keepPts.indexOf(item.payload) !== -1;\\n            });\\n            videoMLine.fmtp = videoMLine.fmtp.filter(function (item) {\\n                return keepPts.indexOf(item.payload) !== -1;\\n            });\\n            if (videoMLine.rtcpFb) {\\n                videoMLine.rtcpFb = videoMLine.rtcpFb.filter(function (item) {\\n                    return keepPts.indexOf(item.payload) !== -1;\\n                });\\n            }\\n        }\\n    }\\n};\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (SDPUtil);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/SDPUtil.js\\\"))\\n\\n/***/ }),\\n/* 15 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar parser = __webpack_require__(126);\\nvar writer = __webpack_require__(127);\\n\\nexports.write = writer;\\nexports.parse = parser.parse;\\nexports.parseFmtpConfig = parser.parseFmtpConfig;\\nexports.parseParams = parser.parseParams;\\nexports.parsePayloads = parser.parsePayloads;\\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\\nexports.parseImageAttributes = parser.parseImageAttributes;\\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\\n\\n\\n/***/ }),\\n/* 16 */\\n/***/ (function(module, exports) {\\n\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nfunction EventEmitter() {\\n  this._events = this._events || {};\\n  this._maxListeners = this._maxListeners || undefined;\\n}\\nmodule.exports = EventEmitter;\\n\\n// Backwards-compat with node 0.10.x\\nEventEmitter.EventEmitter = EventEmitter;\\n\\nEventEmitter.prototype._events = undefined;\\nEventEmitter.prototype._maxListeners = undefined;\\n\\n// By default EventEmitters will print a warning if more than 10 listeners are\\n// added to it. This is a useful default which helps finding memory leaks.\\nEventEmitter.defaultMaxListeners = 10;\\n\\n// Obviously not all Emitters should be limited to 10. This function allows\\n// that to be increased. Set to zero for unlimited.\\nEventEmitter.prototype.setMaxListeners = function(n) {\\n  if (!isNumber(n) || n < 0 || isNaN(n))\\n    throw TypeError('n must be a positive number');\\n  this._maxListeners = n;\\n  return this;\\n};\\n\\nEventEmitter.prototype.emit = function(type) {\\n  var er, handler, len, args, i, listeners;\\n\\n  if (!this._events)\\n    this._events = {};\\n\\n  // If there is no 'error' event listener then throw.\\n  if (type === 'error') {\\n    if (!this._events.error ||\\n        (isObject(this._events.error) && !this._events.error.length)) {\\n      er = arguments[1];\\n      if (er instanceof Error) {\\n        throw er; // Unhandled 'error' event\\n      } else {\\n        // At least give some kind of context to the user\\n        var err = new Error('Uncaught, unspecified \\\"error\\\" event. (' + er + ')');\\n        err.context = er;\\n        throw err;\\n      }\\n    }\\n  }\\n\\n  handler = this._events[type];\\n\\n  if (isUndefined(handler))\\n    return false;\\n\\n  if (isFunction(handler)) {\\n    switch (arguments.length) {\\n      // fast cases\\n      case 1:\\n        handler.call(this);\\n        break;\\n      case 2:\\n        handler.call(this, arguments[1]);\\n        break;\\n      case 3:\\n        handler.call(this, arguments[1], arguments[2]);\\n        break;\\n      // slower\\n      default:\\n        args = Array.prototype.slice.call(arguments, 1);\\n        handler.apply(this, args);\\n    }\\n  } else if (isObject(handler)) {\\n    args = Array.prototype.slice.call(arguments, 1);\\n    listeners = handler.slice();\\n    len = listeners.length;\\n    for (i = 0; i < len; i++)\\n      listeners[i].apply(this, args);\\n  }\\n\\n  return true;\\n};\\n\\nEventEmitter.prototype.addListener = function(type, listener) {\\n  var m;\\n\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  if (!this._events)\\n    this._events = {};\\n\\n  // To avoid recursion in the case that type === \\\"newListener\\\"! Before\\n  // adding it to the listeners, first emit \\\"newListener\\\".\\n  if (this._events.newListener)\\n    this.emit('newListener', type,\\n              isFunction(listener.listener) ?\\n              listener.listener : listener);\\n\\n  if (!this._events[type])\\n    // Optimize the case of one listener. Don't need the extra array object.\\n    this._events[type] = listener;\\n  else if (isObject(this._events[type]))\\n    // If we've already got an array, just append.\\n    this._events[type].push(listener);\\n  else\\n    // Adding the second element, need to change to array.\\n    this._events[type] = [this._events[type], listener];\\n\\n  // Check for listener leak\\n  if (isObject(this._events[type]) && !this._events[type].warned) {\\n    if (!isUndefined(this._maxListeners)) {\\n      m = this._maxListeners;\\n    } else {\\n      m = EventEmitter.defaultMaxListeners;\\n    }\\n\\n    if (m && m > 0 && this._events[type].length > m) {\\n      this._events[type].warned = true;\\n      console.error('(node) warning: possible EventEmitter memory ' +\\n                    'leak detected. %d listeners added. ' +\\n                    'Use emitter.setMaxListeners() to increase limit.',\\n                    this._events[type].length);\\n      if (typeof console.trace === 'function') {\\n        // not supported in IE 10\\n        console.trace();\\n      }\\n    }\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\\n\\nEventEmitter.prototype.once = function(type, listener) {\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  var fired = false;\\n\\n  function g() {\\n    this.removeListener(type, g);\\n\\n    if (!fired) {\\n      fired = true;\\n      listener.apply(this, arguments);\\n    }\\n  }\\n\\n  g.listener = listener;\\n  this.on(type, g);\\n\\n  return this;\\n};\\n\\n// emits a 'removeListener' event iff the listener was removed\\nEventEmitter.prototype.removeListener = function(type, listener) {\\n  var list, position, length, i;\\n\\n  if (!isFunction(listener))\\n    throw TypeError('listener must be a function');\\n\\n  if (!this._events || !this._events[type])\\n    return this;\\n\\n  list = this._events[type];\\n  length = list.length;\\n  position = -1;\\n\\n  if (list === listener ||\\n      (isFunction(list.listener) && list.listener === listener)) {\\n    delete this._events[type];\\n    if (this._events.removeListener)\\n      this.emit('removeListener', type, listener);\\n\\n  } else if (isObject(list)) {\\n    for (i = length; i-- > 0;) {\\n      if (list[i] === listener ||\\n          (list[i].listener && list[i].listener === listener)) {\\n        position = i;\\n        break;\\n      }\\n    }\\n\\n    if (position < 0)\\n      return this;\\n\\n    if (list.length === 1) {\\n      list.length = 0;\\n      delete this._events[type];\\n    } else {\\n      list.splice(position, 1);\\n    }\\n\\n    if (this._events.removeListener)\\n      this.emit('removeListener', type, listener);\\n  }\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.removeAllListeners = function(type) {\\n  var key, listeners;\\n\\n  if (!this._events)\\n    return this;\\n\\n  // not listening for removeListener, no need to emit\\n  if (!this._events.removeListener) {\\n    if (arguments.length === 0)\\n      this._events = {};\\n    else if (this._events[type])\\n      delete this._events[type];\\n    return this;\\n  }\\n\\n  // emit removeListener for all listeners on all events\\n  if (arguments.length === 0) {\\n    for (key in this._events) {\\n      if (key === 'removeListener') continue;\\n      this.removeAllListeners(key);\\n    }\\n    this.removeAllListeners('removeListener');\\n    this._events = {};\\n    return this;\\n  }\\n\\n  listeners = this._events[type];\\n\\n  if (isFunction(listeners)) {\\n    this.removeListener(type, listeners);\\n  } else if (listeners) {\\n    // LIFO order\\n    while (listeners.length)\\n      this.removeListener(type, listeners[listeners.length - 1]);\\n  }\\n  delete this._events[type];\\n\\n  return this;\\n};\\n\\nEventEmitter.prototype.listeners = function(type) {\\n  var ret;\\n  if (!this._events || !this._events[type])\\n    ret = [];\\n  else if (isFunction(this._events[type]))\\n    ret = [this._events[type]];\\n  else\\n    ret = this._events[type].slice();\\n  return ret;\\n};\\n\\nEventEmitter.prototype.listenerCount = function(type) {\\n  if (this._events) {\\n    var evlistener = this._events[type];\\n\\n    if (isFunction(evlistener))\\n      return 1;\\n    else if (evlistener)\\n      return evlistener.length;\\n  }\\n  return 0;\\n};\\n\\nEventEmitter.listenerCount = function(emitter, type) {\\n  return emitter.listenerCount(type);\\n};\\n\\nfunction isFunction(arg) {\\n  return typeof arg === 'function';\\n}\\n\\nfunction isNumber(arg) {\\n  return typeof arg === 'number';\\n}\\n\\nfunction isObject(arg) {\\n  return typeof arg === 'object' && arg !== null;\\n}\\n\\nfunction isUndefined(arg) {\\n  return arg === void 0;\\n}\\n\\n\\n/***/ }),\\n/* 17 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CHROME_EXTENSION_GENERIC_ERROR\\\", function() { return CHROME_EXTENSION_GENERIC_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CHROME_EXTENSION_INSTALLATION_ERROR\\\", function() { return CHROME_EXTENSION_INSTALLATION_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CHROME_EXTENSION_USER_GESTURE_REQUIRED\\\", function() { return CHROME_EXTENSION_USER_GESTURE_REQUIRED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CHROME_EXTENSION_USER_CANCELED\\\", function() { return CHROME_EXTENSION_USER_CANCELED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONSTRAINT_FAILED\\\", function() { return CONSTRAINT_FAILED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ELECTRON_DESKTOP_PICKER_ERROR\\\", function() { return ELECTRON_DESKTOP_PICKER_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ELECTRON_DESKTOP_PICKER_NOT_FOUND\\\", function() { return ELECTRON_DESKTOP_PICKER_NOT_FOUND; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FIREFOX_EXTENSION_NEEDED\\\", function() { return FIREFOX_EXTENSION_NEEDED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"GENERAL\\\", function() { return GENERAL; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NOT_FOUND\\\", function() { return NOT_FOUND; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PERMISSION_DENIED\\\", function() { return PERMISSION_DENIED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRACK_IS_DISPOSED\\\", function() { return TRACK_IS_DISPOSED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRACK_NO_STREAM_FOUND\\\", function() { return TRACK_NO_STREAM_FOUND; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"UNSUPPORTED_RESOLUTION\\\", function() { return UNSUPPORTED_RESOLUTION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NO_DATA_FROM_SOURCE\\\", function() { return NO_DATA_FROM_SOURCE; });\\n/**\\n * The errors for the JitsiTrack objects.\\n */\\n\\n/**\\n * Generic error for jidesha extension for Chrome.\\n */\\nvar CHROME_EXTENSION_GENERIC_ERROR = 'gum.chrome_extension_generic_error';\\n\\n/**\\n * An error which indicates that the jidesha extension for Chrome is\\n * failed to install.\\n */\\nvar CHROME_EXTENSION_INSTALLATION_ERROR = 'gum.chrome_extension_installation_error';\\n\\n/**\\n * This error indicates that the attempt to start screensharing was initiated by\\n * a script which did not originate in user gesture handler. It means that\\n * you should to trigger the action again in response to a button click for\\n * example.\\n * @type {string}\\n */\\nvar CHROME_EXTENSION_USER_GESTURE_REQUIRED = 'gum.chrome_extension_user_gesture_required';\\n\\n/**\\n * An error which indicates that user canceled screen sharing window\\n * selection dialog in jidesha extension for Chrome.\\n */\\nvar CHROME_EXTENSION_USER_CANCELED = 'gum.chrome_extension_user_canceled';\\n\\n/**\\n * An error which indicates that some of requested constraints in\\n * getUserMedia call were not satisfied.\\n */\\nvar CONSTRAINT_FAILED = 'gum.constraint_failed';\\n\\n/**\\n * A generic error which indicates an error occurred while selecting\\n * a DesktopCapturerSource from the electron app.\\n */\\nvar ELECTRON_DESKTOP_PICKER_ERROR = 'gum.electron_desktop_picker_error';\\n\\n/**\\n * An error which indicates a custom desktop picker could not be detected\\n * for the electron app.\\n */\\nvar ELECTRON_DESKTOP_PICKER_NOT_FOUND = 'gum.electron_desktop_picker_not_found';\\n\\n/**\\n * An error which indicates that the jidesha extension for Firefox is\\n * needed to proceed with screen sharing, and that it is not installed.\\n */\\nvar FIREFOX_EXTENSION_NEEDED = 'gum.firefox_extension_needed';\\n\\n/**\\n * Generic getUserMedia error.\\n */\\nvar GENERAL = 'gum.general';\\n\\n/**\\n * An error which indicates that requested device was not found.\\n */\\nvar NOT_FOUND = 'gum.not_found';\\n\\n/**\\n * An error which indicates that user denied permission to share requested\\n * device.\\n */\\nvar PERMISSION_DENIED = 'gum.permission_denied';\\n\\n/**\\n * An error which indicates that track has been already disposed and cannot\\n * be longer used.\\n */\\nvar TRACK_IS_DISPOSED = 'track.track_is_disposed';\\n\\n/**\\n * An error which indicates that track has no MediaStream associated.\\n */\\nvar TRACK_NO_STREAM_FOUND = 'track.no_stream_found';\\n\\n/**\\n * An error which indicates that requested video resolution is not supported\\n * by a webcam.\\n */\\nvar UNSUPPORTED_RESOLUTION = 'gum.unsupported_resolution';\\n\\n/**\\n * Indicates that the track is no receiving any data without reason(the\\n * stream was stopped, etc)\\n */\\nvar NO_DATA_FROM_SOURCE = 'track.no_data_from_source';\\n\\n/***/ }),\\n/* 18 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LOCAL_TRACK_STOPPED\\\", function() { return LOCAL_TRACK_STOPPED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRACK_AUDIO_LEVEL_CHANGED\\\", function() { return TRACK_AUDIO_LEVEL_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRACK_AUDIO_OUTPUT_CHANGED\\\", function() { return TRACK_AUDIO_OUTPUT_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRACK_MUTE_CHANGED\\\", function() { return TRACK_MUTE_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRACK_VIDEOTYPE_CHANGED\\\", function() { return TRACK_VIDEOTYPE_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NO_DATA_FROM_SOURCE\\\", function() { return NO_DATA_FROM_SOURCE; });\\n/**\\n * The media track was removed to the conference.\\n */\\nvar LOCAL_TRACK_STOPPED = 'track.stopped';\\n\\n/**\\n * Audio levels of a this track was changed.\\n * The first argument is a number with audio level value in range [0, 1].\\n * The second argument is a <tt>TraceablePeerConnection</tt> which is the peer\\n * connection which measured the audio level (one audio track can be added\\n * to multiple peer connection at the same time). This argument is optional for\\n * local tracks for which we can measure audio level without the peer\\n * connection (the value will be <tt>undefined</tt>).\\n *\\n * NOTE The second argument should be treated as library internal and can be\\n * removed at any time.\\n */\\nvar TRACK_AUDIO_LEVEL_CHANGED = 'track.audioLevelsChanged';\\n\\n/**\\n * The audio output of the track was changed.\\n */\\nvar TRACK_AUDIO_OUTPUT_CHANGED = 'track.audioOutputChanged';\\n\\n/**\\n * A media track mute status was changed.\\n */\\nvar TRACK_MUTE_CHANGED = 'track.trackMuteChanged';\\n\\n/**\\n * The video type(\\\"camera\\\" or \\\"desktop\\\") of the track was changed.\\n */\\nvar TRACK_VIDEOTYPE_CHANGED = 'track.videoTypeChanged';\\n\\n/**\\n * Indicates that the track is no receiving any data without reason(the\\n * stream was stopped, etc)\\n */\\nvar NO_DATA_FROM_SOURCE = 'track.no_data_from_source';\\n\\n/***/ }),\\n/* 19 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_UsernameGenerator__ = __webpack_require__(68);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_UsernameGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__util_UsernameGenerator__);\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n\\n\\nvar _callStatsUserName = void 0;\\n\\nvar _machineId = void 0;\\n\\n/**\\n *\\n */\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = ({\\n    /**\\n     * Returns fake username for callstats\\n     * @returns {string} fake username for callstats\\n     */\\n    get callStatsUserName() {\\n        if (!_callStatsUserName) {\\n            var localStorage = getLocalStorage();\\n\\n            if (localStorage) {\\n                _callStatsUserName = localStorage.getItem('callStatsUserName');\\n            }\\n            if (!_callStatsUserName) {\\n                _callStatsUserName = generateCallStatsUserName();\\n                if (localStorage) {\\n                    localStorage.setItem('callStatsUserName', _callStatsUserName);\\n                }\\n            }\\n        }\\n\\n        return _callStatsUserName;\\n    },\\n\\n    /**\\n     * Returns current machine id.\\n     * @returns {string} machine id\\n     */\\n    get machineId() {\\n        if (!_machineId) {\\n            var localStorage = getLocalStorage();\\n\\n            if (localStorage) {\\n                _machineId = localStorage.getItem('jitsiMeetId');\\n            }\\n            if (!_machineId) {\\n                _machineId = generateJitsiMeetId();\\n                if (localStorage) {\\n                    localStorage.setItem('jitsiMeetId', _machineId);\\n                }\\n            }\\n        }\\n\\n        return _machineId;\\n    },\\n\\n    /**\\n     * Returns current session id.\\n     * @returns {string} current session id\\n     */\\n    get sessionId() {\\n        // We may update sessionId in localStorage from another JitsiConference\\n        // instance and that's why we should always re-read it.\\n        var localStorage = getLocalStorage();\\n\\n        return localStorage ? localStorage.getItem('sessionId') : undefined;\\n    },\\n\\n    /**\\n     * Save current session id.\\n     * @param {string} sessionId session id\\n     */\\n    set sessionId(sessionId) {\\n        var localStorage = getLocalStorage();\\n\\n        if (localStorage) {\\n            if (sessionId) {\\n                localStorage.setItem('sessionId', sessionId);\\n            } else {\\n                localStorage.removeItem('sessionId');\\n            }\\n        }\\n    }\\n});\\n\\n/**\\n * Generate fake username for callstats.\\n * @returns {string} fake random username\\n */\\nfunction generateCallStatsUserName() {\\n    var username = __WEBPACK_IMPORTED_MODULE_1__util_UsernameGenerator___default.a.generateUsername();\\n\\n    logger.log('generated callstats uid', username);\\n\\n    return username;\\n}\\n\\n/**\\n * Generate unique id.\\n * @returns {string} random unique id\\n */\\nfunction generateJitsiMeetId() {\\n    var jitsiMeetId = generateUniqueId();\\n\\n    logger.log('generated id', jitsiMeetId);\\n\\n    return jitsiMeetId;\\n}\\n\\n/**\\n * Gets the localStorage of the browser. (Technically, gets the localStorage of\\n * the global object because there may be no browser but React Native for\\n * example).\\n * @returns {Storage} the local Storage object (if any)\\n */\\nfunction getLocalStorage() {\\n    var storage = void 0;\\n\\n    try {\\n        // eslint-disable-next-line no-invalid-this\\n        storage = (window || this).localStorage;\\n    } catch (error) {\\n        logger.error(error);\\n    }\\n\\n    return storage;\\n}\\n\\n/**\\n *\\n */\\nfunction generateUniqueId() {\\n    return _p8() + _p8() + _p8() + _p8();\\n}\\n\\n/**\\n *\\n */\\nfunction _p8() {\\n    return (Math.random().toString(16) + '000000000').substr(2, 8);\\n}\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/settings/Settings.js\\\"))\\n\\n/***/ }),\\n/* 20 */\\n/***/ (function(module, exports) {\\n\\n/**\\n * @const\\n */\\nvar ALPHANUM = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\\n\\n/**\\n * Hexadecimal digits.\\n * @const\\n */\\nvar HEX_DIGITS = '0123456789abcdef';\\n\\n/**\\n * Generates random int within the range [min, max]\\n * @param min the minimum value for the generated number\\n * @param max the maximum value for the generated number\\n * @returns random int number\\n */\\nfunction randomInt(min, max) {\\n    return Math.floor(Math.random() * (max - min + 1)) + min;\\n}\\n\\n/**\\n * Get random element from array or string.\\n * @param {Array|string} arr source\\n * @returns array element or string character\\n */\\nfunction randomElement(arr) {\\n    return arr[randomInt(0, arr.length - 1)];\\n}\\n\\n/**\\n * Generate random alphanumeric string.\\n * @param {number} length expected string length\\n * @returns {string} random string of specified length\\n */\\nfunction randomAlphanumStr(length) {\\n    var result = '';\\n\\n    for (var i = 0; i < length; i += 1) {\\n        result += randomElement(ALPHANUM);\\n    }\\n\\n    return result;\\n}\\n\\n/**\\n * Exported interface.\\n */\\nvar RandomUtil = {\\n    /**\\n     * Returns a random hex digit.\\n     * @returns {*}\\n     */\\n    randomHexDigit: function randomHexDigit() {\\n        return randomElement(HEX_DIGITS);\\n    },\\n\\n\\n    /**\\n     * Returns a random string of hex digits with length 'len'.\\n     * @param len the length.\\n     */\\n    randomHexString: function randomHexString(len) {\\n        var ret = '';\\n\\n        while (len--) {\\n            // eslint-disable-line no-param-reassign\\n            ret += this.randomHexDigit();\\n        }\\n\\n        return ret;\\n    },\\n\\n    randomElement: randomElement,\\n    randomAlphanumStr: randomAlphanumStr,\\n    randomInt: randomInt\\n};\\n\\nmodule.exports = RandomUtil;\\n\\n/***/ }),\\n/* 21 */\\n/***/ (function(module, exports) {\\n\\nvar g;\\r\\n\\r\\n// This works in non-strict mode\\r\\ng = (function() {\\r\\n\\treturn this;\\r\\n})();\\r\\n\\r\\ntry {\\r\\n\\t// This works if eval is allowed (see CSP)\\r\\n\\tg = g || Function(\\\"return this\\\")() || (1,eval)(\\\"this\\\");\\r\\n} catch(e) {\\r\\n\\t// This works if the window reference is available\\r\\n\\tif(typeof window === \\\"object\\\")\\r\\n\\t\\tg = window;\\r\\n}\\r\\n\\r\\n// g can still be undefined, but nothing to do about it...\\r\\n// We return undefined, instead of nothing here, so it's\\r\\n// easier to handle this case. if(!global) { ...}\\r\\n\\r\\nmodule.exports = g;\\r\\n\\n\\n/***/ }),\\n/* 22 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction getCurrent(){return window&&window.performance&&window.performance.now&&window.performance.timing&&window.performance.timing.navigationStart?window.performance.now()+window.performance.timing.navigationStart:Date.now()}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.getCurrent=getCurrent;\\n\\n/***/ }),\\n/* 23 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return ConnectionPluginListenable; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_Listenable__ = __webpack_require__(10);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n/**\\n * Creates ConnectionPlugin class that extends the passed class.\\n * @param {Class} base the definition of the class that will be extended by\\n * ConnectionPlugin\\n */\\nfunction getConnectionPluginDefinition() {\\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\\n    function _class() {\\n      _classCallCheck(this, _class);\\n    }\\n\\n    return _class;\\n  }();\\n\\n  /**\\n   * Base class for strophe connection plugins.\\n   */\\n  return function (_base) {\\n    _inherits(_class2, _base);\\n\\n    /**\\n     *\\n     */\\n    function _class2() {\\n      var _ref;\\n\\n      _classCallCheck(this, _class2);\\n\\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n        args[_key] = arguments[_key];\\n      }\\n\\n      var _this = _possibleConstructorReturn(this, (_ref = _class2.__proto__ || Object.getPrototypeOf(_class2)).call.apply(_ref, [this].concat(args)));\\n\\n      _this.connection = null;\\n      return _this;\\n    }\\n\\n    /**\\n     *\\n     * @param connection\\n     */\\n\\n\\n    _createClass(_class2, [{\\n      key: 'init',\\n      value: function init(connection) {\\n        this.connection = connection;\\n      }\\n    }]);\\n\\n    return _class2;\\n  }(base);\\n}\\n\\n/**\\n * ConnectionPlugin class.\\n */\\n/* harmony default export */ __webpack_exports__[\\\"b\\\"] = (getConnectionPluginDefinition());\\n\\n/**\\n * ConnectionPlugin class that extends Listenable.\\n */\\nvar ConnectionPluginListenable = getConnectionPluginDefinition(__WEBPACK_IMPORTED_MODULE_0__util_Listenable__[\\\"a\\\" /* default */]);\\n\\n/***/ }),\\n/* 24 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction detect(){var s=Constants.browserName.chrome,e=null,o=null,n=null,i=Constants.codeBaseType.chrome;if(window&&(!window.navigator||!window.navigator.userAgent||window.csioReactNative))return window&&window.csioGetOsName&&(e=window.csioGetOsName()),window&&window.csioGetOsVer&&(o=window.csioGetOsVer()),window&&window.csioReactNative&&(n=\\\"react-native\\\"),{browserName:s,codeBase:i,os:e,osVersion:o,userAgent:n};var r=(n=navigator.userAgent).toLowerCase(),t=navigator.appVersion,a=\\\"\\\"+parseFloat(navigator.appVersion),d=void 0;-1!==(d=r.indexOf(\\\"opera\\\"))?(s=Constants.browserName.opera,a=r.substring(d+6),-1!==(d=r.indexOf(\\\"Version\\\"))&&(a=r.substring(d+8)),i=Constants.codeBaseType.chrome):-1!==(d=r.indexOf(\\\"opr\\\"))?(s=Constants.browserName.opera,a=r.substring(d+4),-1!==(d=r.indexOf(\\\"Version\\\"))&&(a=r.substring(d+8)),i=Constants.codeBaseType.chrome):-1!==(d=r.indexOf(\\\"msie\\\"))?(s=Constants.browserName.msie,a=r.substring(d+5),i=Constants.codeBaseType.chrome):-1!==(d=r.indexOf(\\\"edge\\\"))?(s=Constants.browserName.edge,a=r.substring(d+5),i=Constants.codeBaseType.edge):-1!==(d=r.indexOf(\\\"chrome\\\"))?(s=Constants.browserName.chrome,a=r.substring(d+7),i=Constants.codeBaseType.chrome):-1!==(d=r.indexOf(\\\"safari\\\"))?(s=Constants.browserName.safari,a=r.substring(d+7),-1!==(d=r.indexOf(\\\"Version\\\"))&&(a=r.substring(d+8)),i=Constants.codeBaseType.chrome):-1!==(d=r.indexOf(\\\"firefox\\\"))?(s=Constants.browserName.firefox,a=r.substring(d+8),i=Constants.codeBaseType.firefox):-1!==(d=r.indexOf(\\\"trident\\\"))&&(s=Constants.browserName.msie,d=r.indexOf(\\\"rv\\\"),a=r.substring(d+3,d+7),i=Constants.codeBaseType.chrome);var w=[{s:\\\"Windows 3.11\\\",r:/win16/},{s:\\\"Windows 95\\\",r:/(windows 95|win95|windows_95)/},{s:\\\"Windows ME\\\",r:/(win 9x 4.90|windows me)/},{s:\\\"Windows 98\\\",r:/(windows 98|win98)/},{s:\\\"Windows CE\\\",r:/windows ce/},{s:\\\"Windows 2000\\\",r:/(windows nt 5.0|windows 2000)/},{s:\\\"Windows XP\\\",r:/(windows nt 5.1|windows xp)/},{s:\\\"Windows Server 2003\\\",r:/windows nt 5.2/},{s:\\\"Windows Vista\\\",r:/windows nt 6.0/},{s:\\\"Windows 7\\\",r:/(windows 7|windows nt 6.1)/},{s:\\\"Windows 8.1\\\",r:/(windows 8.1|windows nt 6.3)/},{s:\\\"Windows 8\\\",r:/(windows 8|windows nt 6.2)/},{s:\\\"Windows 10\\\",r:/(windows 10|windows nt 10.0)/},{s:\\\"Windows NT 4.0\\\",r:/(windows nt 4.0|winnt4.0|winnt|windows nt)/},{s:\\\"Windows ME\\\",r:/windows me/},{s:\\\"Android\\\",r:/android/},{s:\\\"Open BSD\\\",r:/openbsd/},{s:\\\"Sun OS\\\",r:/sunos/},{s:\\\"Linux\\\",r:/(linux|x11)/},{s:\\\"iOS\\\",r:/(iphone|ipad|ipod)/},{s:\\\"Mac OS X\\\",r:/mac os x/},{s:\\\"Mac OS\\\",r:/(macppc|macintel|mac_powerpc|macintosh)/},{s:\\\"QNX\\\",r:/qnx/},{s:\\\"UNIX\\\",r:/unix/},{s:\\\"BeOS\\\",r:/beos/},{s:\\\"OS/2\\\",r:/os\\\\/2/},{s:\\\"Search Bot\\\",r:/(nuhk|googlebot|yammybot|openbot|slurp|msnbot|ask jeeves\\\\/teoma|ia_archiver)/}],c=void 0,m=void 0;for(c in w)if(w.hasOwnProperty(c)&&(m=w[c]).r.test(r)){e=m.s;break}switch(e&&/Windows/.test(e)&&(o=/Windows (.*)/.exec(e)[1],e=Constants.osName.windows),e){case Constants.osName.mac:o=/mac os x (10[\\\\.\\\\_\\\\d]+)/.exec(r)[1];break;case Constants.osName.android:o=/android ([\\\\.\\\\_\\\\d]+)/.exec(r)[1];break;case Constants.osName.ios:o=(o=/os (\\\\d+)_(\\\\d+)_?(\\\\d+)?/.exec(t))[1]+\\\".\\\"+o[2]+\\\".\\\"+(0|o[3])}return{browserName:s,browserVersion:a.toString(),os:e,osVersion:o,codeBase:i,userAgent:n}}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.detect=detect;var Constants=exports.Constants={codeBaseType:{chrome:\\\"Chrome\\\",firefox:\\\"Firefox\\\",edge:\\\"Edge\\\",plugin:\\\"Plugin\\\"},browserName:{chrome:\\\"Chrome\\\",firefox:\\\"Firefox\\\",edge:\\\"Edge\\\",msie:\\\"Microsoft Internet Explorer\\\",safari:\\\"Safari\\\"},osName:{windows:\\\"Windows\\\",mac:\\\"Mac OS X\\\",android:\\\"Android\\\",ios:\\\"iOS\\\"}};\\n\\n/***/ }),\\n/* 25 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve\\n * The MIT License (MIT)\\n * \\n * Copyright (c) 2013-2017 Petka Antonov\\n * \\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n * \\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n * \\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n * THE SOFTWARE.\\n * \\n */\\n/**\\n * bluebird build version 3.5.1\\n * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each\\n*/\\n!function(e){if(true)module.exports=e();else if(\\\"function\\\"==typeof define&&define.amd)define([],e);else{var f;\\\"undefined\\\"!=typeof window?f=window:\\\"undefined\\\"!=typeof global?f=global:\\\"undefined\\\"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_==\\\"function\\\"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_==\\\"function\\\"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise) {\\nvar SomePromiseArray = Promise._SomePromiseArray;\\nfunction any(promises) {\\n    var ret = new SomePromiseArray(promises);\\n    var promise = ret.promise();\\n    ret.setHowMany(1);\\n    ret.setUnwrap();\\n    ret.init();\\n    return promise;\\n}\\n\\nPromise.any = function (promises) {\\n    return any(promises);\\n};\\n\\nPromise.prototype.any = function () {\\n    return any(this);\\n};\\n\\n};\\n\\n},{}],2:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nvar firstLineError;\\ntry {throw new Error(); } catch (e) {firstLineError = e;}\\nvar schedule = _dereq_(\\\"./schedule\\\");\\nvar Queue = _dereq_(\\\"./queue\\\");\\nvar util = _dereq_(\\\"./util\\\");\\n\\nfunction Async() {\\n    this._customScheduler = false;\\n    this._isTickUsed = false;\\n    this._lateQueue = new Queue(16);\\n    this._normalQueue = new Queue(16);\\n    this._haveDrainedQueues = false;\\n    this._trampolineEnabled = true;\\n    var self = this;\\n    this.drainQueues = function () {\\n        self._drainQueues();\\n    };\\n    this._schedule = schedule;\\n}\\n\\nAsync.prototype.setScheduler = function(fn) {\\n    var prev = this._schedule;\\n    this._schedule = fn;\\n    this._customScheduler = true;\\n    return prev;\\n};\\n\\nAsync.prototype.hasCustomScheduler = function() {\\n    return this._customScheduler;\\n};\\n\\nAsync.prototype.enableTrampoline = function() {\\n    this._trampolineEnabled = true;\\n};\\n\\nAsync.prototype.disableTrampolineIfNecessary = function() {\\n    if (util.hasDevTools) {\\n        this._trampolineEnabled = false;\\n    }\\n};\\n\\nAsync.prototype.haveItemsQueued = function () {\\n    return this._isTickUsed || this._haveDrainedQueues;\\n};\\n\\n\\nAsync.prototype.fatalError = function(e, isNode) {\\n    if (isNode) {\\n        process.stderr.write(\\\"Fatal \\\" + (e instanceof Error ? e.stack : e) +\\n            \\\"\\\\n\\\");\\n        process.exit(2);\\n    } else {\\n        this.throwLater(e);\\n    }\\n};\\n\\nAsync.prototype.throwLater = function(fn, arg) {\\n    if (arguments.length === 1) {\\n        arg = fn;\\n        fn = function () { throw arg; };\\n    }\\n    if (typeof setTimeout !== \\\"undefined\\\") {\\n        setTimeout(function() {\\n            fn(arg);\\n        }, 0);\\n    } else try {\\n        this._schedule(function() {\\n            fn(arg);\\n        });\\n    } catch (e) {\\n        throw new Error(\\\"No async scheduler available\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    }\\n};\\n\\nfunction AsyncInvokeLater(fn, receiver, arg) {\\n    this._lateQueue.push(fn, receiver, arg);\\n    this._queueTick();\\n}\\n\\nfunction AsyncInvoke(fn, receiver, arg) {\\n    this._normalQueue.push(fn, receiver, arg);\\n    this._queueTick();\\n}\\n\\nfunction AsyncSettlePromises(promise) {\\n    this._normalQueue._pushOne(promise);\\n    this._queueTick();\\n}\\n\\nif (!util.hasDevTools) {\\n    Async.prototype.invokeLater = AsyncInvokeLater;\\n    Async.prototype.invoke = AsyncInvoke;\\n    Async.prototype.settlePromises = AsyncSettlePromises;\\n} else {\\n    Async.prototype.invokeLater = function (fn, receiver, arg) {\\n        if (this._trampolineEnabled) {\\n            AsyncInvokeLater.call(this, fn, receiver, arg);\\n        } else {\\n            this._schedule(function() {\\n                setTimeout(function() {\\n                    fn.call(receiver, arg);\\n                }, 100);\\n            });\\n        }\\n    };\\n\\n    Async.prototype.invoke = function (fn, receiver, arg) {\\n        if (this._trampolineEnabled) {\\n            AsyncInvoke.call(this, fn, receiver, arg);\\n        } else {\\n            this._schedule(function() {\\n                fn.call(receiver, arg);\\n            });\\n        }\\n    };\\n\\n    Async.prototype.settlePromises = function(promise) {\\n        if (this._trampolineEnabled) {\\n            AsyncSettlePromises.call(this, promise);\\n        } else {\\n            this._schedule(function() {\\n                promise._settlePromises();\\n            });\\n        }\\n    };\\n}\\n\\nAsync.prototype._drainQueue = function(queue) {\\n    while (queue.length() > 0) {\\n        var fn = queue.shift();\\n        if (typeof fn !== \\\"function\\\") {\\n            fn._settlePromises();\\n            continue;\\n        }\\n        var receiver = queue.shift();\\n        var arg = queue.shift();\\n        fn.call(receiver, arg);\\n    }\\n};\\n\\nAsync.prototype._drainQueues = function () {\\n    this._drainQueue(this._normalQueue);\\n    this._reset();\\n    this._haveDrainedQueues = true;\\n    this._drainQueue(this._lateQueue);\\n};\\n\\nAsync.prototype._queueTick = function () {\\n    if (!this._isTickUsed) {\\n        this._isTickUsed = true;\\n        this._schedule(this.drainQueues);\\n    }\\n};\\n\\nAsync.prototype._reset = function () {\\n    this._isTickUsed = false;\\n};\\n\\nmodule.exports = Async;\\nmodule.exports.firstLineError = firstLineError;\\n\\n},{\\\"./queue\\\":26,\\\"./schedule\\\":29,\\\"./util\\\":36}],3:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {\\nvar calledBind = false;\\nvar rejectThis = function(_, e) {\\n    this._reject(e);\\n};\\n\\nvar targetRejected = function(e, context) {\\n    context.promiseRejectionQueued = true;\\n    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\\n};\\n\\nvar bindingResolved = function(thisArg, context) {\\n    if (((this._bitField & 50397184) === 0)) {\\n        this._resolveCallback(context.target);\\n    }\\n};\\n\\nvar bindingRejected = function(e, context) {\\n    if (!context.promiseRejectionQueued) this._reject(e);\\n};\\n\\nPromise.prototype.bind = function (thisArg) {\\n    if (!calledBind) {\\n        calledBind = true;\\n        Promise.prototype._propagateFrom = debug.propagateFromFunction();\\n        Promise.prototype._boundValue = debug.boundValueFunction();\\n    }\\n    var maybePromise = tryConvertToPromise(thisArg);\\n    var ret = new Promise(INTERNAL);\\n    ret._propagateFrom(this, 1);\\n    var target = this._target();\\n    ret._setBoundTo(maybePromise);\\n    if (maybePromise instanceof Promise) {\\n        var context = {\\n            promiseRejectionQueued: false,\\n            promise: ret,\\n            target: target,\\n            bindingPromise: maybePromise\\n        };\\n        target._then(INTERNAL, targetRejected, undefined, ret, context);\\n        maybePromise._then(\\n            bindingResolved, bindingRejected, undefined, ret, context);\\n        ret._setOnCancel(maybePromise);\\n    } else {\\n        ret._resolveCallback(target);\\n    }\\n    return ret;\\n};\\n\\nPromise.prototype._setBoundTo = function (obj) {\\n    if (obj !== undefined) {\\n        this._bitField = this._bitField | 2097152;\\n        this._boundTo = obj;\\n    } else {\\n        this._bitField = this._bitField & (~2097152);\\n    }\\n};\\n\\nPromise.prototype._isBound = function () {\\n    return (this._bitField & 2097152) === 2097152;\\n};\\n\\nPromise.bind = function (thisArg, value) {\\n    return Promise.resolve(value).bind(thisArg);\\n};\\n};\\n\\n},{}],4:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nvar old;\\nif (typeof Promise !== \\\"undefined\\\") old = Promise;\\nfunction noConflict() {\\n    try { if (Promise === bluebird) Promise = old; }\\n    catch (e) {}\\n    return bluebird;\\n}\\nvar bluebird = _dereq_(\\\"./promise\\\")();\\nbluebird.noConflict = noConflict;\\nmodule.exports = bluebird;\\n\\n},{\\\"./promise\\\":22}],5:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nvar cr = Object.create;\\nif (cr) {\\n    var callerCache = cr(null);\\n    var getterCache = cr(null);\\n    callerCache[\\\" size\\\"] = getterCache[\\\" size\\\"] = 0;\\n}\\n\\nmodule.exports = function(Promise) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar canEvaluate = util.canEvaluate;\\nvar isIdentifier = util.isIdentifier;\\n\\nvar getMethodCaller;\\nvar getGetter;\\nif (false) {\\nvar makeMethodCaller = function (methodName) {\\n    return new Function(\\\"ensureMethod\\\", \\\"                                    \\\\n\\\\\\n        return function(obj) {                                               \\\\n\\\\\\n            'use strict'                                                     \\\\n\\\\\\n            var len = this.length;                                           \\\\n\\\\\\n            ensureMethod(obj, 'methodName');                                 \\\\n\\\\\\n            switch(len) {                                                    \\\\n\\\\\\n                case 1: return obj.methodName(this[0]);                      \\\\n\\\\\\n                case 2: return obj.methodName(this[0], this[1]);             \\\\n\\\\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\\\n\\\\\\n                case 0: return obj.methodName();                             \\\\n\\\\\\n                default:                                                     \\\\n\\\\\\n                    return obj.methodName.apply(obj, this);                  \\\\n\\\\\\n            }                                                                \\\\n\\\\\\n        };                                                                   \\\\n\\\\\\n        \\\".replace(/methodName/g, methodName))(ensureMethod);\\n};\\n\\nvar makeGetter = function (propertyName) {\\n    return new Function(\\\"obj\\\", \\\"                                             \\\\n\\\\\\n        'use strict';                                                        \\\\n\\\\\\n        return obj.propertyName;                                             \\\\n\\\\\\n        \\\".replace(\\\"propertyName\\\", propertyName));\\n};\\n\\nvar getCompiled = function(name, compiler, cache) {\\n    var ret = cache[name];\\n    if (typeof ret !== \\\"function\\\") {\\n        if (!isIdentifier(name)) {\\n            return null;\\n        }\\n        ret = compiler(name);\\n        cache[name] = ret;\\n        cache[\\\" size\\\"]++;\\n        if (cache[\\\" size\\\"] > 512) {\\n            var keys = Object.keys(cache);\\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\\n            cache[\\\" size\\\"] = keys.length - 256;\\n        }\\n    }\\n    return ret;\\n};\\n\\ngetMethodCaller = function(name) {\\n    return getCompiled(name, makeMethodCaller, callerCache);\\n};\\n\\ngetGetter = function(name) {\\n    return getCompiled(name, makeGetter, getterCache);\\n};\\n}\\n\\nfunction ensureMethod(obj, methodName) {\\n    var fn;\\n    if (obj != null) fn = obj[methodName];\\n    if (typeof fn !== \\\"function\\\") {\\n        var message = \\\"Object \\\" + util.classString(obj) + \\\" has no method '\\\" +\\n            util.toString(methodName) + \\\"'\\\";\\n        throw new Promise.TypeError(message);\\n    }\\n    return fn;\\n}\\n\\nfunction caller(obj) {\\n    var methodName = this.pop();\\n    var fn = ensureMethod(obj, methodName);\\n    return fn.apply(obj, this);\\n}\\nPromise.prototype.call = function (methodName) {\\n    var args = [].slice.call(arguments, 1);;\\n    if (false) {\\n        if (canEvaluate) {\\n            var maybeCaller = getMethodCaller(methodName);\\n            if (maybeCaller !== null) {\\n                return this._then(\\n                    maybeCaller, undefined, undefined, args, undefined);\\n            }\\n        }\\n    }\\n    args.push(methodName);\\n    return this._then(caller, undefined, undefined, args, undefined);\\n};\\n\\nfunction namedGetter(obj) {\\n    return obj[this];\\n}\\nfunction indexedGetter(obj) {\\n    var index = +this;\\n    if (index < 0) index = Math.max(0, index + obj.length);\\n    return obj[index];\\n}\\nPromise.prototype.get = function (propertyName) {\\n    var isIndex = (typeof propertyName === \\\"number\\\");\\n    var getter;\\n    if (!isIndex) {\\n        if (canEvaluate) {\\n            var maybeGetter = getGetter(propertyName);\\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\\n        } else {\\n            getter = namedGetter;\\n        }\\n    } else {\\n        getter = indexedGetter;\\n    }\\n    return this._then(getter, undefined, undefined, propertyName, undefined);\\n};\\n};\\n\\n},{\\\"./util\\\":36}],6:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise, PromiseArray, apiRejection, debug) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar tryCatch = util.tryCatch;\\nvar errorObj = util.errorObj;\\nvar async = Promise._async;\\n\\nPromise.prototype[\\\"break\\\"] = Promise.prototype.cancel = function() {\\n    if (!debug.cancellation()) return this._warn(\\\"cancellation is disabled\\\");\\n\\n    var promise = this;\\n    var child = promise;\\n    while (promise._isCancellable()) {\\n        if (!promise._cancelBy(child)) {\\n            if (child._isFollowing()) {\\n                child._followee().cancel();\\n            } else {\\n                child._cancelBranched();\\n            }\\n            break;\\n        }\\n\\n        var parent = promise._cancellationParent;\\n        if (parent == null || !parent._isCancellable()) {\\n            if (promise._isFollowing()) {\\n                promise._followee().cancel();\\n            } else {\\n                promise._cancelBranched();\\n            }\\n            break;\\n        } else {\\n            if (promise._isFollowing()) promise._followee().cancel();\\n            promise._setWillBeCancelled();\\n            child = promise;\\n            promise = parent;\\n        }\\n    }\\n};\\n\\nPromise.prototype._branchHasCancelled = function() {\\n    this._branchesRemainingToCancel--;\\n};\\n\\nPromise.prototype._enoughBranchesHaveCancelled = function() {\\n    return this._branchesRemainingToCancel === undefined ||\\n           this._branchesRemainingToCancel <= 0;\\n};\\n\\nPromise.prototype._cancelBy = function(canceller) {\\n    if (canceller === this) {\\n        this._branchesRemainingToCancel = 0;\\n        this._invokeOnCancel();\\n        return true;\\n    } else {\\n        this._branchHasCancelled();\\n        if (this._enoughBranchesHaveCancelled()) {\\n            this._invokeOnCancel();\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\nPromise.prototype._cancelBranched = function() {\\n    if (this._enoughBranchesHaveCancelled()) {\\n        this._cancel();\\n    }\\n};\\n\\nPromise.prototype._cancel = function() {\\n    if (!this._isCancellable()) return;\\n    this._setCancelled();\\n    async.invoke(this._cancelPromises, this, undefined);\\n};\\n\\nPromise.prototype._cancelPromises = function() {\\n    if (this._length() > 0) this._settlePromises();\\n};\\n\\nPromise.prototype._unsetOnCancel = function() {\\n    this._onCancelField = undefined;\\n};\\n\\nPromise.prototype._isCancellable = function() {\\n    return this.isPending() && !this._isCancelled();\\n};\\n\\nPromise.prototype.isCancellable = function() {\\n    return this.isPending() && !this.isCancelled();\\n};\\n\\nPromise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {\\n    if (util.isArray(onCancelCallback)) {\\n        for (var i = 0; i < onCancelCallback.length; ++i) {\\n            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);\\n        }\\n    } else if (onCancelCallback !== undefined) {\\n        if (typeof onCancelCallback === \\\"function\\\") {\\n            if (!internalOnly) {\\n                var e = tryCatch(onCancelCallback).call(this._boundValue());\\n                if (e === errorObj) {\\n                    this._attachExtraTrace(e.e);\\n                    async.throwLater(e.e);\\n                }\\n            }\\n        } else {\\n            onCancelCallback._resultCancelled(this);\\n        }\\n    }\\n};\\n\\nPromise.prototype._invokeOnCancel = function() {\\n    var onCancelCallback = this._onCancel();\\n    this._unsetOnCancel();\\n    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);\\n};\\n\\nPromise.prototype._invokeInternalOnCancel = function() {\\n    if (this._isCancellable()) {\\n        this._doInvokeOnCancel(this._onCancel(), true);\\n        this._unsetOnCancel();\\n    }\\n};\\n\\nPromise.prototype._resultCancelled = function() {\\n    this.cancel();\\n};\\n\\n};\\n\\n},{\\\"./util\\\":36}],7:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(NEXT_FILTER) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar getKeys = _dereq_(\\\"./es5\\\").keys;\\nvar tryCatch = util.tryCatch;\\nvar errorObj = util.errorObj;\\n\\nfunction catchFilter(instances, cb, promise) {\\n    return function(e) {\\n        var boundTo = promise._boundValue();\\n        predicateLoop: for (var i = 0; i < instances.length; ++i) {\\n            var item = instances[i];\\n\\n            if (item === Error ||\\n                (item != null && item.prototype instanceof Error)) {\\n                if (e instanceof item) {\\n                    return tryCatch(cb).call(boundTo, e);\\n                }\\n            } else if (typeof item === \\\"function\\\") {\\n                var matchesPredicate = tryCatch(item).call(boundTo, e);\\n                if (matchesPredicate === errorObj) {\\n                    return matchesPredicate;\\n                } else if (matchesPredicate) {\\n                    return tryCatch(cb).call(boundTo, e);\\n                }\\n            } else if (util.isObject(e)) {\\n                var keys = getKeys(item);\\n                for (var j = 0; j < keys.length; ++j) {\\n                    var key = keys[j];\\n                    if (item[key] != e[key]) {\\n                        continue predicateLoop;\\n                    }\\n                }\\n                return tryCatch(cb).call(boundTo, e);\\n            }\\n        }\\n        return NEXT_FILTER;\\n    };\\n}\\n\\nreturn catchFilter;\\n};\\n\\n},{\\\"./es5\\\":13,\\\"./util\\\":36}],8:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise) {\\nvar longStackTraces = false;\\nvar contextStack = [];\\n\\nPromise.prototype._promiseCreated = function() {};\\nPromise.prototype._pushContext = function() {};\\nPromise.prototype._popContext = function() {return null;};\\nPromise._peekContext = Promise.prototype._peekContext = function() {};\\n\\nfunction Context() {\\n    this._trace = new Context.CapturedTrace(peekContext());\\n}\\nContext.prototype._pushContext = function () {\\n    if (this._trace !== undefined) {\\n        this._trace._promiseCreated = null;\\n        contextStack.push(this._trace);\\n    }\\n};\\n\\nContext.prototype._popContext = function () {\\n    if (this._trace !== undefined) {\\n        var trace = contextStack.pop();\\n        var ret = trace._promiseCreated;\\n        trace._promiseCreated = null;\\n        return ret;\\n    }\\n    return null;\\n};\\n\\nfunction createContext() {\\n    if (longStackTraces) return new Context();\\n}\\n\\nfunction peekContext() {\\n    var lastIndex = contextStack.length - 1;\\n    if (lastIndex >= 0) {\\n        return contextStack[lastIndex];\\n    }\\n    return undefined;\\n}\\nContext.CapturedTrace = null;\\nContext.create = createContext;\\nContext.deactivateLongStackTraces = function() {};\\nContext.activateLongStackTraces = function() {\\n    var Promise_pushContext = Promise.prototype._pushContext;\\n    var Promise_popContext = Promise.prototype._popContext;\\n    var Promise_PeekContext = Promise._peekContext;\\n    var Promise_peekContext = Promise.prototype._peekContext;\\n    var Promise_promiseCreated = Promise.prototype._promiseCreated;\\n    Context.deactivateLongStackTraces = function() {\\n        Promise.prototype._pushContext = Promise_pushContext;\\n        Promise.prototype._popContext = Promise_popContext;\\n        Promise._peekContext = Promise_PeekContext;\\n        Promise.prototype._peekContext = Promise_peekContext;\\n        Promise.prototype._promiseCreated = Promise_promiseCreated;\\n        longStackTraces = false;\\n    };\\n    longStackTraces = true;\\n    Promise.prototype._pushContext = Context.prototype._pushContext;\\n    Promise.prototype._popContext = Context.prototype._popContext;\\n    Promise._peekContext = Promise.prototype._peekContext = peekContext;\\n    Promise.prototype._promiseCreated = function() {\\n        var ctx = this._peekContext();\\n        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;\\n    };\\n};\\nreturn Context;\\n};\\n\\n},{}],9:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise, Context) {\\nvar getDomain = Promise._getDomain;\\nvar async = Promise._async;\\nvar Warning = _dereq_(\\\"./errors\\\").Warning;\\nvar util = _dereq_(\\\"./util\\\");\\nvar canAttachTrace = util.canAttachTrace;\\nvar unhandledRejectionHandled;\\nvar possiblyUnhandledRejection;\\nvar bluebirdFramePattern =\\n    /[\\\\\\\\\\\\/]bluebird[\\\\\\\\\\\\/]js[\\\\\\\\\\\\/](release|debug|instrumented)/;\\nvar nodeFramePattern = /\\\\((?:timers\\\\.js):\\\\d+:\\\\d+\\\\)/;\\nvar parseLinePattern = /[\\\\/<\\\\(](.+?):(\\\\d+):(\\\\d+)\\\\)?\\\\s*$/;\\nvar stackFramePattern = null;\\nvar formatStack = null;\\nvar indentStackFrames = false;\\nvar printWarning;\\nvar debugging = !!(util.env(\\\"BLUEBIRD_DEBUG\\\") != 0 &&\\n                        (true ||\\n                         util.env(\\\"BLUEBIRD_DEBUG\\\") ||\\n                         util.env(\\\"NODE_ENV\\\") === \\\"development\\\"));\\n\\nvar warnings = !!(util.env(\\\"BLUEBIRD_WARNINGS\\\") != 0 &&\\n    (debugging || util.env(\\\"BLUEBIRD_WARNINGS\\\")));\\n\\nvar longStackTraces = !!(util.env(\\\"BLUEBIRD_LONG_STACK_TRACES\\\") != 0 &&\\n    (debugging || util.env(\\\"BLUEBIRD_LONG_STACK_TRACES\\\")));\\n\\nvar wForgottenReturn = util.env(\\\"BLUEBIRD_W_FORGOTTEN_RETURN\\\") != 0 &&\\n    (warnings || !!util.env(\\\"BLUEBIRD_W_FORGOTTEN_RETURN\\\"));\\n\\nPromise.prototype.suppressUnhandledRejections = function() {\\n    var target = this._target();\\n    target._bitField = ((target._bitField & (~1048576)) |\\n                      524288);\\n};\\n\\nPromise.prototype._ensurePossibleRejectionHandled = function () {\\n    if ((this._bitField & 524288) !== 0) return;\\n    this._setRejectionIsUnhandled();\\n    var self = this;\\n    setTimeout(function() {\\n        self._notifyUnhandledRejection();\\n    }, 1);\\n};\\n\\nPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\\n    fireRejectionEvent(\\\"rejectionHandled\\\",\\n                                  unhandledRejectionHandled, undefined, this);\\n};\\n\\nPromise.prototype._setReturnedNonUndefined = function() {\\n    this._bitField = this._bitField | 268435456;\\n};\\n\\nPromise.prototype._returnedNonUndefined = function() {\\n    return (this._bitField & 268435456) !== 0;\\n};\\n\\nPromise.prototype._notifyUnhandledRejection = function () {\\n    if (this._isRejectionUnhandled()) {\\n        var reason = this._settledValue();\\n        this._setUnhandledRejectionIsNotified();\\n        fireRejectionEvent(\\\"unhandledRejection\\\",\\n                                      possiblyUnhandledRejection, reason, this);\\n    }\\n};\\n\\nPromise.prototype._setUnhandledRejectionIsNotified = function () {\\n    this._bitField = this._bitField | 262144;\\n};\\n\\nPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\\n    this._bitField = this._bitField & (~262144);\\n};\\n\\nPromise.prototype._isUnhandledRejectionNotified = function () {\\n    return (this._bitField & 262144) > 0;\\n};\\n\\nPromise.prototype._setRejectionIsUnhandled = function () {\\n    this._bitField = this._bitField | 1048576;\\n};\\n\\nPromise.prototype._unsetRejectionIsUnhandled = function () {\\n    this._bitField = this._bitField & (~1048576);\\n    if (this._isUnhandledRejectionNotified()) {\\n        this._unsetUnhandledRejectionIsNotified();\\n        this._notifyUnhandledRejectionIsHandled();\\n    }\\n};\\n\\nPromise.prototype._isRejectionUnhandled = function () {\\n    return (this._bitField & 1048576) > 0;\\n};\\n\\nPromise.prototype._warn = function(message, shouldUseOwnTrace, promise) {\\n    return warn(message, shouldUseOwnTrace, promise || this);\\n};\\n\\nPromise.onPossiblyUnhandledRejection = function (fn) {\\n    var domain = getDomain();\\n    possiblyUnhandledRejection =\\n        typeof fn === \\\"function\\\" ? (domain === null ?\\n                                            fn : util.domainBind(domain, fn))\\n                                 : undefined;\\n};\\n\\nPromise.onUnhandledRejectionHandled = function (fn) {\\n    var domain = getDomain();\\n    unhandledRejectionHandled =\\n        typeof fn === \\\"function\\\" ? (domain === null ?\\n                                            fn : util.domainBind(domain, fn))\\n                                 : undefined;\\n};\\n\\nvar disableLongStackTraces = function() {};\\nPromise.longStackTraces = function () {\\n    if (async.haveItemsQueued() && !config.longStackTraces) {\\n        throw new Error(\\\"cannot enable long stack traces after promises have been created\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    }\\n    if (!config.longStackTraces && longStackTracesIsSupported()) {\\n        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;\\n        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;\\n        config.longStackTraces = true;\\n        disableLongStackTraces = function() {\\n            if (async.haveItemsQueued() && !config.longStackTraces) {\\n                throw new Error(\\\"cannot enable long stack traces after promises have been created\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n            }\\n            Promise.prototype._captureStackTrace = Promise_captureStackTrace;\\n            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;\\n            Context.deactivateLongStackTraces();\\n            async.enableTrampoline();\\n            config.longStackTraces = false;\\n        };\\n        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;\\n        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;\\n        Context.activateLongStackTraces();\\n        async.disableTrampolineIfNecessary();\\n    }\\n};\\n\\nPromise.hasLongStackTraces = function () {\\n    return config.longStackTraces && longStackTracesIsSupported();\\n};\\n\\nvar fireDomEvent = (function() {\\n    try {\\n        if (typeof CustomEvent === \\\"function\\\") {\\n            var event = new CustomEvent(\\\"CustomEvent\\\");\\n            util.global.dispatchEvent(event);\\n            return function(name, event) {\\n                var domEvent = new CustomEvent(name.toLowerCase(), {\\n                    detail: event,\\n                    cancelable: true\\n                });\\n                return !util.global.dispatchEvent(domEvent);\\n            };\\n        } else if (typeof Event === \\\"function\\\") {\\n            var event = new Event(\\\"CustomEvent\\\");\\n            util.global.dispatchEvent(event);\\n            return function(name, event) {\\n                var domEvent = new Event(name.toLowerCase(), {\\n                    cancelable: true\\n                });\\n                domEvent.detail = event;\\n                return !util.global.dispatchEvent(domEvent);\\n            };\\n        } else {\\n            var event = document.createEvent(\\\"CustomEvent\\\");\\n            event.initCustomEvent(\\\"testingtheevent\\\", false, true, {});\\n            util.global.dispatchEvent(event);\\n            return function(name, event) {\\n                var domEvent = document.createEvent(\\\"CustomEvent\\\");\\n                domEvent.initCustomEvent(name.toLowerCase(), false, true,\\n                    event);\\n                return !util.global.dispatchEvent(domEvent);\\n            };\\n        }\\n    } catch (e) {}\\n    return function() {\\n        return false;\\n    };\\n})();\\n\\nvar fireGlobalEvent = (function() {\\n    if (util.isNode) {\\n        return function() {\\n            return process.emit.apply(process, arguments);\\n        };\\n    } else {\\n        if (!util.global) {\\n            return function() {\\n                return false;\\n            };\\n        }\\n        return function(name) {\\n            var methodName = \\\"on\\\" + name.toLowerCase();\\n            var method = util.global[methodName];\\n            if (!method) return false;\\n            method.apply(util.global, [].slice.call(arguments, 1));\\n            return true;\\n        };\\n    }\\n})();\\n\\nfunction generatePromiseLifecycleEventObject(name, promise) {\\n    return {promise: promise};\\n}\\n\\nvar eventToObjectGenerator = {\\n    promiseCreated: generatePromiseLifecycleEventObject,\\n    promiseFulfilled: generatePromiseLifecycleEventObject,\\n    promiseRejected: generatePromiseLifecycleEventObject,\\n    promiseResolved: generatePromiseLifecycleEventObject,\\n    promiseCancelled: generatePromiseLifecycleEventObject,\\n    promiseChained: function(name, promise, child) {\\n        return {promise: promise, child: child};\\n    },\\n    warning: function(name, warning) {\\n        return {warning: warning};\\n    },\\n    unhandledRejection: function (name, reason, promise) {\\n        return {reason: reason, promise: promise};\\n    },\\n    rejectionHandled: generatePromiseLifecycleEventObject\\n};\\n\\nvar activeFireEvent = function (name) {\\n    var globalEventFired = false;\\n    try {\\n        globalEventFired = fireGlobalEvent.apply(null, arguments);\\n    } catch (e) {\\n        async.throwLater(e);\\n        globalEventFired = true;\\n    }\\n\\n    var domEventFired = false;\\n    try {\\n        domEventFired = fireDomEvent(name,\\n                    eventToObjectGenerator[name].apply(null, arguments));\\n    } catch (e) {\\n        async.throwLater(e);\\n        domEventFired = true;\\n    }\\n\\n    return domEventFired || globalEventFired;\\n};\\n\\nPromise.config = function(opts) {\\n    opts = Object(opts);\\n    if (\\\"longStackTraces\\\" in opts) {\\n        if (opts.longStackTraces) {\\n            Promise.longStackTraces();\\n        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {\\n            disableLongStackTraces();\\n        }\\n    }\\n    if (\\\"warnings\\\" in opts) {\\n        var warningsOption = opts.warnings;\\n        config.warnings = !!warningsOption;\\n        wForgottenReturn = config.warnings;\\n\\n        if (util.isObject(warningsOption)) {\\n            if (\\\"wForgottenReturn\\\" in warningsOption) {\\n                wForgottenReturn = !!warningsOption.wForgottenReturn;\\n            }\\n        }\\n    }\\n    if (\\\"cancellation\\\" in opts && opts.cancellation && !config.cancellation) {\\n        if (async.haveItemsQueued()) {\\n            throw new Error(\\n                \\\"cannot enable cancellation after promises are in use\\\");\\n        }\\n        Promise.prototype._clearCancellationData =\\n            cancellationClearCancellationData;\\n        Promise.prototype._propagateFrom = cancellationPropagateFrom;\\n        Promise.prototype._onCancel = cancellationOnCancel;\\n        Promise.prototype._setOnCancel = cancellationSetOnCancel;\\n        Promise.prototype._attachCancellationCallback =\\n            cancellationAttachCancellationCallback;\\n        Promise.prototype._execute = cancellationExecute;\\n        propagateFromFunction = cancellationPropagateFrom;\\n        config.cancellation = true;\\n    }\\n    if (\\\"monitoring\\\" in opts) {\\n        if (opts.monitoring && !config.monitoring) {\\n            config.monitoring = true;\\n            Promise.prototype._fireEvent = activeFireEvent;\\n        } else if (!opts.monitoring && config.monitoring) {\\n            config.monitoring = false;\\n            Promise.prototype._fireEvent = defaultFireEvent;\\n        }\\n    }\\n    return Promise;\\n};\\n\\nfunction defaultFireEvent() { return false; }\\n\\nPromise.prototype._fireEvent = defaultFireEvent;\\nPromise.prototype._execute = function(executor, resolve, reject) {\\n    try {\\n        executor(resolve, reject);\\n    } catch (e) {\\n        return e;\\n    }\\n};\\nPromise.prototype._onCancel = function () {};\\nPromise.prototype._setOnCancel = function (handler) { ; };\\nPromise.prototype._attachCancellationCallback = function(onCancel) {\\n    ;\\n};\\nPromise.prototype._captureStackTrace = function () {};\\nPromise.prototype._attachExtraTrace = function () {};\\nPromise.prototype._clearCancellationData = function() {};\\nPromise.prototype._propagateFrom = function (parent, flags) {\\n    ;\\n    ;\\n};\\n\\nfunction cancellationExecute(executor, resolve, reject) {\\n    var promise = this;\\n    try {\\n        executor(resolve, reject, function(onCancel) {\\n            if (typeof onCancel !== \\\"function\\\") {\\n                throw new TypeError(\\\"onCancel must be a function, got: \\\" +\\n                                    util.toString(onCancel));\\n            }\\n            promise._attachCancellationCallback(onCancel);\\n        });\\n    } catch (e) {\\n        return e;\\n    }\\n}\\n\\nfunction cancellationAttachCancellationCallback(onCancel) {\\n    if (!this._isCancellable()) return this;\\n\\n    var previousOnCancel = this._onCancel();\\n    if (previousOnCancel !== undefined) {\\n        if (util.isArray(previousOnCancel)) {\\n            previousOnCancel.push(onCancel);\\n        } else {\\n            this._setOnCancel([previousOnCancel, onCancel]);\\n        }\\n    } else {\\n        this._setOnCancel(onCancel);\\n    }\\n}\\n\\nfunction cancellationOnCancel() {\\n    return this._onCancelField;\\n}\\n\\nfunction cancellationSetOnCancel(onCancel) {\\n    this._onCancelField = onCancel;\\n}\\n\\nfunction cancellationClearCancellationData() {\\n    this._cancellationParent = undefined;\\n    this._onCancelField = undefined;\\n}\\n\\nfunction cancellationPropagateFrom(parent, flags) {\\n    if ((flags & 1) !== 0) {\\n        this._cancellationParent = parent;\\n        var branchesRemainingToCancel = parent._branchesRemainingToCancel;\\n        if (branchesRemainingToCancel === undefined) {\\n            branchesRemainingToCancel = 0;\\n        }\\n        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;\\n    }\\n    if ((flags & 2) !== 0 && parent._isBound()) {\\n        this._setBoundTo(parent._boundTo);\\n    }\\n}\\n\\nfunction bindingPropagateFrom(parent, flags) {\\n    if ((flags & 2) !== 0 && parent._isBound()) {\\n        this._setBoundTo(parent._boundTo);\\n    }\\n}\\nvar propagateFromFunction = bindingPropagateFrom;\\n\\nfunction boundValueFunction() {\\n    var ret = this._boundTo;\\n    if (ret !== undefined) {\\n        if (ret instanceof Promise) {\\n            if (ret.isFulfilled()) {\\n                return ret.value();\\n            } else {\\n                return undefined;\\n            }\\n        }\\n    }\\n    return ret;\\n}\\n\\nfunction longStackTracesCaptureStackTrace() {\\n    this._trace = new CapturedTrace(this._peekContext());\\n}\\n\\nfunction longStackTracesAttachExtraTrace(error, ignoreSelf) {\\n    if (canAttachTrace(error)) {\\n        var trace = this._trace;\\n        if (trace !== undefined) {\\n            if (ignoreSelf) trace = trace._parent;\\n        }\\n        if (trace !== undefined) {\\n            trace.attachExtraTrace(error);\\n        } else if (!error.__stackCleaned__) {\\n            var parsed = parseStackAndMessage(error);\\n            util.notEnumerableProp(error, \\\"stack\\\",\\n                parsed.message + \\\"\\\\n\\\" + parsed.stack.join(\\\"\\\\n\\\"));\\n            util.notEnumerableProp(error, \\\"__stackCleaned__\\\", true);\\n        }\\n    }\\n}\\n\\nfunction checkForgottenReturns(returnValue, promiseCreated, name, promise,\\n                               parent) {\\n    if (returnValue === undefined && promiseCreated !== null &&\\n        wForgottenReturn) {\\n        if (parent !== undefined && parent._returnedNonUndefined()) return;\\n        if ((promise._bitField & 65535) === 0) return;\\n\\n        if (name) name = name + \\\" \\\";\\n        var handlerLine = \\\"\\\";\\n        var creatorLine = \\\"\\\";\\n        if (promiseCreated._trace) {\\n            var traceLines = promiseCreated._trace.stack.split(\\\"\\\\n\\\");\\n            var stack = cleanStack(traceLines);\\n            for (var i = stack.length - 1; i >= 0; --i) {\\n                var line = stack[i];\\n                if (!nodeFramePattern.test(line)) {\\n                    var lineMatches = line.match(parseLinePattern);\\n                    if (lineMatches) {\\n                        handlerLine  = \\\"at \\\" + lineMatches[1] +\\n                            \\\":\\\" + lineMatches[2] + \\\":\\\" + lineMatches[3] + \\\" \\\";\\n                    }\\n                    break;\\n                }\\n            }\\n\\n            if (stack.length > 0) {\\n                var firstUserLine = stack[0];\\n                for (var i = 0; i < traceLines.length; ++i) {\\n\\n                    if (traceLines[i] === firstUserLine) {\\n                        if (i > 0) {\\n                            creatorLine = \\\"\\\\n\\\" + traceLines[i - 1];\\n                        }\\n                        break;\\n                    }\\n                }\\n\\n            }\\n        }\\n        var msg = \\\"a promise was created in a \\\" + name +\\n            \\\"handler \\\" + handlerLine + \\\"but was not returned from it, \\\" +\\n            \\\"see http://goo.gl/rRqMUw\\\" +\\n            creatorLine;\\n        promise._warn(msg, true, promiseCreated);\\n    }\\n}\\n\\nfunction deprecated(name, replacement) {\\n    var message = name +\\n        \\\" is deprecated and will be removed in a future version.\\\";\\n    if (replacement) message += \\\" Use \\\" + replacement + \\\" instead.\\\";\\n    return warn(message);\\n}\\n\\nfunction warn(message, shouldUseOwnTrace, promise) {\\n    if (!config.warnings) return;\\n    var warning = new Warning(message);\\n    var ctx;\\n    if (shouldUseOwnTrace) {\\n        promise._attachExtraTrace(warning);\\n    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {\\n        ctx.attachExtraTrace(warning);\\n    } else {\\n        var parsed = parseStackAndMessage(warning);\\n        warning.stack = parsed.message + \\\"\\\\n\\\" + parsed.stack.join(\\\"\\\\n\\\");\\n    }\\n\\n    if (!activeFireEvent(\\\"warning\\\", warning)) {\\n        formatAndLogError(warning, \\\"\\\", true);\\n    }\\n}\\n\\nfunction reconstructStack(message, stacks) {\\n    for (var i = 0; i < stacks.length - 1; ++i) {\\n        stacks[i].push(\\\"From previous event:\\\");\\n        stacks[i] = stacks[i].join(\\\"\\\\n\\\");\\n    }\\n    if (i < stacks.length) {\\n        stacks[i] = stacks[i].join(\\\"\\\\n\\\");\\n    }\\n    return message + \\\"\\\\n\\\" + stacks.join(\\\"\\\\n\\\");\\n}\\n\\nfunction removeDuplicateOrEmptyJumps(stacks) {\\n    for (var i = 0; i < stacks.length; ++i) {\\n        if (stacks[i].length === 0 ||\\n            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\\n            stacks.splice(i, 1);\\n            i--;\\n        }\\n    }\\n}\\n\\nfunction removeCommonRoots(stacks) {\\n    var current = stacks[0];\\n    for (var i = 1; i < stacks.length; ++i) {\\n        var prev = stacks[i];\\n        var currentLastIndex = current.length - 1;\\n        var currentLastLine = current[currentLastIndex];\\n        var commonRootMeetPoint = -1;\\n\\n        for (var j = prev.length - 1; j >= 0; --j) {\\n            if (prev[j] === currentLastLine) {\\n                commonRootMeetPoint = j;\\n                break;\\n            }\\n        }\\n\\n        for (var j = commonRootMeetPoint; j >= 0; --j) {\\n            var line = prev[j];\\n            if (current[currentLastIndex] === line) {\\n                current.pop();\\n                currentLastIndex--;\\n            } else {\\n                break;\\n            }\\n        }\\n        current = prev;\\n    }\\n}\\n\\nfunction cleanStack(stack) {\\n    var ret = [];\\n    for (var i = 0; i < stack.length; ++i) {\\n        var line = stack[i];\\n        var isTraceLine = \\\"    (No stack trace)\\\" === line ||\\n            stackFramePattern.test(line);\\n        var isInternalFrame = isTraceLine && shouldIgnore(line);\\n        if (isTraceLine && !isInternalFrame) {\\n            if (indentStackFrames && line.charAt(0) !== \\\" \\\") {\\n                line = \\\"    \\\" + line;\\n            }\\n            ret.push(line);\\n        }\\n    }\\n    return ret;\\n}\\n\\nfunction stackFramesAsArray(error) {\\n    var stack = error.stack.replace(/\\\\s+$/g, \\\"\\\").split(\\\"\\\\n\\\");\\n    for (var i = 0; i < stack.length; ++i) {\\n        var line = stack[i];\\n        if (\\\"    (No stack trace)\\\" === line || stackFramePattern.test(line)) {\\n            break;\\n        }\\n    }\\n    if (i > 0 && error.name != \\\"SyntaxError\\\") {\\n        stack = stack.slice(i);\\n    }\\n    return stack;\\n}\\n\\nfunction parseStackAndMessage(error) {\\n    var stack = error.stack;\\n    var message = error.toString();\\n    stack = typeof stack === \\\"string\\\" && stack.length > 0\\n                ? stackFramesAsArray(error) : [\\\"    (No stack trace)\\\"];\\n    return {\\n        message: message,\\n        stack: error.name == \\\"SyntaxError\\\" ? stack : cleanStack(stack)\\n    };\\n}\\n\\nfunction formatAndLogError(error, title, isSoft) {\\n    if (typeof console !== \\\"undefined\\\") {\\n        var message;\\n        if (util.isObject(error)) {\\n            var stack = error.stack;\\n            message = title + formatStack(stack, error);\\n        } else {\\n            message = title + String(error);\\n        }\\n        if (typeof printWarning === \\\"function\\\") {\\n            printWarning(message, isSoft);\\n        } else if (typeof console.log === \\\"function\\\" ||\\n            typeof console.log === \\\"object\\\") {\\n            console.log(message);\\n        }\\n    }\\n}\\n\\nfunction fireRejectionEvent(name, localHandler, reason, promise) {\\n    var localEventFired = false;\\n    try {\\n        if (typeof localHandler === \\\"function\\\") {\\n            localEventFired = true;\\n            if (name === \\\"rejectionHandled\\\") {\\n                localHandler(promise);\\n            } else {\\n                localHandler(reason, promise);\\n            }\\n        }\\n    } catch (e) {\\n        async.throwLater(e);\\n    }\\n\\n    if (name === \\\"unhandledRejection\\\") {\\n        if (!activeFireEvent(name, reason, promise) && !localEventFired) {\\n            formatAndLogError(reason, \\\"Unhandled rejection \\\");\\n        }\\n    } else {\\n        activeFireEvent(name, promise);\\n    }\\n}\\n\\nfunction formatNonError(obj) {\\n    var str;\\n    if (typeof obj === \\\"function\\\") {\\n        str = \\\"[function \\\" +\\n            (obj.name || \\\"anonymous\\\") +\\n            \\\"]\\\";\\n    } else {\\n        str = obj && typeof obj.toString === \\\"function\\\"\\n            ? obj.toString() : util.toString(obj);\\n        var ruselessToString = /\\\\[object [a-zA-Z0-9$_]+\\\\]/;\\n        if (ruselessToString.test(str)) {\\n            try {\\n                var newStr = JSON.stringify(obj);\\n                str = newStr;\\n            }\\n            catch(e) {\\n\\n            }\\n        }\\n        if (str.length === 0) {\\n            str = \\\"(empty array)\\\";\\n        }\\n    }\\n    return (\\\"(<\\\" + snip(str) + \\\">, no stack trace)\\\");\\n}\\n\\nfunction snip(str) {\\n    var maxChars = 41;\\n    if (str.length < maxChars) {\\n        return str;\\n    }\\n    return str.substr(0, maxChars - 3) + \\\"...\\\";\\n}\\n\\nfunction longStackTracesIsSupported() {\\n    return typeof captureStackTrace === \\\"function\\\";\\n}\\n\\nvar shouldIgnore = function() { return false; };\\nvar parseLineInfoRegex = /[\\\\/<\\\\(]([^:\\\\/]+):(\\\\d+):(?:\\\\d+)\\\\)?\\\\s*$/;\\nfunction parseLineInfo(line) {\\n    var matches = line.match(parseLineInfoRegex);\\n    if (matches) {\\n        return {\\n            fileName: matches[1],\\n            line: parseInt(matches[2], 10)\\n        };\\n    }\\n}\\n\\nfunction setBounds(firstLineError, lastLineError) {\\n    if (!longStackTracesIsSupported()) return;\\n    var firstStackLines = firstLineError.stack.split(\\\"\\\\n\\\");\\n    var lastStackLines = lastLineError.stack.split(\\\"\\\\n\\\");\\n    var firstIndex = -1;\\n    var lastIndex = -1;\\n    var firstFileName;\\n    var lastFileName;\\n    for (var i = 0; i < firstStackLines.length; ++i) {\\n        var result = parseLineInfo(firstStackLines[i]);\\n        if (result) {\\n            firstFileName = result.fileName;\\n            firstIndex = result.line;\\n            break;\\n        }\\n    }\\n    for (var i = 0; i < lastStackLines.length; ++i) {\\n        var result = parseLineInfo(lastStackLines[i]);\\n        if (result) {\\n            lastFileName = result.fileName;\\n            lastIndex = result.line;\\n            break;\\n        }\\n    }\\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\\n        firstFileName !== lastFileName || firstIndex >= lastIndex) {\\n        return;\\n    }\\n\\n    shouldIgnore = function(line) {\\n        if (bluebirdFramePattern.test(line)) return true;\\n        var info = parseLineInfo(line);\\n        if (info) {\\n            if (info.fileName === firstFileName &&\\n                (firstIndex <= info.line && info.line <= lastIndex)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n}\\n\\nfunction CapturedTrace(parent) {\\n    this._parent = parent;\\n    this._promisesCreated = 0;\\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\\n    captureStackTrace(this, CapturedTrace);\\n    if (length > 32) this.uncycle();\\n}\\nutil.inherits(CapturedTrace, Error);\\nContext.CapturedTrace = CapturedTrace;\\n\\nCapturedTrace.prototype.uncycle = function() {\\n    var length = this._length;\\n    if (length < 2) return;\\n    var nodes = [];\\n    var stackToIndex = {};\\n\\n    for (var i = 0, node = this; node !== undefined; ++i) {\\n        nodes.push(node);\\n        node = node._parent;\\n    }\\n    length = this._length = i;\\n    for (var i = length - 1; i >= 0; --i) {\\n        var stack = nodes[i].stack;\\n        if (stackToIndex[stack] === undefined) {\\n            stackToIndex[stack] = i;\\n        }\\n    }\\n    for (var i = 0; i < length; ++i) {\\n        var currentStack = nodes[i].stack;\\n        var index = stackToIndex[currentStack];\\n        if (index !== undefined && index !== i) {\\n            if (index > 0) {\\n                nodes[index - 1]._parent = undefined;\\n                nodes[index - 1]._length = 1;\\n            }\\n            nodes[i]._parent = undefined;\\n            nodes[i]._length = 1;\\n            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\\n\\n            if (index < length - 1) {\\n                cycleEdgeNode._parent = nodes[index + 1];\\n                cycleEdgeNode._parent.uncycle();\\n                cycleEdgeNode._length =\\n                    cycleEdgeNode._parent._length + 1;\\n            } else {\\n                cycleEdgeNode._parent = undefined;\\n                cycleEdgeNode._length = 1;\\n            }\\n            var currentChildLength = cycleEdgeNode._length + 1;\\n            for (var j = i - 2; j >= 0; --j) {\\n                nodes[j]._length = currentChildLength;\\n                currentChildLength++;\\n            }\\n            return;\\n        }\\n    }\\n};\\n\\nCapturedTrace.prototype.attachExtraTrace = function(error) {\\n    if (error.__stackCleaned__) return;\\n    this.uncycle();\\n    var parsed = parseStackAndMessage(error);\\n    var message = parsed.message;\\n    var stacks = [parsed.stack];\\n\\n    var trace = this;\\n    while (trace !== undefined) {\\n        stacks.push(cleanStack(trace.stack.split(\\\"\\\\n\\\")));\\n        trace = trace._parent;\\n    }\\n    removeCommonRoots(stacks);\\n    removeDuplicateOrEmptyJumps(stacks);\\n    util.notEnumerableProp(error, \\\"stack\\\", reconstructStack(message, stacks));\\n    util.notEnumerableProp(error, \\\"__stackCleaned__\\\", true);\\n};\\n\\nvar captureStackTrace = (function stackDetection() {\\n    var v8stackFramePattern = /^\\\\s*at\\\\s*/;\\n    var v8stackFormatter = function(stack, error) {\\n        if (typeof stack === \\\"string\\\") return stack;\\n\\n        if (error.name !== undefined &&\\n            error.message !== undefined) {\\n            return error.toString();\\n        }\\n        return formatNonError(error);\\n    };\\n\\n    if (typeof Error.stackTraceLimit === \\\"number\\\" &&\\n        typeof Error.captureStackTrace === \\\"function\\\") {\\n        Error.stackTraceLimit += 6;\\n        stackFramePattern = v8stackFramePattern;\\n        formatStack = v8stackFormatter;\\n        var captureStackTrace = Error.captureStackTrace;\\n\\n        shouldIgnore = function(line) {\\n            return bluebirdFramePattern.test(line);\\n        };\\n        return function(receiver, ignoreUntil) {\\n            Error.stackTraceLimit += 6;\\n            captureStackTrace(receiver, ignoreUntil);\\n            Error.stackTraceLimit -= 6;\\n        };\\n    }\\n    var err = new Error();\\n\\n    if (typeof err.stack === \\\"string\\\" &&\\n        err.stack.split(\\\"\\\\n\\\")[0].indexOf(\\\"stackDetection@\\\") >= 0) {\\n        stackFramePattern = /@/;\\n        formatStack = v8stackFormatter;\\n        indentStackFrames = true;\\n        return function captureStackTrace(o) {\\n            o.stack = new Error().stack;\\n        };\\n    }\\n\\n    var hasStackAfterThrow;\\n    try { throw new Error(); }\\n    catch(e) {\\n        hasStackAfterThrow = (\\\"stack\\\" in e);\\n    }\\n    if (!(\\\"stack\\\" in err) && hasStackAfterThrow &&\\n        typeof Error.stackTraceLimit === \\\"number\\\") {\\n        stackFramePattern = v8stackFramePattern;\\n        formatStack = v8stackFormatter;\\n        return function captureStackTrace(o) {\\n            Error.stackTraceLimit += 6;\\n            try { throw new Error(); }\\n            catch(e) { o.stack = e.stack; }\\n            Error.stackTraceLimit -= 6;\\n        };\\n    }\\n\\n    formatStack = function(stack, error) {\\n        if (typeof stack === \\\"string\\\") return stack;\\n\\n        if ((typeof error === \\\"object\\\" ||\\n            typeof error === \\\"function\\\") &&\\n            error.name !== undefined &&\\n            error.message !== undefined) {\\n            return error.toString();\\n        }\\n        return formatNonError(error);\\n    };\\n\\n    return null;\\n\\n})([]);\\n\\nif (typeof console !== \\\"undefined\\\" && typeof console.warn !== \\\"undefined\\\") {\\n    printWarning = function (message) {\\n        console.warn(message);\\n    };\\n    if (util.isNode && process.stderr.isTTY) {\\n        printWarning = function(message, isSoft) {\\n            var color = isSoft ? \\\"\\\\u001b[33m\\\" : \\\"\\\\u001b[31m\\\";\\n            console.warn(color + message + \\\"\\\\u001b[0m\\\\n\\\");\\n        };\\n    } else if (!util.isNode && typeof (new Error().stack) === \\\"string\\\") {\\n        printWarning = function(message, isSoft) {\\n            console.warn(\\\"%c\\\" + message,\\n                        isSoft ? \\\"color: darkorange\\\" : \\\"color: red\\\");\\n        };\\n    }\\n}\\n\\nvar config = {\\n    warnings: warnings,\\n    longStackTraces: false,\\n    cancellation: false,\\n    monitoring: false\\n};\\n\\nif (longStackTraces) Promise.longStackTraces();\\n\\nreturn {\\n    longStackTraces: function() {\\n        return config.longStackTraces;\\n    },\\n    warnings: function() {\\n        return config.warnings;\\n    },\\n    cancellation: function() {\\n        return config.cancellation;\\n    },\\n    monitoring: function() {\\n        return config.monitoring;\\n    },\\n    propagateFromFunction: function() {\\n        return propagateFromFunction;\\n    },\\n    boundValueFunction: function() {\\n        return boundValueFunction;\\n    },\\n    checkForgottenReturns: checkForgottenReturns,\\n    setBounds: setBounds,\\n    warn: warn,\\n    deprecated: deprecated,\\n    CapturedTrace: CapturedTrace,\\n    fireDomEvent: fireDomEvent,\\n    fireGlobalEvent: fireGlobalEvent\\n};\\n};\\n\\n},{\\\"./errors\\\":12,\\\"./util\\\":36}],10:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise) {\\nfunction returner() {\\n    return this.value;\\n}\\nfunction thrower() {\\n    throw this.reason;\\n}\\n\\nPromise.prototype[\\\"return\\\"] =\\nPromise.prototype.thenReturn = function (value) {\\n    if (value instanceof Promise) value.suppressUnhandledRejections();\\n    return this._then(\\n        returner, undefined, undefined, {value: value}, undefined);\\n};\\n\\nPromise.prototype[\\\"throw\\\"] =\\nPromise.prototype.thenThrow = function (reason) {\\n    return this._then(\\n        thrower, undefined, undefined, {reason: reason}, undefined);\\n};\\n\\nPromise.prototype.catchThrow = function (reason) {\\n    if (arguments.length <= 1) {\\n        return this._then(\\n            undefined, thrower, undefined, {reason: reason}, undefined);\\n    } else {\\n        var _reason = arguments[1];\\n        var handler = function() {throw _reason;};\\n        return this.caught(reason, handler);\\n    }\\n};\\n\\nPromise.prototype.catchReturn = function (value) {\\n    if (arguments.length <= 1) {\\n        if (value instanceof Promise) value.suppressUnhandledRejections();\\n        return this._then(\\n            undefined, returner, undefined, {value: value}, undefined);\\n    } else {\\n        var _value = arguments[1];\\n        if (_value instanceof Promise) _value.suppressUnhandledRejections();\\n        var handler = function() {return _value;};\\n        return this.caught(value, handler);\\n    }\\n};\\n};\\n\\n},{}],11:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise, INTERNAL) {\\nvar PromiseReduce = Promise.reduce;\\nvar PromiseAll = Promise.all;\\n\\nfunction promiseAllThis() {\\n    return PromiseAll(this);\\n}\\n\\nfunction PromiseMapSeries(promises, fn) {\\n    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);\\n}\\n\\nPromise.prototype.each = function (fn) {\\n    return PromiseReduce(this, fn, INTERNAL, 0)\\n              ._then(promiseAllThis, undefined, undefined, this, undefined);\\n};\\n\\nPromise.prototype.mapSeries = function (fn) {\\n    return PromiseReduce(this, fn, INTERNAL, INTERNAL);\\n};\\n\\nPromise.each = function (promises, fn) {\\n    return PromiseReduce(promises, fn, INTERNAL, 0)\\n              ._then(promiseAllThis, undefined, undefined, promises, undefined);\\n};\\n\\nPromise.mapSeries = PromiseMapSeries;\\n};\\n\\n\\n},{}],12:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nvar es5 = _dereq_(\\\"./es5\\\");\\nvar Objectfreeze = es5.freeze;\\nvar util = _dereq_(\\\"./util\\\");\\nvar inherits = util.inherits;\\nvar notEnumerableProp = util.notEnumerableProp;\\n\\nfunction subError(nameProperty, defaultMessage) {\\n    function SubError(message) {\\n        if (!(this instanceof SubError)) return new SubError(message);\\n        notEnumerableProp(this, \\\"message\\\",\\n            typeof message === \\\"string\\\" ? message : defaultMessage);\\n        notEnumerableProp(this, \\\"name\\\", nameProperty);\\n        if (Error.captureStackTrace) {\\n            Error.captureStackTrace(this, this.constructor);\\n        } else {\\n            Error.call(this);\\n        }\\n    }\\n    inherits(SubError, Error);\\n    return SubError;\\n}\\n\\nvar _TypeError, _RangeError;\\nvar Warning = subError(\\\"Warning\\\", \\\"warning\\\");\\nvar CancellationError = subError(\\\"CancellationError\\\", \\\"cancellation error\\\");\\nvar TimeoutError = subError(\\\"TimeoutError\\\", \\\"timeout error\\\");\\nvar AggregateError = subError(\\\"AggregateError\\\", \\\"aggregate error\\\");\\ntry {\\n    _TypeError = TypeError;\\n    _RangeError = RangeError;\\n} catch(e) {\\n    _TypeError = subError(\\\"TypeError\\\", \\\"type error\\\");\\n    _RangeError = subError(\\\"RangeError\\\", \\\"range error\\\");\\n}\\n\\nvar methods = (\\\"join pop push shift unshift slice filter forEach some \\\" +\\n    \\\"every map indexOf lastIndexOf reduce reduceRight sort reverse\\\").split(\\\" \\\");\\n\\nfor (var i = 0; i < methods.length; ++i) {\\n    if (typeof Array.prototype[methods[i]] === \\\"function\\\") {\\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\\n    }\\n}\\n\\nes5.defineProperty(AggregateError.prototype, \\\"length\\\", {\\n    value: 0,\\n    configurable: false,\\n    writable: true,\\n    enumerable: true\\n});\\nAggregateError.prototype[\\\"isOperational\\\"] = true;\\nvar level = 0;\\nAggregateError.prototype.toString = function() {\\n    var indent = Array(level * 4 + 1).join(\\\" \\\");\\n    var ret = \\\"\\\\n\\\" + indent + \\\"AggregateError of:\\\" + \\\"\\\\n\\\";\\n    level++;\\n    indent = Array(level * 4 + 1).join(\\\" \\\");\\n    for (var i = 0; i < this.length; ++i) {\\n        var str = this[i] === this ? \\\"[Circular AggregateError]\\\" : this[i] + \\\"\\\";\\n        var lines = str.split(\\\"\\\\n\\\");\\n        for (var j = 0; j < lines.length; ++j) {\\n            lines[j] = indent + lines[j];\\n        }\\n        str = lines.join(\\\"\\\\n\\\");\\n        ret += str + \\\"\\\\n\\\";\\n    }\\n    level--;\\n    return ret;\\n};\\n\\nfunction OperationalError(message) {\\n    if (!(this instanceof OperationalError))\\n        return new OperationalError(message);\\n    notEnumerableProp(this, \\\"name\\\", \\\"OperationalError\\\");\\n    notEnumerableProp(this, \\\"message\\\", message);\\n    this.cause = message;\\n    this[\\\"isOperational\\\"] = true;\\n\\n    if (message instanceof Error) {\\n        notEnumerableProp(this, \\\"message\\\", message.message);\\n        notEnumerableProp(this, \\\"stack\\\", message.stack);\\n    } else if (Error.captureStackTrace) {\\n        Error.captureStackTrace(this, this.constructor);\\n    }\\n\\n}\\ninherits(OperationalError, Error);\\n\\nvar errorTypes = Error[\\\"__BluebirdErrorTypes__\\\"];\\nif (!errorTypes) {\\n    errorTypes = Objectfreeze({\\n        CancellationError: CancellationError,\\n        TimeoutError: TimeoutError,\\n        OperationalError: OperationalError,\\n        RejectionError: OperationalError,\\n        AggregateError: AggregateError\\n    });\\n    es5.defineProperty(Error, \\\"__BluebirdErrorTypes__\\\", {\\n        value: errorTypes,\\n        writable: false,\\n        enumerable: false,\\n        configurable: false\\n    });\\n}\\n\\nmodule.exports = {\\n    Error: Error,\\n    TypeError: _TypeError,\\n    RangeError: _RangeError,\\n    CancellationError: errorTypes.CancellationError,\\n    OperationalError: errorTypes.OperationalError,\\n    TimeoutError: errorTypes.TimeoutError,\\n    AggregateError: errorTypes.AggregateError,\\n    Warning: Warning\\n};\\n\\n},{\\\"./es5\\\":13,\\\"./util\\\":36}],13:[function(_dereq_,module,exports){\\nvar isES5 = (function(){\\n    \\\"use strict\\\";\\n    return this === undefined;\\n})();\\n\\nif (isES5) {\\n    module.exports = {\\n        freeze: Object.freeze,\\n        defineProperty: Object.defineProperty,\\n        getDescriptor: Object.getOwnPropertyDescriptor,\\n        keys: Object.keys,\\n        names: Object.getOwnPropertyNames,\\n        getPrototypeOf: Object.getPrototypeOf,\\n        isArray: Array.isArray,\\n        isES5: isES5,\\n        propertyIsWritable: function(obj, prop) {\\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\\n            return !!(!descriptor || descriptor.writable || descriptor.set);\\n        }\\n    };\\n} else {\\n    var has = {}.hasOwnProperty;\\n    var str = {}.toString;\\n    var proto = {}.constructor.prototype;\\n\\n    var ObjectKeys = function (o) {\\n        var ret = [];\\n        for (var key in o) {\\n            if (has.call(o, key)) {\\n                ret.push(key);\\n            }\\n        }\\n        return ret;\\n    };\\n\\n    var ObjectGetDescriptor = function(o, key) {\\n        return {value: o[key]};\\n    };\\n\\n    var ObjectDefineProperty = function (o, key, desc) {\\n        o[key] = desc.value;\\n        return o;\\n    };\\n\\n    var ObjectFreeze = function (obj) {\\n        return obj;\\n    };\\n\\n    var ObjectGetPrototypeOf = function (obj) {\\n        try {\\n            return Object(obj).constructor.prototype;\\n        }\\n        catch (e) {\\n            return proto;\\n        }\\n    };\\n\\n    var ArrayIsArray = function (obj) {\\n        try {\\n            return str.call(obj) === \\\"[object Array]\\\";\\n        }\\n        catch(e) {\\n            return false;\\n        }\\n    };\\n\\n    module.exports = {\\n        isArray: ArrayIsArray,\\n        keys: ObjectKeys,\\n        names: ObjectKeys,\\n        defineProperty: ObjectDefineProperty,\\n        getDescriptor: ObjectGetDescriptor,\\n        freeze: ObjectFreeze,\\n        getPrototypeOf: ObjectGetPrototypeOf,\\n        isES5: isES5,\\n        propertyIsWritable: function() {\\n            return true;\\n        }\\n    };\\n}\\n\\n},{}],14:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise, INTERNAL) {\\nvar PromiseMap = Promise.map;\\n\\nPromise.prototype.filter = function (fn, options) {\\n    return PromiseMap(this, fn, options, INTERNAL);\\n};\\n\\nPromise.filter = function (promises, fn, options) {\\n    return PromiseMap(promises, fn, options, INTERNAL);\\n};\\n};\\n\\n},{}],15:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar CancellationError = Promise.CancellationError;\\nvar errorObj = util.errorObj;\\nvar catchFilter = _dereq_(\\\"./catch_filter\\\")(NEXT_FILTER);\\n\\nfunction PassThroughHandlerContext(promise, type, handler) {\\n    this.promise = promise;\\n    this.type = type;\\n    this.handler = handler;\\n    this.called = false;\\n    this.cancelPromise = null;\\n}\\n\\nPassThroughHandlerContext.prototype.isFinallyHandler = function() {\\n    return this.type === 0;\\n};\\n\\nfunction FinallyHandlerCancelReaction(finallyHandler) {\\n    this.finallyHandler = finallyHandler;\\n}\\n\\nFinallyHandlerCancelReaction.prototype._resultCancelled = function() {\\n    checkCancel(this.finallyHandler);\\n};\\n\\nfunction checkCancel(ctx, reason) {\\n    if (ctx.cancelPromise != null) {\\n        if (arguments.length > 1) {\\n            ctx.cancelPromise._reject(reason);\\n        } else {\\n            ctx.cancelPromise._cancel();\\n        }\\n        ctx.cancelPromise = null;\\n        return true;\\n    }\\n    return false;\\n}\\n\\nfunction succeed() {\\n    return finallyHandler.call(this, this.promise._target()._settledValue());\\n}\\nfunction fail(reason) {\\n    if (checkCancel(this, reason)) return;\\n    errorObj.e = reason;\\n    return errorObj;\\n}\\nfunction finallyHandler(reasonOrValue) {\\n    var promise = this.promise;\\n    var handler = this.handler;\\n\\n    if (!this.called) {\\n        this.called = true;\\n        var ret = this.isFinallyHandler()\\n            ? handler.call(promise._boundValue())\\n            : handler.call(promise._boundValue(), reasonOrValue);\\n        if (ret === NEXT_FILTER) {\\n            return ret;\\n        } else if (ret !== undefined) {\\n            promise._setReturnedNonUndefined();\\n            var maybePromise = tryConvertToPromise(ret, promise);\\n            if (maybePromise instanceof Promise) {\\n                if (this.cancelPromise != null) {\\n                    if (maybePromise._isCancelled()) {\\n                        var reason =\\n                            new CancellationError(\\\"late cancellation observer\\\");\\n                        promise._attachExtraTrace(reason);\\n                        errorObj.e = reason;\\n                        return errorObj;\\n                    } else if (maybePromise.isPending()) {\\n                        maybePromise._attachCancellationCallback(\\n                            new FinallyHandlerCancelReaction(this));\\n                    }\\n                }\\n                return maybePromise._then(\\n                    succeed, fail, undefined, this, undefined);\\n            }\\n        }\\n    }\\n\\n    if (promise.isRejected()) {\\n        checkCancel(this);\\n        errorObj.e = reasonOrValue;\\n        return errorObj;\\n    } else {\\n        checkCancel(this);\\n        return reasonOrValue;\\n    }\\n}\\n\\nPromise.prototype._passThrough = function(handler, type, success, fail) {\\n    if (typeof handler !== \\\"function\\\") return this.then();\\n    return this._then(success,\\n                      fail,\\n                      undefined,\\n                      new PassThroughHandlerContext(this, type, handler),\\n                      undefined);\\n};\\n\\nPromise.prototype.lastly =\\nPromise.prototype[\\\"finally\\\"] = function (handler) {\\n    return this._passThrough(handler,\\n                             0,\\n                             finallyHandler,\\n                             finallyHandler);\\n};\\n\\n\\nPromise.prototype.tap = function (handler) {\\n    return this._passThrough(handler, 1, finallyHandler);\\n};\\n\\nPromise.prototype.tapCatch = function (handlerOrPredicate) {\\n    var len = arguments.length;\\n    if(len === 1) {\\n        return this._passThrough(handlerOrPredicate,\\n                                 1,\\n                                 undefined,\\n                                 finallyHandler);\\n    } else {\\n         var catchInstances = new Array(len - 1),\\n            j = 0, i;\\n        for (i = 0; i < len - 1; ++i) {\\n            var item = arguments[i];\\n            if (util.isObject(item)) {\\n                catchInstances[j++] = item;\\n            } else {\\n                return Promise.reject(new TypeError(\\n                    \\\"tapCatch statement predicate: \\\"\\n                    + \\\"expecting an object but got \\\" + util.classString(item)\\n                ));\\n            }\\n        }\\n        catchInstances.length = j;\\n        var handler = arguments[i];\\n        return this._passThrough(catchFilter(catchInstances, handler, this),\\n                                 1,\\n                                 undefined,\\n                                 finallyHandler);\\n    }\\n\\n};\\n\\nreturn PassThroughHandlerContext;\\n};\\n\\n},{\\\"./catch_filter\\\":7,\\\"./util\\\":36}],16:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise,\\n                          apiRejection,\\n                          INTERNAL,\\n                          tryConvertToPromise,\\n                          Proxyable,\\n                          debug) {\\nvar errors = _dereq_(\\\"./errors\\\");\\nvar TypeError = errors.TypeError;\\nvar util = _dereq_(\\\"./util\\\");\\nvar errorObj = util.errorObj;\\nvar tryCatch = util.tryCatch;\\nvar yieldHandlers = [];\\n\\nfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\\n    for (var i = 0; i < yieldHandlers.length; ++i) {\\n        traceParent._pushContext();\\n        var result = tryCatch(yieldHandlers[i])(value);\\n        traceParent._popContext();\\n        if (result === errorObj) {\\n            traceParent._pushContext();\\n            var ret = Promise.reject(errorObj.e);\\n            traceParent._popContext();\\n            return ret;\\n        }\\n        var maybePromise = tryConvertToPromise(result, traceParent);\\n        if (maybePromise instanceof Promise) return maybePromise;\\n    }\\n    return null;\\n}\\n\\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\\n    if (debug.cancellation()) {\\n        var internal = new Promise(INTERNAL);\\n        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);\\n        this._promise = internal.lastly(function() {\\n            return _finallyPromise;\\n        });\\n        internal._captureStackTrace();\\n        internal._setOnCancel(this);\\n    } else {\\n        var promise = this._promise = new Promise(INTERNAL);\\n        promise._captureStackTrace();\\n    }\\n    this._stack = stack;\\n    this._generatorFunction = generatorFunction;\\n    this._receiver = receiver;\\n    this._generator = undefined;\\n    this._yieldHandlers = typeof yieldHandler === \\\"function\\\"\\n        ? [yieldHandler].concat(yieldHandlers)\\n        : yieldHandlers;\\n    this._yieldedPromise = null;\\n    this._cancellationPhase = false;\\n}\\nutil.inherits(PromiseSpawn, Proxyable);\\n\\nPromiseSpawn.prototype._isResolved = function() {\\n    return this._promise === null;\\n};\\n\\nPromiseSpawn.prototype._cleanup = function() {\\n    this._promise = this._generator = null;\\n    if (debug.cancellation() && this._finallyPromise !== null) {\\n        this._finallyPromise._fulfill();\\n        this._finallyPromise = null;\\n    }\\n};\\n\\nPromiseSpawn.prototype._promiseCancelled = function() {\\n    if (this._isResolved()) return;\\n    var implementsReturn = typeof this._generator[\\\"return\\\"] !== \\\"undefined\\\";\\n\\n    var result;\\n    if (!implementsReturn) {\\n        var reason = new Promise.CancellationError(\\n            \\\"generator .return() sentinel\\\");\\n        Promise.coroutine.returnSentinel = reason;\\n        this._promise._attachExtraTrace(reason);\\n        this._promise._pushContext();\\n        result = tryCatch(this._generator[\\\"throw\\\"]).call(this._generator,\\n                                                         reason);\\n        this._promise._popContext();\\n    } else {\\n        this._promise._pushContext();\\n        result = tryCatch(this._generator[\\\"return\\\"]).call(this._generator,\\n                                                          undefined);\\n        this._promise._popContext();\\n    }\\n    this._cancellationPhase = true;\\n    this._yieldedPromise = null;\\n    this._continue(result);\\n};\\n\\nPromiseSpawn.prototype._promiseFulfilled = function(value) {\\n    this._yieldedPromise = null;\\n    this._promise._pushContext();\\n    var result = tryCatch(this._generator.next).call(this._generator, value);\\n    this._promise._popContext();\\n    this._continue(result);\\n};\\n\\nPromiseSpawn.prototype._promiseRejected = function(reason) {\\n    this._yieldedPromise = null;\\n    this._promise._attachExtraTrace(reason);\\n    this._promise._pushContext();\\n    var result = tryCatch(this._generator[\\\"throw\\\"])\\n        .call(this._generator, reason);\\n    this._promise._popContext();\\n    this._continue(result);\\n};\\n\\nPromiseSpawn.prototype._resultCancelled = function() {\\n    if (this._yieldedPromise instanceof Promise) {\\n        var promise = this._yieldedPromise;\\n        this._yieldedPromise = null;\\n        promise.cancel();\\n    }\\n};\\n\\nPromiseSpawn.prototype.promise = function () {\\n    return this._promise;\\n};\\n\\nPromiseSpawn.prototype._run = function () {\\n    this._generator = this._generatorFunction.call(this._receiver);\\n    this._receiver =\\n        this._generatorFunction = undefined;\\n    this._promiseFulfilled(undefined);\\n};\\n\\nPromiseSpawn.prototype._continue = function (result) {\\n    var promise = this._promise;\\n    if (result === errorObj) {\\n        this._cleanup();\\n        if (this._cancellationPhase) {\\n            return promise.cancel();\\n        } else {\\n            return promise._rejectCallback(result.e, false);\\n        }\\n    }\\n\\n    var value = result.value;\\n    if (result.done === true) {\\n        this._cleanup();\\n        if (this._cancellationPhase) {\\n            return promise.cancel();\\n        } else {\\n            return promise._resolveCallback(value);\\n        }\\n    } else {\\n        var maybePromise = tryConvertToPromise(value, this._promise);\\n        if (!(maybePromise instanceof Promise)) {\\n            maybePromise =\\n                promiseFromYieldHandler(maybePromise,\\n                                        this._yieldHandlers,\\n                                        this._promise);\\n            if (maybePromise === null) {\\n                this._promiseRejected(\\n                    new TypeError(\\n                        \\\"A value %s was yielded that could not be treated as a promise\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\\u000a\\\".replace(\\\"%s\\\", String(value)) +\\n                        \\\"From coroutine:\\\\u000a\\\" +\\n                        this._stack.split(\\\"\\\\n\\\").slice(1, -7).join(\\\"\\\\n\\\")\\n                    )\\n                );\\n                return;\\n            }\\n        }\\n        maybePromise = maybePromise._target();\\n        var bitField = maybePromise._bitField;\\n        ;\\n        if (((bitField & 50397184) === 0)) {\\n            this._yieldedPromise = maybePromise;\\n            maybePromise._proxy(this, null);\\n        } else if (((bitField & 33554432) !== 0)) {\\n            Promise._async.invoke(\\n                this._promiseFulfilled, this, maybePromise._value()\\n            );\\n        } else if (((bitField & 16777216) !== 0)) {\\n            Promise._async.invoke(\\n                this._promiseRejected, this, maybePromise._reason()\\n            );\\n        } else {\\n            this._promiseCancelled();\\n        }\\n    }\\n};\\n\\nPromise.coroutine = function (generatorFunction, options) {\\n    if (typeof generatorFunction !== \\\"function\\\") {\\n        throw new TypeError(\\\"generatorFunction must be a function\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    }\\n    var yieldHandler = Object(options).yieldHandler;\\n    var PromiseSpawn$ = PromiseSpawn;\\n    var stack = new Error().stack;\\n    return function () {\\n        var generator = generatorFunction.apply(this, arguments);\\n        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\\n                                      stack);\\n        var ret = spawn.promise();\\n        spawn._generator = generator;\\n        spawn._promiseFulfilled(undefined);\\n        return ret;\\n    };\\n};\\n\\nPromise.coroutine.addYieldHandler = function(fn) {\\n    if (typeof fn !== \\\"function\\\") {\\n        throw new TypeError(\\\"expecting a function but got \\\" + util.classString(fn));\\n    }\\n    yieldHandlers.push(fn);\\n};\\n\\nPromise.spawn = function (generatorFunction) {\\n    debug.deprecated(\\\"Promise.spawn()\\\", \\\"Promise.coroutine()\\\");\\n    if (typeof generatorFunction !== \\\"function\\\") {\\n        return apiRejection(\\\"generatorFunction must be a function\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    }\\n    var spawn = new PromiseSpawn(generatorFunction, this);\\n    var ret = spawn.promise();\\n    spawn._run(Promise.spawn);\\n    return ret;\\n};\\n};\\n\\n},{\\\"./errors\\\":12,\\\"./util\\\":36}],17:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports =\\nfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,\\n         getDomain) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar canEvaluate = util.canEvaluate;\\nvar tryCatch = util.tryCatch;\\nvar errorObj = util.errorObj;\\nvar reject;\\n\\nif (false) {\\nif (canEvaluate) {\\n    var thenCallback = function(i) {\\n        return new Function(\\\"value\\\", \\\"holder\\\", \\\"                             \\\\n\\\\\\n            'use strict';                                                    \\\\n\\\\\\n            holder.pIndex = value;                                           \\\\n\\\\\\n            holder.checkFulfillment(this);                                   \\\\n\\\\\\n            \\\".replace(/Index/g, i));\\n    };\\n\\n    var promiseSetter = function(i) {\\n        return new Function(\\\"promise\\\", \\\"holder\\\", \\\"                           \\\\n\\\\\\n            'use strict';                                                    \\\\n\\\\\\n            holder.pIndex = promise;                                         \\\\n\\\\\\n            \\\".replace(/Index/g, i));\\n    };\\n\\n    var generateHolderClass = function(total) {\\n        var props = new Array(total);\\n        for (var i = 0; i < props.length; ++i) {\\n            props[i] = \\\"this.p\\\" + (i+1);\\n        }\\n        var assignment = props.join(\\\" = \\\") + \\\" = null;\\\";\\n        var cancellationCode= \\\"var promise;\\\\n\\\" + props.map(function(prop) {\\n            return \\\"                                                         \\\\n\\\\\\n                promise = \\\" + prop + \\\";                                      \\\\n\\\\\\n                if (promise instanceof Promise) {                            \\\\n\\\\\\n                    promise.cancel();                                        \\\\n\\\\\\n                }                                                            \\\\n\\\\\\n            \\\";\\n        }).join(\\\"\\\\n\\\");\\n        var passedArguments = props.join(\\\", \\\");\\n        var name = \\\"Holder$\\\" + total;\\n\\n\\n        var code = \\\"return function(tryCatch, errorObj, Promise, async) {    \\\\n\\\\\\n            'use strict';                                                    \\\\n\\\\\\n            function [TheName](fn) {                                         \\\\n\\\\\\n                [TheProperties]                                              \\\\n\\\\\\n                this.fn = fn;                                                \\\\n\\\\\\n                this.asyncNeeded = true;                                     \\\\n\\\\\\n                this.now = 0;                                                \\\\n\\\\\\n            }                                                                \\\\n\\\\\\n                                                                             \\\\n\\\\\\n            [TheName].prototype._callFunction = function(promise) {          \\\\n\\\\\\n                promise._pushContext();                                      \\\\n\\\\\\n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \\\\n\\\\\\n                promise._popContext();                                       \\\\n\\\\\\n                if (ret === errorObj) {                                      \\\\n\\\\\\n                    promise._rejectCallback(ret.e, false);                   \\\\n\\\\\\n                } else {                                                     \\\\n\\\\\\n                    promise._resolveCallback(ret);                           \\\\n\\\\\\n                }                                                            \\\\n\\\\\\n            };                                                               \\\\n\\\\\\n                                                                             \\\\n\\\\\\n            [TheName].prototype.checkFulfillment = function(promise) {       \\\\n\\\\\\n                var now = ++this.now;                                        \\\\n\\\\\\n                if (now === [TheTotal]) {                                    \\\\n\\\\\\n                    if (this.asyncNeeded) {                                  \\\\n\\\\\\n                        async.invoke(this._callFunction, this, promise);     \\\\n\\\\\\n                    } else {                                                 \\\\n\\\\\\n                        this._callFunction(promise);                         \\\\n\\\\\\n                    }                                                        \\\\n\\\\\\n                                                                             \\\\n\\\\\\n                }                                                            \\\\n\\\\\\n            };                                                               \\\\n\\\\\\n                                                                             \\\\n\\\\\\n            [TheName].prototype._resultCancelled = function() {              \\\\n\\\\\\n                [CancellationCode]                                           \\\\n\\\\\\n            };                                                               \\\\n\\\\\\n                                                                             \\\\n\\\\\\n            return [TheName];                                                \\\\n\\\\\\n        }(tryCatch, errorObj, Promise, async);                               \\\\n\\\\\\n        \\\";\\n\\n        code = code.replace(/\\\\[TheName\\\\]/g, name)\\n            .replace(/\\\\[TheTotal\\\\]/g, total)\\n            .replace(/\\\\[ThePassedArguments\\\\]/g, passedArguments)\\n            .replace(/\\\\[TheProperties\\\\]/g, assignment)\\n            .replace(/\\\\[CancellationCode\\\\]/g, cancellationCode);\\n\\n        return new Function(\\\"tryCatch\\\", \\\"errorObj\\\", \\\"Promise\\\", \\\"async\\\", code)\\n                           (tryCatch, errorObj, Promise, async);\\n    };\\n\\n    var holderClasses = [];\\n    var thenCallbacks = [];\\n    var promiseSetters = [];\\n\\n    for (var i = 0; i < 8; ++i) {\\n        holderClasses.push(generateHolderClass(i + 1));\\n        thenCallbacks.push(thenCallback(i + 1));\\n        promiseSetters.push(promiseSetter(i + 1));\\n    }\\n\\n    reject = function (reason) {\\n        this._reject(reason);\\n    };\\n}}\\n\\nPromise.join = function () {\\n    var last = arguments.length - 1;\\n    var fn;\\n    if (last > 0 && typeof arguments[last] === \\\"function\\\") {\\n        fn = arguments[last];\\n        if (false) {\\n            if (last <= 8 && canEvaluate) {\\n                var ret = new Promise(INTERNAL);\\n                ret._captureStackTrace();\\n                var HolderClass = holderClasses[last - 1];\\n                var holder = new HolderClass(fn);\\n                var callbacks = thenCallbacks;\\n\\n                for (var i = 0; i < last; ++i) {\\n                    var maybePromise = tryConvertToPromise(arguments[i], ret);\\n                    if (maybePromise instanceof Promise) {\\n                        maybePromise = maybePromise._target();\\n                        var bitField = maybePromise._bitField;\\n                        ;\\n                        if (((bitField & 50397184) === 0)) {\\n                            maybePromise._then(callbacks[i], reject,\\n                                               undefined, ret, holder);\\n                            promiseSetters[i](maybePromise, holder);\\n                            holder.asyncNeeded = false;\\n                        } else if (((bitField & 33554432) !== 0)) {\\n                            callbacks[i].call(ret,\\n                                              maybePromise._value(), holder);\\n                        } else if (((bitField & 16777216) !== 0)) {\\n                            ret._reject(maybePromise._reason());\\n                        } else {\\n                            ret._cancel();\\n                        }\\n                    } else {\\n                        callbacks[i].call(ret, maybePromise, holder);\\n                    }\\n                }\\n\\n                if (!ret._isFateSealed()) {\\n                    if (holder.asyncNeeded) {\\n                        var domain = getDomain();\\n                        if (domain !== null) {\\n                            holder.fn = util.domainBind(domain, holder.fn);\\n                        }\\n                    }\\n                    ret._setAsyncGuaranteed();\\n                    ret._setOnCancel(holder);\\n                }\\n                return ret;\\n            }\\n        }\\n    }\\n    var args = [].slice.call(arguments);;\\n    if (fn) args.pop();\\n    var ret = new PromiseArray(args).promise();\\n    return fn !== undefined ? ret.spread(fn) : ret;\\n};\\n\\n};\\n\\n},{\\\"./util\\\":36}],18:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise,\\n                          PromiseArray,\\n                          apiRejection,\\n                          tryConvertToPromise,\\n                          INTERNAL,\\n                          debug) {\\nvar getDomain = Promise._getDomain;\\nvar util = _dereq_(\\\"./util\\\");\\nvar tryCatch = util.tryCatch;\\nvar errorObj = util.errorObj;\\nvar async = Promise._async;\\n\\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\\n    this.constructor$(promises);\\n    this._promise._captureStackTrace();\\n    var domain = getDomain();\\n    this._callback = domain === null ? fn : util.domainBind(domain, fn);\\n    this._preservedValues = _filter === INTERNAL\\n        ? new Array(this.length())\\n        : null;\\n    this._limit = limit;\\n    this._inFlight = 0;\\n    this._queue = [];\\n    async.invoke(this._asyncInit, this, undefined);\\n}\\nutil.inherits(MappingPromiseArray, PromiseArray);\\n\\nMappingPromiseArray.prototype._asyncInit = function() {\\n    this._init$(undefined, -2);\\n};\\n\\nMappingPromiseArray.prototype._init = function () {};\\n\\nMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\\n    var values = this._values;\\n    var length = this.length();\\n    var preservedValues = this._preservedValues;\\n    var limit = this._limit;\\n\\n    if (index < 0) {\\n        index = (index * -1) - 1;\\n        values[index] = value;\\n        if (limit >= 1) {\\n            this._inFlight--;\\n            this._drainQueue();\\n            if (this._isResolved()) return true;\\n        }\\n    } else {\\n        if (limit >= 1 && this._inFlight >= limit) {\\n            values[index] = value;\\n            this._queue.push(index);\\n            return false;\\n        }\\n        if (preservedValues !== null) preservedValues[index] = value;\\n\\n        var promise = this._promise;\\n        var callback = this._callback;\\n        var receiver = promise._boundValue();\\n        promise._pushContext();\\n        var ret = tryCatch(callback).call(receiver, value, index, length);\\n        var promiseCreated = promise._popContext();\\n        debug.checkForgottenReturns(\\n            ret,\\n            promiseCreated,\\n            preservedValues !== null ? \\\"Promise.filter\\\" : \\\"Promise.map\\\",\\n            promise\\n        );\\n        if (ret === errorObj) {\\n            this._reject(ret.e);\\n            return true;\\n        }\\n\\n        var maybePromise = tryConvertToPromise(ret, this._promise);\\n        if (maybePromise instanceof Promise) {\\n            maybePromise = maybePromise._target();\\n            var bitField = maybePromise._bitField;\\n            ;\\n            if (((bitField & 50397184) === 0)) {\\n                if (limit >= 1) this._inFlight++;\\n                values[index] = maybePromise;\\n                maybePromise._proxy(this, (index + 1) * -1);\\n                return false;\\n            } else if (((bitField & 33554432) !== 0)) {\\n                ret = maybePromise._value();\\n            } else if (((bitField & 16777216) !== 0)) {\\n                this._reject(maybePromise._reason());\\n                return true;\\n            } else {\\n                this._cancel();\\n                return true;\\n            }\\n        }\\n        values[index] = ret;\\n    }\\n    var totalResolved = ++this._totalResolved;\\n    if (totalResolved >= length) {\\n        if (preservedValues !== null) {\\n            this._filter(values, preservedValues);\\n        } else {\\n            this._resolve(values);\\n        }\\n        return true;\\n    }\\n    return false;\\n};\\n\\nMappingPromiseArray.prototype._drainQueue = function () {\\n    var queue = this._queue;\\n    var limit = this._limit;\\n    var values = this._values;\\n    while (queue.length > 0 && this._inFlight < limit) {\\n        if (this._isResolved()) return;\\n        var index = queue.pop();\\n        this._promiseFulfilled(values[index], index);\\n    }\\n};\\n\\nMappingPromiseArray.prototype._filter = function (booleans, values) {\\n    var len = values.length;\\n    var ret = new Array(len);\\n    var j = 0;\\n    for (var i = 0; i < len; ++i) {\\n        if (booleans[i]) ret[j++] = values[i];\\n    }\\n    ret.length = j;\\n    this._resolve(ret);\\n};\\n\\nMappingPromiseArray.prototype.preservedValues = function () {\\n    return this._preservedValues;\\n};\\n\\nfunction map(promises, fn, options, _filter) {\\n    if (typeof fn !== \\\"function\\\") {\\n        return apiRejection(\\\"expecting a function but got \\\" + util.classString(fn));\\n    }\\n\\n    var limit = 0;\\n    if (options !== undefined) {\\n        if (typeof options === \\\"object\\\" && options !== null) {\\n            if (typeof options.concurrency !== \\\"number\\\") {\\n                return Promise.reject(\\n                    new TypeError(\\\"'concurrency' must be a number but it is \\\" +\\n                                    util.classString(options.concurrency)));\\n            }\\n            limit = options.concurrency;\\n        } else {\\n            return Promise.reject(new TypeError(\\n                            \\\"options argument must be an object but it is \\\" +\\n                             util.classString(options)));\\n        }\\n    }\\n    limit = typeof limit === \\\"number\\\" &&\\n        isFinite(limit) && limit >= 1 ? limit : 0;\\n    return new MappingPromiseArray(promises, fn, limit, _filter).promise();\\n}\\n\\nPromise.prototype.map = function (fn, options) {\\n    return map(this, fn, options, null);\\n};\\n\\nPromise.map = function (promises, fn, options, _filter) {\\n    return map(promises, fn, options, _filter);\\n};\\n\\n\\n};\\n\\n},{\\\"./util\\\":36}],19:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports =\\nfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar tryCatch = util.tryCatch;\\n\\nPromise.method = function (fn) {\\n    if (typeof fn !== \\\"function\\\") {\\n        throw new Promise.TypeError(\\\"expecting a function but got \\\" + util.classString(fn));\\n    }\\n    return function () {\\n        var ret = new Promise(INTERNAL);\\n        ret._captureStackTrace();\\n        ret._pushContext();\\n        var value = tryCatch(fn).apply(this, arguments);\\n        var promiseCreated = ret._popContext();\\n        debug.checkForgottenReturns(\\n            value, promiseCreated, \\\"Promise.method\\\", ret);\\n        ret._resolveFromSyncValue(value);\\n        return ret;\\n    };\\n};\\n\\nPromise.attempt = Promise[\\\"try\\\"] = function (fn) {\\n    if (typeof fn !== \\\"function\\\") {\\n        return apiRejection(\\\"expecting a function but got \\\" + util.classString(fn));\\n    }\\n    var ret = new Promise(INTERNAL);\\n    ret._captureStackTrace();\\n    ret._pushContext();\\n    var value;\\n    if (arguments.length > 1) {\\n        debug.deprecated(\\\"calling Promise.try with more than 1 argument\\\");\\n        var arg = arguments[1];\\n        var ctx = arguments[2];\\n        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)\\n                                  : tryCatch(fn).call(ctx, arg);\\n    } else {\\n        value = tryCatch(fn)();\\n    }\\n    var promiseCreated = ret._popContext();\\n    debug.checkForgottenReturns(\\n        value, promiseCreated, \\\"Promise.try\\\", ret);\\n    ret._resolveFromSyncValue(value);\\n    return ret;\\n};\\n\\nPromise.prototype._resolveFromSyncValue = function (value) {\\n    if (value === util.errorObj) {\\n        this._rejectCallback(value.e, false);\\n    } else {\\n        this._resolveCallback(value, true);\\n    }\\n};\\n};\\n\\n},{\\\"./util\\\":36}],20:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nvar util = _dereq_(\\\"./util\\\");\\nvar maybeWrapAsError = util.maybeWrapAsError;\\nvar errors = _dereq_(\\\"./errors\\\");\\nvar OperationalError = errors.OperationalError;\\nvar es5 = _dereq_(\\\"./es5\\\");\\n\\nfunction isUntypedError(obj) {\\n    return obj instanceof Error &&\\n        es5.getPrototypeOf(obj) === Error.prototype;\\n}\\n\\nvar rErrorKey = /^(?:name|message|stack|cause)$/;\\nfunction wrapAsOperationalError(obj) {\\n    var ret;\\n    if (isUntypedError(obj)) {\\n        ret = new OperationalError(obj);\\n        ret.name = obj.name;\\n        ret.message = obj.message;\\n        ret.stack = obj.stack;\\n        var keys = es5.keys(obj);\\n        for (var i = 0; i < keys.length; ++i) {\\n            var key = keys[i];\\n            if (!rErrorKey.test(key)) {\\n                ret[key] = obj[key];\\n            }\\n        }\\n        return ret;\\n    }\\n    util.markAsOriginatingFromRejection(obj);\\n    return obj;\\n}\\n\\nfunction nodebackForPromise(promise, multiArgs) {\\n    return function(err, value) {\\n        if (promise === null) return;\\n        if (err) {\\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\\n            promise._attachExtraTrace(wrapped);\\n            promise._reject(wrapped);\\n        } else if (!multiArgs) {\\n            promise._fulfill(value);\\n        } else {\\n            var args = [].slice.call(arguments, 1);;\\n            promise._fulfill(args);\\n        }\\n        promise = null;\\n    };\\n}\\n\\nmodule.exports = nodebackForPromise;\\n\\n},{\\\"./errors\\\":12,\\\"./es5\\\":13,\\\"./util\\\":36}],21:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar async = Promise._async;\\nvar tryCatch = util.tryCatch;\\nvar errorObj = util.errorObj;\\n\\nfunction spreadAdapter(val, nodeback) {\\n    var promise = this;\\n    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\\n    var ret =\\n        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\\n    if (ret === errorObj) {\\n        async.throwLater(ret.e);\\n    }\\n}\\n\\nfunction successAdapter(val, nodeback) {\\n    var promise = this;\\n    var receiver = promise._boundValue();\\n    var ret = val === undefined\\n        ? tryCatch(nodeback).call(receiver, null)\\n        : tryCatch(nodeback).call(receiver, null, val);\\n    if (ret === errorObj) {\\n        async.throwLater(ret.e);\\n    }\\n}\\nfunction errorAdapter(reason, nodeback) {\\n    var promise = this;\\n    if (!reason) {\\n        var newReason = new Error(reason + \\\"\\\");\\n        newReason.cause = reason;\\n        reason = newReason;\\n    }\\n    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\\n    if (ret === errorObj) {\\n        async.throwLater(ret.e);\\n    }\\n}\\n\\nPromise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,\\n                                                                     options) {\\n    if (typeof nodeback == \\\"function\\\") {\\n        var adapter = successAdapter;\\n        if (options !== undefined && Object(options).spread) {\\n            adapter = spreadAdapter;\\n        }\\n        this._then(\\n            adapter,\\n            errorAdapter,\\n            undefined,\\n            this,\\n            nodeback\\n        );\\n    }\\n    return this;\\n};\\n};\\n\\n},{\\\"./util\\\":36}],22:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function() {\\nvar makeSelfResolutionError = function () {\\n    return new TypeError(\\\"circular promise resolution chain\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n};\\nvar reflectHandler = function() {\\n    return new Promise.PromiseInspection(this._target());\\n};\\nvar apiRejection = function(msg) {\\n    return Promise.reject(new TypeError(msg));\\n};\\nfunction Proxyable() {}\\nvar UNDEFINED_BINDING = {};\\nvar util = _dereq_(\\\"./util\\\");\\n\\nvar getDomain;\\nif (util.isNode) {\\n    getDomain = function() {\\n        var ret = process.domain;\\n        if (ret === undefined) ret = null;\\n        return ret;\\n    };\\n} else {\\n    getDomain = function() {\\n        return null;\\n    };\\n}\\nutil.notEnumerableProp(Promise, \\\"_getDomain\\\", getDomain);\\n\\nvar es5 = _dereq_(\\\"./es5\\\");\\nvar Async = _dereq_(\\\"./async\\\");\\nvar async = new Async();\\nes5.defineProperty(Promise, \\\"_async\\\", {value: async});\\nvar errors = _dereq_(\\\"./errors\\\");\\nvar TypeError = Promise.TypeError = errors.TypeError;\\nPromise.RangeError = errors.RangeError;\\nvar CancellationError = Promise.CancellationError = errors.CancellationError;\\nPromise.TimeoutError = errors.TimeoutError;\\nPromise.OperationalError = errors.OperationalError;\\nPromise.RejectionError = errors.OperationalError;\\nPromise.AggregateError = errors.AggregateError;\\nvar INTERNAL = function(){};\\nvar APPLY = {};\\nvar NEXT_FILTER = {};\\nvar tryConvertToPromise = _dereq_(\\\"./thenables\\\")(Promise, INTERNAL);\\nvar PromiseArray =\\n    _dereq_(\\\"./promise_array\\\")(Promise, INTERNAL,\\n                               tryConvertToPromise, apiRejection, Proxyable);\\nvar Context = _dereq_(\\\"./context\\\")(Promise);\\n /*jshint unused:false*/\\nvar createContext = Context.create;\\nvar debug = _dereq_(\\\"./debuggability\\\")(Promise, Context);\\nvar CapturedTrace = debug.CapturedTrace;\\nvar PassThroughHandlerContext =\\n    _dereq_(\\\"./finally\\\")(Promise, tryConvertToPromise, NEXT_FILTER);\\nvar catchFilter = _dereq_(\\\"./catch_filter\\\")(NEXT_FILTER);\\nvar nodebackForPromise = _dereq_(\\\"./nodeback\\\");\\nvar errorObj = util.errorObj;\\nvar tryCatch = util.tryCatch;\\nfunction check(self, executor) {\\n    if (self == null || self.constructor !== Promise) {\\n        throw new TypeError(\\\"the promise constructor cannot be invoked directly\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    }\\n    if (typeof executor !== \\\"function\\\") {\\n        throw new TypeError(\\\"expecting a function but got \\\" + util.classString(executor));\\n    }\\n\\n}\\n\\nfunction Promise(executor) {\\n    if (executor !== INTERNAL) {\\n        check(this, executor);\\n    }\\n    this._bitField = 0;\\n    this._fulfillmentHandler0 = undefined;\\n    this._rejectionHandler0 = undefined;\\n    this._promise0 = undefined;\\n    this._receiver0 = undefined;\\n    this._resolveFromExecutor(executor);\\n    this._promiseCreated();\\n    this._fireEvent(\\\"promiseCreated\\\", this);\\n}\\n\\nPromise.prototype.toString = function () {\\n    return \\\"[object Promise]\\\";\\n};\\n\\nPromise.prototype.caught = Promise.prototype[\\\"catch\\\"] = function (fn) {\\n    var len = arguments.length;\\n    if (len > 1) {\\n        var catchInstances = new Array(len - 1),\\n            j = 0, i;\\n        for (i = 0; i < len - 1; ++i) {\\n            var item = arguments[i];\\n            if (util.isObject(item)) {\\n                catchInstances[j++] = item;\\n            } else {\\n                return apiRejection(\\\"Catch statement predicate: \\\" +\\n                    \\\"expecting an object but got \\\" + util.classString(item));\\n            }\\n        }\\n        catchInstances.length = j;\\n        fn = arguments[i];\\n        return this.then(undefined, catchFilter(catchInstances, fn, this));\\n    }\\n    return this.then(undefined, fn);\\n};\\n\\nPromise.prototype.reflect = function () {\\n    return this._then(reflectHandler,\\n        reflectHandler, undefined, this, undefined);\\n};\\n\\nPromise.prototype.then = function (didFulfill, didReject) {\\n    if (debug.warnings() && arguments.length > 0 &&\\n        typeof didFulfill !== \\\"function\\\" &&\\n        typeof didReject !== \\\"function\\\") {\\n        var msg = \\\".then() only accepts functions but was passed: \\\" +\\n                util.classString(didFulfill);\\n        if (arguments.length > 1) {\\n            msg += \\\", \\\" + util.classString(didReject);\\n        }\\n        this._warn(msg);\\n    }\\n    return this._then(didFulfill, didReject, undefined, undefined, undefined);\\n};\\n\\nPromise.prototype.done = function (didFulfill, didReject) {\\n    var promise =\\n        this._then(didFulfill, didReject, undefined, undefined, undefined);\\n    promise._setIsFinal();\\n};\\n\\nPromise.prototype.spread = function (fn) {\\n    if (typeof fn !== \\\"function\\\") {\\n        return apiRejection(\\\"expecting a function but got \\\" + util.classString(fn));\\n    }\\n    return this.all()._then(fn, undefined, undefined, APPLY, undefined);\\n};\\n\\nPromise.prototype.toJSON = function () {\\n    var ret = {\\n        isFulfilled: false,\\n        isRejected: false,\\n        fulfillmentValue: undefined,\\n        rejectionReason: undefined\\n    };\\n    if (this.isFulfilled()) {\\n        ret.fulfillmentValue = this.value();\\n        ret.isFulfilled = true;\\n    } else if (this.isRejected()) {\\n        ret.rejectionReason = this.reason();\\n        ret.isRejected = true;\\n    }\\n    return ret;\\n};\\n\\nPromise.prototype.all = function () {\\n    if (arguments.length > 0) {\\n        this._warn(\\\".all() was passed arguments but it does not take any\\\");\\n    }\\n    return new PromiseArray(this).promise();\\n};\\n\\nPromise.prototype.error = function (fn) {\\n    return this.caught(util.originatesFromRejection, fn);\\n};\\n\\nPromise.getNewLibraryCopy = module.exports;\\n\\nPromise.is = function (val) {\\n    return val instanceof Promise;\\n};\\n\\nPromise.fromNode = Promise.fromCallback = function(fn) {\\n    var ret = new Promise(INTERNAL);\\n    ret._captureStackTrace();\\n    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs\\n                                         : false;\\n    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));\\n    if (result === errorObj) {\\n        ret._rejectCallback(result.e, true);\\n    }\\n    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();\\n    return ret;\\n};\\n\\nPromise.all = function (promises) {\\n    return new PromiseArray(promises).promise();\\n};\\n\\nPromise.cast = function (obj) {\\n    var ret = tryConvertToPromise(obj);\\n    if (!(ret instanceof Promise)) {\\n        ret = new Promise(INTERNAL);\\n        ret._captureStackTrace();\\n        ret._setFulfilled();\\n        ret._rejectionHandler0 = obj;\\n    }\\n    return ret;\\n};\\n\\nPromise.resolve = Promise.fulfilled = Promise.cast;\\n\\nPromise.reject = Promise.rejected = function (reason) {\\n    var ret = new Promise(INTERNAL);\\n    ret._captureStackTrace();\\n    ret._rejectCallback(reason, true);\\n    return ret;\\n};\\n\\nPromise.setScheduler = function(fn) {\\n    if (typeof fn !== \\\"function\\\") {\\n        throw new TypeError(\\\"expecting a function but got \\\" + util.classString(fn));\\n    }\\n    return async.setScheduler(fn);\\n};\\n\\nPromise.prototype._then = function (\\n    didFulfill,\\n    didReject,\\n    _,    receiver,\\n    internalData\\n) {\\n    var haveInternalData = internalData !== undefined;\\n    var promise = haveInternalData ? internalData : new Promise(INTERNAL);\\n    var target = this._target();\\n    var bitField = target._bitField;\\n\\n    if (!haveInternalData) {\\n        promise._propagateFrom(this, 3);\\n        promise._captureStackTrace();\\n        if (receiver === undefined &&\\n            ((this._bitField & 2097152) !== 0)) {\\n            if (!((bitField & 50397184) === 0)) {\\n                receiver = this._boundValue();\\n            } else {\\n                receiver = target === this ? undefined : this._boundTo;\\n            }\\n        }\\n        this._fireEvent(\\\"promiseChained\\\", this, promise);\\n    }\\n\\n    var domain = getDomain();\\n    if (!((bitField & 50397184) === 0)) {\\n        var handler, value, settler = target._settlePromiseCtx;\\n        if (((bitField & 33554432) !== 0)) {\\n            value = target._rejectionHandler0;\\n            handler = didFulfill;\\n        } else if (((bitField & 16777216) !== 0)) {\\n            value = target._fulfillmentHandler0;\\n            handler = didReject;\\n            target._unsetRejectionIsUnhandled();\\n        } else {\\n            settler = target._settlePromiseLateCancellationObserver;\\n            value = new CancellationError(\\\"late cancellation observer\\\");\\n            target._attachExtraTrace(value);\\n            handler = didReject;\\n        }\\n\\n        async.invoke(settler, target, {\\n            handler: domain === null ? handler\\n                : (typeof handler === \\\"function\\\" &&\\n                    util.domainBind(domain, handler)),\\n            promise: promise,\\n            receiver: receiver,\\n            value: value\\n        });\\n    } else {\\n        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);\\n    }\\n\\n    return promise;\\n};\\n\\nPromise.prototype._length = function () {\\n    return this._bitField & 65535;\\n};\\n\\nPromise.prototype._isFateSealed = function () {\\n    return (this._bitField & 117506048) !== 0;\\n};\\n\\nPromise.prototype._isFollowing = function () {\\n    return (this._bitField & 67108864) === 67108864;\\n};\\n\\nPromise.prototype._setLength = function (len) {\\n    this._bitField = (this._bitField & -65536) |\\n        (len & 65535);\\n};\\n\\nPromise.prototype._setFulfilled = function () {\\n    this._bitField = this._bitField | 33554432;\\n    this._fireEvent(\\\"promiseFulfilled\\\", this);\\n};\\n\\nPromise.prototype._setRejected = function () {\\n    this._bitField = this._bitField | 16777216;\\n    this._fireEvent(\\\"promiseRejected\\\", this);\\n};\\n\\nPromise.prototype._setFollowing = function () {\\n    this._bitField = this._bitField | 67108864;\\n    this._fireEvent(\\\"promiseResolved\\\", this);\\n};\\n\\nPromise.prototype._setIsFinal = function () {\\n    this._bitField = this._bitField | 4194304;\\n};\\n\\nPromise.prototype._isFinal = function () {\\n    return (this._bitField & 4194304) > 0;\\n};\\n\\nPromise.prototype._unsetCancelled = function() {\\n    this._bitField = this._bitField & (~65536);\\n};\\n\\nPromise.prototype._setCancelled = function() {\\n    this._bitField = this._bitField | 65536;\\n    this._fireEvent(\\\"promiseCancelled\\\", this);\\n};\\n\\nPromise.prototype._setWillBeCancelled = function() {\\n    this._bitField = this._bitField | 8388608;\\n};\\n\\nPromise.prototype._setAsyncGuaranteed = function() {\\n    if (async.hasCustomScheduler()) return;\\n    this._bitField = this._bitField | 134217728;\\n};\\n\\nPromise.prototype._receiverAt = function (index) {\\n    var ret = index === 0 ? this._receiver0 : this[\\n            index * 4 - 4 + 3];\\n    if (ret === UNDEFINED_BINDING) {\\n        return undefined;\\n    } else if (ret === undefined && this._isBound()) {\\n        return this._boundValue();\\n    }\\n    return ret;\\n};\\n\\nPromise.prototype._promiseAt = function (index) {\\n    return this[\\n            index * 4 - 4 + 2];\\n};\\n\\nPromise.prototype._fulfillmentHandlerAt = function (index) {\\n    return this[\\n            index * 4 - 4 + 0];\\n};\\n\\nPromise.prototype._rejectionHandlerAt = function (index) {\\n    return this[\\n            index * 4 - 4 + 1];\\n};\\n\\nPromise.prototype._boundValue = function() {};\\n\\nPromise.prototype._migrateCallback0 = function (follower) {\\n    var bitField = follower._bitField;\\n    var fulfill = follower._fulfillmentHandler0;\\n    var reject = follower._rejectionHandler0;\\n    var promise = follower._promise0;\\n    var receiver = follower._receiverAt(0);\\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\\n};\\n\\nPromise.prototype._migrateCallbackAt = function (follower, index) {\\n    var fulfill = follower._fulfillmentHandlerAt(index);\\n    var reject = follower._rejectionHandlerAt(index);\\n    var promise = follower._promiseAt(index);\\n    var receiver = follower._receiverAt(index);\\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\\n};\\n\\nPromise.prototype._addCallbacks = function (\\n    fulfill,\\n    reject,\\n    promise,\\n    receiver,\\n    domain\\n) {\\n    var index = this._length();\\n\\n    if (index >= 65535 - 4) {\\n        index = 0;\\n        this._setLength(0);\\n    }\\n\\n    if (index === 0) {\\n        this._promise0 = promise;\\n        this._receiver0 = receiver;\\n        if (typeof fulfill === \\\"function\\\") {\\n            this._fulfillmentHandler0 =\\n                domain === null ? fulfill : util.domainBind(domain, fulfill);\\n        }\\n        if (typeof reject === \\\"function\\\") {\\n            this._rejectionHandler0 =\\n                domain === null ? reject : util.domainBind(domain, reject);\\n        }\\n    } else {\\n        var base = index * 4 - 4;\\n        this[base + 2] = promise;\\n        this[base + 3] = receiver;\\n        if (typeof fulfill === \\\"function\\\") {\\n            this[base + 0] =\\n                domain === null ? fulfill : util.domainBind(domain, fulfill);\\n        }\\n        if (typeof reject === \\\"function\\\") {\\n            this[base + 1] =\\n                domain === null ? reject : util.domainBind(domain, reject);\\n        }\\n    }\\n    this._setLength(index + 1);\\n    return index;\\n};\\n\\nPromise.prototype._proxy = function (proxyable, arg) {\\n    this._addCallbacks(undefined, undefined, arg, proxyable, null);\\n};\\n\\nPromise.prototype._resolveCallback = function(value, shouldBind) {\\n    if (((this._bitField & 117506048) !== 0)) return;\\n    if (value === this)\\n        return this._rejectCallback(makeSelfResolutionError(), false);\\n    var maybePromise = tryConvertToPromise(value, this);\\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\\n\\n    if (shouldBind) this._propagateFrom(maybePromise, 2);\\n\\n    var promise = maybePromise._target();\\n\\n    if (promise === this) {\\n        this._reject(makeSelfResolutionError());\\n        return;\\n    }\\n\\n    var bitField = promise._bitField;\\n    if (((bitField & 50397184) === 0)) {\\n        var len = this._length();\\n        if (len > 0) promise._migrateCallback0(this);\\n        for (var i = 1; i < len; ++i) {\\n            promise._migrateCallbackAt(this, i);\\n        }\\n        this._setFollowing();\\n        this._setLength(0);\\n        this._setFollowee(promise);\\n    } else if (((bitField & 33554432) !== 0)) {\\n        this._fulfill(promise._value());\\n    } else if (((bitField & 16777216) !== 0)) {\\n        this._reject(promise._reason());\\n    } else {\\n        var reason = new CancellationError(\\\"late cancellation observer\\\");\\n        promise._attachExtraTrace(reason);\\n        this._reject(reason);\\n    }\\n};\\n\\nPromise.prototype._rejectCallback =\\nfunction(reason, synchronous, ignoreNonErrorWarnings) {\\n    var trace = util.ensureErrorObject(reason);\\n    var hasStack = trace === reason;\\n    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {\\n        var message = \\\"a promise was rejected with a non-error: \\\" +\\n            util.classString(reason);\\n        this._warn(message, true);\\n    }\\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\\n    this._reject(reason);\\n};\\n\\nPromise.prototype._resolveFromExecutor = function (executor) {\\n    if (executor === INTERNAL) return;\\n    var promise = this;\\n    this._captureStackTrace();\\n    this._pushContext();\\n    var synchronous = true;\\n    var r = this._execute(executor, function(value) {\\n        promise._resolveCallback(value);\\n    }, function (reason) {\\n        promise._rejectCallback(reason, synchronous);\\n    });\\n    synchronous = false;\\n    this._popContext();\\n\\n    if (r !== undefined) {\\n        promise._rejectCallback(r, true);\\n    }\\n};\\n\\nPromise.prototype._settlePromiseFromHandler = function (\\n    handler, receiver, value, promise\\n) {\\n    var bitField = promise._bitField;\\n    if (((bitField & 65536) !== 0)) return;\\n    promise._pushContext();\\n    var x;\\n    if (receiver === APPLY) {\\n        if (!value || typeof value.length !== \\\"number\\\") {\\n            x = errorObj;\\n            x.e = new TypeError(\\\"cannot .spread() a non-array: \\\" +\\n                                    util.classString(value));\\n        } else {\\n            x = tryCatch(handler).apply(this._boundValue(), value);\\n        }\\n    } else {\\n        x = tryCatch(handler).call(receiver, value);\\n    }\\n    var promiseCreated = promise._popContext();\\n    bitField = promise._bitField;\\n    if (((bitField & 65536) !== 0)) return;\\n\\n    if (x === NEXT_FILTER) {\\n        promise._reject(value);\\n    } else if (x === errorObj) {\\n        promise._rejectCallback(x.e, false);\\n    } else {\\n        debug.checkForgottenReturns(x, promiseCreated, \\\"\\\",  promise, this);\\n        promise._resolveCallback(x);\\n    }\\n};\\n\\nPromise.prototype._target = function() {\\n    var ret = this;\\n    while (ret._isFollowing()) ret = ret._followee();\\n    return ret;\\n};\\n\\nPromise.prototype._followee = function() {\\n    return this._rejectionHandler0;\\n};\\n\\nPromise.prototype._setFollowee = function(promise) {\\n    this._rejectionHandler0 = promise;\\n};\\n\\nPromise.prototype._settlePromise = function(promise, handler, receiver, value) {\\n    var isPromise = promise instanceof Promise;\\n    var bitField = this._bitField;\\n    var asyncGuaranteed = ((bitField & 134217728) !== 0);\\n    if (((bitField & 65536) !== 0)) {\\n        if (isPromise) promise._invokeInternalOnCancel();\\n\\n        if (receiver instanceof PassThroughHandlerContext &&\\n            receiver.isFinallyHandler()) {\\n            receiver.cancelPromise = promise;\\n            if (tryCatch(handler).call(receiver, value) === errorObj) {\\n                promise._reject(errorObj.e);\\n            }\\n        } else if (handler === reflectHandler) {\\n            promise._fulfill(reflectHandler.call(receiver));\\n        } else if (receiver instanceof Proxyable) {\\n            receiver._promiseCancelled(promise);\\n        } else if (isPromise || promise instanceof PromiseArray) {\\n            promise._cancel();\\n        } else {\\n            receiver.cancel();\\n        }\\n    } else if (typeof handler === \\\"function\\\") {\\n        if (!isPromise) {\\n            handler.call(receiver, value, promise);\\n        } else {\\n            if (asyncGuaranteed) promise._setAsyncGuaranteed();\\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\\n        }\\n    } else if (receiver instanceof Proxyable) {\\n        if (!receiver._isResolved()) {\\n            if (((bitField & 33554432) !== 0)) {\\n                receiver._promiseFulfilled(value, promise);\\n            } else {\\n                receiver._promiseRejected(value, promise);\\n            }\\n        }\\n    } else if (isPromise) {\\n        if (asyncGuaranteed) promise._setAsyncGuaranteed();\\n        if (((bitField & 33554432) !== 0)) {\\n            promise._fulfill(value);\\n        } else {\\n            promise._reject(value);\\n        }\\n    }\\n};\\n\\nPromise.prototype._settlePromiseLateCancellationObserver = function(ctx) {\\n    var handler = ctx.handler;\\n    var promise = ctx.promise;\\n    var receiver = ctx.receiver;\\n    var value = ctx.value;\\n    if (typeof handler === \\\"function\\\") {\\n        if (!(promise instanceof Promise)) {\\n            handler.call(receiver, value, promise);\\n        } else {\\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\\n        }\\n    } else if (promise instanceof Promise) {\\n        promise._reject(value);\\n    }\\n};\\n\\nPromise.prototype._settlePromiseCtx = function(ctx) {\\n    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);\\n};\\n\\nPromise.prototype._settlePromise0 = function(handler, value, bitField) {\\n    var promise = this._promise0;\\n    var receiver = this._receiverAt(0);\\n    this._promise0 = undefined;\\n    this._receiver0 = undefined;\\n    this._settlePromise(promise, handler, receiver, value);\\n};\\n\\nPromise.prototype._clearCallbackDataAtIndex = function(index) {\\n    var base = index * 4 - 4;\\n    this[base + 2] =\\n    this[base + 3] =\\n    this[base + 0] =\\n    this[base + 1] = undefined;\\n};\\n\\nPromise.prototype._fulfill = function (value) {\\n    var bitField = this._bitField;\\n    if (((bitField & 117506048) >>> 16)) return;\\n    if (value === this) {\\n        var err = makeSelfResolutionError();\\n        this._attachExtraTrace(err);\\n        return this._reject(err);\\n    }\\n    this._setFulfilled();\\n    this._rejectionHandler0 = value;\\n\\n    if ((bitField & 65535) > 0) {\\n        if (((bitField & 134217728) !== 0)) {\\n            this._settlePromises();\\n        } else {\\n            async.settlePromises(this);\\n        }\\n    }\\n};\\n\\nPromise.prototype._reject = function (reason) {\\n    var bitField = this._bitField;\\n    if (((bitField & 117506048) >>> 16)) return;\\n    this._setRejected();\\n    this._fulfillmentHandler0 = reason;\\n\\n    if (this._isFinal()) {\\n        return async.fatalError(reason, util.isNode);\\n    }\\n\\n    if ((bitField & 65535) > 0) {\\n        async.settlePromises(this);\\n    } else {\\n        this._ensurePossibleRejectionHandled();\\n    }\\n};\\n\\nPromise.prototype._fulfillPromises = function (len, value) {\\n    for (var i = 1; i < len; i++) {\\n        var handler = this._fulfillmentHandlerAt(i);\\n        var promise = this._promiseAt(i);\\n        var receiver = this._receiverAt(i);\\n        this._clearCallbackDataAtIndex(i);\\n        this._settlePromise(promise, handler, receiver, value);\\n    }\\n};\\n\\nPromise.prototype._rejectPromises = function (len, reason) {\\n    for (var i = 1; i < len; i++) {\\n        var handler = this._rejectionHandlerAt(i);\\n        var promise = this._promiseAt(i);\\n        var receiver = this._receiverAt(i);\\n        this._clearCallbackDataAtIndex(i);\\n        this._settlePromise(promise, handler, receiver, reason);\\n    }\\n};\\n\\nPromise.prototype._settlePromises = function () {\\n    var bitField = this._bitField;\\n    var len = (bitField & 65535);\\n\\n    if (len > 0) {\\n        if (((bitField & 16842752) !== 0)) {\\n            var reason = this._fulfillmentHandler0;\\n            this._settlePromise0(this._rejectionHandler0, reason, bitField);\\n            this._rejectPromises(len, reason);\\n        } else {\\n            var value = this._rejectionHandler0;\\n            this._settlePromise0(this._fulfillmentHandler0, value, bitField);\\n            this._fulfillPromises(len, value);\\n        }\\n        this._setLength(0);\\n    }\\n    this._clearCancellationData();\\n};\\n\\nPromise.prototype._settledValue = function() {\\n    var bitField = this._bitField;\\n    if (((bitField & 33554432) !== 0)) {\\n        return this._rejectionHandler0;\\n    } else if (((bitField & 16777216) !== 0)) {\\n        return this._fulfillmentHandler0;\\n    }\\n};\\n\\nfunction deferResolve(v) {this.promise._resolveCallback(v);}\\nfunction deferReject(v) {this.promise._rejectCallback(v, false);}\\n\\nPromise.defer = Promise.pending = function() {\\n    debug.deprecated(\\\"Promise.defer\\\", \\\"new Promise\\\");\\n    var promise = new Promise(INTERNAL);\\n    return {\\n        promise: promise,\\n        resolve: deferResolve,\\n        reject: deferReject\\n    };\\n};\\n\\nutil.notEnumerableProp(Promise,\\n                       \\\"_makeSelfResolutionError\\\",\\n                       makeSelfResolutionError);\\n\\n_dereq_(\\\"./method\\\")(Promise, INTERNAL, tryConvertToPromise, apiRejection,\\n    debug);\\n_dereq_(\\\"./bind\\\")(Promise, INTERNAL, tryConvertToPromise, debug);\\n_dereq_(\\\"./cancel\\\")(Promise, PromiseArray, apiRejection, debug);\\n_dereq_(\\\"./direct_resolve\\\")(Promise);\\n_dereq_(\\\"./synchronous_inspection\\\")(Promise);\\n_dereq_(\\\"./join\\\")(\\n    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);\\nPromise.Promise = Promise;\\nPromise.version = \\\"3.5.1\\\";\\n_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\\n_dereq_('./call_get.js')(Promise);\\n_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);\\n_dereq_('./timers.js')(Promise, INTERNAL, debug);\\n_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);\\n_dereq_('./nodeify.js')(Promise);\\n_dereq_('./promisify.js')(Promise, INTERNAL);\\n_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);\\n_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);\\n_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\\n_dereq_('./settle.js')(Promise, PromiseArray, debug);\\n_dereq_('./some.js')(Promise, PromiseArray, apiRejection);\\n_dereq_('./filter.js')(Promise, INTERNAL);\\n_dereq_('./each.js')(Promise, INTERNAL);\\n_dereq_('./any.js')(Promise);\\n                                                         \\n    util.toFastProperties(Promise);                                          \\n    util.toFastProperties(Promise.prototype);                                \\n    function fillTypes(value) {                                              \\n        var p = new Promise(INTERNAL);                                       \\n        p._fulfillmentHandler0 = value;                                      \\n        p._rejectionHandler0 = value;                                        \\n        p._promise0 = value;                                                 \\n        p._receiver0 = value;                                                \\n    }                                                                        \\n    // Complete slack tracking, opt out of field-type tracking and           \\n    // stabilize map                                                         \\n    fillTypes({a: 1});                                                       \\n    fillTypes({b: 2});                                                       \\n    fillTypes({c: 3});                                                       \\n    fillTypes(1);                                                            \\n    fillTypes(function(){});                                                 \\n    fillTypes(undefined);                                                    \\n    fillTypes(false);                                                        \\n    fillTypes(new Promise(INTERNAL));                                        \\n    debug.setBounds(Async.firstLineError, util.lastLineError);               \\n    return Promise;                                                          \\n\\n};\\n\\n},{\\\"./any.js\\\":1,\\\"./async\\\":2,\\\"./bind\\\":3,\\\"./call_get.js\\\":5,\\\"./cancel\\\":6,\\\"./catch_filter\\\":7,\\\"./context\\\":8,\\\"./debuggability\\\":9,\\\"./direct_resolve\\\":10,\\\"./each.js\\\":11,\\\"./errors\\\":12,\\\"./es5\\\":13,\\\"./filter.js\\\":14,\\\"./finally\\\":15,\\\"./generators.js\\\":16,\\\"./join\\\":17,\\\"./map.js\\\":18,\\\"./method\\\":19,\\\"./nodeback\\\":20,\\\"./nodeify.js\\\":21,\\\"./promise_array\\\":23,\\\"./promisify.js\\\":24,\\\"./props.js\\\":25,\\\"./race.js\\\":27,\\\"./reduce.js\\\":28,\\\"./settle.js\\\":30,\\\"./some.js\\\":31,\\\"./synchronous_inspection\\\":32,\\\"./thenables\\\":33,\\\"./timers.js\\\":34,\\\"./using.js\\\":35,\\\"./util\\\":36}],23:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\\n    apiRejection, Proxyable) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar isArray = util.isArray;\\n\\nfunction toResolutionValue(val) {\\n    switch(val) {\\n    case -2: return [];\\n    case -3: return {};\\n    case -6: return new Map();\\n    }\\n}\\n\\nfunction PromiseArray(values) {\\n    var promise = this._promise = new Promise(INTERNAL);\\n    if (values instanceof Promise) {\\n        promise._propagateFrom(values, 3);\\n    }\\n    promise._setOnCancel(this);\\n    this._values = values;\\n    this._length = 0;\\n    this._totalResolved = 0;\\n    this._init(undefined, -2);\\n}\\nutil.inherits(PromiseArray, Proxyable);\\n\\nPromiseArray.prototype.length = function () {\\n    return this._length;\\n};\\n\\nPromiseArray.prototype.promise = function () {\\n    return this._promise;\\n};\\n\\nPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\\n    var values = tryConvertToPromise(this._values, this._promise);\\n    if (values instanceof Promise) {\\n        values = values._target();\\n        var bitField = values._bitField;\\n        ;\\n        this._values = values;\\n\\n        if (((bitField & 50397184) === 0)) {\\n            this._promise._setAsyncGuaranteed();\\n            return values._then(\\n                init,\\n                this._reject,\\n                undefined,\\n                this,\\n                resolveValueIfEmpty\\n           );\\n        } else if (((bitField & 33554432) !== 0)) {\\n            values = values._value();\\n        } else if (((bitField & 16777216) !== 0)) {\\n            return this._reject(values._reason());\\n        } else {\\n            return this._cancel();\\n        }\\n    }\\n    values = util.asArray(values);\\n    if (values === null) {\\n        var err = apiRejection(\\n            \\\"expecting an array or an iterable object but got \\\" + util.classString(values)).reason();\\n        this._promise._rejectCallback(err, false);\\n        return;\\n    }\\n\\n    if (values.length === 0) {\\n        if (resolveValueIfEmpty === -5) {\\n            this._resolveEmptyArray();\\n        }\\n        else {\\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\\n        }\\n        return;\\n    }\\n    this._iterate(values);\\n};\\n\\nPromiseArray.prototype._iterate = function(values) {\\n    var len = this.getActualLength(values.length);\\n    this._length = len;\\n    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\\n    var result = this._promise;\\n    var isResolved = false;\\n    var bitField = null;\\n    for (var i = 0; i < len; ++i) {\\n        var maybePromise = tryConvertToPromise(values[i], result);\\n\\n        if (maybePromise instanceof Promise) {\\n            maybePromise = maybePromise._target();\\n            bitField = maybePromise._bitField;\\n        } else {\\n            bitField = null;\\n        }\\n\\n        if (isResolved) {\\n            if (bitField !== null) {\\n                maybePromise.suppressUnhandledRejections();\\n            }\\n        } else if (bitField !== null) {\\n            if (((bitField & 50397184) === 0)) {\\n                maybePromise._proxy(this, i);\\n                this._values[i] = maybePromise;\\n            } else if (((bitField & 33554432) !== 0)) {\\n                isResolved = this._promiseFulfilled(maybePromise._value(), i);\\n            } else if (((bitField & 16777216) !== 0)) {\\n                isResolved = this._promiseRejected(maybePromise._reason(), i);\\n            } else {\\n                isResolved = this._promiseCancelled(i);\\n            }\\n        } else {\\n            isResolved = this._promiseFulfilled(maybePromise, i);\\n        }\\n    }\\n    if (!isResolved) result._setAsyncGuaranteed();\\n};\\n\\nPromiseArray.prototype._isResolved = function () {\\n    return this._values === null;\\n};\\n\\nPromiseArray.prototype._resolve = function (value) {\\n    this._values = null;\\n    this._promise._fulfill(value);\\n};\\n\\nPromiseArray.prototype._cancel = function() {\\n    if (this._isResolved() || !this._promise._isCancellable()) return;\\n    this._values = null;\\n    this._promise._cancel();\\n};\\n\\nPromiseArray.prototype._reject = function (reason) {\\n    this._values = null;\\n    this._promise._rejectCallback(reason, false);\\n};\\n\\nPromiseArray.prototype._promiseFulfilled = function (value, index) {\\n    this._values[index] = value;\\n    var totalResolved = ++this._totalResolved;\\n    if (totalResolved >= this._length) {\\n        this._resolve(this._values);\\n        return true;\\n    }\\n    return false;\\n};\\n\\nPromiseArray.prototype._promiseCancelled = function() {\\n    this._cancel();\\n    return true;\\n};\\n\\nPromiseArray.prototype._promiseRejected = function (reason) {\\n    this._totalResolved++;\\n    this._reject(reason);\\n    return true;\\n};\\n\\nPromiseArray.prototype._resultCancelled = function() {\\n    if (this._isResolved()) return;\\n    var values = this._values;\\n    this._cancel();\\n    if (values instanceof Promise) {\\n        values.cancel();\\n    } else {\\n        for (var i = 0; i < values.length; ++i) {\\n            if (values[i] instanceof Promise) {\\n                values[i].cancel();\\n            }\\n        }\\n    }\\n};\\n\\nPromiseArray.prototype.shouldCopyValues = function () {\\n    return true;\\n};\\n\\nPromiseArray.prototype.getActualLength = function (len) {\\n    return len;\\n};\\n\\nreturn PromiseArray;\\n};\\n\\n},{\\\"./util\\\":36}],24:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise, INTERNAL) {\\nvar THIS = {};\\nvar util = _dereq_(\\\"./util\\\");\\nvar nodebackForPromise = _dereq_(\\\"./nodeback\\\");\\nvar withAppended = util.withAppended;\\nvar maybeWrapAsError = util.maybeWrapAsError;\\nvar canEvaluate = util.canEvaluate;\\nvar TypeError = _dereq_(\\\"./errors\\\").TypeError;\\nvar defaultSuffix = \\\"Async\\\";\\nvar defaultPromisified = {__isPromisified__: true};\\nvar noCopyProps = [\\n    \\\"arity\\\",    \\\"length\\\",\\n    \\\"name\\\",\\n    \\\"arguments\\\",\\n    \\\"caller\\\",\\n    \\\"callee\\\",\\n    \\\"prototype\\\",\\n    \\\"__isPromisified__\\\"\\n];\\nvar noCopyPropsPattern = new RegExp(\\\"^(?:\\\" + noCopyProps.join(\\\"|\\\") + \\\")$\\\");\\n\\nvar defaultFilter = function(name) {\\n    return util.isIdentifier(name) &&\\n        name.charAt(0) !== \\\"_\\\" &&\\n        name !== \\\"constructor\\\";\\n};\\n\\nfunction propsFilter(key) {\\n    return !noCopyPropsPattern.test(key);\\n}\\n\\nfunction isPromisified(fn) {\\n    try {\\n        return fn.__isPromisified__ === true;\\n    }\\n    catch (e) {\\n        return false;\\n    }\\n}\\n\\nfunction hasPromisified(obj, key, suffix) {\\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\\n                                            defaultPromisified);\\n    return val ? isPromisified(val) : false;\\n}\\nfunction checkValid(ret, suffix, suffixRegexp) {\\n    for (var i = 0; i < ret.length; i += 2) {\\n        var key = ret[i];\\n        if (suffixRegexp.test(key)) {\\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \\\"\\\");\\n            for (var j = 0; j < ret.length; j += 2) {\\n                if (ret[j] === keyWithoutAsyncSuffix) {\\n                    throw new TypeError(\\\"Cannot promisify an API that has normal methods with '%s'-suffix\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\"\\n                        .replace(\\\"%s\\\", suffix));\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\\n    var keys = util.inheritedDataKeys(obj);\\n    var ret = [];\\n    for (var i = 0; i < keys.length; ++i) {\\n        var key = keys[i];\\n        var value = obj[key];\\n        var passesDefaultFilter = filter === defaultFilter\\n            ? true : defaultFilter(key, value, obj);\\n        if (typeof value === \\\"function\\\" &&\\n            !isPromisified(value) &&\\n            !hasPromisified(obj, key, suffix) &&\\n            filter(key, value, obj, passesDefaultFilter)) {\\n            ret.push(key, value);\\n        }\\n    }\\n    checkValid(ret, suffix, suffixRegexp);\\n    return ret;\\n}\\n\\nvar escapeIdentRegex = function(str) {\\n    return str.replace(/([$])/, \\\"\\\\\\\\$\\\");\\n};\\n\\nvar makeNodePromisifiedEval;\\nif (false) {\\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\\n    var ret = [likelyArgumentCount];\\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\\n        ret.push(i);\\n    }\\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\\n        ret.push(i);\\n    }\\n    return ret;\\n};\\n\\nvar argumentSequence = function(argumentCount) {\\n    return util.filledRange(argumentCount, \\\"_arg\\\", \\\"\\\");\\n};\\n\\nvar parameterDeclaration = function(parameterCount) {\\n    return util.filledRange(\\n        Math.max(parameterCount, 3), \\\"_arg\\\", \\\"\\\");\\n};\\n\\nvar parameterCount = function(fn) {\\n    if (typeof fn.length === \\\"number\\\") {\\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\\n    }\\n    return 0;\\n};\\n\\nmakeNodePromisifiedEval =\\nfunction(callback, receiver, originalName, fn, _, multiArgs) {\\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\\n    var shouldProxyThis = typeof callback === \\\"string\\\" || receiver === THIS;\\n\\n    function generateCallForArgumentCount(count) {\\n        var args = argumentSequence(count).join(\\\", \\\");\\n        var comma = count > 0 ? \\\", \\\" : \\\"\\\";\\n        var ret;\\n        if (shouldProxyThis) {\\n            ret = \\\"ret = callback.call(this, {{args}}, nodeback); break;\\\\n\\\";\\n        } else {\\n            ret = receiver === undefined\\n                ? \\\"ret = callback({{args}}, nodeback); break;\\\\n\\\"\\n                : \\\"ret = callback.call(receiver, {{args}}, nodeback); break;\\\\n\\\";\\n        }\\n        return ret.replace(\\\"{{args}}\\\", args).replace(\\\", \\\", comma);\\n    }\\n\\n    function generateArgumentSwitchCase() {\\n        var ret = \\\"\\\";\\n        for (var i = 0; i < argumentOrder.length; ++i) {\\n            ret += \\\"case \\\" + argumentOrder[i] +\\\":\\\" +\\n                generateCallForArgumentCount(argumentOrder[i]);\\n        }\\n\\n        ret += \\\"                                                             \\\\n\\\\\\n        default:                                                             \\\\n\\\\\\n            var args = new Array(len + 1);                                   \\\\n\\\\\\n            var i = 0;                                                       \\\\n\\\\\\n            for (var i = 0; i < len; ++i) {                                  \\\\n\\\\\\n               args[i] = arguments[i];                                       \\\\n\\\\\\n            }                                                                \\\\n\\\\\\n            args[i] = nodeback;                                              \\\\n\\\\\\n            [CodeForCall]                                                    \\\\n\\\\\\n            break;                                                           \\\\n\\\\\\n        \\\".replace(\\\"[CodeForCall]\\\", (shouldProxyThis\\n                                ? \\\"ret = callback.apply(this, args);\\\\n\\\"\\n                                : \\\"ret = callback.apply(receiver, args);\\\\n\\\"));\\n        return ret;\\n    }\\n\\n    var getFunctionCode = typeof callback === \\\"string\\\"\\n                                ? (\\\"this != null ? this['\\\"+callback+\\\"'] : fn\\\")\\n                                : \\\"fn\\\";\\n    var body = \\\"'use strict';                                                \\\\n\\\\\\n        var ret = function (Parameters) {                                    \\\\n\\\\\\n            'use strict';                                                    \\\\n\\\\\\n            var len = arguments.length;                                      \\\\n\\\\\\n            var promise = new Promise(INTERNAL);                             \\\\n\\\\\\n            promise._captureStackTrace();                                    \\\\n\\\\\\n            var nodeback = nodebackForPromise(promise, \\\" + multiArgs + \\\");   \\\\n\\\\\\n            var ret;                                                         \\\\n\\\\\\n            var callback = tryCatch([GetFunctionCode]);                      \\\\n\\\\\\n            switch(len) {                                                    \\\\n\\\\\\n                [CodeForSwitchCase]                                          \\\\n\\\\\\n            }                                                                \\\\n\\\\\\n            if (ret === errorObj) {                                          \\\\n\\\\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\\\n\\\\\\n            }                                                                \\\\n\\\\\\n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \\\\n\\\\\\n            return promise;                                                  \\\\n\\\\\\n        };                                                                   \\\\n\\\\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\\\n\\\\\\n        return ret;                                                          \\\\n\\\\\\n    \\\".replace(\\\"[CodeForSwitchCase]\\\", generateArgumentSwitchCase())\\n        .replace(\\\"[GetFunctionCode]\\\", getFunctionCode);\\n    body = body.replace(\\\"Parameters\\\", parameterDeclaration(newParameterCount));\\n    return new Function(\\\"Promise\\\",\\n                        \\\"fn\\\",\\n                        \\\"receiver\\\",\\n                        \\\"withAppended\\\",\\n                        \\\"maybeWrapAsError\\\",\\n                        \\\"nodebackForPromise\\\",\\n                        \\\"tryCatch\\\",\\n                        \\\"errorObj\\\",\\n                        \\\"notEnumerableProp\\\",\\n                        \\\"INTERNAL\\\",\\n                        body)(\\n                    Promise,\\n                    fn,\\n                    receiver,\\n                    withAppended,\\n                    maybeWrapAsError,\\n                    nodebackForPromise,\\n                    util.tryCatch,\\n                    util.errorObj,\\n                    util.notEnumerableProp,\\n                    INTERNAL);\\n};\\n}\\n\\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\\n    var defaultThis = (function() {return this;})();\\n    var method = callback;\\n    if (typeof method === \\\"string\\\") {\\n        callback = fn;\\n    }\\n    function promisified() {\\n        var _receiver = receiver;\\n        if (receiver === THIS) _receiver = this;\\n        var promise = new Promise(INTERNAL);\\n        promise._captureStackTrace();\\n        var cb = typeof method === \\\"string\\\" && this !== defaultThis\\n            ? this[method] : callback;\\n        var fn = nodebackForPromise(promise, multiArgs);\\n        try {\\n            cb.apply(_receiver, withAppended(arguments, fn));\\n        } catch(e) {\\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\\n        }\\n        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\\n        return promise;\\n    }\\n    util.notEnumerableProp(promisified, \\\"__isPromisified__\\\", true);\\n    return promisified;\\n}\\n\\nvar makeNodePromisified = canEvaluate\\n    ? makeNodePromisifiedEval\\n    : makeNodePromisifiedClosure;\\n\\nfunction promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \\\"$\\\");\\n    var methods =\\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\\n\\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\\n        var key = methods[i];\\n        var fn = methods[i+1];\\n        var promisifiedKey = key + suffix;\\n        if (promisifier === makeNodePromisified) {\\n            obj[promisifiedKey] =\\n                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\\n        } else {\\n            var promisified = promisifier(fn, function() {\\n                return makeNodePromisified(key, THIS, key,\\n                                           fn, suffix, multiArgs);\\n            });\\n            util.notEnumerableProp(promisified, \\\"__isPromisified__\\\", true);\\n            obj[promisifiedKey] = promisified;\\n        }\\n    }\\n    util.toFastProperties(obj);\\n    return obj;\\n}\\n\\nfunction promisify(callback, receiver, multiArgs) {\\n    return makeNodePromisified(callback, receiver, undefined,\\n                                callback, null, multiArgs);\\n}\\n\\nPromise.promisify = function (fn, options) {\\n    if (typeof fn !== \\\"function\\\") {\\n        throw new TypeError(\\\"expecting a function but got \\\" + util.classString(fn));\\n    }\\n    if (isPromisified(fn)) {\\n        return fn;\\n    }\\n    options = Object(options);\\n    var receiver = options.context === undefined ? THIS : options.context;\\n    var multiArgs = !!options.multiArgs;\\n    var ret = promisify(fn, receiver, multiArgs);\\n    util.copyDescriptors(fn, ret, propsFilter);\\n    return ret;\\n};\\n\\nPromise.promisifyAll = function (target, options) {\\n    if (typeof target !== \\\"function\\\" && typeof target !== \\\"object\\\") {\\n        throw new TypeError(\\\"the target of promisifyAll must be an object or a function\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    }\\n    options = Object(options);\\n    var multiArgs = !!options.multiArgs;\\n    var suffix = options.suffix;\\n    if (typeof suffix !== \\\"string\\\") suffix = defaultSuffix;\\n    var filter = options.filter;\\n    if (typeof filter !== \\\"function\\\") filter = defaultFilter;\\n    var promisifier = options.promisifier;\\n    if (typeof promisifier !== \\\"function\\\") promisifier = makeNodePromisified;\\n\\n    if (!util.isIdentifier(suffix)) {\\n        throw new RangeError(\\\"suffix must be a valid identifier\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    }\\n\\n    var keys = util.inheritedDataKeys(target);\\n    for (var i = 0; i < keys.length; ++i) {\\n        var value = target[keys[i]];\\n        if (keys[i] !== \\\"constructor\\\" &&\\n            util.isClass(value)) {\\n            promisifyAll(value.prototype, suffix, filter, promisifier,\\n                multiArgs);\\n            promisifyAll(value, suffix, filter, promisifier, multiArgs);\\n        }\\n    }\\n\\n    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\\n};\\n};\\n\\n\\n},{\\\"./errors\\\":12,\\\"./nodeback\\\":20,\\\"./util\\\":36}],25:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(\\n    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar isObject = util.isObject;\\nvar es5 = _dereq_(\\\"./es5\\\");\\nvar Es6Map;\\nif (typeof Map === \\\"function\\\") Es6Map = Map;\\n\\nvar mapToEntries = (function() {\\n    var index = 0;\\n    var size = 0;\\n\\n    function extractEntry(value, key) {\\n        this[index] = value;\\n        this[index + size] = key;\\n        index++;\\n    }\\n\\n    return function mapToEntries(map) {\\n        size = map.size;\\n        index = 0;\\n        var ret = new Array(map.size * 2);\\n        map.forEach(extractEntry, ret);\\n        return ret;\\n    };\\n})();\\n\\nvar entriesToMap = function(entries) {\\n    var ret = new Es6Map();\\n    var length = entries.length / 2 | 0;\\n    for (var i = 0; i < length; ++i) {\\n        var key = entries[length + i];\\n        var value = entries[i];\\n        ret.set(key, value);\\n    }\\n    return ret;\\n};\\n\\nfunction PropertiesPromiseArray(obj) {\\n    var isMap = false;\\n    var entries;\\n    if (Es6Map !== undefined && obj instanceof Es6Map) {\\n        entries = mapToEntries(obj);\\n        isMap = true;\\n    } else {\\n        var keys = es5.keys(obj);\\n        var len = keys.length;\\n        entries = new Array(len * 2);\\n        for (var i = 0; i < len; ++i) {\\n            var key = keys[i];\\n            entries[i] = obj[key];\\n            entries[i + len] = key;\\n        }\\n    }\\n    this.constructor$(entries);\\n    this._isMap = isMap;\\n    this._init$(undefined, isMap ? -6 : -3);\\n}\\nutil.inherits(PropertiesPromiseArray, PromiseArray);\\n\\nPropertiesPromiseArray.prototype._init = function () {};\\n\\nPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\\n    this._values[index] = value;\\n    var totalResolved = ++this._totalResolved;\\n    if (totalResolved >= this._length) {\\n        var val;\\n        if (this._isMap) {\\n            val = entriesToMap(this._values);\\n        } else {\\n            val = {};\\n            var keyOffset = this.length();\\n            for (var i = 0, len = this.length(); i < len; ++i) {\\n                val[this._values[i + keyOffset]] = this._values[i];\\n            }\\n        }\\n        this._resolve(val);\\n        return true;\\n    }\\n    return false;\\n};\\n\\nPropertiesPromiseArray.prototype.shouldCopyValues = function () {\\n    return false;\\n};\\n\\nPropertiesPromiseArray.prototype.getActualLength = function (len) {\\n    return len >> 1;\\n};\\n\\nfunction props(promises) {\\n    var ret;\\n    var castValue = tryConvertToPromise(promises);\\n\\n    if (!isObject(castValue)) {\\n        return apiRejection(\\\"cannot await properties of a non-object\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    } else if (castValue instanceof Promise) {\\n        ret = castValue._then(\\n            Promise.props, undefined, undefined, undefined, undefined);\\n    } else {\\n        ret = new PropertiesPromiseArray(castValue).promise();\\n    }\\n\\n    if (castValue instanceof Promise) {\\n        ret._propagateFrom(castValue, 2);\\n    }\\n    return ret;\\n}\\n\\nPromise.prototype.props = function () {\\n    return props(this);\\n};\\n\\nPromise.props = function (promises) {\\n    return props(promises);\\n};\\n};\\n\\n},{\\\"./es5\\\":13,\\\"./util\\\":36}],26:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\\n    for (var j = 0; j < len; ++j) {\\n        dst[j + dstIndex] = src[j + srcIndex];\\n        src[j + srcIndex] = void 0;\\n    }\\n}\\n\\nfunction Queue(capacity) {\\n    this._capacity = capacity;\\n    this._length = 0;\\n    this._front = 0;\\n}\\n\\nQueue.prototype._willBeOverCapacity = function (size) {\\n    return this._capacity < size;\\n};\\n\\nQueue.prototype._pushOne = function (arg) {\\n    var length = this.length();\\n    this._checkCapacity(length + 1);\\n    var i = (this._front + length) & (this._capacity - 1);\\n    this[i] = arg;\\n    this._length = length + 1;\\n};\\n\\nQueue.prototype.push = function (fn, receiver, arg) {\\n    var length = this.length() + 3;\\n    if (this._willBeOverCapacity(length)) {\\n        this._pushOne(fn);\\n        this._pushOne(receiver);\\n        this._pushOne(arg);\\n        return;\\n    }\\n    var j = this._front + length - 3;\\n    this._checkCapacity(length);\\n    var wrapMask = this._capacity - 1;\\n    this[(j + 0) & wrapMask] = fn;\\n    this[(j + 1) & wrapMask] = receiver;\\n    this[(j + 2) & wrapMask] = arg;\\n    this._length = length;\\n};\\n\\nQueue.prototype.shift = function () {\\n    var front = this._front,\\n        ret = this[front];\\n\\n    this[front] = undefined;\\n    this._front = (front + 1) & (this._capacity - 1);\\n    this._length--;\\n    return ret;\\n};\\n\\nQueue.prototype.length = function () {\\n    return this._length;\\n};\\n\\nQueue.prototype._checkCapacity = function (size) {\\n    if (this._capacity < size) {\\n        this._resizeTo(this._capacity << 1);\\n    }\\n};\\n\\nQueue.prototype._resizeTo = function (capacity) {\\n    var oldCapacity = this._capacity;\\n    this._capacity = capacity;\\n    var front = this._front;\\n    var length = this._length;\\n    var moveItemsCount = (front + length) & (oldCapacity - 1);\\n    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\\n};\\n\\nmodule.exports = Queue;\\n\\n},{}],27:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(\\n    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\\nvar util = _dereq_(\\\"./util\\\");\\n\\nvar raceLater = function (promise) {\\n    return promise.then(function(array) {\\n        return race(array, promise);\\n    });\\n};\\n\\nfunction race(promises, parent) {\\n    var maybePromise = tryConvertToPromise(promises);\\n\\n    if (maybePromise instanceof Promise) {\\n        return raceLater(maybePromise);\\n    } else {\\n        promises = util.asArray(promises);\\n        if (promises === null)\\n            return apiRejection(\\\"expecting an array or an iterable object but got \\\" + util.classString(promises));\\n    }\\n\\n    var ret = new Promise(INTERNAL);\\n    if (parent !== undefined) {\\n        ret._propagateFrom(parent, 3);\\n    }\\n    var fulfill = ret._fulfill;\\n    var reject = ret._reject;\\n    for (var i = 0, len = promises.length; i < len; ++i) {\\n        var val = promises[i];\\n\\n        if (val === undefined && !(i in promises)) {\\n            continue;\\n        }\\n\\n        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\\n    }\\n    return ret;\\n}\\n\\nPromise.race = function (promises) {\\n    return race(promises, undefined);\\n};\\n\\nPromise.prototype.race = function () {\\n    return race(this, undefined);\\n};\\n\\n};\\n\\n},{\\\"./util\\\":36}],28:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise,\\n                          PromiseArray,\\n                          apiRejection,\\n                          tryConvertToPromise,\\n                          INTERNAL,\\n                          debug) {\\nvar getDomain = Promise._getDomain;\\nvar util = _dereq_(\\\"./util\\\");\\nvar tryCatch = util.tryCatch;\\n\\nfunction ReductionPromiseArray(promises, fn, initialValue, _each) {\\n    this.constructor$(promises);\\n    var domain = getDomain();\\n    this._fn = domain === null ? fn : util.domainBind(domain, fn);\\n    if (initialValue !== undefined) {\\n        initialValue = Promise.resolve(initialValue);\\n        initialValue._attachCancellationCallback(this);\\n    }\\n    this._initialValue = initialValue;\\n    this._currentCancellable = null;\\n    if(_each === INTERNAL) {\\n        this._eachValues = Array(this._length);\\n    } else if (_each === 0) {\\n        this._eachValues = null;\\n    } else {\\n        this._eachValues = undefined;\\n    }\\n    this._promise._captureStackTrace();\\n    this._init$(undefined, -5);\\n}\\nutil.inherits(ReductionPromiseArray, PromiseArray);\\n\\nReductionPromiseArray.prototype._gotAccum = function(accum) {\\n    if (this._eachValues !== undefined && \\n        this._eachValues !== null && \\n        accum !== INTERNAL) {\\n        this._eachValues.push(accum);\\n    }\\n};\\n\\nReductionPromiseArray.prototype._eachComplete = function(value) {\\n    if (this._eachValues !== null) {\\n        this._eachValues.push(value);\\n    }\\n    return this._eachValues;\\n};\\n\\nReductionPromiseArray.prototype._init = function() {};\\n\\nReductionPromiseArray.prototype._resolveEmptyArray = function() {\\n    this._resolve(this._eachValues !== undefined ? this._eachValues\\n                                                 : this._initialValue);\\n};\\n\\nReductionPromiseArray.prototype.shouldCopyValues = function () {\\n    return false;\\n};\\n\\nReductionPromiseArray.prototype._resolve = function(value) {\\n    this._promise._resolveCallback(value);\\n    this._values = null;\\n};\\n\\nReductionPromiseArray.prototype._resultCancelled = function(sender) {\\n    if (sender === this._initialValue) return this._cancel();\\n    if (this._isResolved()) return;\\n    this._resultCancelled$();\\n    if (this._currentCancellable instanceof Promise) {\\n        this._currentCancellable.cancel();\\n    }\\n    if (this._initialValue instanceof Promise) {\\n        this._initialValue.cancel();\\n    }\\n};\\n\\nReductionPromiseArray.prototype._iterate = function (values) {\\n    this._values = values;\\n    var value;\\n    var i;\\n    var length = values.length;\\n    if (this._initialValue !== undefined) {\\n        value = this._initialValue;\\n        i = 0;\\n    } else {\\n        value = Promise.resolve(values[0]);\\n        i = 1;\\n    }\\n\\n    this._currentCancellable = value;\\n\\n    if (!value.isRejected()) {\\n        for (; i < length; ++i) {\\n            var ctx = {\\n                accum: null,\\n                value: values[i],\\n                index: i,\\n                length: length,\\n                array: this\\n            };\\n            value = value._then(gotAccum, undefined, undefined, ctx, undefined);\\n        }\\n    }\\n\\n    if (this._eachValues !== undefined) {\\n        value = value\\n            ._then(this._eachComplete, undefined, undefined, this, undefined);\\n    }\\n    value._then(completed, completed, undefined, value, this);\\n};\\n\\nPromise.prototype.reduce = function (fn, initialValue) {\\n    return reduce(this, fn, initialValue, null);\\n};\\n\\nPromise.reduce = function (promises, fn, initialValue, _each) {\\n    return reduce(promises, fn, initialValue, _each);\\n};\\n\\nfunction completed(valueOrReason, array) {\\n    if (this.isFulfilled()) {\\n        array._resolve(valueOrReason);\\n    } else {\\n        array._reject(valueOrReason);\\n    }\\n}\\n\\nfunction reduce(promises, fn, initialValue, _each) {\\n    if (typeof fn !== \\\"function\\\") {\\n        return apiRejection(\\\"expecting a function but got \\\" + util.classString(fn));\\n    }\\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\\n    return array.promise();\\n}\\n\\nfunction gotAccum(accum) {\\n    this.accum = accum;\\n    this.array._gotAccum(accum);\\n    var value = tryConvertToPromise(this.value, this.array._promise);\\n    if (value instanceof Promise) {\\n        this.array._currentCancellable = value;\\n        return value._then(gotValue, undefined, undefined, this, undefined);\\n    } else {\\n        return gotValue.call(this, value);\\n    }\\n}\\n\\nfunction gotValue(value) {\\n    var array = this.array;\\n    var promise = array._promise;\\n    var fn = tryCatch(array._fn);\\n    promise._pushContext();\\n    var ret;\\n    if (array._eachValues !== undefined) {\\n        ret = fn.call(promise._boundValue(), value, this.index, this.length);\\n    } else {\\n        ret = fn.call(promise._boundValue(),\\n                              this.accum, value, this.index, this.length);\\n    }\\n    if (ret instanceof Promise) {\\n        array._currentCancellable = ret;\\n    }\\n    var promiseCreated = promise._popContext();\\n    debug.checkForgottenReturns(\\n        ret,\\n        promiseCreated,\\n        array._eachValues !== undefined ? \\\"Promise.each\\\" : \\\"Promise.reduce\\\",\\n        promise\\n    );\\n    return ret;\\n}\\n};\\n\\n},{\\\"./util\\\":36}],29:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nvar util = _dereq_(\\\"./util\\\");\\nvar schedule;\\nvar noAsyncScheduler = function() {\\n    throw new Error(\\\"No async scheduler available\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n};\\nvar NativePromise = util.getNativePromise();\\nif (util.isNode && typeof MutationObserver === \\\"undefined\\\") {\\n    var GlobalSetImmediate = global.setImmediate;\\n    var ProcessNextTick = process.nextTick;\\n    schedule = util.isRecentNode\\n                ? function(fn) { GlobalSetImmediate.call(global, fn); }\\n                : function(fn) { ProcessNextTick.call(process, fn); };\\n} else if (typeof NativePromise === \\\"function\\\" &&\\n           typeof NativePromise.resolve === \\\"function\\\") {\\n    var nativePromise = NativePromise.resolve();\\n    schedule = function(fn) {\\n        nativePromise.then(fn);\\n    };\\n} else if ((typeof MutationObserver !== \\\"undefined\\\") &&\\n          !(typeof window !== \\\"undefined\\\" &&\\n            window.navigator &&\\n            (window.navigator.standalone || window.cordova))) {\\n    schedule = (function() {\\n        var div = document.createElement(\\\"div\\\");\\n        var opts = {attributes: true};\\n        var toggleScheduled = false;\\n        var div2 = document.createElement(\\\"div\\\");\\n        var o2 = new MutationObserver(function() {\\n            div.classList.toggle(\\\"foo\\\");\\n            toggleScheduled = false;\\n        });\\n        o2.observe(div2, opts);\\n\\n        var scheduleToggle = function() {\\n            if (toggleScheduled) return;\\n            toggleScheduled = true;\\n            div2.classList.toggle(\\\"foo\\\");\\n        };\\n\\n        return function schedule(fn) {\\n            var o = new MutationObserver(function() {\\n                o.disconnect();\\n                fn();\\n            });\\n            o.observe(div, opts);\\n            scheduleToggle();\\n        };\\n    })();\\n} else if (typeof setImmediate !== \\\"undefined\\\") {\\n    schedule = function (fn) {\\n        setImmediate(fn);\\n    };\\n} else if (typeof setTimeout !== \\\"undefined\\\") {\\n    schedule = function (fn) {\\n        setTimeout(fn, 0);\\n    };\\n} else {\\n    schedule = noAsyncScheduler;\\n}\\nmodule.exports = schedule;\\n\\n},{\\\"./util\\\":36}],30:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports =\\n    function(Promise, PromiseArray, debug) {\\nvar PromiseInspection = Promise.PromiseInspection;\\nvar util = _dereq_(\\\"./util\\\");\\n\\nfunction SettledPromiseArray(values) {\\n    this.constructor$(values);\\n}\\nutil.inherits(SettledPromiseArray, PromiseArray);\\n\\nSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\\n    this._values[index] = inspection;\\n    var totalResolved = ++this._totalResolved;\\n    if (totalResolved >= this._length) {\\n        this._resolve(this._values);\\n        return true;\\n    }\\n    return false;\\n};\\n\\nSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\\n    var ret = new PromiseInspection();\\n    ret._bitField = 33554432;\\n    ret._settledValueField = value;\\n    return this._promiseResolved(index, ret);\\n};\\nSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\\n    var ret = new PromiseInspection();\\n    ret._bitField = 16777216;\\n    ret._settledValueField = reason;\\n    return this._promiseResolved(index, ret);\\n};\\n\\nPromise.settle = function (promises) {\\n    debug.deprecated(\\\".settle()\\\", \\\".reflect()\\\");\\n    return new SettledPromiseArray(promises).promise();\\n};\\n\\nPromise.prototype.settle = function () {\\n    return Promise.settle(this);\\n};\\n};\\n\\n},{\\\"./util\\\":36}],31:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports =\\nfunction(Promise, PromiseArray, apiRejection) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar RangeError = _dereq_(\\\"./errors\\\").RangeError;\\nvar AggregateError = _dereq_(\\\"./errors\\\").AggregateError;\\nvar isArray = util.isArray;\\nvar CANCELLATION = {};\\n\\n\\nfunction SomePromiseArray(values) {\\n    this.constructor$(values);\\n    this._howMany = 0;\\n    this._unwrap = false;\\n    this._initialized = false;\\n}\\nutil.inherits(SomePromiseArray, PromiseArray);\\n\\nSomePromiseArray.prototype._init = function () {\\n    if (!this._initialized) {\\n        return;\\n    }\\n    if (this._howMany === 0) {\\n        this._resolve([]);\\n        return;\\n    }\\n    this._init$(undefined, -5);\\n    var isArrayResolved = isArray(this._values);\\n    if (!this._isResolved() &&\\n        isArrayResolved &&\\n        this._howMany > this._canPossiblyFulfill()) {\\n        this._reject(this._getRangeError(this.length()));\\n    }\\n};\\n\\nSomePromiseArray.prototype.init = function () {\\n    this._initialized = true;\\n    this._init();\\n};\\n\\nSomePromiseArray.prototype.setUnwrap = function () {\\n    this._unwrap = true;\\n};\\n\\nSomePromiseArray.prototype.howMany = function () {\\n    return this._howMany;\\n};\\n\\nSomePromiseArray.prototype.setHowMany = function (count) {\\n    this._howMany = count;\\n};\\n\\nSomePromiseArray.prototype._promiseFulfilled = function (value) {\\n    this._addFulfilled(value);\\n    if (this._fulfilled() === this.howMany()) {\\n        this._values.length = this.howMany();\\n        if (this.howMany() === 1 && this._unwrap) {\\n            this._resolve(this._values[0]);\\n        } else {\\n            this._resolve(this._values);\\n        }\\n        return true;\\n    }\\n    return false;\\n\\n};\\nSomePromiseArray.prototype._promiseRejected = function (reason) {\\n    this._addRejected(reason);\\n    return this._checkOutcome();\\n};\\n\\nSomePromiseArray.prototype._promiseCancelled = function () {\\n    if (this._values instanceof Promise || this._values == null) {\\n        return this._cancel();\\n    }\\n    this._addRejected(CANCELLATION);\\n    return this._checkOutcome();\\n};\\n\\nSomePromiseArray.prototype._checkOutcome = function() {\\n    if (this.howMany() > this._canPossiblyFulfill()) {\\n        var e = new AggregateError();\\n        for (var i = this.length(); i < this._values.length; ++i) {\\n            if (this._values[i] !== CANCELLATION) {\\n                e.push(this._values[i]);\\n            }\\n        }\\n        if (e.length > 0) {\\n            this._reject(e);\\n        } else {\\n            this._cancel();\\n        }\\n        return true;\\n    }\\n    return false;\\n};\\n\\nSomePromiseArray.prototype._fulfilled = function () {\\n    return this._totalResolved;\\n};\\n\\nSomePromiseArray.prototype._rejected = function () {\\n    return this._values.length - this.length();\\n};\\n\\nSomePromiseArray.prototype._addRejected = function (reason) {\\n    this._values.push(reason);\\n};\\n\\nSomePromiseArray.prototype._addFulfilled = function (value) {\\n    this._values[this._totalResolved++] = value;\\n};\\n\\nSomePromiseArray.prototype._canPossiblyFulfill = function () {\\n    return this.length() - this._rejected();\\n};\\n\\nSomePromiseArray.prototype._getRangeError = function (count) {\\n    var message = \\\"Input array must contain at least \\\" +\\n            this._howMany + \\\" items but contains only \\\" + count + \\\" items\\\";\\n    return new RangeError(message);\\n};\\n\\nSomePromiseArray.prototype._resolveEmptyArray = function () {\\n    this._reject(this._getRangeError(0));\\n};\\n\\nfunction some(promises, howMany) {\\n    if ((howMany | 0) !== howMany || howMany < 0) {\\n        return apiRejection(\\\"expecting a positive integer\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    }\\n    var ret = new SomePromiseArray(promises);\\n    var promise = ret.promise();\\n    ret.setHowMany(howMany);\\n    ret.init();\\n    return promise;\\n}\\n\\nPromise.some = function (promises, howMany) {\\n    return some(promises, howMany);\\n};\\n\\nPromise.prototype.some = function (howMany) {\\n    return some(this, howMany);\\n};\\n\\nPromise._SomePromiseArray = SomePromiseArray;\\n};\\n\\n},{\\\"./errors\\\":12,\\\"./util\\\":36}],32:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise) {\\nfunction PromiseInspection(promise) {\\n    if (promise !== undefined) {\\n        promise = promise._target();\\n        this._bitField = promise._bitField;\\n        this._settledValueField = promise._isFateSealed()\\n            ? promise._settledValue() : undefined;\\n    }\\n    else {\\n        this._bitField = 0;\\n        this._settledValueField = undefined;\\n    }\\n}\\n\\nPromiseInspection.prototype._settledValue = function() {\\n    return this._settledValueField;\\n};\\n\\nvar value = PromiseInspection.prototype.value = function () {\\n    if (!this.isFulfilled()) {\\n        throw new TypeError(\\\"cannot get fulfillment value of a non-fulfilled promise\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    }\\n    return this._settledValue();\\n};\\n\\nvar reason = PromiseInspection.prototype.error =\\nPromiseInspection.prototype.reason = function () {\\n    if (!this.isRejected()) {\\n        throw new TypeError(\\\"cannot get rejection reason of a non-rejected promise\\\\u000a\\\\u000a    See http://goo.gl/MqrFmX\\\\u000a\\\");\\n    }\\n    return this._settledValue();\\n};\\n\\nvar isFulfilled = PromiseInspection.prototype.isFulfilled = function() {\\n    return (this._bitField & 33554432) !== 0;\\n};\\n\\nvar isRejected = PromiseInspection.prototype.isRejected = function () {\\n    return (this._bitField & 16777216) !== 0;\\n};\\n\\nvar isPending = PromiseInspection.prototype.isPending = function () {\\n    return (this._bitField & 50397184) === 0;\\n};\\n\\nvar isResolved = PromiseInspection.prototype.isResolved = function () {\\n    return (this._bitField & 50331648) !== 0;\\n};\\n\\nPromiseInspection.prototype.isCancelled = function() {\\n    return (this._bitField & 8454144) !== 0;\\n};\\n\\nPromise.prototype.__isCancelled = function() {\\n    return (this._bitField & 65536) === 65536;\\n};\\n\\nPromise.prototype._isCancelled = function() {\\n    return this._target().__isCancelled();\\n};\\n\\nPromise.prototype.isCancelled = function() {\\n    return (this._target()._bitField & 8454144) !== 0;\\n};\\n\\nPromise.prototype.isPending = function() {\\n    return isPending.call(this._target());\\n};\\n\\nPromise.prototype.isRejected = function() {\\n    return isRejected.call(this._target());\\n};\\n\\nPromise.prototype.isFulfilled = function() {\\n    return isFulfilled.call(this._target());\\n};\\n\\nPromise.prototype.isResolved = function() {\\n    return isResolved.call(this._target());\\n};\\n\\nPromise.prototype.value = function() {\\n    return value.call(this._target());\\n};\\n\\nPromise.prototype.reason = function() {\\n    var target = this._target();\\n    target._unsetRejectionIsUnhandled();\\n    return reason.call(target);\\n};\\n\\nPromise.prototype._value = function() {\\n    return this._settledValue();\\n};\\n\\nPromise.prototype._reason = function() {\\n    this._unsetRejectionIsUnhandled();\\n    return this._settledValue();\\n};\\n\\nPromise.PromiseInspection = PromiseInspection;\\n};\\n\\n},{}],33:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise, INTERNAL) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar errorObj = util.errorObj;\\nvar isObject = util.isObject;\\n\\nfunction tryConvertToPromise(obj, context) {\\n    if (isObject(obj)) {\\n        if (obj instanceof Promise) return obj;\\n        var then = getThen(obj);\\n        if (then === errorObj) {\\n            if (context) context._pushContext();\\n            var ret = Promise.reject(then.e);\\n            if (context) context._popContext();\\n            return ret;\\n        } else if (typeof then === \\\"function\\\") {\\n            if (isAnyBluebirdPromise(obj)) {\\n                var ret = new Promise(INTERNAL);\\n                obj._then(\\n                    ret._fulfill,\\n                    ret._reject,\\n                    undefined,\\n                    ret,\\n                    null\\n                );\\n                return ret;\\n            }\\n            return doThenable(obj, then, context);\\n        }\\n    }\\n    return obj;\\n}\\n\\nfunction doGetThen(obj) {\\n    return obj.then;\\n}\\n\\nfunction getThen(obj) {\\n    try {\\n        return doGetThen(obj);\\n    } catch (e) {\\n        errorObj.e = e;\\n        return errorObj;\\n    }\\n}\\n\\nvar hasProp = {}.hasOwnProperty;\\nfunction isAnyBluebirdPromise(obj) {\\n    try {\\n        return hasProp.call(obj, \\\"_promise0\\\");\\n    } catch (e) {\\n        return false;\\n    }\\n}\\n\\nfunction doThenable(x, then, context) {\\n    var promise = new Promise(INTERNAL);\\n    var ret = promise;\\n    if (context) context._pushContext();\\n    promise._captureStackTrace();\\n    if (context) context._popContext();\\n    var synchronous = true;\\n    var result = util.tryCatch(then).call(x, resolve, reject);\\n    synchronous = false;\\n\\n    if (promise && result === errorObj) {\\n        promise._rejectCallback(result.e, true, true);\\n        promise = null;\\n    }\\n\\n    function resolve(value) {\\n        if (!promise) return;\\n        promise._resolveCallback(value);\\n        promise = null;\\n    }\\n\\n    function reject(reason) {\\n        if (!promise) return;\\n        promise._rejectCallback(reason, synchronous, true);\\n        promise = null;\\n    }\\n    return ret;\\n}\\n\\nreturn tryConvertToPromise;\\n};\\n\\n},{\\\"./util\\\":36}],34:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function(Promise, INTERNAL, debug) {\\nvar util = _dereq_(\\\"./util\\\");\\nvar TimeoutError = Promise.TimeoutError;\\n\\nfunction HandleWrapper(handle)  {\\n    this.handle = handle;\\n}\\n\\nHandleWrapper.prototype._resultCancelled = function() {\\n    clearTimeout(this.handle);\\n};\\n\\nvar afterValue = function(value) { return delay(+this).thenReturn(value); };\\nvar delay = Promise.delay = function (ms, value) {\\n    var ret;\\n    var handle;\\n    if (value !== undefined) {\\n        ret = Promise.resolve(value)\\n                ._then(afterValue, null, null, ms, undefined);\\n        if (debug.cancellation() && value instanceof Promise) {\\n            ret._setOnCancel(value);\\n        }\\n    } else {\\n        ret = new Promise(INTERNAL);\\n        handle = setTimeout(function() { ret._fulfill(); }, +ms);\\n        if (debug.cancellation()) {\\n            ret._setOnCancel(new HandleWrapper(handle));\\n        }\\n        ret._captureStackTrace();\\n    }\\n    ret._setAsyncGuaranteed();\\n    return ret;\\n};\\n\\nPromise.prototype.delay = function (ms) {\\n    return delay(ms, this);\\n};\\n\\nvar afterTimeout = function (promise, message, parent) {\\n    var err;\\n    if (typeof message !== \\\"string\\\") {\\n        if (message instanceof Error) {\\n            err = message;\\n        } else {\\n            err = new TimeoutError(\\\"operation timed out\\\");\\n        }\\n    } else {\\n        err = new TimeoutError(message);\\n    }\\n    util.markAsOriginatingFromRejection(err);\\n    promise._attachExtraTrace(err);\\n    promise._reject(err);\\n\\n    if (parent != null) {\\n        parent.cancel();\\n    }\\n};\\n\\nfunction successClear(value) {\\n    clearTimeout(this.handle);\\n    return value;\\n}\\n\\nfunction failureClear(reason) {\\n    clearTimeout(this.handle);\\n    throw reason;\\n}\\n\\nPromise.prototype.timeout = function (ms, message) {\\n    ms = +ms;\\n    var ret, parent;\\n\\n    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {\\n        if (ret.isPending()) {\\n            afterTimeout(ret, message, parent);\\n        }\\n    }, ms));\\n\\n    if (debug.cancellation()) {\\n        parent = this.then();\\n        ret = parent._then(successClear, failureClear,\\n                            undefined, handleWrapper, undefined);\\n        ret._setOnCancel(handleWrapper);\\n    } else {\\n        ret = this._then(successClear, failureClear,\\n                            undefined, handleWrapper, undefined);\\n    }\\n\\n    return ret;\\n};\\n\\n};\\n\\n},{\\\"./util\\\":36}],35:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\\n    createContext, INTERNAL, debug) {\\n    var util = _dereq_(\\\"./util\\\");\\n    var TypeError = _dereq_(\\\"./errors\\\").TypeError;\\n    var inherits = _dereq_(\\\"./util\\\").inherits;\\n    var errorObj = util.errorObj;\\n    var tryCatch = util.tryCatch;\\n    var NULL = {};\\n\\n    function thrower(e) {\\n        setTimeout(function(){throw e;}, 0);\\n    }\\n\\n    function castPreservingDisposable(thenable) {\\n        var maybePromise = tryConvertToPromise(thenable);\\n        if (maybePromise !== thenable &&\\n            typeof thenable._isDisposable === \\\"function\\\" &&\\n            typeof thenable._getDisposer === \\\"function\\\" &&\\n            thenable._isDisposable()) {\\n            maybePromise._setDisposable(thenable._getDisposer());\\n        }\\n        return maybePromise;\\n    }\\n    function dispose(resources, inspection) {\\n        var i = 0;\\n        var len = resources.length;\\n        var ret = new Promise(INTERNAL);\\n        function iterator() {\\n            if (i >= len) return ret._fulfill();\\n            var maybePromise = castPreservingDisposable(resources[i++]);\\n            if (maybePromise instanceof Promise &&\\n                maybePromise._isDisposable()) {\\n                try {\\n                    maybePromise = tryConvertToPromise(\\n                        maybePromise._getDisposer().tryDispose(inspection),\\n                        resources.promise);\\n                } catch (e) {\\n                    return thrower(e);\\n                }\\n                if (maybePromise instanceof Promise) {\\n                    return maybePromise._then(iterator, thrower,\\n                                              null, null, null);\\n                }\\n            }\\n            iterator();\\n        }\\n        iterator();\\n        return ret;\\n    }\\n\\n    function Disposer(data, promise, context) {\\n        this._data = data;\\n        this._promise = promise;\\n        this._context = context;\\n    }\\n\\n    Disposer.prototype.data = function () {\\n        return this._data;\\n    };\\n\\n    Disposer.prototype.promise = function () {\\n        return this._promise;\\n    };\\n\\n    Disposer.prototype.resource = function () {\\n        if (this.promise().isFulfilled()) {\\n            return this.promise().value();\\n        }\\n        return NULL;\\n    };\\n\\n    Disposer.prototype.tryDispose = function(inspection) {\\n        var resource = this.resource();\\n        var context = this._context;\\n        if (context !== undefined) context._pushContext();\\n        var ret = resource !== NULL\\n            ? this.doDispose(resource, inspection) : null;\\n        if (context !== undefined) context._popContext();\\n        this._promise._unsetDisposable();\\n        this._data = null;\\n        return ret;\\n    };\\n\\n    Disposer.isDisposer = function (d) {\\n        return (d != null &&\\n                typeof d.resource === \\\"function\\\" &&\\n                typeof d.tryDispose === \\\"function\\\");\\n    };\\n\\n    function FunctionDisposer(fn, promise, context) {\\n        this.constructor$(fn, promise, context);\\n    }\\n    inherits(FunctionDisposer, Disposer);\\n\\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\\n        var fn = this.data();\\n        return fn.call(resource, resource, inspection);\\n    };\\n\\n    function maybeUnwrapDisposer(value) {\\n        if (Disposer.isDisposer(value)) {\\n            this.resources[this.index]._setDisposable(value);\\n            return value.promise();\\n        }\\n        return value;\\n    }\\n\\n    function ResourceList(length) {\\n        this.length = length;\\n        this.promise = null;\\n        this[length-1] = null;\\n    }\\n\\n    ResourceList.prototype._resultCancelled = function() {\\n        var len = this.length;\\n        for (var i = 0; i < len; ++i) {\\n            var item = this[i];\\n            if (item instanceof Promise) {\\n                item.cancel();\\n            }\\n        }\\n    };\\n\\n    Promise.using = function () {\\n        var len = arguments.length;\\n        if (len < 2) return apiRejection(\\n                        \\\"you must pass at least 2 arguments to Promise.using\\\");\\n        var fn = arguments[len - 1];\\n        if (typeof fn !== \\\"function\\\") {\\n            return apiRejection(\\\"expecting a function but got \\\" + util.classString(fn));\\n        }\\n        var input;\\n        var spreadArgs = true;\\n        if (len === 2 && Array.isArray(arguments[0])) {\\n            input = arguments[0];\\n            len = input.length;\\n            spreadArgs = false;\\n        } else {\\n            input = arguments;\\n            len--;\\n        }\\n        var resources = new ResourceList(len);\\n        for (var i = 0; i < len; ++i) {\\n            var resource = input[i];\\n            if (Disposer.isDisposer(resource)) {\\n                var disposer = resource;\\n                resource = resource.promise();\\n                resource._setDisposable(disposer);\\n            } else {\\n                var maybePromise = tryConvertToPromise(resource);\\n                if (maybePromise instanceof Promise) {\\n                    resource =\\n                        maybePromise._then(maybeUnwrapDisposer, null, null, {\\n                            resources: resources,\\n                            index: i\\n                    }, undefined);\\n                }\\n            }\\n            resources[i] = resource;\\n        }\\n\\n        var reflectedResources = new Array(resources.length);\\n        for (var i = 0; i < reflectedResources.length; ++i) {\\n            reflectedResources[i] = Promise.resolve(resources[i]).reflect();\\n        }\\n\\n        var resultPromise = Promise.all(reflectedResources)\\n            .then(function(inspections) {\\n                for (var i = 0; i < inspections.length; ++i) {\\n                    var inspection = inspections[i];\\n                    if (inspection.isRejected()) {\\n                        errorObj.e = inspection.error();\\n                        return errorObj;\\n                    } else if (!inspection.isFulfilled()) {\\n                        resultPromise.cancel();\\n                        return;\\n                    }\\n                    inspections[i] = inspection.value();\\n                }\\n                promise._pushContext();\\n\\n                fn = tryCatch(fn);\\n                var ret = spreadArgs\\n                    ? fn.apply(undefined, inspections) : fn(inspections);\\n                var promiseCreated = promise._popContext();\\n                debug.checkForgottenReturns(\\n                    ret, promiseCreated, \\\"Promise.using\\\", promise);\\n                return ret;\\n            });\\n\\n        var promise = resultPromise.lastly(function() {\\n            var inspection = new Promise.PromiseInspection(resultPromise);\\n            return dispose(resources, inspection);\\n        });\\n        resources.promise = promise;\\n        promise._setOnCancel(resources);\\n        return promise;\\n    };\\n\\n    Promise.prototype._setDisposable = function (disposer) {\\n        this._bitField = this._bitField | 131072;\\n        this._disposer = disposer;\\n    };\\n\\n    Promise.prototype._isDisposable = function () {\\n        return (this._bitField & 131072) > 0;\\n    };\\n\\n    Promise.prototype._getDisposer = function () {\\n        return this._disposer;\\n    };\\n\\n    Promise.prototype._unsetDisposable = function () {\\n        this._bitField = this._bitField & (~131072);\\n        this._disposer = undefined;\\n    };\\n\\n    Promise.prototype.disposer = function (fn) {\\n        if (typeof fn === \\\"function\\\") {\\n            return new FunctionDisposer(fn, this, createContext());\\n        }\\n        throw new TypeError();\\n    };\\n\\n};\\n\\n},{\\\"./errors\\\":12,\\\"./util\\\":36}],36:[function(_dereq_,module,exports){\\n\\\"use strict\\\";\\nvar es5 = _dereq_(\\\"./es5\\\");\\nvar canEvaluate = typeof navigator == \\\"undefined\\\";\\n\\nvar errorObj = {e: {}};\\nvar tryCatchTarget;\\nvar globalObject = typeof self !== \\\"undefined\\\" ? self :\\n    typeof window !== \\\"undefined\\\" ? window :\\n    typeof global !== \\\"undefined\\\" ? global :\\n    this !== undefined ? this : null;\\n\\nfunction tryCatcher() {\\n    try {\\n        var target = tryCatchTarget;\\n        tryCatchTarget = null;\\n        return target.apply(this, arguments);\\n    } catch (e) {\\n        errorObj.e = e;\\n        return errorObj;\\n    }\\n}\\nfunction tryCatch(fn) {\\n    tryCatchTarget = fn;\\n    return tryCatcher;\\n}\\n\\nvar inherits = function(Child, Parent) {\\n    var hasProp = {}.hasOwnProperty;\\n\\n    function T() {\\n        this.constructor = Child;\\n        this.constructor$ = Parent;\\n        for (var propertyName in Parent.prototype) {\\n            if (hasProp.call(Parent.prototype, propertyName) &&\\n                propertyName.charAt(propertyName.length-1) !== \\\"$\\\"\\n           ) {\\n                this[propertyName + \\\"$\\\"] = Parent.prototype[propertyName];\\n            }\\n        }\\n    }\\n    T.prototype = Parent.prototype;\\n    Child.prototype = new T();\\n    return Child.prototype;\\n};\\n\\n\\nfunction isPrimitive(val) {\\n    return val == null || val === true || val === false ||\\n        typeof val === \\\"string\\\" || typeof val === \\\"number\\\";\\n\\n}\\n\\nfunction isObject(value) {\\n    return typeof value === \\\"function\\\" ||\\n           typeof value === \\\"object\\\" && value !== null;\\n}\\n\\nfunction maybeWrapAsError(maybeError) {\\n    if (!isPrimitive(maybeError)) return maybeError;\\n\\n    return new Error(safeToString(maybeError));\\n}\\n\\nfunction withAppended(target, appendee) {\\n    var len = target.length;\\n    var ret = new Array(len + 1);\\n    var i;\\n    for (i = 0; i < len; ++i) {\\n        ret[i] = target[i];\\n    }\\n    ret[i] = appendee;\\n    return ret;\\n}\\n\\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\\n    if (es5.isES5) {\\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\\n\\n        if (desc != null) {\\n            return desc.get == null && desc.set == null\\n                    ? desc.value\\n                    : defaultValue;\\n        }\\n    } else {\\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\\n    }\\n}\\n\\nfunction notEnumerableProp(obj, name, value) {\\n    if (isPrimitive(obj)) return obj;\\n    var descriptor = {\\n        value: value,\\n        configurable: true,\\n        enumerable: false,\\n        writable: true\\n    };\\n    es5.defineProperty(obj, name, descriptor);\\n    return obj;\\n}\\n\\nfunction thrower(r) {\\n    throw r;\\n}\\n\\nvar inheritedDataKeys = (function() {\\n    var excludedPrototypes = [\\n        Array.prototype,\\n        Object.prototype,\\n        Function.prototype\\n    ];\\n\\n    var isExcludedProto = function(val) {\\n        for (var i = 0; i < excludedPrototypes.length; ++i) {\\n            if (excludedPrototypes[i] === val) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n\\n    if (es5.isES5) {\\n        var getKeys = Object.getOwnPropertyNames;\\n        return function(obj) {\\n            var ret = [];\\n            var visitedKeys = Object.create(null);\\n            while (obj != null && !isExcludedProto(obj)) {\\n                var keys;\\n                try {\\n                    keys = getKeys(obj);\\n                } catch (e) {\\n                    return ret;\\n                }\\n                for (var i = 0; i < keys.length; ++i) {\\n                    var key = keys[i];\\n                    if (visitedKeys[key]) continue;\\n                    visitedKeys[key] = true;\\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\\n                    if (desc != null && desc.get == null && desc.set == null) {\\n                        ret.push(key);\\n                    }\\n                }\\n                obj = es5.getPrototypeOf(obj);\\n            }\\n            return ret;\\n        };\\n    } else {\\n        var hasProp = {}.hasOwnProperty;\\n        return function(obj) {\\n            if (isExcludedProto(obj)) return [];\\n            var ret = [];\\n\\n            /*jshint forin:false */\\n            enumeration: for (var key in obj) {\\n                if (hasProp.call(obj, key)) {\\n                    ret.push(key);\\n                } else {\\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\\n                        if (hasProp.call(excludedPrototypes[i], key)) {\\n                            continue enumeration;\\n                        }\\n                    }\\n                    ret.push(key);\\n                }\\n            }\\n            return ret;\\n        };\\n    }\\n\\n})();\\n\\nvar thisAssignmentPattern = /this\\\\s*\\\\.\\\\s*\\\\S+\\\\s*=/;\\nfunction isClass(fn) {\\n    try {\\n        if (typeof fn === \\\"function\\\") {\\n            var keys = es5.names(fn.prototype);\\n\\n            var hasMethods = es5.isES5 && keys.length > 1;\\n            var hasMethodsOtherThanConstructor = keys.length > 0 &&\\n                !(keys.length === 1 && keys[0] === \\\"constructor\\\");\\n            var hasThisAssignmentAndStaticMethods =\\n                thisAssignmentPattern.test(fn + \\\"\\\") && es5.names(fn).length > 0;\\n\\n            if (hasMethods || hasMethodsOtherThanConstructor ||\\n                hasThisAssignmentAndStaticMethods) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    } catch (e) {\\n        return false;\\n    }\\n}\\n\\nfunction toFastProperties(obj) {\\n    /*jshint -W027,-W055,-W031*/\\n    function FakeConstructor() {}\\n    FakeConstructor.prototype = obj;\\n    var l = 8;\\n    while (l--) new FakeConstructor();\\n    return obj;\\n    eval(obj);\\n}\\n\\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\\nfunction isIdentifier(str) {\\n    return rident.test(str);\\n}\\n\\nfunction filledRange(count, prefix, suffix) {\\n    var ret = new Array(count);\\n    for(var i = 0; i < count; ++i) {\\n        ret[i] = prefix + i + suffix;\\n    }\\n    return ret;\\n}\\n\\nfunction safeToString(obj) {\\n    try {\\n        return obj + \\\"\\\";\\n    } catch (e) {\\n        return \\\"[no string representation]\\\";\\n    }\\n}\\n\\nfunction isError(obj) {\\n    return obj instanceof Error ||\\n        (obj !== null &&\\n           typeof obj === \\\"object\\\" &&\\n           typeof obj.message === \\\"string\\\" &&\\n           typeof obj.name === \\\"string\\\");\\n}\\n\\nfunction markAsOriginatingFromRejection(e) {\\n    try {\\n        notEnumerableProp(e, \\\"isOperational\\\", true);\\n    }\\n    catch(ignore) {}\\n}\\n\\nfunction originatesFromRejection(e) {\\n    if (e == null) return false;\\n    return ((e instanceof Error[\\\"__BluebirdErrorTypes__\\\"].OperationalError) ||\\n        e[\\\"isOperational\\\"] === true);\\n}\\n\\nfunction canAttachTrace(obj) {\\n    return isError(obj) && es5.propertyIsWritable(obj, \\\"stack\\\");\\n}\\n\\nvar ensureErrorObject = (function() {\\n    if (!(\\\"stack\\\" in new Error())) {\\n        return function(value) {\\n            if (canAttachTrace(value)) return value;\\n            try {throw new Error(safeToString(value));}\\n            catch(err) {return err;}\\n        };\\n    } else {\\n        return function(value) {\\n            if (canAttachTrace(value)) return value;\\n            return new Error(safeToString(value));\\n        };\\n    }\\n})();\\n\\nfunction classString(obj) {\\n    return {}.toString.call(obj);\\n}\\n\\nfunction copyDescriptors(from, to, filter) {\\n    var keys = es5.names(from);\\n    for (var i = 0; i < keys.length; ++i) {\\n        var key = keys[i];\\n        if (filter(key)) {\\n            try {\\n                es5.defineProperty(to, key, es5.getDescriptor(from, key));\\n            } catch (ignore) {}\\n        }\\n    }\\n}\\n\\nvar asArray = function(v) {\\n    if (es5.isArray(v)) {\\n        return v;\\n    }\\n    return null;\\n};\\n\\nif (typeof Symbol !== \\\"undefined\\\" && Symbol.iterator) {\\n    var ArrayFrom = typeof Array.from === \\\"function\\\" ? function(v) {\\n        return Array.from(v);\\n    } : function(v) {\\n        var ret = [];\\n        var it = v[Symbol.iterator]();\\n        var itResult;\\n        while (!((itResult = it.next()).done)) {\\n            ret.push(itResult.value);\\n        }\\n        return ret;\\n    };\\n\\n    asArray = function(v) {\\n        if (es5.isArray(v)) {\\n            return v;\\n        } else if (v != null && typeof v[Symbol.iterator] === \\\"function\\\") {\\n            return ArrayFrom(v);\\n        }\\n        return null;\\n    };\\n}\\n\\nvar isNode = typeof process !== \\\"undefined\\\" &&\\n        classString(process).toLowerCase() === \\\"[object process]\\\";\\n\\nvar hasEnvVariables = typeof process !== \\\"undefined\\\" &&\\n    typeof process.env !== \\\"undefined\\\";\\n\\nfunction env(key) {\\n    return hasEnvVariables ? process.env[key] : undefined;\\n}\\n\\nfunction getNativePromise() {\\n    if (typeof Promise === \\\"function\\\") {\\n        try {\\n            var promise = new Promise(function(){});\\n            if ({}.toString.call(promise) === \\\"[object Promise]\\\") {\\n                return Promise;\\n            }\\n        } catch (e) {}\\n    }\\n}\\n\\nfunction domainBind(self, cb) {\\n    return self.bind(cb);\\n}\\n\\nvar ret = {\\n    isClass: isClass,\\n    isIdentifier: isIdentifier,\\n    inheritedDataKeys: inheritedDataKeys,\\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\\n    thrower: thrower,\\n    isArray: es5.isArray,\\n    asArray: asArray,\\n    notEnumerableProp: notEnumerableProp,\\n    isPrimitive: isPrimitive,\\n    isObject: isObject,\\n    isError: isError,\\n    canEvaluate: canEvaluate,\\n    errorObj: errorObj,\\n    tryCatch: tryCatch,\\n    inherits: inherits,\\n    withAppended: withAppended,\\n    maybeWrapAsError: maybeWrapAsError,\\n    toFastProperties: toFastProperties,\\n    filledRange: filledRange,\\n    toString: safeToString,\\n    canAttachTrace: canAttachTrace,\\n    ensureErrorObject: ensureErrorObject,\\n    originatesFromRejection: originatesFromRejection,\\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\\n    classString: classString,\\n    copyDescriptors: copyDescriptors,\\n    hasDevTools: typeof chrome !== \\\"undefined\\\" && chrome &&\\n                 typeof chrome.loadTimes === \\\"function\\\",\\n    isNode: isNode,\\n    hasEnvVariables: hasEnvVariables,\\n    env: env,\\n    global: globalObject,\\n    getNativePromise: getNativePromise,\\n    domainBind: domainBind\\n};\\nret.isRecentNode = ret.isNode && (function() {\\n    var version = process.versions.node.split(\\\".\\\").map(Number);\\n    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);\\n})();\\n\\nif (ret.isNode) ret.toFastProperties(process);\\n\\ntry {throw new Error(); } catch (e) {ret.lastLineError = e;}\\nmodule.exports = ret;\\n\\n},{\\\"./es5\\\":13}]},{},[4])(4)\\n});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34), __webpack_require__(21), __webpack_require__(39).setImmediate))\\n\\n/***/ }),\\n/* 26 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONNECTION_DISCONNECTED\\\", function() { return CONNECTION_DISCONNECTED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONNECTION_ESTABLISHED\\\", function() { return CONNECTION_ESTABLISHED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONNECTION_FAILED\\\", function() { return CONNECTION_FAILED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WRONG_STATE\\\", function() { return WRONG_STATE; });\\n/**\\n * The events for the connection.\\n */\\n\\n/**\\n * Indicates that the connection has been disconnected. The event provides\\n * the following parameters to its listeners:\\n *\\n * @param msg {string} a message associated with the disconnect such as the\\n * last (known) error message\\n */\\nvar CONNECTION_DISCONNECTED = 'connection.connectionDisconnected';\\n\\n/**\\n * Indicates that the connection has been established. The event provides\\n * the following parameters to its listeners:\\n *\\n * @param id {string} the ID of the local endpoint/participant/peer (within\\n * the context of the established connection)\\n */\\nvar CONNECTION_ESTABLISHED = 'connection.connectionEstablished';\\n\\n/**\\n * Indicates that the connection has been failed for some reason. The event\\n * provides the following parameters to its listeners:\\n *\\n * @param err {string} the error (message) associated with the failure\\n */\\nvar CONNECTION_FAILED = 'connection.connectionFailed';\\n\\n/**\\n * Indicates that the performed action cannot be executed because the\\n * connection is not in the correct state(connected, disconnected, etc.)\\n */\\nvar WRONG_STATE = 'connection.wrongState';\\n\\n/***/ }),\\n/* 27 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__BridgeChannel__ = __webpack_require__(119);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__JitsiConferenceEvents__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__JitsiLocalTrack__ = __webpack_require__(120);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__JitsiTrackError__ = __webpack_require__(12);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__JitsiTrackErrors__ = __webpack_require__(17);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util_Listenable__ = __webpack_require__(10);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__RTCUtils__ = __webpack_require__(28);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__statistics_statistics__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__TraceablePeerConnection__ = __webpack_require__(142);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__service_RTC_VideoType__ = __webpack_require__(13);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__service_RTC_VideoType___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14__service_RTC_VideoType__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global __filename */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\nvar rtcTrackIdCounter = 0;\\n\\n/**\\n *\\n * @param tracksInfo\\n * @param options\\n */\\nfunction createLocalTracks(tracksInfo, options) {\\n    var newTracks = [];\\n    var deviceId = null;\\n\\n    tracksInfo.forEach(function (trackInfo) {\\n        if (trackInfo.mediaType === __WEBPACK_IMPORTED_MODULE_8__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]) {\\n            deviceId = options.micDeviceId;\\n        } else if (trackInfo.videoType === __WEBPACK_IMPORTED_MODULE_14__service_RTC_VideoType___default.a.CAMERA) {\\n            deviceId = options.cameraDeviceId;\\n        }\\n        rtcTrackIdCounter += 1;\\n        var localTrack = new __WEBPACK_IMPORTED_MODULE_4__JitsiLocalTrack__[\\\"a\\\" /* default */](_extends({}, trackInfo, {\\n            deviceId: deviceId,\\n            facingMode: options.facingMode,\\n            rtcId: rtcTrackIdCounter\\n        }));\\n\\n        newTracks.push(localTrack);\\n    });\\n\\n    return newTracks;\\n}\\n\\n/**\\n * Creates {@code JitsiLocalTrack} instances from the passed in meta information\\n * about MedieaTracks.\\n *\\n * @param {Object[]} mediaStreamMetaData - An array of meta information with\\n * MediaTrack instances. Each can look like:\\n * {{\\n *     stream: MediaStream instance that holds a track with audio or video,\\n *     track: MediaTrack within the MediaStream,\\n *     videoType: \\\"camera\\\" or \\\"desktop\\\" or falsy,\\n *     sourceId: ID of the desktopsharing source,\\n *     sourceType: The desktopsharing source type\\n * }}\\n */\\nfunction _newCreateLocalTracks() {\\n    var mediaStreamMetaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n    return mediaStreamMetaData.map(function (metaData) {\\n        var sourceId = metaData.sourceId,\\n            sourceType = metaData.sourceType,\\n            stream = metaData.stream,\\n            track = metaData.track,\\n            videoType = metaData.videoType;\\n\\n        var _track$getSettings = track.getSettings(),\\n            deviceId = _track$getSettings.deviceId,\\n            facingMode = _track$getSettings.facingMode;\\n\\n        // FIXME Move rtcTrackIdCounter to a static method in JitsiLocalTrack\\n        // so RTC does not need to handle ID management. This move would be\\n        // safer to do once the old createLocalTracks is removed.\\n\\n\\n        rtcTrackIdCounter += 1;\\n\\n        return new __WEBPACK_IMPORTED_MODULE_4__JitsiLocalTrack__[\\\"a\\\" /* default */]({\\n            deviceId: deviceId,\\n            facingMode: facingMode,\\n            mediaType: track.kind,\\n            rtcId: rtcTrackIdCounter,\\n            sourceId: sourceId,\\n            sourceType: sourceType,\\n            stream: stream,\\n            track: track,\\n            videoType: videoType || null\\n        });\\n    });\\n}\\n\\n/**\\n *\\n */\\n\\nvar RTC = function (_Listenable) {\\n    _inherits(RTC, _Listenable);\\n\\n    /**\\n     *\\n     * @param conference\\n     * @param options\\n     */\\n    function RTC(conference) {\\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n        _classCallCheck(this, RTC);\\n\\n        var _this = _possibleConstructorReturn(this, (RTC.__proto__ || Object.getPrototypeOf(RTC)).call(this));\\n\\n        _this.conference = conference;\\n\\n        /**\\n         * A map of active <tt>TraceablePeerConnection</tt>.\\n         * @type {Map.<number, TraceablePeerConnection>}\\n         */\\n        _this.peerConnections = new Map();\\n\\n        /**\\n         * The counter used to generated id numbers assigned to peer connections\\n         * @type {number}\\n         */\\n        _this.peerConnectionIdCounter = 1;\\n\\n        _this.localTracks = [];\\n\\n        _this.options = options;\\n\\n        // BridgeChannel instance.\\n        // @private\\n        // @type {BridgeChannel}\\n        _this._channel = null;\\n\\n        // A flag whether we had received that the channel had opened we can\\n        // get this flag out of sync if for some reason channel got closed\\n        // from server, a desired behaviour so we can see errors when this\\n        // happen.\\n        // @private\\n        // @type {boolean}\\n        _this._channelOpen = false;\\n\\n        /**\\n         * The value specified to the last invocation of setLastN before the\\n         * channel completed opening. If non-null, the value will be sent\\n         * through a channel (once) as soon as it opens and will then be\\n         * discarded.\\n         * @private\\n         * @type {number}\\n         */\\n        _this._lastN = -1;\\n\\n        /**\\n         * Defines the last N endpoints list. It can be null or an array once\\n         * initialised with a channel last N event.\\n         * @type {Array<string>|null}\\n         * @private\\n         */\\n        _this._lastNEndpoints = null;\\n\\n        /**\\n         * The endpoint ID of currently pinned participant or <tt>null</tt> if\\n         * no user is pinned.\\n         * @type {string|null}\\n         * @private\\n         */\\n        _this._pinnedEndpoint = null;\\n\\n        /**\\n         * The endpoint ID of currently selected participant or <tt>null</tt> if\\n         * no user is selected.\\n         * @type {string|null}\\n         * @private\\n         */\\n        _this._selectedEndpoint = null;\\n\\n        // The last N change listener.\\n        _this._lastNChangeListener = _this._onLastNChanged.bind(_this);\\n\\n        // Switch audio output device on all remote audio tracks. Local audio\\n        // tracks handle this event by themselves.\\n        if (__WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].isDeviceChangeAvailable('output')) {\\n            __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].addListener(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.AUDIO_OUTPUT_DEVICE_CHANGED, function (deviceId) {\\n                return _this._updateAudioOutputForAudioTracks(deviceId);\\n            });\\n\\n            __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].addListener(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.DEVICE_LIST_CHANGED, function () {\\n                return _this._updateAudioOutputForAudioTracks(__WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].getAudioOutputDevice());\\n            });\\n        }\\n        return _this;\\n    }\\n\\n    /**\\n     * Creates the local MediaStreams.\\n     * @param {object} [options] Optional parameters.\\n     * @param {array} options.devices The devices that will be requested.\\n     * @param {string} options.resolution Resolution constraints.\\n     * @param {bool} options.dontCreateJitsiTrack If <tt>true</tt> objects with\\n     *     the following structure {stream: the Media Stream, type: \\\"audio\\\" or\\n     *     \\\"video\\\", videoType: \\\"camera\\\" or \\\"desktop\\\"} will be returned trough\\n     *     the Promise, otherwise JitsiTrack objects will be returned.\\n     * @param {string} options.cameraDeviceId\\n     * @param {string} options.micDeviceId\\n     * @returns {*} Promise object that will receive the new JitsiTracks\\n     */\\n\\n\\n    _createClass(RTC, [{\\n        key: 'initializeBridgeChannel',\\n\\n\\n        /**\\n         * Initializes the bridge channel of this instance.\\n         * At least one of both, peerconnection or wsUrl parameters, must be\\n         * given.\\n         * @param {RTCPeerConnection} [peerconnection] WebRTC peer connection\\n         * instance.\\n         * @param {string} [wsUrl] WebSocket URL.\\n         */\\n        value: function initializeBridgeChannel(peerconnection, wsUrl) {\\n            var _this2 = this;\\n\\n            this._channel = new __WEBPACK_IMPORTED_MODULE_1__BridgeChannel__[\\\"a\\\" /* default */](peerconnection, wsUrl, this.eventEmitter);\\n\\n            this._channelOpenListener = function () {\\n                // Mark that channel as opened.\\n                _this2._channelOpen = true;\\n\\n                // When the channel becomes available, tell the bridge about\\n                // video selections so that it can do adaptive simulcast,\\n                // we want the notification to trigger even if userJid\\n                // is undefined, or null.\\n                try {\\n                    _this2._channel.sendPinnedEndpointMessage(_this2._pinnedEndpoint);\\n                    _this2._channel.sendSelectedEndpointMessage(_this2._selectedEndpoint);\\n                } catch (error) {\\n                    __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default.a.callErrorHandler(error);\\n                    logger.error('Cannot send selected(' + _this2._selectedEndpoint + ')' + ('pinned(' + _this2._pinnedEndpoint + ') endpoint message.'), error);\\n                }\\n\\n                _this2.removeListener(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.DATA_CHANNEL_OPEN, _this2._channelOpenListener);\\n                _this2._channelOpenListener = null;\\n\\n                // If setLastN was invoked before the bridge channel completed\\n                // opening, apply the specified value now that the channel\\n                // is open. NOTE that -1 is the default value assumed by both\\n                // RTC module and the JVB.\\n                if (_this2._lastN !== -1) {\\n                    _this2._channel.sendSetLastNMessage(_this2._lastN);\\n                }\\n            };\\n\\n            this.addListener(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.DATA_CHANNEL_OPEN, this._channelOpenListener);\\n\\n            // Add Last N change listener.\\n            this.addListener(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener);\\n        }\\n\\n        /**\\n         * Receives events when Last N had changed.\\n         * @param {array} lastNEndpoints The new Last N endpoints.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_onLastNChanged',\\n        value: function _onLastNChanged() {\\n            var _this3 = this;\\n\\n            var lastNEndpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n            var oldLastNEndpoints = this._lastNEndpoints || [];\\n            var leavingLastNEndpoints = [];\\n            var enteringLastNEndpoints = [];\\n\\n            this._lastNEndpoints = lastNEndpoints;\\n\\n            leavingLastNEndpoints = oldLastNEndpoints.filter(function (id) {\\n                return !_this3.isInLastN(id);\\n            });\\n\\n            enteringLastNEndpoints = lastNEndpoints.filter(function (id) {\\n                return oldLastNEndpoints.indexOf(id) === -1;\\n            });\\n\\n            this.conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_3__JitsiConferenceEvents__[\\\"LAST_N_ENDPOINTS_CHANGED\\\"], leavingLastNEndpoints, enteringLastNEndpoints);\\n        }\\n\\n        /**\\n         * Should be called when current media session ends and after the\\n         * PeerConnection has been closed using PeerConnection.close() method.\\n         */\\n\\n    }, {\\n        key: 'onCallEnded',\\n        value: function onCallEnded() {\\n            if (this._channel) {\\n                // The BridgeChannel is not explicitly closed as the PeerConnection\\n                // is closed on call ended which triggers datachannel onclose\\n                // events. If using a WebSocket, the channel must be closed since\\n                // it is not managed by the PeerConnection.\\n                // The reference is cleared to disable any logic related to the\\n                // channel.\\n                if (this._channel && this._channel.mode === 'websocket') {\\n                    this._channel.close();\\n                }\\n\\n                this._channel = null;\\n                this._channelOpen = false;\\n            }\\n        }\\n\\n        /**\\n         * Sets the maximum video size the local participant should receive from\\n         * remote participants. Will no-op if no data channel has been established.\\n         *\\n         * @param {number} maxFrameHeightPixels the maximum frame height, in pixels,\\n         * this receiver is willing to receive.\\n         * @returns {void}\\n         */\\n\\n    }, {\\n        key: 'setReceiverVideoConstraint',\\n        value: function setReceiverVideoConstraint(maxFrameHeight) {\\n            if (this._channel) {\\n                this._channel.sendReceiverVideoConstraintMessage(maxFrameHeight);\\n            }\\n        }\\n\\n        /**\\n         * Elects the participant with the given id to be the selected participant\\n         * in order to always receive video for this participant (even when last n\\n         * is enabled).\\n         * If there is no channel we store it and send it through the channel once\\n         * it is created.\\n         * @param {string} id The user id.\\n         * @throws NetworkError or InvalidStateError or Error if the operation\\n         * fails.\\n         */\\n\\n    }, {\\n        key: 'selectEndpoint',\\n        value: function selectEndpoint(id) {\\n            // Cache the value if channel is missing, till we open it.\\n            this._selectedEndpoint = id;\\n            if (this._channel && this._channelOpen) {\\n                this._channel.sendSelectedEndpointMessage(id);\\n            }\\n        }\\n\\n        /**\\n         * Elects the participant with the given id to be the pinned participant in\\n         * order to always receive video for this participant (even when last n is\\n         * enabled).\\n         * @param {stirng} id The user id.\\n         * @throws NetworkError or InvalidStateError or Error if the operation\\n         * fails.\\n         */\\n\\n    }, {\\n        key: 'pinEndpoint',\\n        value: function pinEndpoint(id) {\\n            // Cache the value if channel is missing, till we open it.\\n            this._pinnedEndpoint = id;\\n            if (this._channel && this._channelOpen) {\\n                this._channel.sendPinnedEndpointMessage(id);\\n            }\\n        }\\n\\n        /**\\n         *\\n         * @param eventType\\n         * @param listener\\n         */\\n\\n    }, {\\n        key: 'createPeerConnection',\\n\\n\\n        /* eslint-disable max-params */\\n\\n        /**\\n         * Creates new <tt>TraceablePeerConnection</tt>\\n         * @param {SignalingLayer} signaling The signaling layer that will\\n         *      provide information about the media or participants which is not\\n         *      carried over SDP.\\n         * @param {object} iceConfig An object describing the ICE config like\\n         *      defined in the WebRTC specification.\\n         * @param {boolean} isP2P Indicates whether or not the new TPC will be used\\n         *      in a peer to peer type of session.\\n         * @param {object} options The config options.\\n         * @param {boolean} options.disableSimulcast If set to 'true' will disable\\n         *      the simulcast.\\n         * @param {boolean} options.disableRtx If set to 'true' will disable the\\n         *      RTX.\\n         * @param {boolean} options.disableH264 If set to 'true' H264 will be\\n         *      disabled by removing it from the SDP.\\n         * @param {boolean} options.preferH264 If set to 'true' H264 will be\\n         *      preferred over other video codecs.\\n         * @return {TraceablePeerConnection}\\n         */\\n        value: function createPeerConnection(signaling, iceConfig, isP2P, options) {\\n            var pcConstraints = RTC.getPCConstraints(isP2P);\\n\\n            if (typeof options.abtestSuspendVideo !== 'undefined') {\\n                __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].setSuspendVideo(pcConstraints, options.abtestSuspendVideo);\\n\\n                __WEBPACK_IMPORTED_MODULE_12__statistics_statistics__[\\\"a\\\" /* default */].analytics.addPermanentProperties({ abtestSuspendVideo: options.abtestSuspendVideo });\\n            }\\n\\n            var newConnection = new __WEBPACK_IMPORTED_MODULE_13__TraceablePeerConnection__[\\\"a\\\" /* default */](this, this.peerConnectionIdCounter, signaling, iceConfig, pcConstraints, isP2P, options);\\n\\n            this.peerConnections.set(newConnection.id, newConnection);\\n            this.peerConnectionIdCounter += 1;\\n\\n            return newConnection;\\n        }\\n\\n        /* eslint-enable max-params */\\n\\n        /**\\n         * Removed given peer connection from this RTC module instance.\\n         * @param {TraceablePeerConnection} traceablePeerConnection\\n         * @return {boolean} <tt>true</tt> if the given peer connection was removed\\n         * successfully or <tt>false</tt> if there was no peer connection mapped in\\n         * this RTC instance.\\n         */\\n\\n    }, {\\n        key: '_removePeerConnection',\\n        value: function _removePeerConnection(traceablePeerConnection) {\\n            var id = traceablePeerConnection.id;\\n\\n            if (this.peerConnections.has(id)) {\\n                // NOTE Remote tracks are not removed here.\\n                this.peerConnections.delete(id);\\n\\n                return true;\\n            }\\n\\n            return false;\\n        }\\n\\n        /**\\n         *\\n         * @param track\\n         */\\n\\n    }, {\\n        key: 'addLocalTrack',\\n        value: function addLocalTrack(track) {\\n            if (!track) {\\n                throw new Error('track must not be null nor undefined');\\n            }\\n\\n            this.localTracks.push(track);\\n\\n            track.conference = this.conference;\\n        }\\n\\n        /**\\n         * Returns the current value for \\\"lastN\\\" - the amount of videos are going\\n         * to be delivered. When set to -1 for unlimited or all available videos.\\n         * @return {number}\\n         */\\n\\n    }, {\\n        key: 'getLastN',\\n        value: function getLastN() {\\n            return this._lastN;\\n        }\\n\\n        /**\\n         * Get local video track.\\n         * @returns {JitsiLocalTrack|undefined}\\n         */\\n\\n    }, {\\n        key: 'getLocalVideoTrack',\\n        value: function getLocalVideoTrack() {\\n            var localVideo = this.getLocalTracks(__WEBPACK_IMPORTED_MODULE_8__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]);\\n\\n            return localVideo.length ? localVideo[0] : undefined;\\n        }\\n\\n        /**\\n         * Get local audio track.\\n         * @returns {JitsiLocalTrack|undefined}\\n         */\\n\\n    }, {\\n        key: 'getLocalAudioTrack',\\n        value: function getLocalAudioTrack() {\\n            var localAudio = this.getLocalTracks(__WEBPACK_IMPORTED_MODULE_8__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]);\\n\\n            return localAudio.length ? localAudio[0] : undefined;\\n        }\\n\\n        /**\\n         * Returns the local tracks of the given media type, or all local tracks if\\n         * no specific type is given.\\n         * @param {MediaType} [mediaType] Optional media type filter.\\n         * (audio or video).\\n         */\\n\\n    }, {\\n        key: 'getLocalTracks',\\n        value: function getLocalTracks(mediaType) {\\n            var tracks = this.localTracks.slice();\\n\\n            if (mediaType !== undefined) {\\n                tracks = tracks.filter(function (track) {\\n                    return track.getType() === mediaType;\\n                });\\n            }\\n\\n            return tracks;\\n        }\\n\\n        /**\\n         * Obtains all remote tracks currently known to this RTC module instance.\\n         * @param {MediaType} [mediaType] The remote tracks will be filtered\\n         *      by their media type if this argument is specified.\\n         * @return {Array<JitsiRemoteTrack>}\\n         */\\n\\n    }, {\\n        key: 'getRemoteTracks',\\n        value: function getRemoteTracks(mediaType) {\\n            var remoteTracks = [];\\n\\n            var _iteratorNormalCompletion = true;\\n            var _didIteratorError = false;\\n            var _iteratorError = undefined;\\n\\n            try {\\n                for (var _iterator = this.peerConnections.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                    var tpc = _step.value;\\n\\n                    var pcRemoteTracks = tpc.getRemoteTracks(undefined, mediaType);\\n\\n                    if (pcRemoteTracks) {\\n                        remoteTracks = remoteTracks.concat(pcRemoteTracks);\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError = true;\\n                _iteratorError = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion && _iterator.return) {\\n                        _iterator.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError) {\\n                        throw _iteratorError;\\n                    }\\n                }\\n            }\\n\\n            return remoteTracks;\\n        }\\n\\n        /**\\n         * Set mute for all local audio streams attached to the conference.\\n         * @param value The mute value.\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: 'setAudioMute',\\n        value: function setAudioMute(value) {\\n            var mutePromises = [];\\n\\n            this.getLocalTracks(__WEBPACK_IMPORTED_MODULE_8__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]).forEach(function (audioTrack) {\\n                // this is a Promise\\n                mutePromises.push(value ? audioTrack.mute() : audioTrack.unmute());\\n            });\\n\\n            // We return a Promise from all Promises so we can wait for their\\n            // execution.\\n            return Promise.all(mutePromises);\\n        }\\n\\n        /**\\n         *\\n         * @param track\\n         */\\n\\n    }, {\\n        key: 'removeLocalTrack',\\n        value: function removeLocalTrack(track) {\\n            var pos = this.localTracks.indexOf(track);\\n\\n            if (pos === -1) {\\n                return;\\n            }\\n\\n            this.localTracks.splice(pos, 1);\\n        }\\n\\n        /**\\n         * Removes all JitsiRemoteTracks associated with given MUC nickname\\n         * (resource part of the JID). Returns array of removed tracks.\\n         *\\n         * @param {string} Owner The resource part of the MUC JID.\\n         * @returns {JitsiRemoteTrack[]}\\n         */\\n\\n    }, {\\n        key: 'removeRemoteTracks',\\n        value: function removeRemoteTracks(owner) {\\n            var removedTracks = [];\\n\\n            var _iteratorNormalCompletion2 = true;\\n            var _didIteratorError2 = false;\\n            var _iteratorError2 = undefined;\\n\\n            try {\\n                for (var _iterator2 = this.peerConnections.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                    var tpc = _step2.value;\\n\\n                    var pcRemovedTracks = tpc.removeRemoteTracks(owner);\\n\\n                    removedTracks = removedTracks.concat(pcRemovedTracks);\\n                }\\n            } catch (err) {\\n                _didIteratorError2 = true;\\n                _iteratorError2 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                        _iterator2.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError2) {\\n                        throw _iteratorError2;\\n                    }\\n                }\\n            }\\n\\n            logger.debug('Removed remote tracks for ' + owner + (' count: ' + removedTracks.length));\\n\\n            return removedTracks;\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'closeBridgeChannel',\\n\\n\\n        /**\\n         * Closes the currently opened bridge channel.\\n         */\\n        value: function closeBridgeChannel() {\\n            if (this._channel) {\\n                this._channel.close();\\n                this._channelOpen = false;\\n\\n                this.removeListener(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener);\\n            }\\n        }\\n\\n        /* eslint-disable max-params */\\n        /**\\n         *\\n         * @param {TraceablePeerConnection} tpc\\n         * @param {number} ssrc\\n         * @param {number} audioLevel\\n         * @param {boolean} isLocal\\n         */\\n\\n    }, {\\n        key: 'setAudioLevel',\\n        value: function setAudioLevel(tpc, ssrc, audioLevel, isLocal) {\\n            var track = tpc.getTrackBySSRC(ssrc);\\n\\n            if (!track) {\\n                return;\\n            } else if (!track.isAudioTrack()) {\\n                logger.warn('Received audio level for non-audio track: ' + ssrc);\\n\\n                return;\\n            } else if (track.isLocal() !== isLocal) {\\n                logger.error(track + ' was expected to ' + (isLocal ? 'be' : 'not be') + ' local');\\n            }\\n\\n            track.setAudioLevel(audioLevel, tpc);\\n        }\\n\\n        /* eslint-enable max-params */\\n\\n        /**\\n         * Sends message via the bridge channel.\\n         * @param {string} to The id of the endpoint that should receive the\\n         *      message. If \\\"\\\" the message will be sent to all participants.\\n         * @param {object} payload The payload of the message.\\n         * @throws NetworkError or InvalidStateError or Error if the operation\\n         * fails or there is no data channel created.\\n         */\\n\\n    }, {\\n        key: 'sendChannelMessage',\\n        value: function sendChannelMessage(to, payload) {\\n            if (this._channel) {\\n                this._channel.sendMessage(to, payload);\\n            } else {\\n                throw new Error('Channel support is disabled!');\\n            }\\n        }\\n\\n        /**\\n         * Selects a new value for \\\"lastN\\\". The requested amount of videos are going\\n         * to be delivered after the value is in effect. Set to -1 for unlimited or\\n         * all available videos.\\n         * @param {number} value the new value for lastN.\\n         */\\n\\n    }, {\\n        key: 'setLastN',\\n        value: function setLastN(value) {\\n            if (this._lastN !== value) {\\n                this._lastN = value;\\n                if (this._channel && this._channelOpen) {\\n                    this._channel.sendSetLastNMessage(value);\\n                }\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.LASTN_VALUE_CHANGED, value);\\n            }\\n        }\\n\\n        /**\\n         * Indicates if the endpoint id is currently included in the last N.\\n         * @param {string} id The endpoint id that we check for last N.\\n         * @returns {boolean} true if the endpoint id is in the last N or if we\\n         * don't have bridge channel support, otherwise we return false.\\n         */\\n\\n    }, {\\n        key: 'isInLastN',\\n        value: function isInLastN(id) {\\n            return !this._lastNEndpoints // lastNEndpoints not initialised yet.\\n            || this._lastNEndpoints.indexOf(id) > -1;\\n        }\\n\\n        /**\\n         * Updates the target audio output device for all remote audio tracks.\\n         *\\n         * @param {string} deviceId - The device id of the audio ouput device to\\n         * use for all remote tracks.\\n         * @private\\n         * @returns {void}\\n         */\\n\\n    }, {\\n        key: '_updateAudioOutputForAudioTracks',\\n        value: function _updateAudioOutputForAudioTracks(deviceId) {\\n            var remoteAudioTracks = this.getRemoteTracks(__WEBPACK_IMPORTED_MODULE_8__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]);\\n\\n            var _iteratorNormalCompletion3 = true;\\n            var _didIteratorError3 = false;\\n            var _iteratorError3 = undefined;\\n\\n            try {\\n                for (var _iterator3 = remoteAudioTracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n                    var track = _step3.value;\\n\\n                    track.setAudioOutput(deviceId);\\n                }\\n            } catch (err) {\\n                _didIteratorError3 = true;\\n                _iteratorError3 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                        _iterator3.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError3) {\\n                        throw _iteratorError3;\\n                    }\\n                }\\n            }\\n        }\\n    }], [{\\n        key: 'obtainAudioAndVideoPermissions',\\n        value: function obtainAudioAndVideoPermissions(options) {\\n            var usesNewGumFlow = __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].usesNewGumFlow();\\n            var obtainMediaPromise = usesNewGumFlow ? __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].newObtainAudioAndVideoPermissions(options) : __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].obtainAudioAndVideoPermissions(options);\\n\\n            return obtainMediaPromise.then(function (tracksInfo) {\\n                var tracks = usesNewGumFlow ? _newCreateLocalTracks(tracksInfo) : createLocalTracks(tracksInfo, options);\\n\\n                return tracks.some(function (track) {\\n                    return !track._isReceivingData();\\n                }) ? Promise.reject(new __WEBPACK_IMPORTED_MODULE_5__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_6__JitsiTrackErrors__[\\\"NO_DATA_FROM_SOURCE\\\"])) : tracks;\\n            });\\n        }\\n    }, {\\n        key: 'addListener',\\n        value: function addListener(eventType, listener) {\\n            __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].addListener(eventType, listener);\\n        }\\n\\n        /**\\n         *\\n         * @param eventType\\n         * @param listener\\n         */\\n\\n    }, {\\n        key: 'removeListener',\\n        value: function removeListener(eventType, listener) {\\n            __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].removeListener(eventType, listener);\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'isRTCReady',\\n        value: function isRTCReady() {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].isRTCReady();\\n        }\\n\\n        /**\\n         *\\n         * @param options\\n         */\\n\\n    }, {\\n        key: 'init',\\n        value: function init() {\\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n            this.options = options;\\n\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].init(this.options);\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'getDeviceAvailability',\\n        value: function getDeviceAvailability() {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].getDeviceAvailability();\\n        }\\n    }, {\\n        key: 'getPCConstraints',\\n        value: function getPCConstraints(isP2P) {\\n            var pcConstraints = isP2P ? __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].p2pPcConstraints : __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].pcConstraints;\\n\\n            if (!pcConstraints) {\\n                return {};\\n            }\\n\\n            return JSON.parse(JSON.stringify(pcConstraints));\\n        }\\n\\n        /**\\n         *\\n         * @param elSelector\\n         * @param stream\\n         */\\n\\n    }, {\\n        key: 'attachMediaStream',\\n        value: function attachMediaStream(elSelector, stream) {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].attachMediaStream(elSelector, stream);\\n        }\\n\\n        /**\\n         * Returns the id of the given stream.\\n         * @param {MediaStream} stream\\n         */\\n\\n    }, {\\n        key: 'getStreamID',\\n        value: function getStreamID(stream) {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].getStreamID(stream);\\n        }\\n\\n        /**\\n         * Returns the id of the given track.\\n         * @param {MediaStreamTrack} track\\n         */\\n\\n    }, {\\n        key: 'getTrackID',\\n        value: function getTrackID(track) {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].getTrackID(track);\\n        }\\n\\n        /**\\n         * Returns true if retrieving the the list of input devices is supported\\n         * and false if not.\\n         */\\n\\n    }, {\\n        key: 'isDeviceListAvailable',\\n        value: function isDeviceListAvailable() {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].isDeviceListAvailable();\\n        }\\n\\n        /**\\n         * Returns true if changing the input (camera / microphone) or output\\n         * (audio) device is supported and false if not.\\n         * @param {string} [deviceType] Type of device to change. Default is\\n         *      undefined or 'input', 'output' - for audio output device change.\\n         * @returns {boolean} true if available, false otherwise.\\n         */\\n\\n    }, {\\n        key: 'isDeviceChangeAvailable',\\n        value: function isDeviceChangeAvailable(deviceType) {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].isDeviceChangeAvailable(deviceType);\\n        }\\n\\n        /**\\n         * Returns currently used audio output device id, '' stands for default\\n         * device\\n         * @returns {string}\\n         */\\n\\n    }, {\\n        key: 'getAudioOutputDevice',\\n        value: function getAudioOutputDevice() {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].getAudioOutputDevice();\\n        }\\n\\n        /**\\n         * Returns list of available media devices if its obtained, otherwise an\\n         * empty array is returned/\\n         * @returns {array} list of available media devices.\\n         */\\n\\n    }, {\\n        key: 'getCurrentlyAvailableMediaDevices',\\n        value: function getCurrentlyAvailableMediaDevices() {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].getCurrentlyAvailableMediaDevices();\\n        }\\n\\n        /**\\n         * Returns event data for device to be reported to stats.\\n         * @returns {MediaDeviceInfo} device.\\n         */\\n\\n    }, {\\n        key: 'getEventDataForActiveDevice',\\n        value: function getEventDataForActiveDevice(device) {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].getEventDataForActiveDevice(device);\\n        }\\n\\n        /**\\n         * Sets current audio output device.\\n         * @param {string} deviceId Id of 'audiooutput' device from\\n         *      navigator.mediaDevices.enumerateDevices().\\n         * @returns {Promise} resolves when audio output is changed, is rejected\\n         *      otherwise\\n         */\\n\\n    }, {\\n        key: 'setAudioOutputDevice',\\n        value: function setAudioOutputDevice(deviceId) {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].setAudioOutputDevice(deviceId);\\n        }\\n\\n        /**\\n         * Returns <tt>true<tt/> if given WebRTC MediaStream is considered a valid\\n         * \\\"user\\\" stream which means that it's not a \\\"receive only\\\" stream nor a\\n         * \\\"mixed\\\" JVB stream.\\n         *\\n         * Clients that implement Unified Plan, such as Firefox use recvonly\\n         * \\\"streams/channels/tracks\\\" for receiving remote stream/tracks, as opposed\\n         * to Plan B where there are only 3 channels: audio, video and data.\\n         *\\n         * @param {MediaStream} stream The WebRTC MediaStream instance.\\n         * @returns {boolean}\\n         */\\n\\n    }, {\\n        key: 'isUserStream',\\n        value: function isUserStream(stream) {\\n            return RTC.isUserStreamById(__WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].getStreamID(stream));\\n        }\\n\\n        /**\\n         * Returns <tt>true<tt/> if a WebRTC MediaStream identified by given stream\\n         * ID is considered a valid \\\"user\\\" stream which means that it's not a\\n         * \\\"receive only\\\" stream nor a \\\"mixed\\\" JVB stream.\\n         *\\n         * Clients that implement Unified Plan, such as Firefox use recvonly\\n         * \\\"streams/channels/tracks\\\" for receiving remote stream/tracks, as opposed\\n         * to Plan B where there are only 3 channels: audio, video and data.\\n         *\\n         * @param {string} streamId The id of WebRTC MediaStream.\\n         * @returns {boolean}\\n         */\\n\\n    }, {\\n        key: 'isUserStreamById',\\n        value: function isUserStreamById(streamId) {\\n            return streamId && streamId !== 'mixedmslabel' && streamId !== 'default';\\n        }\\n\\n        /**\\n         * Allows to receive list of available cameras/microphones.\\n         * @param {function} callback Would receive array of devices as an\\n         *      argument.\\n         */\\n\\n    }, {\\n        key: 'enumerateDevices',\\n        value: function enumerateDevices(callback) {\\n            __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].enumerateDevices(callback);\\n        }\\n\\n        /**\\n         * A method to handle stopping of the stream.\\n         * One point to handle the differences in various implementations.\\n         * @param {MediaStream} mediaStream MediaStream object to stop.\\n         */\\n\\n    }, {\\n        key: 'stopMediaStream',\\n        value: function stopMediaStream(mediaStream) {\\n            __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].stopMediaStream(mediaStream);\\n        }\\n\\n        /**\\n         * Returns whether the desktop sharing is enabled or not.\\n         * @returns {boolean}\\n         */\\n\\n    }, {\\n        key: 'isDesktopSharingEnabled',\\n        value: function isDesktopSharingEnabled() {\\n            return __WEBPACK_IMPORTED_MODULE_11__RTCUtils__[\\\"a\\\" /* default */].isDesktopSharingEnabled();\\n        }\\n    }]);\\n\\n    return RTC;\\n}(__WEBPACK_IMPORTED_MODULE_7__util_Listenable__[\\\"a\\\" /* default */]);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (RTC);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/RTC.js\\\"))\\n\\n/***/ }),\\n/* 28 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_RTC_CameraFacingMode__ = __webpack_require__(55);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_RTC_CameraFacingMode___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__service_RTC_CameraFacingMode__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_events__ = __webpack_require__(16);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_events__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__util_GlobalOnErrorHandler__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__JitsiTrackError__ = __webpack_require__(12);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_Listenable__ = __webpack_require__(10);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__service_RTC_Resolutions__ = __webpack_require__(35);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__service_RTC_Resolutions___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__service_RTC_Resolutions__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ortc_RTCPeerConnection__ = __webpack_require__(121);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__ = __webpack_require__(130);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__xmpp_SDPUtil__ = __webpack_require__(14);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__statistics_statistics__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__service_RTC_VideoType__ = __webpack_require__(13);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__service_RTC_VideoType___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15__service_RTC_VideoType__);\\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\\n\\n/* global $,\\n          __filename,\\n          attachMediaStream,\\n          MediaStreamTrack,\\n          RTCIceCandidate: true,\\n          RTCPeerConnection,\\n          RTCSessionDescription: true,\\n          webkitMediaStream,\\n          webkitRTCPeerConnection,\\n          webkitURL\\n*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_3_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n// XXX Don't require Temasys unless it's to be used because it doesn't run on\\n// React Native, for example.\\nvar AdapterJS = __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed() ? __webpack_require__(37) : undefined;\\n\\n// Require adapter only for certain browsers. This is being done for\\n// react-native, which has its own shims, and while browsers are being migrated\\n// over to use adapter's shims.\\nif (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].usesNewGumFlow()) {\\n    __webpack_require__(131);\\n}\\n\\nvar eventEmitter = new __WEBPACK_IMPORTED_MODULE_2_events___default.a();\\n\\nvar AVAILABLE_DEVICES_POLL_INTERVAL_TIME = 3000; // ms\\n\\n// TODO (brian): Move this devices hash, maybe to a model, so RTCUtils remains\\n// stateless.\\nvar devices = {\\n    audio: false,\\n    video: false\\n};\\n\\n// Currently audio output device change is supported only in Chrome and\\n// default output always has 'default' device ID\\nvar audioOutputDeviceId = 'default'; // default device\\n// whether user has explicitly set a device to use\\nvar audioOutputChanged = false;\\n\\n// Disables all audio processing\\nvar disableAP = false;\\n\\n// Disables Acoustic Echo Cancellation\\nvar disableAEC = false;\\n\\n// Disables Noise Suppression\\nvar disableNS = false;\\n\\n// Disables Automatic Gain Control\\nvar disableAGC = false;\\n\\n// Disables Highpass Filter\\nvar disableHPF = false;\\n\\nvar featureDetectionAudioEl = document.createElement('audio');\\nvar isAudioOutputDeviceChangeAvailable = typeof featureDetectionAudioEl.setSinkId !== 'undefined';\\n\\nvar currentlyAvailableMediaDevices = void 0;\\n\\n/**\\n * \\\"rawEnumerateDevicesWithCallback\\\" will be initialized only after WebRTC is\\n * ready. Otherwise it is too early to assume that the devices listing is not\\n * supported.\\n */\\nvar rawEnumerateDevicesWithCallback = void 0;\\n\\n/**\\n *\\n */\\nfunction initRawEnumerateDevicesWithCallback() {\\n    rawEnumerateDevicesWithCallback = navigator.mediaDevices && navigator.mediaDevices.enumerateDevices ? function (callback) {\\n        navigator.mediaDevices.enumerateDevices().then(callback, function () {\\n            return callback([]);\\n        });\\n    }\\n\\n    // Safari:\\n    // \\\"ReferenceError: Can't find variable: MediaStreamTrack\\\" when\\n    // Temasys plugin is not installed yet, have to delay this call\\n    // until WebRTC is ready.\\n    : MediaStreamTrack && MediaStreamTrack.getSources ? function (callback) {\\n        MediaStreamTrack.getSources(function (sources) {\\n            return callback(sources.map(convertMediaStreamTrackSource));\\n        });\\n    } : undefined;\\n}\\n\\n// TODO: currently no browser supports 'devicechange' event even in nightly\\n// builds so no feature/browser detection is used at all. However in future this\\n// should be changed to some expression. Progress on 'devicechange' event\\n// implementation for Chrome/Opera/NWJS can be tracked at\\n// https://bugs.chromium.org/p/chromium/issues/detail?id=388648, for Firefox -\\n// at https://bugzilla.mozilla.org/show_bug.cgi?id=1152383. More information on\\n// 'devicechange' event can be found in spec -\\n// http://w3c.github.io/mediacapture-main/#event-mediadevices-devicechange\\n// TODO: check MS Edge\\nvar isDeviceChangeEventSupported = false;\\n\\nvar rtcReady = false;\\n\\n/**\\n *\\n * @param constraints\\n * @param isNewStyleConstraintsSupported\\n * @param resolution\\n */\\nfunction setResolutionConstraints(constraints, isNewStyleConstraintsSupported, resolution) {\\n    if (__WEBPACK_IMPORTED_MODULE_8__service_RTC_Resolutions___default.a[resolution]) {\\n        if (isNewStyleConstraintsSupported) {\\n            constraints.video.width = {\\n                ideal: __WEBPACK_IMPORTED_MODULE_8__service_RTC_Resolutions___default.a[resolution].width\\n            };\\n            constraints.video.height = {\\n                ideal: __WEBPACK_IMPORTED_MODULE_8__service_RTC_Resolutions___default.a[resolution].height\\n            };\\n        }\\n\\n        constraints.video.mandatory.minWidth = __WEBPACK_IMPORTED_MODULE_8__service_RTC_Resolutions___default.a[resolution].width;\\n        constraints.video.mandatory.minHeight = __WEBPACK_IMPORTED_MODULE_8__service_RTC_Resolutions___default.a[resolution].height;\\n    }\\n\\n    if (constraints.video.mandatory.minWidth) {\\n        constraints.video.mandatory.maxWidth = constraints.video.mandatory.minWidth;\\n    }\\n\\n    if (constraints.video.mandatory.minHeight) {\\n        constraints.video.mandatory.maxHeight = constraints.video.mandatory.minHeight;\\n    }\\n}\\n\\n/**\\n * @param {string[]} um required user media types\\n *\\n * @param {Object} [options={}] optional parameters\\n * @param {string} options.resolution\\n * @param {number} options.bandwidth\\n * @param {number} options.fps\\n * @param {string} options.desktopStream\\n * @param {string} options.cameraDeviceId\\n * @param {string} options.micDeviceId\\n * @param {CameraFacingMode} options.facingMode\\n * @param {bool} firefox_fake_device\\n */\\nfunction getConstraints(um, options) {\\n    var constraints = { audio: false,\\n        video: false };\\n\\n    // Don't mix new and old style settings for Chromium as this leads\\n    // to TypeError in new Chromium versions. @see\\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=614716\\n    // This is a temporary solution, in future we will fully split old and\\n    // new style constraints when new versions of Chromium and Firefox will\\n    // have stable support of new constraints format. For more information\\n    // @see https://github.com/jitsi/lib-jitsi-meet/pull/136\\n    var isNewStyleConstraintsSupported = __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isEdge() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isReactNative() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed();\\n\\n    if (um.indexOf('video') >= 0) {\\n        // same behaviour as true\\n        constraints.video = { mandatory: {},\\n            optional: [] };\\n\\n        if (options.cameraDeviceId) {\\n            if (isNewStyleConstraintsSupported) {\\n                // New style of setting device id.\\n                constraints.video.deviceId = options.cameraDeviceId;\\n            }\\n\\n            // Old style.\\n            constraints.video.optional.push({\\n                sourceId: options.cameraDeviceId\\n            });\\n        } else {\\n            // Prefer the front i.e. user-facing camera (to the back i.e.\\n            // environment-facing camera, for example).\\n            // TODO: Maybe use \\\"exact\\\" syntax if options.facingMode is defined,\\n            // but this probably needs to be decided when updating other\\n            // constraints, as we currently don't use \\\"exact\\\" syntax anywhere.\\n            var facingMode = options.facingMode || __WEBPACK_IMPORTED_MODULE_1__service_RTC_CameraFacingMode___default.a.USER;\\n\\n            if (isNewStyleConstraintsSupported) {\\n                constraints.video.facingMode = facingMode;\\n            }\\n            constraints.video.optional.push({\\n                facingMode: facingMode\\n            });\\n        }\\n\\n        if (options.minFps || options.maxFps || options.fps) {\\n            // for some cameras it might be necessary to request 30fps\\n            // so they choose 30fps mjpg over 10fps yuy2\\n            if (options.minFps || options.fps) {\\n                // Fall back to options.fps for backwards compatibility\\n                options.minFps = options.minFps || options.fps;\\n                constraints.video.mandatory.minFrameRate = options.minFps;\\n            }\\n            if (options.maxFps) {\\n                constraints.video.mandatory.maxFrameRate = options.maxFps;\\n            }\\n        }\\n\\n        setResolutionConstraints(constraints, isNewStyleConstraintsSupported, options.resolution);\\n    }\\n    if (um.indexOf('audio') >= 0) {\\n        if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isReactNative()) {\\n            // The react-native-webrtc project that we're currently using\\n            // expects the audio constraint to be a boolean.\\n            constraints.audio = true;\\n        } else if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox()) {\\n            if (options.micDeviceId) {\\n                constraints.audio = {\\n                    mandatory: {},\\n                    deviceId: options.micDeviceId, // new style\\n                    optional: [{\\n                        sourceId: options.micDeviceId // old style\\n                    }] };\\n            } else {\\n                constraints.audio = true;\\n            }\\n        } else {\\n            // same behaviour as true\\n            constraints.audio = { mandatory: {},\\n                optional: [] };\\n            if (options.micDeviceId) {\\n                if (isNewStyleConstraintsSupported) {\\n                    // New style of setting device id.\\n                    constraints.audio.deviceId = options.micDeviceId;\\n                }\\n\\n                // Old style.\\n                constraints.audio.optional.push({\\n                    sourceId: options.micDeviceId\\n                });\\n            }\\n\\n            // if it is good enough for hangouts...\\n            constraints.audio.optional.push({ echoCancellation: !disableAEC && !disableAP }, { googEchoCancellation: !disableAEC && !disableAP }, { googAutoGainControl: !disableAGC && !disableAP }, { googNoiseSuppression: !disableNS && !disableAP }, { googHighpassFilter: !disableHPF && !disableAP }, { googNoiseSuppression2: !disableNS && !disableAP }, { googEchoCancellation2: !disableAEC && !disableAP }, { googAutoGainControl2: !disableAGC && !disableAP });\\n        }\\n    }\\n    if (um.indexOf('screen') >= 0) {\\n        if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isChrome()) {\\n            constraints.video = {\\n                mandatory: {\\n                    chromeMediaSource: 'screen',\\n                    maxWidth: window.screen.width,\\n                    maxHeight: window.screen.height,\\n                    maxFrameRate: 3\\n                },\\n                optional: []\\n            };\\n        } else if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed()) {\\n            constraints.video = {\\n                optional: [{\\n                    sourceId: AdapterJS.WebRTCPlugin.plugin.screensharingKey\\n                }]\\n            };\\n        } else if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox()) {\\n            constraints.video = {\\n                mozMediaSource: 'window',\\n                mediaSource: 'window'\\n            };\\n        } else {\\n            var errmsg = '\\\\'screen\\\\' WebRTC media source is supported only in Chrome' + ' and with Temasys plugin';\\n\\n            __WEBPACK_IMPORTED_MODULE_4__util_GlobalOnErrorHandler___default.a.callErrorHandler(new Error(errmsg));\\n            logger.error(errmsg);\\n        }\\n    }\\n    if (um.indexOf('desktop') >= 0) {\\n        constraints.video = {\\n            mandatory: {\\n                chromeMediaSource: 'desktop',\\n                chromeMediaSourceId: options.desktopStream,\\n                maxWidth: window.screen.width,\\n                maxHeight: window.screen.height,\\n                maxFrameRate: 3\\n            },\\n            optional: []\\n        };\\n    }\\n\\n    if (options.bandwidth) {\\n        if (!constraints.video) {\\n            // same behaviour as true\\n            constraints.video = { mandatory: {},\\n                optional: [] };\\n        }\\n        constraints.video.optional.push({ bandwidth: options.bandwidth });\\n    }\\n\\n    // we turn audio for both audio and video tracks, the fake audio & video\\n    // seems to work only when enabled in one getUserMedia call, we cannot get\\n    // fake audio separate by fake video this later can be a problem with some\\n    // of the tests\\n    if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox() && options.firefox_fake_device) {\\n        // seems to be fixed now, removing this experimental fix, as having\\n        // multiple audio tracks brake the tests\\n        // constraints.audio = true;\\n        constraints.fake = true;\\n    }\\n\\n    return constraints;\\n}\\n\\n/**\\n * Default MediaStreamConstraints to use for calls to getUserMedia.\\n *\\n * @private\\n */\\nvar DEFAULT_CONSTRAINTS = {\\n    video: {\\n        aspectRatio: 16 / 9,\\n        height: {\\n            ideal: 1080,\\n            max: 1080,\\n            min: 240\\n        }\\n    }\\n};\\n\\n/**\\n * Creates a constraints object to be passed into a call to getUserMedia.\\n *\\n * @param {Array} um - An array of user media types to get. The accepted\\n * types are \\\"video\\\", \\\"audio\\\", and \\\"desktop.\\\"\\n * @param {Object} options - Various values to be added to the constraints.\\n * @param {string} options.cameraDeviceId - The device id for the video\\n * capture device to get video from.\\n * @param {Object} options.constraints - Default constraints object to use\\n * as a base for the returned constraints.\\n * @param {Object} options.desktopStream - The desktop source id from which\\n * to capture a desktop sharing video.\\n * @param {string} options.facingMode - Which direction the camera is\\n * pointing to.\\n * @param {string} options.micDeviceId - The device id for the audio capture\\n * device to get audio from.\\n * @private\\n * @returns {Object}\\n */\\nfunction newGetConstraints() {\\n    var um = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n    // Create a deep copy of the constraints to avoid any modification of\\n    // the passed in constraints object.\\n    var constraints = JSON.parse(JSON.stringify(options.constraints || DEFAULT_CONSTRAINTS));\\n\\n    if (um.indexOf('video') >= 0) {\\n        if (!constraints.video) {\\n            constraints.video = {};\\n        }\\n\\n        if (options.cameraDeviceId) {\\n            constraints.video.deviceId = options.cameraDeviceId;\\n        } else {\\n            var facingMode = options.facingMode || __WEBPACK_IMPORTED_MODULE_1__service_RTC_CameraFacingMode___default.a.USER;\\n\\n            constraints.video.facingMode = facingMode;\\n        }\\n    } else {\\n        constraints.video = false;\\n    }\\n\\n    if (um.indexOf('audio') >= 0) {\\n        if (!constraints.audio || typeof constraints.audio === 'boolean') {\\n            constraints.audio = {};\\n        }\\n\\n        // NOTE(brian): the new-style ('advanced' instead of 'optional')\\n        // doesn't seem to carry through the googXXX constraints\\n        // Changing back to 'optional' here (even with video using\\n        // the 'advanced' style) allows them to be passed through\\n        // but also requires the device id to capture to be set in optional\\n        // as sourceId otherwise the constraints are considered malformed.\\n        if (!constraints.audio.optional) {\\n            constraints.audio.optional = [];\\n        }\\n\\n        constraints.audio.optional.push({ sourceId: options.micDeviceId }, { echoCancellation: !disableAEC && !disableAP }, { googEchoCancellation: !disableAEC && !disableAP }, { googAutoGainControl: !disableAGC && !disableAP }, { googNoiseSuppression: !disableNS && !disableAP }, { googHighpassFilter: !disableHPF && !disableAP }, { googNoiseSuppression2: !disableNS && !disableAP }, { googEchoCancellation2: !disableAEC && !disableAP }, { googAutoGainControl2: !disableAGC && !disableAP });\\n    } else {\\n        constraints.audio = false;\\n    }\\n\\n    if (um.indexOf('desktop') >= 0) {\\n        if (!constraints.video || typeof constraints.video === 'boolean') {\\n            constraints.video = {};\\n        }\\n\\n        constraints.video = {\\n            mandatory: {\\n                chromeMediaSource: 'desktop',\\n                chromeMediaSourceId: options.desktopStream,\\n                maxWidth: window.screen.width,\\n                maxHeight: window.screen.height,\\n                maxFrameRate: 3\\n            }\\n        };\\n    }\\n\\n    return constraints;\\n}\\n\\n/**\\n * Sets the availbale devices based on the options we requested and the\\n * streams we received.\\n * @param um the options we requested to getUserMedia.\\n * @param stream the stream we received from calling getUserMedia.\\n */\\nfunction setAvailableDevices(um, stream) {\\n    var audioTracksReceived = stream && stream.getAudioTracks().length > 0;\\n    var videoTracksReceived = stream && stream.getVideoTracks().length > 0;\\n\\n    if (um.indexOf('video') !== -1) {\\n        devices.video = videoTracksReceived;\\n    }\\n    if (um.indexOf('audio') !== -1) {\\n        devices.audio = audioTracksReceived;\\n    }\\n\\n    eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.AVAILABLE_DEVICES_CHANGED, devices);\\n}\\n\\n/**\\n * Checks if new list of available media devices differs from previous one.\\n * @param {MediaDeviceInfo[]} newDevices - list of new devices.\\n * @returns {boolean} - true if list is different, false otherwise.\\n */\\nfunction compareAvailableMediaDevices(newDevices) {\\n    if (newDevices.length !== currentlyAvailableMediaDevices.length) {\\n        return true;\\n    }\\n\\n    /* eslint-disable newline-per-chained-call */\\n\\n    return newDevices.map(mediaDeviceInfoToJSON).sort().join('') !== currentlyAvailableMediaDevices.map(mediaDeviceInfoToJSON).sort().join('');\\n\\n    /* eslint-enable newline-per-chained-call */\\n\\n    /**\\n     *\\n     * @param info\\n     */\\n    function mediaDeviceInfoToJSON(info) {\\n        return JSON.stringify({\\n            kind: info.kind,\\n            deviceId: info.deviceId,\\n            groupId: info.groupId,\\n            label: info.label,\\n            facing: info.facing\\n        });\\n    }\\n}\\n\\n/**\\n * Periodically polls enumerateDevices() method to check if list of media\\n * devices has changed. This is temporary workaround until 'devicechange' event\\n * will be supported by browsers.\\n */\\nfunction pollForAvailableMediaDevices() {\\n    // Here we use plain navigator.mediaDevices.enumerateDevices instead of\\n    // wrapped because we just need to know the fact the devices changed, labels\\n    // do not matter. This fixes situation when we have no devices initially,\\n    // and then plug in a new one.\\n    if (rawEnumerateDevicesWithCallback) {\\n        rawEnumerateDevicesWithCallback(function (ds) {\\n            // We don't fire RTCEvents.DEVICE_LIST_CHANGED for the first time\\n            // we call enumerateDevices(). This is the initial step.\\n            if (typeof currentlyAvailableMediaDevices === 'undefined') {\\n                currentlyAvailableMediaDevices = ds.slice(0);\\n            } else if (compareAvailableMediaDevices(ds)) {\\n                onMediaDevicesListChanged(ds);\\n            }\\n\\n            window.setTimeout(pollForAvailableMediaDevices, AVAILABLE_DEVICES_POLL_INTERVAL_TIME);\\n        });\\n    }\\n}\\n\\n/**\\n * Sends analytics event with the passed device list.\\n *\\n * @param {Array<MediaDeviceInfo>} deviceList - List with info about the\\n * available devices.\\n * @returns {void}\\n */\\nfunction sendDeviceListToAnalytics(deviceList) {\\n    var devicesPropsArray = deviceList.map(function (_ref) {\\n        var deviceId = _ref.deviceId,\\n            groupId = _ref.groupId,\\n            kind = _ref.kind,\\n            label = _ref.label;\\n\\n        // Filter the props of the device object.\\n        return {\\n            deviceId: deviceId,\\n            groupId: groupId,\\n            kind: kind,\\n            label: label\\n        };\\n    });\\n\\n    __WEBPACK_IMPORTED_MODULE_14__statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"i\\\" /* DEVICE_LIST */], { devices: devicesPropsArray });\\n}\\n\\n/**\\n * Event handler for the 'devicechange' event.\\n *\\n * @param {MediaDeviceInfo[]} devices - list of media devices.\\n * @emits RTCEvents.DEVICE_LIST_CHANGED\\n */\\nfunction onMediaDevicesListChanged(devicesReceived) {\\n    currentlyAvailableMediaDevices = devicesReceived.slice(0);\\n    logger.info('list of media devices has changed:', currentlyAvailableMediaDevices);\\n\\n    sendDeviceListToAnalytics(currentlyAvailableMediaDevices);\\n\\n    var videoInputDevices = currentlyAvailableMediaDevices.filter(function (d) {\\n        return d.kind === 'videoinput';\\n    });\\n    var audioInputDevices = currentlyAvailableMediaDevices.filter(function (d) {\\n        return d.kind === 'audioinput';\\n    });\\n    var videoInputDevicesWithEmptyLabels = videoInputDevices.filter(function (d) {\\n        return d.label === '';\\n    });\\n    var audioInputDevicesWithEmptyLabels = audioInputDevices.filter(function (d) {\\n        return d.label === '';\\n    });\\n\\n    if (videoInputDevices.length && videoInputDevices.length === videoInputDevicesWithEmptyLabels.length) {\\n        devices.video = false;\\n    }\\n\\n    if (audioInputDevices.length && audioInputDevices.length === audioInputDevicesWithEmptyLabels.length) {\\n        devices.audio = false;\\n    }\\n\\n    eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.DEVICE_LIST_CHANGED, devicesReceived);\\n}\\n\\n/**\\n * Apply function with arguments if function exists.\\n * Do nothing if function not provided.\\n * @param {function} [fn] function to apply\\n * @param {Array} [args=[]] arguments for function\\n */\\nfunction maybeApply(fn, args) {\\n    fn && fn.apply(undefined, _toConsumableArray(args));\\n}\\n\\n/**\\n * Wrap `getUserMedia` in order to convert between callback and Promise based\\n * APIs.\\n * @param {Function} getUserMedia native function\\n * @returns {Function} wrapped function\\n */\\nfunction wrapGetUserMedia(getUserMedia) {\\n    var usePromises = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n    var gUM = void 0;\\n\\n    if (usePromises) {\\n        gUM = function gUM(constraints, successCallback, errorCallback) {\\n            return getUserMedia(constraints).then(function (stream) {\\n                maybeApply(successCallback, [stream]);\\n\\n                return stream;\\n            }).catch(function (error) {\\n                maybeApply(errorCallback, [error]);\\n\\n                throw error;\\n            });\\n        };\\n    } else {\\n        gUM = function gUM(constraints, successCallback, errorCallback) {\\n            getUserMedia(constraints, function (stream) {\\n                maybeApply(successCallback, [stream]);\\n            }, function (error) {\\n                maybeApply(errorCallback, [error]);\\n            });\\n        };\\n    }\\n\\n    return gUM;\\n}\\n\\n/**\\n * Use old MediaStreamTrack to get devices list and\\n * convert it to enumerateDevices format.\\n * @param {Function} callback function to call when received devices list.\\n */\\nfunction enumerateDevicesThroughMediaStreamTrack(callback) {\\n    MediaStreamTrack.getSources(function (sources) {\\n        return callback(sources.map(convertMediaStreamTrackSource));\\n    });\\n}\\n\\n/**\\n * Converts MediaStreamTrack Source to enumerateDevices format.\\n * @param {Object} source\\n */\\nfunction convertMediaStreamTrackSource(source) {\\n    var kind = (source.kind || '').toLowerCase();\\n\\n    return {\\n        facing: source.facing || null,\\n        label: source.label,\\n\\n        // theoretically deprecated MediaStreamTrack.getSources should\\n        // not return 'audiooutput' devices but let's handle it in any\\n        // case\\n        kind: kind ? kind === 'audiooutput' ? kind : kind + 'input' : null,\\n        deviceId: source.id,\\n        groupId: source.groupId || null\\n    };\\n}\\n\\n/**\\n * Handles the newly created Media Streams.\\n * @param streams the new Media Streams\\n * @param resolution the resolution of the video streams\\n * @returns {*[]} object that describes the new streams\\n */\\nfunction handleLocalStream(streams, resolution) {\\n    var audioStream = void 0,\\n        desktopStream = void 0,\\n        videoStream = void 0;\\n    var res = [];\\n\\n    // XXX The function obtainAudioAndVideoPermissions has examined the type of\\n    // the browser, its capabilities, etc. and has taken the decision whether to\\n    // invoke getUserMedia per device (e.g. Firefox) or once for both audio and\\n    // video (e.g. Chrome). In order to not duplicate the logic here, examine\\n    // the specified streams and figure out what we've received based on\\n    // obtainAudioAndVideoPermissions' decision.\\n    if (streams) {\\n        // As mentioned above, certian types of browser (e.g. Chrome) support\\n        // (with a result which meets our requirements expressed bellow) calling\\n        // getUserMedia once for both audio and video.\\n        var audioVideo = streams.audioVideo;\\n\\n        if (audioVideo) {\\n            var NativeMediaStream = window.webkitMediaStream || window.MediaStream;\\n            var audioTracks = audioVideo.getAudioTracks();\\n\\n            if (audioTracks.length) {\\n                // eslint-disable-next-line new-cap\\n                audioStream = new NativeMediaStream();\\n                for (var i = 0; i < audioTracks.length; i++) {\\n                    audioStream.addTrack(audioTracks[i]);\\n                }\\n            }\\n\\n            var videoTracks = audioVideo.getVideoTracks();\\n\\n            if (videoTracks.length) {\\n                // eslint-disable-next-line new-cap\\n                videoStream = new NativeMediaStream();\\n                for (var j = 0; j < videoTracks.length; j++) {\\n                    videoStream.addTrack(videoTracks[j]);\\n                }\\n            }\\n        } else {\\n            // On other types of browser (e.g. Firefox) we choose (namely,\\n            // obtainAudioAndVideoPermissions) to call getUserMedia per device\\n            // (type).\\n            audioStream = streams.audio;\\n            videoStream = streams.video;\\n        }\\n\\n        desktopStream = streams.desktop;\\n    }\\n\\n    if (desktopStream) {\\n        var _desktopStream = desktopStream,\\n            stream = _desktopStream.stream,\\n            sourceId = _desktopStream.sourceId,\\n            sourceType = _desktopStream.sourceType;\\n\\n\\n        res.push({\\n            stream: stream,\\n            sourceId: sourceId,\\n            sourceType: sourceType,\\n            track: stream.getVideoTracks()[0],\\n            mediaType: __WEBPACK_IMPORTED_MODULE_7__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */],\\n            videoType: __WEBPACK_IMPORTED_MODULE_15__service_RTC_VideoType___default.a.DESKTOP\\n        });\\n    }\\n    if (audioStream) {\\n        res.push({\\n            stream: audioStream,\\n            track: audioStream.getAudioTracks()[0],\\n            mediaType: __WEBPACK_IMPORTED_MODULE_7__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */],\\n            videoType: null\\n        });\\n    }\\n    if (videoStream) {\\n        res.push({\\n            stream: videoStream,\\n            track: videoStream.getVideoTracks()[0],\\n            mediaType: __WEBPACK_IMPORTED_MODULE_7__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */],\\n            videoType: __WEBPACK_IMPORTED_MODULE_15__service_RTC_VideoType___default.a.CAMERA,\\n            resolution: resolution\\n        });\\n    }\\n\\n    return res;\\n}\\n\\n/**\\n * Represents a default implementation of setting a <tt>MediaStream</tt> as the\\n * source of a video element that tries to be browser-agnostic through feature\\n * checking. Note though that it was not completely clear from the predating\\n * browser-specific implementations what &quot;videoSrc&quot; was because one\\n * implementation of {@link RTCUtils#getVideoSrc} would return\\n * <tt>MediaStream</tt> (e.g. Firefox), another a <tt>string</tt> representation\\n * of the <tt>URL</tt> of the <tt>MediaStream</tt> (e.g. Chrome) and the return\\n * value was only used by {@link RTCUIHelper#getVideoId} which itself did not\\n * appear to be used anywhere. Generally, the implementation will try to follow\\n * the related standards i.e. work with the <tt>srcObject</tt> and <tt>src</tt>\\n * properties of the specified <tt>element</tt> taking into account vender\\n * prefixes.\\n *\\n * @param element the element whose video source/src is to be set to the\\n * specified <tt>stream</tt>\\n * @param {MediaStream} stream the <tt>MediaStream</tt> to set as the video\\n * source/src of <tt>element</tt>\\n */\\nfunction defaultSetVideoSrc(element, stream) {\\n    // srcObject\\n    var srcObjectPropertyName = 'srcObject';\\n\\n    if (!(srcObjectPropertyName in element)) {\\n        srcObjectPropertyName = 'mozSrcObject';\\n        if (!(srcObjectPropertyName in element)) {\\n            srcObjectPropertyName = null;\\n        }\\n    }\\n    if (srcObjectPropertyName) {\\n        element[srcObjectPropertyName] = stream;\\n\\n        return;\\n    }\\n\\n    // src\\n    var src = void 0;\\n\\n    if (stream) {\\n        src = stream.jitsiObjectURL;\\n\\n        // Save the created URL for stream so we can reuse it and not keep\\n        // creating URLs.\\n        if (!src) {\\n            stream.jitsiObjectURL = src = (URL || webkitURL).createObjectURL(stream);\\n        }\\n    }\\n    element.src = src || '';\\n}\\n\\n/**\\n *\\n */\\n\\nvar RTCUtils = function (_Listenable) {\\n    _inherits(RTCUtils, _Listenable);\\n\\n    /**\\n     *\\n     */\\n    function RTCUtils() {\\n        _classCallCheck(this, RTCUtils);\\n\\n        return _possibleConstructorReturn(this, (RTCUtils.__proto__ || Object.getPrototypeOf(RTCUtils)).call(this, eventEmitter));\\n    }\\n\\n    /**\\n     * Depending on the browser, sets difference instance methods for\\n     * interacting with user media and adds methods to native webrtc related\\n     * objects. Also creates an instance variable for peer connection\\n     * constraints.\\n     *\\n     * @param {Object} options\\n     * @returns {void}\\n     */\\n\\n\\n    _createClass(RTCUtils, [{\\n        key: 'init',\\n        value: function init() {\\n            var _this2 = this;\\n\\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n            if (typeof options.disableAEC === 'boolean') {\\n                disableAEC = options.disableAEC;\\n                logger.info('Disable AEC: ' + disableAEC);\\n            }\\n            if (typeof options.disableNS === 'boolean') {\\n                disableNS = options.disableNS;\\n                logger.info('Disable NS: ' + disableNS);\\n            }\\n            if (typeof options.disableAP === 'boolean') {\\n                disableAP = options.disableAP;\\n                logger.info('Disable AP: ' + disableAP);\\n            }\\n            if (typeof options.disableAGC === 'boolean') {\\n                disableAGC = options.disableAGC;\\n                logger.info('Disable AGC: ' + disableAGC);\\n            }\\n            if (typeof options.disableHPF === 'boolean') {\\n                disableHPF = options.disableHPF;\\n                logger.info('Disable HPF: ' + disableHPF);\\n            }\\n\\n            // Initialize rawEnumerateDevicesWithCallback\\n            initRawEnumerateDevicesWithCallback();\\n\\n            return new Promise(function (resolve, reject) {\\n                if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].usesNewGumFlow()) {\\n                    _this2.RTCPeerConnectionType = window.RTCPeerConnection;\\n\\n                    _this2.getUserMedia = function (constraints, successCallback, errorCallback) {\\n                        return window.navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\\n                            successCallback && successCallback(stream);\\n\\n                            return stream;\\n                        }).catch(function (err) {\\n                            errorCallback && errorCallback(err);\\n\\n                            return Promise.reject(err);\\n                        });\\n                    };\\n\\n                    _this2.enumerateDevices = function (callback) {\\n                        return window.navigator.mediaDevices.enumerateDevices().then(function (foundDevices) {\\n                            callback(foundDevices);\\n\\n                            return foundDevices;\\n                        }).catch(function (err) {\\n                            logger.error('Error enumerating devices: ' + err);\\n\\n                            callback([]);\\n\\n                            return [];\\n                        });\\n                    };\\n\\n                    _this2.attachMediaStream = wrapAttachMediaStream(function (element, stream) {\\n                        if (element) {\\n                            element.srcObject = stream;\\n                        }\\n\\n                        return element;\\n                    });\\n\\n                    _this2.getStreamID = function (stream) {\\n                        return stream.id;\\n                    };\\n                    _this2.getTrackID = function (track) {\\n                        return track.id;\\n                    };\\n                } else if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isChrome() // this is chrome < 61\\n                || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isOpera() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isNWJS() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isElectron() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isReactNative()) {\\n\\n                    _this2.RTCPeerConnectionType = webkitRTCPeerConnection;\\n                    var getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\\n\\n                    _this2.getUserMedia = wrapGetUserMedia(getUserMedia);\\n                    _this2.enumerateDevices = rawEnumerateDevicesWithCallback;\\n\\n                    _this2.attachMediaStream = wrapAttachMediaStream(function (element, stream) {\\n                        defaultSetVideoSrc(element, stream);\\n\\n                        return element;\\n                    });\\n                    _this2.getStreamID = function (stream) {\\n                        // A. MediaStreams from FF endpoints have the characters '{'\\n                        // and '}' that make jQuery choke.\\n                        // B. The react-native-webrtc implementation that we use on\\n                        // React Native at the time of this writing returns a number\\n                        // for the id of MediaStream. Let's just say that a number\\n                        // contains no special characters.\\n                        var id = stream.id;\\n\\n                        // XXX The return statement is affected by automatic\\n                        // semicolon insertion (ASI). No line terminator is allowed\\n                        // between the return keyword and the expression.\\n                        return typeof id === 'number' ? id : __WEBPACK_IMPORTED_MODULE_13__xmpp_SDPUtil__[\\\"a\\\" /* default */].filterSpecialChars(id);\\n                    };\\n                    _this2.getTrackID = function (track) {\\n                        return track.id;\\n                    };\\n\\n                    if (!webkitMediaStream.prototype.getVideoTracks) {\\n                        webkitMediaStream.prototype.getVideoTracks = function () {\\n                            return this.videoTracks;\\n                        };\\n                    }\\n                    if (!webkitMediaStream.prototype.getAudioTracks) {\\n                        webkitMediaStream.prototype.getAudioTracks = function () {\\n                            return this.audioTracks;\\n                        };\\n                    }\\n                } else if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isEdge()) {\\n                    _this2.RTCPeerConnectionType = __WEBPACK_IMPORTED_MODULE_11__ortc_RTCPeerConnection__[\\\"a\\\" /* default */];\\n                    _this2.getUserMedia = wrapGetUserMedia(navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices), true);\\n                    _this2.enumerateDevices = rawEnumerateDevicesWithCallback;\\n                    _this2.attachMediaStream = wrapAttachMediaStream(function (element, stream) {\\n                        defaultSetVideoSrc(element, stream);\\n\\n                        return element;\\n                    });\\n\\n                    // ORTC does not generate remote MediaStreams so those are\\n                    // manually created by the ORTC shim. This means that their\\n                    // id (internally generated) does not match the stream id\\n                    // signaled into the remote SDP. Therefore, the shim adds a\\n                    // custom jitsiRemoteId property with the original stream id.\\n                    _this2.getStreamID = function (stream) {\\n                        var id = stream.jitsiRemoteId || stream.id;\\n\\n                        return __WEBPACK_IMPORTED_MODULE_13__xmpp_SDPUtil__[\\\"a\\\" /* default */].filterSpecialChars(id);\\n                    };\\n\\n                    // Remote MediaStreamTracks generated by ORTC (within a\\n                    // RTCRtpReceiver) have an internally/random id which does not\\n                    // match the track id signaled in the remote SDP. The shim adds\\n                    // a custom jitsi-id property with the original track id.\\n                    _this2.getTrackID = function (track) {\\n                        return track.jitsiRemoteId || track.id;\\n                    };\\n                } else if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed()) {\\n                    // Detect IE/Safari\\n                    var webRTCReadyCb = function webRTCReadyCb() {\\n                        _this2.RTCPeerConnectionType = RTCPeerConnection;\\n                        _this2.getUserMedia = window.getUserMedia;\\n                        _this2.enumerateDevices = enumerateDevicesThroughMediaStreamTrack;\\n                        _this2.attachMediaStream = wrapAttachMediaStream(function (element, stream) {\\n                            if (stream) {\\n                                if (stream.id === 'dummyAudio' || stream.id === 'dummyVideo') {\\n                                    return;\\n                                }\\n\\n                                // The container must be visible in order to\\n                                // play or attach the stream when Temasys plugin\\n                                // is in use\\n                                var containerSel = $(element);\\n\\n                                if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed() && !containerSel.is(':visible')) {\\n                                    containerSel.show();\\n                                }\\n                                var video = stream.getVideoTracks().length > 0;\\n\\n                                if (video && !$(element).is(':visible')) {\\n                                    throw new Error('video element must be visible to' + ' attach video stream');\\n                                }\\n                            }\\n\\n                            return attachMediaStream(element, stream);\\n                        });\\n                        _this2.getStreamID = function (stream) {\\n                            return __WEBPACK_IMPORTED_MODULE_13__xmpp_SDPUtil__[\\\"a\\\" /* default */].filterSpecialChars(stream.label);\\n                        };\\n                        _this2.getTrackID = function (track) {\\n                            return track.id;\\n                        };\\n\\n                        onReady(options, _this2.getUserMediaWithConstraints.bind(_this2));\\n                    };\\n                    var webRTCReadyPromise = new Promise(function (r) {\\n                        return AdapterJS.webRTCReady(r);\\n                    });\\n\\n                    // Resolve or reject depending on whether the Temasys plugin is\\n                    // installed.\\n                    AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix, AdapterJS.WebRTCPlugin.pluginInfo.plugName, AdapterJS.WebRTCPlugin.pluginInfo.type,\\n                    /* installed */function () {\\n                        webRTCReadyPromise.then(function () {\\n                            webRTCReadyCb();\\n                            resolve();\\n                        });\\n                    },\\n                    /* not installed */function () {\\n                        var error = new Error('Temasys plugin is not installed');\\n\\n                        error.name = 'WEBRTC_NOT_READY';\\n                        error.webRTCReadyPromise = webRTCReadyPromise;\\n\\n                        reject(error);\\n                    });\\n                } else {\\n                    rejectWithWebRTCNotSupported('Browser does not appear to be WebRTC-capable', reject);\\n\\n                    return;\\n                }\\n\\n                _this2._initPCConstraints(options);\\n\\n                // Call onReady() if Temasys plugin is not used\\n                if (!__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed()) {\\n                    onReady(options, _this2.getUserMediaWithConstraints.bind(_this2));\\n                    resolve();\\n                }\\n            });\\n        }\\n\\n        /**\\n         * Creates instance objects for peer connection constraints both for p2p\\n         * and outside of p2p.\\n         *\\n         * @params {Object} options - Configuration for setting RTCUtil's instance\\n         * objects for peer connection constraints.\\n         * @params {boolean} options.useIPv6 - Set to true if IPv6 should be used.\\n         * @params {boolean} options.disableSuspendVideo - Whether or not video\\n         * should become suspended if bandwidth estimation becomes low.\\n         * @params {Object} options.testing - Additional configuration for work in\\n         * development.\\n         * @params {Object} options.testing.forceP2PSuspendVideoRatio - True if\\n         * video should become suspended if bandwidth estimation becomes low while\\n         * in peer to peer connection mode.\\n         */\\n\\n    }, {\\n        key: '_initPCConstraints',\\n        value: function _initPCConstraints(options) {\\n            if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox()) {\\n                this.pcConstraints = {};\\n            } else if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isChrome() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isOpera() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isNWJS() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isElectron() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isReactNative()) {\\n                this.pcConstraints = { optional: [{ googHighStartBitrate: 0 }, { googPayloadPadding: true }, { googScreencastMinBitrate: 400 }, { googCpuOveruseDetection: true }, { googCpuOveruseEncodeUsage: true }, { googCpuUnderuseThreshold: 55 }, { googCpuOveruseThreshold: 85 }] };\\n\\n                if (options.useIPv6) {\\n                    // https://code.google.com/p/webrtc/issues/detail?id=2828\\n                    this.pcConstraints.optional.push({ googIPv6: true });\\n                }\\n\\n                this.p2pPcConstraints = JSON.parse(JSON.stringify(this.pcConstraints));\\n\\n                // Allows sending of video to be suspended if the bandwidth\\n                // estimation is too low.\\n                if (!options.disableSuspendVideo) {\\n                    this.pcConstraints.optional.push({ googSuspendBelowMinBitrate: true });\\n                }\\n\\n                // There's no reason not to use this for p2p\\n                this.p2pPcConstraints.optional.push({\\n                    googSuspendBelowMinBitrate: true\\n                });\\n            }\\n\\n            this.p2pPcConstraints = this.p2pPcConstraints || this.pcConstraints;\\n        }\\n\\n        /* eslint-disable max-params */\\n\\n        /**\\n        * @param {string[]} um required user media types\\n        * @param {function} successCallback\\n        * @param {Function} failureCallback\\n        * @param {Object} [options] optional parameters\\n        * @param {string} options.resolution\\n        * @param {number} options.bandwidth\\n        * @param {number} options.fps\\n        * @param {string} options.desktopStream\\n        * @param {string} options.cameraDeviceId\\n        * @param {string} options.micDeviceId\\n        **/\\n\\n    }, {\\n        key: 'getUserMediaWithConstraints',\\n        value: function getUserMediaWithConstraints(um, successCallback, failureCallback) {\\n            var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\\n\\n            var constraints = getConstraints(um, options);\\n\\n            logger.info('Get media constraints', constraints);\\n\\n            try {\\n                this.getUserMedia(constraints, function (stream) {\\n                    logger.log('onUserMediaSuccess');\\n                    setAvailableDevices(um, stream);\\n                    successCallback(stream);\\n                }, function (error) {\\n                    setAvailableDevices(um, undefined);\\n                    logger.warn('Failed to get access to local media. Error ', error, constraints);\\n\\n                    if (failureCallback) {\\n                        failureCallback(new __WEBPACK_IMPORTED_MODULE_5__JitsiTrackError__[\\\"a\\\" /* default */](error, constraints, um));\\n                    }\\n                });\\n            } catch (e) {\\n                logger.error('GUM failed: ', e);\\n\\n                if (failureCallback) {\\n                    failureCallback(new __WEBPACK_IMPORTED_MODULE_5__JitsiTrackError__[\\\"a\\\" /* default */](e, constraints, um));\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Acquires a media stream via getUserMedia that\\n         * matches the given constraints\\n         *\\n         * @param {array} umDevices which devices to acquire (e.g. audio, video)\\n         * @param {Object} constraints - Stream specifications to use.\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: '_newGetUserMediaWithConstraints',\\n        value: function _newGetUserMediaWithConstraints(umDevices) {\\n            var _this3 = this;\\n\\n            var constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n            return new Promise(function (resolve, reject) {\\n                try {\\n                    _this3.getUserMedia(constraints).then(function (stream) {\\n                        logger.log('onUserMediaSuccess');\\n\\n                        // TODO(brian): Is this call needed? Why is this\\n                        // happening at gUM time? Isn't there an event listener\\n                        // for this?\\n                        setAvailableDevices(umDevices, stream);\\n\\n                        resolve(stream);\\n                    }).catch(function (error) {\\n                        logger.warn('Failed to get access to local media. ' + (' ' + error + ' ' + constraints + ' '));\\n\\n                        // TODO(brian): Is this call needed? Why is this\\n                        // happening at gUM time? Isn't there an event listener\\n                        // for this?\\n                        setAvailableDevices(umDevices, undefined);\\n                        reject(new __WEBPACK_IMPORTED_MODULE_5__JitsiTrackError__[\\\"a\\\" /* default */](error, constraints, umDevices));\\n                    });\\n                } catch (error) {\\n                    logger.error('GUM failed: ' + error);\\n                    reject(new __WEBPACK_IMPORTED_MODULE_5__JitsiTrackError__[\\\"a\\\" /* default */](error, constraints, umDevices));\\n                }\\n            });\\n        }\\n\\n        /**\\n         * Acquire a display stream via the screenObtainer. This requires extra\\n         * logic compared to use screenObtainer versus normal device capture logic\\n         * in RTCUtils#_newGetUserMediaWithConstraints.\\n         *\\n         * @param {Object} desktopSharingExtensionExternalInstallation\\n         * @param {string[]} desktopSharingSources\\n         * @returns {Promise} A promise which will be resolved with an object whic\\n         * contains the acquired display stream. If desktop sharing is not supported\\n         * then a rejected promise will be returned.\\n         */\\n\\n    }, {\\n        key: '_newGetDesktopMedia',\\n        value: function _newGetDesktopMedia(desktopSharingExtensionExternalInstallation, desktopSharingSources) {\\n            if (!__WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__[\\\"a\\\" /* default */].isSupported() || !__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].supportsVideo()) {\\n                return Promise.reject(new Error('Desktop sharing is not supported!'));\\n            }\\n\\n            var desktopSharingOptions = _extends({}, desktopSharingExtensionExternalInstallation, {\\n                desktopSharingSources: desktopSharingSources\\n            });\\n\\n            return new Promise(function (resolve, reject) {\\n                __WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__[\\\"a\\\" /* default */].obtainStream(desktopSharingOptions, function (stream) {\\n                    resolve(stream);\\n                }, function (error) {\\n                    reject(error);\\n                });\\n            });\\n        }\\n\\n        /* eslint-enable max-params */\\n\\n        /**\\n         * Creates the local MediaStreams.\\n         * @param {Object} [options] optional parameters\\n         * @param {Array} options.devices the devices that will be requested\\n         * @param {string} options.resolution resolution constraints\\n         * @param {bool} options.dontCreateJitsiTrack if <tt>true</tt> objects with\\n         * the following structure {stream: the Media Stream, type: \\\"audio\\\" or\\n         * \\\"video\\\", videoType: \\\"camera\\\" or \\\"desktop\\\"} will be returned trough the\\n         * Promise, otherwise JitsiTrack objects will be returned.\\n         * @param {string} options.cameraDeviceId\\n         * @param {string} options.micDeviceId\\n         * @returns {*} Promise object that will receive the new JitsiTracks\\n         */\\n\\n    }, {\\n        key: 'obtainAudioAndVideoPermissions',\\n        value: function obtainAudioAndVideoPermissions() {\\n            var _this4 = this;\\n\\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n            var self = this;\\n\\n            var dsOptions = _extends({}, options.desktopSharingExtensionExternalInstallation, {\\n                desktopSharingSources: options.desktopSharingSources\\n            });\\n\\n            return new Promise(function (resolve, reject) {\\n                var successCallback = function successCallback(stream) {\\n                    resolve(handleLocalStream(stream, options.resolution));\\n                };\\n\\n                options.devices = options.devices || ['audio', 'video'];\\n                options.resolution = options.resolution || '720';\\n\\n                if (!__WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__[\\\"a\\\" /* default */].isSupported() && options.devices.indexOf('desktop') !== -1) {\\n                    reject(new Error('Desktop sharing is not supported!'));\\n                }\\n                if (__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox()\\n\\n                // XXX The react-native-webrtc implementation that we\\n                // utilize on React Native at the time of this writing does\\n                // not support the MediaStream constructors defined by\\n                // https://www.w3.org/TR/mediacapture-streams/#constructors\\n                // and instead has a single constructor which expects (an\\n                // NSNumber as) a MediaStream ID.\\n                || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isReactNative() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed()) {\\n                    var GUM = function GUM(device, s, e) {\\n                        this.getUserMediaWithConstraints(device, s, e, options);\\n                    };\\n\\n                    var deviceGUM = {\\n                        'audio': GUM.bind(self, ['audio']),\\n                        'video': GUM.bind(self, ['video'])\\n                    };\\n\\n                    if (__WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__[\\\"a\\\" /* default */].isSupported()) {\\n                        deviceGUM.desktop = __WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__[\\\"a\\\" /* default */].obtainStream.bind(__WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__[\\\"a\\\" /* default */], dsOptions);\\n                    }\\n\\n                    // With FF/IE we can't split the stream into audio and video\\n                    // because FF doesn't support media stream constructors. So, we\\n                    // need to get the audio stream separately from the video stream\\n                    // using two distinct GUM calls. Not very user friendly :-( but\\n                    // we don't have many other options neither.\\n                    //\\n                    // Note that we pack those 2 streams in a single object and pass\\n                    // it to the successCallback method.\\n                    obtainDevices({\\n                        devices: options.devices,\\n                        streams: [],\\n                        successCallback: successCallback,\\n                        errorCallback: reject,\\n                        deviceGUM: deviceGUM\\n                    });\\n                } else {\\n                    var hasDesktop = options.devices.indexOf('desktop') > -1;\\n\\n                    if (hasDesktop) {\\n                        options.devices.splice(options.devices.indexOf('desktop'), 1);\\n                    }\\n\\n                    if (options.devices.length) {\\n                        _this4.getUserMediaWithConstraints(options.devices, function (stream) {\\n                            var audioDeviceRequested = options.devices.indexOf('audio') !== -1;\\n                            var videoDeviceRequested = options.devices.indexOf('video') !== -1;\\n                            var audioTracksReceived = stream.getAudioTracks().length > 0;\\n                            var videoTracksReceived = stream.getVideoTracks().length > 0;\\n\\n                            if (audioDeviceRequested && !audioTracksReceived || videoDeviceRequested && !videoTracksReceived) {\\n                                self.stopMediaStream(stream);\\n\\n                                // We are getting here in case if we requested\\n                                // 'audio' or 'video' devices or both, but\\n                                // didn't get corresponding MediaStreamTrack in\\n                                // response stream. We don't know the reason why\\n                                // this happened, so reject with general error.\\n                                // eslint-disable-next-line no-shadow\\n                                var _devices = [];\\n\\n                                if (audioDeviceRequested && !audioTracksReceived) {\\n                                    _devices.push('audio');\\n                                }\\n\\n                                if (videoDeviceRequested && !videoTracksReceived) {\\n                                    _devices.push('video');\\n                                }\\n\\n                                // we are missing one of the media we requested\\n                                // in order to get the actual error that caused\\n                                // this missing media we will call one more time\\n                                // getUserMedia so we can obtain the actual\\n                                // error (Example usecases are requesting\\n                                // audio and video and video device is missing\\n                                // or device is denied to be used and chrome is\\n                                // set to not ask for permissions)\\n                                self.getUserMediaWithConstraints(_devices, function () {\\n                                    // we already failed to obtain this\\n                                    // media, so we are not supposed in any\\n                                    // way to receive success for this call\\n                                    // any way we will throw an error to be\\n                                    // sure the promise will finish\\n                                    reject(new __WEBPACK_IMPORTED_MODULE_5__JitsiTrackError__[\\\"a\\\" /* default */]({ name: 'UnknownError' }, getConstraints(options.devices, options), _devices));\\n                                }, function (error) {\\n                                    // rejects with real error for not\\n                                    // obtaining the media\\n                                    reject(error);\\n                                }, options);\\n\\n                                return;\\n                            }\\n                            if (hasDesktop) {\\n                                __WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__[\\\"a\\\" /* default */].obtainStream(dsOptions, function (desktop) {\\n                                    successCallback({ audioVideo: stream,\\n                                        desktop: desktop });\\n                                }, function (error) {\\n                                    self.stopMediaStream(stream);\\n\\n                                    reject(error);\\n                                });\\n                            } else {\\n                                successCallback({ audioVideo: stream });\\n                            }\\n                        }, function (error) {\\n                            return reject(error);\\n                        }, options);\\n                    } else if (hasDesktop) {\\n                        __WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__[\\\"a\\\" /* default */].obtainStream(dsOptions, function (desktop) {\\n                            return successCallback({ desktop: desktop });\\n                        }, function (error) {\\n                            return reject(error);\\n                        });\\n                    }\\n                }\\n            });\\n        }\\n\\n        /**\\n         * Gets streams from specified device types. This function intentionally\\n         * ignores errors for upstream to catch and handle instead.\\n         *\\n         * @param {Object} options - A hash describing what devices to get and\\n         * relevant constraints.\\n         * @param {string[]} options.devices - The types of media to capture. Valid\\n         * values are \\\"desktop\\\", \\\"audio\\\", and \\\"video\\\".\\n         * @returns {Promise} The promise, when successful, will return an array of\\n         * meta data for the requested device type, which includes the stream and\\n         * track. If an error occurs, it will be deferred to the caller for\\n         * handling.\\n         */\\n\\n    }, {\\n        key: 'newObtainAudioAndVideoPermissions',\\n        value: function newObtainAudioAndVideoPermissions(options) {\\n            logger.info('Using the new gUM flow');\\n\\n            var mediaStreamsMetaData = [];\\n\\n            // Declare private functions to be used in the promise chain below.\\n            // These functions are declared in the scope of this function because\\n            // they are not being used anywhere else, so only this function needs to\\n            // know about them.\\n\\n            /**\\n             * Executes a request for desktop media if specified in options.\\n             *\\n             * @returns {Promise}\\n             */\\n            var maybeRequestDesktopDevice = function () {\\n                var umDevices = options.devices || [];\\n                var isDesktopDeviceRequsted = umDevices.indexOf('desktop') !== -1;\\n\\n                return isDesktopDeviceRequsted ? this._newGetDesktopMedia(options.desktopSharingExtensionExternalInstallation, options.desktopSharingSources) : Promise.resolve();\\n            }.bind(this);\\n\\n            /**\\n             * Creates a meta data object about the passed in desktopStream and\\n             * pushes the meta data to the internal array mediaStreamsMetaData to be\\n             * returned later.\\n             *\\n             * @param {MediaStreamTrack} desktopStream - A track for a desktop\\n             * capture.\\n             * @returns {void}\\n             */\\n            var maybeCreateAndAddDesktopTrack = function maybeCreateAndAddDesktopTrack(desktopStream) {\\n                if (!desktopStream) {\\n                    return;\\n                }\\n\\n                var stream = desktopStream.stream,\\n                    sourceId = desktopStream.sourceId,\\n                    sourceType = desktopStream.sourceType;\\n\\n\\n                mediaStreamsMetaData.push({\\n                    stream: stream,\\n                    sourceId: sourceId,\\n                    sourceType: sourceType,\\n                    track: stream.getVideoTracks()[0],\\n                    videoType: __WEBPACK_IMPORTED_MODULE_15__service_RTC_VideoType___default.a.DESKTOP\\n                });\\n            };\\n\\n            /**\\n             * Executes a request for audio and/or video, as specified in options.\\n             * By default both audio and video will be captured if options.devices\\n             * is not defined.\\n             *\\n             * @returns {Promise}\\n             */\\n            var maybeRequestCaptureDevices = function () {\\n                var umDevices = options.devices || ['audio', 'video'];\\n                var requestedCaptureDevices = umDevices.filter(function (device) {\\n                    return device === 'audio' || device === 'video' && __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].supportsVideo();\\n                });\\n\\n                if (!requestedCaptureDevices.length) {\\n                    return Promise.resolve();\\n                }\\n\\n                var constraints = newGetConstraints(requestedCaptureDevices, options);\\n\\n                logger.info('Got media constraints: ', constraints);\\n\\n                return this._newGetUserMediaWithConstraints(requestedCaptureDevices, constraints);\\n            }.bind(this);\\n\\n            /**\\n             * Splits the passed in media stream into separate audio and video\\n             * streams and creates meta data objects for each and pushes them to the\\n             * internal array mediaStreamsMetaData to be returned later.\\n             *\\n             * @param {MediaStreamTrack} avStream - A track for with audio and/or\\n             * video track.\\n             * @returns {void}\\n             */\\n            var maybeCreateAndAddAVTracks = function maybeCreateAndAddAVTracks(avStream) {\\n                if (!avStream) {\\n                    return;\\n                }\\n\\n                var audioTracks = avStream.getAudioTracks();\\n\\n                if (audioTracks.length) {\\n                    var audioStream = new MediaStream(audioTracks);\\n\\n                    mediaStreamsMetaData.push({\\n                        stream: audioStream,\\n                        track: audioStream.getAudioTracks()[0]\\n                    });\\n                }\\n\\n                var videoTracks = avStream.getVideoTracks();\\n\\n                if (videoTracks.length) {\\n                    var videoStream = new MediaStream(videoTracks);\\n\\n                    mediaStreamsMetaData.push({\\n                        stream: videoStream,\\n                        track: videoStream.getVideoTracks()[0],\\n                        videoType: __WEBPACK_IMPORTED_MODULE_15__service_RTC_VideoType___default.a.CAMERA\\n                    });\\n                }\\n            };\\n\\n            return maybeRequestDesktopDevice().then(maybeCreateAndAddDesktopTrack).then(maybeRequestCaptureDevices).then(maybeCreateAndAddAVTracks).then(function () {\\n                return mediaStreamsMetaData;\\n            });\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'getDeviceAvailability',\\n        value: function getDeviceAvailability() {\\n            return devices;\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'isRTCReady',\\n        value: function isRTCReady() {\\n            return rtcReady;\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: '_isDeviceListAvailable',\\n        value: function _isDeviceListAvailable() {\\n            if (!rtcReady) {\\n                throw new Error('WebRTC not ready yet');\\n            }\\n\\n            return Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices || typeof MediaStreamTrack !== 'undefined' && MediaStreamTrack.getSources);\\n        }\\n\\n        /**\\n         * Returns a promise which can be used to make sure that the WebRTC stack\\n         * has been initialized.\\n         *\\n         * @returns {Promise} which is resolved only if the WebRTC stack is ready.\\n         * Note that currently we do not detect stack initialization failure and\\n         * the promise is never rejected(unless unexpected error occurs).\\n         */\\n\\n    }, {\\n        key: 'onRTCReady',\\n        value: function onRTCReady() {\\n            if (rtcReady) {\\n                return Promise.resolve();\\n            }\\n\\n            return new Promise(function (resolve) {\\n                var listener = function listener() {\\n                    eventEmitter.removeListener(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.RTC_READY, listener);\\n                    resolve();\\n                };\\n\\n                eventEmitter.addListener(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.RTC_READY, listener);\\n\\n                // We have no failed event, so... it either resolves or nothing\\n                // happens.\\n            });\\n        }\\n\\n        /**\\n         * Checks if its possible to enumerate available cameras/microphones.\\n         *\\n         * @returns {Promise<boolean>} a Promise which will be resolved only once\\n         * the WebRTC stack is ready, either with true if the device listing is\\n         * available available or with false otherwise.\\n         */\\n\\n    }, {\\n        key: 'isDeviceListAvailable',\\n        value: function isDeviceListAvailable() {\\n            return this.onRTCReady().then(this._isDeviceListAvailable.bind(this));\\n        }\\n\\n        /**\\n         * Returns true if changing the input (camera / microphone) or output\\n         * (audio) device is supported and false if not.\\n         * @params {string} [deviceType] - type of device to change. Default is\\n         *      undefined or 'input', 'output' - for audio output device change.\\n         * @returns {boolean} true if available, false otherwise.\\n         */\\n\\n    }, {\\n        key: 'isDeviceChangeAvailable',\\n        value: function isDeviceChangeAvailable(deviceType) {\\n            return deviceType === 'output' || deviceType === 'audiooutput' ? isAudioOutputDeviceChangeAvailable : __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isChrome() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isOpera() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isNWJS() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isElectron() || __WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isEdge();\\n        }\\n\\n        /**\\n         * A method to handle stopping of the stream.\\n         * One point to handle the differences in various implementations.\\n         * @param mediaStream MediaStream object to stop.\\n         */\\n\\n    }, {\\n        key: 'stopMediaStream',\\n        value: function stopMediaStream(mediaStream) {\\n            mediaStream.getTracks().forEach(function (track) {\\n                // stop() not supported with IE\\n                if (!__WEBPACK_IMPORTED_MODULE_9__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed() && track.stop) {\\n                    track.stop();\\n                }\\n            });\\n\\n            // leave stop for implementation still using it\\n            if (mediaStream.stop) {\\n                mediaStream.stop();\\n            }\\n\\n            // The MediaStream implementation of the react-native-webrtc project has\\n            // an explicit release method that is to be invoked in order to release\\n            // used resources such as memory.\\n            if (mediaStream.release) {\\n                mediaStream.release();\\n            }\\n\\n            // if we have done createObjectURL, lets clean it\\n            var url = mediaStream.jitsiObjectURL;\\n\\n            if (url) {\\n                delete mediaStream.jitsiObjectURL;\\n                (URL || webkitURL).revokeObjectURL(url);\\n            }\\n        }\\n\\n        /**\\n         * Returns whether the desktop sharing is enabled or not.\\n         * @returns {boolean}\\n         */\\n\\n    }, {\\n        key: 'isDesktopSharingEnabled',\\n        value: function isDesktopSharingEnabled() {\\n            return __WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__[\\\"a\\\" /* default */].isSupported();\\n        }\\n\\n        /**\\n         * Sets current audio output device.\\n         * @param {string} deviceId - id of 'audiooutput' device from\\n         *      navigator.mediaDevices.enumerateDevices(), 'default' for default\\n         *      device\\n         * @returns {Promise} - resolves when audio output is changed, is rejected\\n         *      otherwise\\n         */\\n\\n    }, {\\n        key: 'setAudioOutputDevice',\\n        value: function setAudioOutputDevice(deviceId) {\\n            if (!this.isDeviceChangeAvailable('output')) {\\n                Promise.reject(new Error('Audio output device change is not supported'));\\n            }\\n\\n            return featureDetectionAudioEl.setSinkId(deviceId).then(function () {\\n                audioOutputDeviceId = deviceId;\\n                audioOutputChanged = true;\\n\\n                logger.log('Audio output device set to ' + deviceId);\\n\\n                eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.AUDIO_OUTPUT_DEVICE_CHANGED, deviceId);\\n            });\\n        }\\n\\n        /**\\n         * Returns currently used audio output device id, '' stands for default\\n         * device\\n         * @returns {string}\\n         */\\n\\n    }, {\\n        key: 'getAudioOutputDevice',\\n        value: function getAudioOutputDevice() {\\n            return audioOutputDeviceId;\\n        }\\n\\n        /**\\n         * Returns list of available media devices if its obtained, otherwise an\\n         * empty array is returned/\\n         * @returns {Array} list of available media devices.\\n         */\\n\\n    }, {\\n        key: 'getCurrentlyAvailableMediaDevices',\\n        value: function getCurrentlyAvailableMediaDevices() {\\n            return currentlyAvailableMediaDevices;\\n        }\\n\\n        /**\\n         * Returns event data for device to be reported to stats.\\n         * @returns {MediaDeviceInfo} device.\\n         */\\n\\n    }, {\\n        key: 'getEventDataForActiveDevice',\\n        value: function getEventDataForActiveDevice(device) {\\n            var deviceList = [];\\n            var deviceData = {\\n                'deviceId': device.deviceId,\\n                'kind': device.kind,\\n                'label': device.label,\\n                'groupId': device.groupId\\n            };\\n\\n            deviceList.push(deviceData);\\n\\n            return { deviceList: deviceList };\\n        }\\n\\n        /**\\n         * Configures the given PeerConnection constraints to either enable or\\n         * disable (according to the value of the 'enable' parameter) the\\n         * 'googSuspendBelowMinBitrate' option.\\n         * @param constraints the constraints on which to operate.\\n         * @param enable {boolean} whether to enable or disable the suspend video\\n         * option.\\n         */\\n\\n    }, {\\n        key: 'setSuspendVideo',\\n        value: function setSuspendVideo(constraints, enable) {\\n            if (!constraints.optional) {\\n                constraints.optional = [];\\n            }\\n\\n            // Get rid of all \\\"googSuspendBelowMinBitrate\\\" constraints (we assume\\n            // that the elements of constraints.optional contain a single property).\\n            constraints.optional = constraints.optional.filter(function (c) {\\n                return !c.hasOwnProperty('googSuspendBelowMinBitrate');\\n            });\\n\\n            if (enable) {\\n                constraints.optional.push({ googSuspendBelowMinBitrate: 'true' });\\n            }\\n        }\\n    }]);\\n\\n    return RTCUtils;\\n}(__WEBPACK_IMPORTED_MODULE_6__util_Listenable__[\\\"a\\\" /* default */]);\\n\\n/**\\n * Rejects a Promise because WebRTC is not supported.\\n *\\n * @param {string} errorMessage - The human-readable message of the Error which\\n * is the reason for the rejection.\\n * @param {Function} reject - The reject function of the Promise.\\n * @returns {void}\\n */\\n\\n\\nfunction rejectWithWebRTCNotSupported(errorMessage, reject) {\\n    var error = new Error(errorMessage);\\n\\n    // WebRTC is not supported either natively or via a known plugin such as\\n    // Temasys.\\n    // XXX The Error class already has a property name which is commonly used to\\n    // detail the represented error in a non-human-readable way (in contrast to\\n    // the human-readable property message). I explicitly did not want to\\n    // introduce a new specific property.\\n    // FIXME None of the existing JitsiXXXErrors seemed to be appropriate\\n    // recipients of the constant WEBRTC_NOT_SUPPORTED so I explicitly chose to\\n    // leave it as a magic string at the time of this writing.\\n    error.name = 'WEBRTC_NOT_SUPPORTED';\\n\\n    logger.error(errorMessage);\\n    reject(error);\\n}\\n\\nvar rtcUtils = new RTCUtils();\\n\\n/**\\n *\\n * @param options\\n */\\nfunction obtainDevices(options) {\\n    if (!options.devices || options.devices.length === 0) {\\n        return options.successCallback(options.streams || {});\\n    }\\n\\n    var device = options.devices.splice(0, 1);\\n\\n    options.deviceGUM[device](function (stream) {\\n        options.streams = options.streams || {};\\n        options.streams[device] = stream;\\n        obtainDevices(options);\\n    }, function (error) {\\n        Object.keys(options.streams).forEach(function (d) {\\n            return rtcUtils.stopMediaStream(options.streams[d]);\\n        });\\n        logger.error('failed to obtain ' + device + ' stream - stop', error);\\n\\n        options.errorCallback(error);\\n    });\\n}\\n\\n/**\\n * In case of IE we continue from 'onReady' callback passed to RTCUtils\\n * constructor. It will be invoked by Temasys plugin once it is initialized.\\n *\\n * @param options\\n * @param GUM\\n */\\nfunction onReady(options, GUM) {\\n    rtcReady = true;\\n    eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.RTC_READY, true);\\n    __WEBPACK_IMPORTED_MODULE_12__ScreenObtainer__[\\\"a\\\" /* default */].init(options, GUM);\\n\\n    if (rtcUtils.isDeviceListAvailable() && rawEnumerateDevicesWithCallback) {\\n        rawEnumerateDevicesWithCallback(function (ds) {\\n            currentlyAvailableMediaDevices = ds.splice(0);\\n\\n            logger.info('Available devices: ', currentlyAvailableMediaDevices);\\n            sendDeviceListToAnalytics(currentlyAvailableMediaDevices);\\n\\n            eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_10__service_RTC_RTCEvents___default.a.DEVICE_LIST_AVAILABLE, currentlyAvailableMediaDevices);\\n\\n            if (isDeviceChangeEventSupported) {\\n                navigator.mediaDevices.addEventListener('devicechange', function () {\\n                    return rtcUtils.enumerateDevices(onMediaDevicesListChanged);\\n                });\\n            } else {\\n                pollForAvailableMediaDevices();\\n            }\\n        });\\n    }\\n}\\n\\n/**\\n * Wraps original attachMediaStream function to set current audio output device\\n * if this is supported.\\n * @param {Function} origAttachMediaStream\\n * @returns {Function}\\n */\\nfunction wrapAttachMediaStream(origAttachMediaStream) {\\n    return function (element, stream) {\\n        // eslint-disable-next-line prefer-rest-params\\n        var res = origAttachMediaStream.apply(rtcUtils, arguments);\\n\\n        if (stream && rtcUtils.isDeviceChangeAvailable('output') && stream.getAudioTracks && stream.getAudioTracks().length\\n\\n        // we skip setting audio output if there was no explicit change\\n        && audioOutputChanged) {\\n            element.setSinkId(rtcUtils.getAudioOutputDevice()).catch(function (ex) {\\n                var err = new __WEBPACK_IMPORTED_MODULE_5__JitsiTrackError__[\\\"a\\\" /* default */](ex, null, ['audiooutput']);\\n\\n                __WEBPACK_IMPORTED_MODULE_4__util_GlobalOnErrorHandler___default.a.callUnhandledRejectionHandler({\\n                    promise: this, // eslint-disable-line no-invalid-this\\n                    reason: err\\n                });\\n\\n                logger.warn('Failed to set audio output device for the element.' + ' Default audio output device will be used' + ' instead', element, err);\\n            });\\n        }\\n\\n        return res;\\n    };\\n}\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (rtcUtils);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/RTCUtils.js\\\"))\\n\\n/***/ }),\\n/* 29 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (immutable) */ __webpack_exports__[\\\"b\\\"] = parsePrimarySSRC;\\n/* harmony export (immutable) */ __webpack_exports__[\\\"c\\\"] = parseSecondarySSRC;\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return SdpTransformWrap; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sdp_transform__ = __webpack_require__(15);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sdp_transform___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_sdp_transform__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n/**\\n * Parses the primary SSRC of given SSRC group.\\n * @param {object} group the SSRC group object as defined by the 'sdp-transform'\\n * @return {Number} the primary SSRC number\\n */\\nfunction parsePrimarySSRC(group) {\\n    return parseInt(group.ssrcs.split(' ')[0], 10);\\n}\\n\\n/**\\n * Parses the secondary SSRC of given SSRC group.\\n * @param {object} group the SSRC group object as defined by the 'sdp-transform'\\n * @return {Number} the secondary SSRC number\\n */\\nfunction parseSecondarySSRC(group) {\\n    return parseInt(group.ssrcs.split(' ')[1], 10);\\n}\\n\\n/**\\n * Tells how many distinct SSRCs are contained in given media line.\\n * @param {Object} mLine the media line object as defined by 'sdp-transform' lib\\n * @return {number}\\n */\\nfunction _getSSRCCount(mLine) {\\n    if (!mLine.ssrcs) {\\n        return 0;\\n    }\\n\\n    return mLine.ssrcs.map(function (ssrcInfo) {\\n        return ssrcInfo.id;\\n    }).filter(function (ssrc, index, array) {\\n        return array.indexOf(ssrc) === index;\\n    }).length;\\n}\\n\\n/**\\n * A wrapper around 'sdp-transform' media description object which provides\\n * utility methods for common SDP/SSRC related operations.\\n */\\n\\nvar MLineWrap = function () {\\n\\n    /**\\n     * Creates new <tt>MLineWrap</t>>\\n     * @param {Object} mLine the media line object as defined by 'sdp-transform'\\n     * lib.\\n     */\\n    function MLineWrap(mLine) {\\n        _classCallCheck(this, MLineWrap);\\n\\n        if (!mLine) {\\n            throw new Error('mLine is undefined');\\n        }\\n\\n        this.mLine = mLine;\\n    }\\n\\n    /**\\n     * Getter for the mLine's \\\"ssrcs\\\" array. If the array was undefined an empty\\n     * one will be preassigned.\\n     *\\n     * @return {Array<Object>} an array of 'sdp-transform' SSRC attributes\\n     * objects.\\n     */\\n\\n\\n    _createClass(MLineWrap, [{\\n        key: 'getSSRCAttrValue',\\n\\n\\n        /**\\n         * Obtains value from SSRC attribute.\\n         * @param {number} ssrcNumber the SSRC number for which attribute is to be\\n         * found\\n         * @param {string} attrName the name of the SSRC attribute to be found.\\n         * @return {string|undefined} the value of SSRC attribute or\\n         * <tt>undefined</tt> if no such attribute exists.\\n         */\\n        value: function getSSRCAttrValue(ssrcNumber, attrName) {\\n            var attribute = this.ssrcs.find(function (ssrcObj) {\\n                return ssrcObj.id === ssrcNumber && ssrcObj.attribute === attrName;\\n            });\\n\\n            return attribute && attribute.value;\\n        }\\n\\n        /**\\n         * Removes all attributes for given SSRC number.\\n         * @param {number} ssrcNum the SSRC number for which all attributes will be\\n         * removed.\\n         */\\n\\n    }, {\\n        key: 'removeSSRC',\\n        value: function removeSSRC(ssrcNum) {\\n            if (!this.mLine.ssrcs || !this.mLine.ssrcs.length) {\\n                return;\\n            }\\n\\n            this.mLine.ssrcs = this.mLine.ssrcs.filter(function (ssrcObj) {\\n                return ssrcObj.id !== ssrcNum;\\n            });\\n        }\\n\\n        /**\\n         * Adds SSRC attribute\\n         * @param {object} ssrcObj the SSRC attribute object as defined in\\n         * the 'sdp-transform' lib.\\n         */\\n\\n    }, {\\n        key: 'addSSRCAttribute',\\n        value: function addSSRCAttribute(ssrcObj) {\\n            this.ssrcs.push(ssrcObj);\\n        }\\n\\n        /**\\n         * Finds a SSRC group matching both semantics and SSRCs in order.\\n         * @param {string} semantics the name of the semantics\\n         * @param {string} [ssrcs] group SSRCs as a string (like it's defined in\\n         * SSRC group object of the 'sdp-transform' lib) e.g. \\\"1232546 342344 25434\\\"\\n         * @return {object|undefined} the SSRC group object or <tt>undefined</tt> if\\n         * not found.\\n         */\\n\\n    }, {\\n        key: 'findGroup',\\n        value: function findGroup(semantics, ssrcs) {\\n            return this.ssrcGroups.find(function (group) {\\n                return group.semantics === semantics && (!ssrcs || ssrcs === group.ssrcs);\\n            });\\n        }\\n\\n        /**\\n         * Finds all groups matching given semantic's name.\\n         * @param {string} semantics the name of the semantics\\n         * @return {Array.<object>} an array of SSRC group objects as defined by\\n         * the 'sdp-transform' lib.\\n         */\\n\\n    }, {\\n        key: 'findGroups',\\n        value: function findGroups(semantics) {\\n            return this.ssrcGroups.filter(function (group) {\\n                return group.semantics === semantics;\\n            });\\n        }\\n\\n        /**\\n         * Finds all groups matching given semantic's name and group's primary SSRC.\\n         * @param {string} semantics the name of the semantics\\n         * @param {number} primarySSRC the primary SSRC number to be matched\\n         * @return {Object} SSRC group object as defined by the 'sdp-transform' lib.\\n         */\\n\\n    }, {\\n        key: 'findGroupByPrimarySSRC',\\n        value: function findGroupByPrimarySSRC(semantics, primarySSRC) {\\n            return this.ssrcGroups.find(function (group) {\\n                return group.semantics === semantics && parsePrimarySSRC(group) === primarySSRC;\\n            });\\n        }\\n\\n        /**\\n         * @param {string|null} msid the media stream id or <tt>null</tt> to match\\n         * the first SSRC object with any 'msid' value.\\n         * @return {Object|undefined} the SSRC object as defined by 'sdp-transform'\\n         * lib.\\n         */\\n\\n    }, {\\n        key: 'findSSRCByMSID',\\n        value: function findSSRCByMSID(msid) {\\n            return this.ssrcs.find(function (ssrcObj) {\\n                return ssrcObj.attribute === 'msid' && (msid === null || ssrcObj.value === msid);\\n            });\\n        }\\n\\n        /**\\n         * Gets the SSRC count for the underlying media description.\\n         * @return {number}\\n         */\\n\\n    }, {\\n        key: 'getSSRCCount',\\n        value: function getSSRCCount() {\\n            return _getSSRCCount(this.mLine);\\n        }\\n\\n        /**\\n         * Checks whether the underlying media description contains any SSRC groups.\\n         * @return {boolean} <tt>true</tt> if there are any SSRC groups or\\n         * <tt>false</tt> otherwise.\\n         */\\n\\n    }, {\\n        key: 'containsAnySSRCGroups',\\n        value: function containsAnySSRCGroups() {\\n            return this.mLine.ssrcGroups !== undefined;\\n        }\\n\\n        /**\\n         * Finds the primary video SSRC.\\n         * @returns {number|undefined} the primary video ssrc\\n         * @throws Error if the underlying media description is not a video\\n         */\\n\\n    }, {\\n        key: 'getPrimaryVideoSsrc',\\n        value: function getPrimaryVideoSsrc() {\\n            var mediaType = this.mLine.type;\\n\\n            if (mediaType !== 'video') {\\n                throw new Error('getPrimarySsrc doesn\\\\'t work with \\\\'' + mediaType + '\\\\'');\\n            }\\n\\n            var numSsrcs = _getSSRCCount(this.mLine);\\n\\n            if (numSsrcs === 1) {\\n                // Not using \\\"ssrcs\\\" getter on purpose here\\n                return this.mLine.ssrcs[0].id;\\n            }\\n\\n            // Look for a SIM, FID, or FEC-FR group\\n            if (this.mLine.ssrcGroups) {\\n                var simGroup = this.findGroup('SIM');\\n\\n                if (simGroup) {\\n                    return parsePrimarySSRC(simGroup);\\n                }\\n                var fidGroup = this.findGroup('FID');\\n\\n                if (fidGroup) {\\n                    return parsePrimarySSRC(fidGroup);\\n                }\\n                var fecGroup = this.findGroup('FEC-FR');\\n\\n                if (fecGroup) {\\n                    return parsePrimarySSRC(fecGroup);\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Obtains RTX SSRC from the underlying video description (the\\n         * secondary SSRC of the first \\\"FID\\\" group found)\\n         * @param {number} primarySsrc the video ssrc for which to find the\\n         * corresponding rtx ssrc\\n         * @returns {number|undefined} the rtx ssrc (or undefined if there isn't\\n         * one)\\n         */\\n\\n    }, {\\n        key: 'getRtxSSRC',\\n        value: function getRtxSSRC(primarySsrc) {\\n            var fidGroup = this.findGroupByPrimarySSRC('FID', primarySsrc);\\n\\n            return fidGroup && parseSecondarySSRC(fidGroup);\\n        }\\n\\n        /**\\n         * Obtains all SSRCs contained in the underlying media description.\\n         * @return {Array.<number>} an array with all SSRC as numbers.\\n         */\\n\\n    }, {\\n        key: 'getSSRCs',\\n        value: function getSSRCs() {\\n            return this.ssrcs.map(function (ssrcInfo) {\\n                return ssrcInfo.id;\\n            }).filter(function (ssrc, index, array) {\\n                return array.indexOf(ssrc) === index;\\n            });\\n        }\\n\\n        /**\\n         * Obtains primary video SSRCs.\\n         * @return {Array.<number>} an array of all primary video SSRCs as numbers.\\n         * @throws Error if the wrapped media description is not a video.\\n         */\\n\\n    }, {\\n        key: 'getPrimaryVideoSSRCs',\\n        value: function getPrimaryVideoSSRCs() {\\n            var mediaType = this.mLine.type;\\n\\n            if (mediaType !== 'video') {\\n                throw new Error('getPrimaryVideoSSRCs doesn\\\\'t work with ' + mediaType);\\n            }\\n\\n            var videoSSRCs = this.getSSRCs();\\n\\n            var _iteratorNormalCompletion = true;\\n            var _didIteratorError = false;\\n            var _iteratorError = undefined;\\n\\n            try {\\n                for (var _iterator = this.ssrcGroups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                    var ssrcGroupInfo = _step.value;\\n\\n                    // Right now, FID and FEC-FR groups are the only ones we parse to\\n                    // disqualify streams.  If/when others arise we'll\\n                    // need to add support for them here\\n                    if (ssrcGroupInfo.semantics === 'FID' || ssrcGroupInfo.semantics === 'FEC-FR') {\\n                        // secondary streams should be filtered out\\n                        var secondarySsrc = parseSecondarySSRC(ssrcGroupInfo);\\n\\n                        videoSSRCs.splice(videoSSRCs.indexOf(secondarySsrc), 1);\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError = true;\\n                _iteratorError = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion && _iterator.return) {\\n                        _iterator.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError) {\\n                        throw _iteratorError;\\n                    }\\n                }\\n            }\\n\\n            return videoSSRCs;\\n        }\\n\\n        /**\\n         * Dumps all SSRC groups of this media description to JSON.\\n         */\\n\\n    }, {\\n        key: 'dumpSSRCGroups',\\n        value: function dumpSSRCGroups() {\\n            return JSON.stringify(this.mLine.ssrcGroups);\\n        }\\n\\n        /**\\n         * Removes all SSRC groups which contain given SSRC number at any position.\\n         * @param {number} ssrc the SSRC for which all matching groups are to be\\n         * removed.\\n         */\\n\\n    }, {\\n        key: 'removeGroupsWithSSRC',\\n        value: function removeGroupsWithSSRC(ssrc) {\\n            if (!this.mLine.ssrcGroups) {\\n                return;\\n            }\\n\\n            this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter(function (groupInfo) {\\n                return groupInfo.ssrcs.indexOf('' + ssrc) === -1;\\n            });\\n        }\\n\\n        /**\\n         * Removes groups that match given semantics.\\n         * @param {string} semantics e.g. \\\"SIM\\\" or \\\"FID\\\"\\n         */\\n\\n    }, {\\n        key: 'removeGroupsBySemantics',\\n        value: function removeGroupsBySemantics(semantics) {\\n            if (!this.mLine.ssrcGroups) {\\n                return;\\n            }\\n\\n            this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter(function (groupInfo) {\\n                return groupInfo.semantics !== semantics;\\n            });\\n        }\\n\\n        /**\\n         * Replaces SSRC (does not affect SSRC groups, but only attributes).\\n         * @param {number} oldSSRC the old SSRC number\\n         * @param {number} newSSRC the new SSRC number\\n         */\\n\\n    }, {\\n        key: 'replaceSSRC',\\n        value: function replaceSSRC(oldSSRC, newSSRC) {\\n            if (this.mLine.ssrcs) {\\n                this.mLine.ssrcs.forEach(function (ssrcInfo) {\\n                    if (ssrcInfo.id === oldSSRC) {\\n                        ssrcInfo.id = newSSRC;\\n                    }\\n                });\\n            }\\n        }\\n\\n        /**\\n         * Adds given SSRC group to this media description.\\n         * @param {object} group the SSRC group object as defined by\\n         * the 'sdp-transform' lib.\\n         */\\n\\n    }, {\\n        key: 'addSSRCGroup',\\n        value: function addSSRCGroup(group) {\\n            this.ssrcGroups.push(group);\\n        }\\n    }, {\\n        key: 'ssrcs',\\n        get: function get() {\\n            if (!this.mLine.ssrcs) {\\n                this.mLine.ssrcs = [];\\n            }\\n\\n            return this.mLine.ssrcs;\\n        }\\n\\n        /**\\n         * Setter for the mLine's \\\"ssrcs\\\" array.\\n         *\\n         * @param {Array<Object>} ssrcs an array of 'sdp-transform' SSRC attributes\\n         * objects.\\n         */\\n        ,\\n        set: function set(ssrcs) {\\n            this.mLine.ssrcs = ssrcs;\\n        }\\n\\n        /**\\n         * Returns the direction of the underlying media description.\\n         * @return {string} the media direction name as defined in the SDP.\\n         */\\n\\n    }, {\\n        key: 'direction',\\n        get: function get() {\\n            return this.mLine.direction;\\n        }\\n\\n        /**\\n         * Modifies the direction of the underlying media description.\\n         * @param {string} direction the new direction to be set\\n         */\\n        ,\\n        set: function set(direction) {\\n            this.mLine.direction = direction;\\n        }\\n\\n        /**\\n         * Exposes the SSRC group array of the underlying media description object.\\n         * @return {Array.<Object>}\\n         */\\n\\n    }, {\\n        key: 'ssrcGroups',\\n        get: function get() {\\n            if (!this.mLine.ssrcGroups) {\\n                this.mLine.ssrcGroups = [];\\n            }\\n\\n            return this.mLine.ssrcGroups;\\n        }\\n\\n        /**\\n         * Modifies the SSRC groups array of the underlying media description\\n         * object.\\n         * @param {Array.<Object>} ssrcGroups\\n         */\\n        ,\\n        set: function set(ssrcGroups) {\\n            this.mLine.ssrcGroups = ssrcGroups;\\n        }\\n    }]);\\n\\n    return MLineWrap;\\n}();\\n\\n/**\\n * Utility class for SDP manipulation using the 'sdp-transform' library.\\n *\\n * Typical use usage scenario:\\n *\\n * const transformer = new SdpTransformWrap(rawSdp);\\n * const videoMLine = transformer.selectMedia('video);\\n * if (videoMLine) {\\n *     videoMLiner.addSSRCAttribute({\\n *         id: 2342343,\\n *         attribute: \\\"cname\\\",\\n *         value: \\\"someCname\\\"\\n *     });\\n *     rawSdp = transformer.toRawSdp();\\n * }\\n */\\n\\n\\nvar SdpTransformWrap = function () {\\n\\n    /**\\n     * Creates new instance and parses the raw SDP into objects using\\n     * 'sdp-transform' lib.\\n     * @param {string} rawSDP the SDP in raw text format.\\n     */\\n    function SdpTransformWrap(rawSDP) {\\n        _classCallCheck(this, SdpTransformWrap);\\n\\n        this.parsedSDP = __WEBPACK_IMPORTED_MODULE_0_sdp_transform__[\\\"parse\\\"](rawSDP);\\n    }\\n\\n    /**\\n     * Selects the first media SDP of given name.\\n     * @param {string} mediaType the name of the media e.g. 'audio', 'video',\\n     * 'data'.\\n     * @return {MLineWrap|null} return {@link MLineWrap} instance for the media\\n     * line or <tt>null</tt> if not found. The object returned references\\n     * the underlying SDP state held by this <tt>SdpTransformWrap</tt> instance\\n     * (it's not a copy).\\n     */\\n\\n\\n    _createClass(SdpTransformWrap, [{\\n        key: 'selectMedia',\\n        value: function selectMedia(mediaType) {\\n            var selectedMLine = this.parsedSDP.media.find(function (mLine) {\\n                return mLine.type === mediaType;\\n            });\\n\\n            return selectedMLine ? new MLineWrap(selectedMLine) : null;\\n        }\\n\\n        /**\\n         * Converts the currently stored SDP state in this instance to raw text SDP\\n         * format.\\n         * @return {string}\\n         */\\n\\n    }, {\\n        key: 'toRawSDP',\\n        value: function toRawSDP() {\\n            return __WEBPACK_IMPORTED_MODULE_0_sdp_transform__[\\\"write\\\"](this.parsedSDP);\\n        }\\n    }]);\\n\\n    return SdpTransformWrap;\\n}();\\n\\n/***/ }),\\n/* 30 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"STATUS_AVAILABLE\\\", function() { return STATUS_AVAILABLE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"STATUS_UNDEFINED\\\", function() { return STATUS_UNDEFINED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"STATUS_BUSY\\\", function() { return STATUS_BUSY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"STATE_ON\\\", function() { return STATE_ON; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"STATE_OFF\\\", function() { return STATE_OFF; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"STATE_PENDING\\\", function() { return STATE_PENDING; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"STATE_RETRYING\\\", function() { return STATE_RETRYING; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"STATE_FAILED\\\", function() { return STATE_FAILED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ERROR_NO_CONNECTION\\\", function() { return ERROR_NO_CONNECTION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ERROR_SESSION_EXISTS\\\", function() { return ERROR_SESSION_EXISTS; });\\n/**\\n * Status that video SIP GW service is available.\\n * @type {string}\\n */\\nvar STATUS_AVAILABLE = 'available';\\n\\n/**\\n * Status that video SIP GW service is not available.\\n * @type {string}\\n */\\nvar STATUS_UNDEFINED = 'undefined';\\n\\n/**\\n * Status that video SIP GW service is available but there are no free nodes\\n * at the moment to serve new requests.\\n * @type {string}\\n */\\nvar STATUS_BUSY = 'busy';\\n\\n/**\\n * Video SIP GW session state, currently running.\\n * @type {string}\\n */\\nvar STATE_ON = 'on';\\n\\n/**\\n * Video SIP GW session state, currently stopped and not running.\\n * @type {string}\\n */\\nvar STATE_OFF = 'off';\\n\\n/**\\n * Video SIP GW session state, currently is starting.\\n * @type {string}\\n */\\nvar STATE_PENDING = 'pending';\\n\\n/**\\n * Video SIP GW session state, has observed some issues and is retrying at the\\n * moment.\\n * @type {string}\\n */\\nvar STATE_RETRYING = 'retrying';\\n\\n/**\\n * Video SIP GW session state, tried to start but it failed.\\n * @type {string}\\n */\\nvar STATE_FAILED = 'failed';\\n\\n/**\\n * Error on trying to create video SIP GW session in conference where\\n * there is no room connection (hasn't joined or has left the room).\\n * @type {string}\\n */\\nvar ERROR_NO_CONNECTION = 'error_no_connection';\\n\\n/**\\n * Error on trying to create video SIP GW session with address for which\\n * there is an already created session.\\n * @type {string}\\n */\\nvar ERROR_SESSION_EXISTS = 'error_session_already_exists';\\n\\n/***/ }),\\n/* 31 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LOCAL_STATS_UPDATED\\\", function() { return LOCAL_STATS_UPDATED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"REMOTE_STATS_UPDATED\\\", function() { return REMOTE_STATS_UPDATED; });\\n/**\\n * Indicates that the local connection statistics were updated.\\n */\\nvar LOCAL_STATS_UPDATED = 'cq.local_stats_updated';\\n\\n/**\\n * Indicates that the connection statistics for a particular remote participant\\n * were updated.\\n */\\nvar REMOTE_STATS_UPDATED = 'cq.remote_stats_updated';\\n\\n/***/ }),\\n/* 32 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"AUTHENTICATION_REQUIRED\\\", function() { return AUTHENTICATION_REQUIRED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CHAT_ERROR\\\", function() { return CHAT_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONFERENCE_DESTROYED\\\", function() { return CONFERENCE_DESTROYED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONFERENCE_MAX_USERS\\\", function() { return CONFERENCE_MAX_USERS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONNECTION_ERROR\\\", function() { return CONNECTION_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NOT_ALLOWED_ERROR\\\", function() { return NOT_ALLOWED_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FOCUS_DISCONNECTED\\\", function() { return FOCUS_DISCONNECTED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"FOCUS_LEFT\\\", function() { return FOCUS_LEFT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"GRACEFUL_SHUTDOWN\\\", function() { return GRACEFUL_SHUTDOWN; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"INCOMPATIBLE_SERVER_VERSIONS\\\", function() { return INCOMPATIBLE_SERVER_VERSIONS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"JINGLE_FATAL_ERROR\\\", function() { return JINGLE_FATAL_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PASSWORD_NOT_SUPPORTED\\\", function() { return PASSWORD_NOT_SUPPORTED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PASSWORD_REQUIRED\\\", function() { return PASSWORD_REQUIRED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RESERVATION_ERROR\\\", function() { return RESERVATION_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SETUP_FAILED\\\", function() { return SETUP_FAILED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VIDEOBRIDGE_NOT_AVAILABLE\\\", function() { return VIDEOBRIDGE_NOT_AVAILABLE; });\\n/**\\n * The errors for the conference.\\n */\\n\\n/**\\n * Indicates that client must be authenticated to create the conference.\\n */\\nvar AUTHENTICATION_REQUIRED = 'conference.authenticationRequired';\\n\\n/**\\n * Indicates that chat error occurred.\\n */\\nvar CHAT_ERROR = 'conference.chatError';\\n\\n/**\\n * Indicates that conference has been destroyed.\\n */\\nvar CONFERENCE_DESTROYED = 'conference.destroyed';\\n\\n/**\\n * Indicates that max users limit has been reached.\\n */\\nvar CONFERENCE_MAX_USERS = 'conference.max_users';\\n\\n/**\\n * Indicates that a connection error occurred when trying to join a conference.\\n */\\nvar CONNECTION_ERROR = 'conference.connectionError';\\n\\n/**\\n * Indicates that a connection error is due to not allowed,\\n * occurred when trying to join a conference.\\n */\\nvar NOT_ALLOWED_ERROR = 'conference.connectionError.notAllowed';\\n\\n/**\\n * Indicates that focus error happened.\\n */\\nvar FOCUS_DISCONNECTED = 'conference.focusDisconnected';\\n\\n/**\\n * Indicates that focus left the conference.\\n */\\nvar FOCUS_LEFT = 'conference.focusLeft';\\n\\n/**\\n * Indicates that graceful shutdown happened.\\n */\\nvar GRACEFUL_SHUTDOWN = 'conference.gracefulShutdown';\\n\\n/**\\n * Indicates that the versions of the server side components are incompatible\\n * with the client side.\\n */\\nvar INCOMPATIBLE_SERVER_VERSIONS = 'conference.incompatible_server_versions';\\n\\n/**\\n * Indicates that jingle fatal error happened.\\n */\\nvar JINGLE_FATAL_ERROR = 'conference.jingleFatalError';\\n\\n/**\\n * Indicates that password cannot be set for this conference.\\n */\\nvar PASSWORD_NOT_SUPPORTED = 'conference.passwordNotSupported';\\n\\n/**\\n * Indicates that a password is required in order to join the conference.\\n */\\nvar PASSWORD_REQUIRED = 'conference.passwordRequired';\\n\\n/**\\n * Indicates that reservation system returned error.\\n */\\nvar RESERVATION_ERROR = 'conference.reservationError';\\n\\n/**\\n * Indicates that the conference setup failed.\\n */\\nvar SETUP_FAILED = 'conference.setup_failed';\\n\\n/**\\n * Indicates that there is no available videobridge.\\n */\\nvar VIDEOBRIDGE_NOT_AVAILABLE = 'conference.videobridgeNotAvailable';\\n\\n/***/ }),\\n/* 33 */\\n/***/ (function(module, exports) {\\n\\n/*! callstats.js  version = 3.27.0 2017-12-14 */\\nfunction SWPlugin(){this.attaches=[],this.signalListeners=[],this.mapFnc=null}SWPlugin.prototype={constructor:SWPlugin,add:function(a){console.log(\\\"Abstract method is called width value: \\\"+a)},remove:function(a){console.log(\\\"Abstract method is called with value: \\\"+a)},attach:function(a,b){this.attaches.push({cb:a,that:\\\"undefined\\\"==typeof b?null:b})},notify:function(a){for(var b=0;b<this.attaches.length;++b){var c=this.attaches[b];c.cb?c.cb.call(c.that,a):c.cb(a)}},addMapFnc:function(a){this.mapFnc=a},map:function(){},mapping:function(a,b){null!==this.mapFnc&&this.mapFnc(a,b)},addSignalListener:function(a,b,c){this.signalListeners.push({signalName:a,cb:b,that:\\\"undefined\\\"==typeof c?null:c})},signalize:function(a,b){for(var c=0;c<this.signalListeners.length;++c){var d=this.signalListeners[c];d.signalName===a&&null!==d.cb&&void 0!==d.cb&&(d.that?d.cb.call(d.that,b):d.cb(b))}}},module.exports=SWPlugin;\\n\\n/***/ }),\\n/* 34 */\\n/***/ (function(module, exports) {\\n\\n// shim for using process in browser\\nvar process = module.exports = {};\\n\\n// cached from whatever global is present so that test runners that stub it\\n// don't break things.  But we need to wrap it in a try catch in case it is\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\n// function because try/catches deoptimize in certain engines.\\n\\nvar cachedSetTimeout;\\nvar cachedClearTimeout;\\n\\nfunction defaultSetTimout() {\\n    throw new Error('setTimeout has not been defined');\\n}\\nfunction defaultClearTimeout () {\\n    throw new Error('clearTimeout has not been defined');\\n}\\n(function () {\\n    try {\\n        if (typeof setTimeout === 'function') {\\n            cachedSetTimeout = setTimeout;\\n        } else {\\n            cachedSetTimeout = defaultSetTimout;\\n        }\\n    } catch (e) {\\n        cachedSetTimeout = defaultSetTimout;\\n    }\\n    try {\\n        if (typeof clearTimeout === 'function') {\\n            cachedClearTimeout = clearTimeout;\\n        } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n        }\\n    } catch (e) {\\n        cachedClearTimeout = defaultClearTimeout;\\n    }\\n} ())\\nfunction runTimeout(fun) {\\n    if (cachedSetTimeout === setTimeout) {\\n        //normal enviroments in sane situations\\n        return setTimeout(fun, 0);\\n    }\\n    // if setTimeout wasn't available but was latter defined\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n        cachedSetTimeout = setTimeout;\\n        return setTimeout(fun, 0);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedSetTimeout(fun, 0);\\n    } catch(e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\n            return cachedSetTimeout.call(null, fun, 0);\\n        } catch(e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\n            return cachedSetTimeout.call(this, fun, 0);\\n        }\\n    }\\n\\n\\n}\\nfunction runClearTimeout(marker) {\\n    if (cachedClearTimeout === clearTimeout) {\\n        //normal enviroments in sane situations\\n        return clearTimeout(marker);\\n    }\\n    // if clearTimeout wasn't available but was latter defined\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n        cachedClearTimeout = clearTimeout;\\n        return clearTimeout(marker);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedClearTimeout(marker);\\n    } catch (e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\n            return cachedClearTimeout.call(null, marker);\\n        } catch (e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\n            return cachedClearTimeout.call(this, marker);\\n        }\\n    }\\n\\n\\n\\n}\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = runTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    runClearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        runTimeout(drainQueue);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\nprocess.prependListener = noop;\\nprocess.prependOnceListener = noop;\\n\\nprocess.listeners = function (name) { return [] }\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n\\n\\n/***/ }),\\n/* 35 */\\n/***/ (function(module, exports) {\\n\\nvar Resolutions = {\\n    '1080': {\\n        width: 1920,\\n        height: 1080,\\n        order: 7\\n    },\\n    'fullhd': {\\n        width: 1920,\\n        height: 1080,\\n        order: 7\\n    },\\n    '720': {\\n        width: 1280,\\n        height: 720,\\n        order: 6\\n    },\\n    'hd': {\\n        width: 1280,\\n        height: 720,\\n        order: 6\\n    },\\n    '960': {\\n        width: 960,\\n        height: 720,\\n        order: 5\\n    },\\n\\n    // 16:9 resolution first.\\n    '360': {\\n        width: 640,\\n        height: 360,\\n        order: 4\\n    },\\n    '640': {\\n        width: 640,\\n        height: 480,\\n        order: 3\\n    },\\n    'vga': {\\n        width: 640,\\n        height: 480,\\n        order: 3\\n    },\\n\\n    // 16:9 resolution first.\\n    '180': {\\n        width: 320,\\n        height: 180,\\n        order: 2\\n    },\\n    '320': {\\n        width: 320,\\n        height: 240,\\n        order: 1\\n    }\\n};\\n\\nmodule.exports = Resolutions;\\n\\n/***/ }),\\n/* 36 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return ParticipantConnectionStatus; });\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__JitsiTrackEvents__ = __webpack_require__(18);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__statistics_statistics__ = __webpack_require__(5);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/* global __filename */\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Default value of 500 milliseconds for\\n * {@link ParticipantConnectionStatus.outOfLastNTimeout}.\\n *\\n * @type {number}\\n */\\nvar DEFAULT_NOT_IN_LAST_N_TIMEOUT = 500;\\n\\n/**\\n * Default value of 2000 milliseconds for\\n * {@link ParticipantConnectionStatus.rtcMuteTimeout}.\\n *\\n * @type {number}\\n */\\nvar DEFAULT_RTC_MUTE_TIMEOUT = 2000;\\n\\n/**\\n * The time to wait a track to be restored. Track which was out of lastN\\n * should be inactive and when entering lastN it becomes restoring and when\\n * data is received from bridge it will become active, but if no data is\\n * received for some time we set status of that participant connection to\\n * interrupted.\\n * @type {number}\\n */\\nvar DEFAULT_RESTORING_TIMEOUT = 5000;\\n\\n/**\\n * Participant connection statuses.\\n *\\n * @type {{\\n *      ACTIVE: string,\\n *      INACTIVE: string,\\n *      INTERRUPTED: string,\\n *      RESTORING: string\\n * }}\\n */\\nvar ParticipantConnectionStatus = {\\n    /**\\n     * Status indicating that connection is currently active.\\n     */\\n    ACTIVE: 'active',\\n\\n    /**\\n     * Status indicating that connection is currently inactive.\\n     * Inactive means the connection was stopped on purpose from the bridge,\\n     * like exiting lastN or adaptivity decided to drop video because of not\\n     * enough bandwidth.\\n     */\\n    INACTIVE: 'inactive',\\n\\n    /**\\n     * Status indicating that connection is currently interrupted.\\n     */\\n    INTERRUPTED: 'interrupted',\\n\\n    /**\\n     * Status indicating that connection is currently restoring.\\n     */\\n    RESTORING: 'restoring'\\n};\\n\\n/**\\n * Class is responsible for emitting\\n * JitsiConferenceEvents.PARTICIPANT_CONN_STATUS_CHANGED events.\\n */\\n\\nvar ParticipantConnectionStatusHandler = function () {\\n    _createClass(ParticipantConnectionStatusHandler, null, [{\\n        key: '_getNewStateForJvbMode',\\n\\n        /* eslint-disable max-params*/\\n        /**\\n         * Calculates the new {@link ParticipantConnectionStatus} based on\\n         * the values given for some specific remote user. It is assumed that\\n         * the conference is currently in the JVB mode (in contrary to the P2P mode)\\n         * @param {boolean} isConnectionActiveByJvb true if the JVB did not get any\\n         * data from the user for the last 15 seconds.\\n         * @param {boolean} isInLastN indicates whether the user is in the last N\\n         * set. When set to false it means that JVB is not sending any video for\\n         * the user.\\n         * @param {boolean} isRestoringTimedout if true it means that the user has\\n         * been outside of last N too long to be considered\\n         * {@link ParticipantConnectionStatus.RESTORING}.\\n         * @param {boolean} isVideoMuted true if the user is video muted and we\\n         * should not expect to receive any video.\\n         * @param {boolean} isVideoTrackFrozen if the current browser support video\\n         * frozen detection then it will be set to true when the video track is\\n         * frozen. If the current browser does not support frozen detection the it's\\n         * always false.\\n         * @return {ParticipantConnectionStatus} the new connection status for\\n         * the user for whom the values above were provided.\\n         * @private\\n         */\\n        value: function _getNewStateForJvbMode(isConnectionActiveByJvb, isInLastN, isRestoringTimedout, isVideoMuted, isVideoTrackFrozen) {\\n            if (!isConnectionActiveByJvb) {\\n                // when there is a connection problem signaled from jvb\\n                // it means no media was flowing for at least 15secs, so both audio\\n                // and video are most likely interrupted\\n                return ParticipantConnectionStatus.INTERRUPTED;\\n            } else if (isVideoMuted) {\\n                // If the connection is active according to JVB and the user is\\n                // video muted there is no way for the connection to be inactive,\\n                // because the detection logic below only makes sense for video.\\n                return ParticipantConnectionStatus.ACTIVE;\\n            }\\n\\n            // Logic when isVideoTrackFrozen is supported\\n            if (__WEBPACK_IMPORTED_MODULE_4__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isVideoMuteOnConnInterruptedSupported()) {\\n                if (!isVideoTrackFrozen) {\\n                    // If the video is playing we're good\\n                    return ParticipantConnectionStatus.ACTIVE;\\n                } else if (isInLastN) {\\n                    return isRestoringTimedout ? ParticipantConnectionStatus.INTERRUPTED : ParticipantConnectionStatus.RESTORING;\\n                }\\n\\n                return ParticipantConnectionStatus.INACTIVE;\\n            }\\n\\n            // Because this browser is incapable of detecting frozen video we must\\n            // rely on the lastN value\\n            return isInLastN ? ParticipantConnectionStatus.ACTIVE : ParticipantConnectionStatus.INACTIVE;\\n        }\\n\\n        /* eslint-enable max-params*/\\n\\n        /**\\n         * In P2P mode we don't care about any values coming from the JVB and\\n         * the connection status can be only active or interrupted.\\n         * @param {boolean} isVideoMuted the user if video muted\\n         * @param {boolean} isVideoTrackFrozen true if the video track for\\n         * the remote user is currently frozen. If the current browser does not\\n         * support video frozen detection then it's always false.\\n         * @return {ParticipantConnectionStatus}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_getNewStateForP2PMode',\\n        value: function _getNewStateForP2PMode(isVideoMuted, isVideoTrackFrozen) {\\n            if (!__WEBPACK_IMPORTED_MODULE_4__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isVideoMuteOnConnInterruptedSupported()) {\\n                // There's no way to detect problems in P2P when there's no video\\n                // track frozen detection...\\n                return ParticipantConnectionStatus.ACTIVE;\\n            }\\n\\n            return isVideoMuted || !isVideoTrackFrozen ? ParticipantConnectionStatus.ACTIVE : ParticipantConnectionStatus.INTERRUPTED;\\n        }\\n\\n        /**\\n         * Creates new instance of <tt>ParticipantConnectionStatus</tt>.\\n         *\\n         * @constructor\\n         * @param {RTC} rtc the RTC service instance\\n         * @param {JitsiConference} conference parent conference instance\\n         * @param {Object} options\\n         * @param {number} [options.rtcMuteTimeout=2000] custom value for\\n         * {@link ParticipantConnectionStatus.rtcMuteTimeout}.\\n         * @param {number} [options.outOfLastNTimeout=500] custom value for\\n         * {@link ParticipantConnectionStatus.outOfLastNTimeout}.\\n         */\\n\\n    }]);\\n\\n    function ParticipantConnectionStatusHandler(rtc, conference, options) {\\n        _classCallCheck(this, ParticipantConnectionStatusHandler);\\n\\n        this.rtc = rtc;\\n        this.conference = conference;\\n\\n        /**\\n         * A map of the \\\"endpoint ID\\\"(which corresponds to the resource part\\n         * of MUC JID(nickname)) to the timeout callback IDs scheduled using\\n         * window.setTimeout.\\n         * @type {Object.<string, number>}\\n         */\\n        this.trackTimers = {};\\n\\n        /**\\n         * This map holds the endpoint connection status received from the JVB\\n         * (as it might be different than the one stored in JitsiParticipant).\\n         * Required for getting back in sync when remote video track is removed.\\n         * @type {Object.<string, boolean>}\\n         */\\n        this.connStatusFromJvb = {};\\n\\n        /**\\n         * If video track frozen detection through RTC mute event is supported,\\n         * we wait some time until video track is considered frozen. But because\\n         * when the user falls out of last N it is expected for the video to\\n         * freeze this timeout must be significantly reduced in \\\"out of last N\\\"\\n         * case.\\n         *\\n         * Basically this value is used instead of {@link rtcMuteTimeout} when\\n         * user is not in last N.\\n         * @type {number}\\n         */\\n        this.outOfLastNTimeout = typeof options.outOfLastNTimeout === 'number' ? options.outOfLastNTimeout : DEFAULT_NOT_IN_LAST_N_TIMEOUT;\\n\\n        /**\\n         * How long we're going to wait after the RTC video track muted event\\n         * for the corresponding signalling mute event, before the connection\\n         * interrupted is fired. The default value is\\n         * {@link DEFAULT_RTC_MUTE_TIMEOUT}.\\n         *\\n         * @type {number} amount of time in milliseconds\\n         */\\n        this.rtcMuteTimeout = typeof options.rtcMuteTimeout === 'number' ? options.rtcMuteTimeout : DEFAULT_RTC_MUTE_TIMEOUT;\\n\\n        /**\\n         * This map holds a timestamp indicating  when participant's video track\\n         * was RTC muted (it is assumed that each participant can have only 1\\n         * video track at a time). The purpose of storing the timestamp is to\\n         * avoid the transition to disconnected status in case of legitimate\\n         * video mute operation where the signalling video muted event can\\n         * arrive shortly after RTC muted event.\\n         *\\n         * The key is participant's ID which is the same as endpoint id in\\n         * the Colibri conference allocated on the JVB.\\n         *\\n         * The value is a timestamp measured in milliseconds obtained with\\n         * <tt>Date.now()</tt>.\\n         *\\n         * FIXME merge this logic with NO_DATA_FROM_SOURCE event\\n         *       implemented in JitsiLocalTrack by extending the event to\\n         *       the remote track and allowing to set different timeout for\\n         *       local and remote tracks.\\n         *\\n         * @type {Object.<string, number>}\\n         */\\n        this.rtcMutedTimestamp = {};\\n        logger.info('RtcMuteTimeout set to: ' + this.rtcMuteTimeout);\\n\\n        /**\\n         * This map holds the timestamps indicating when participant's video\\n         * entered lastN set. Participants entering lastN will have connection\\n         * status restoring and when we start receiving video will become\\n         * active, but if video is not received for certain time\\n         * {@link DEFAULT_RESTORING_TIMEOUT} that participant connection status\\n         * will become interrupted.\\n         *\\n         * @type {Map<string, number>}\\n         */\\n        this.enteredLastNTimestamp = new Map();\\n\\n        /**\\n         * A map of the \\\"endpoint ID\\\"(which corresponds to the resource part\\n         * of MUC JID(nickname)) to the restoring timeout callback IDs\\n         * scheduled using window.setTimeout.\\n         *\\n         * @type {Map<string, number>}\\n         */\\n        this.restoringTimers = new Map();\\n    }\\n\\n    /**\\n     * Gets the video frozen timeout for given user.\\n     * @param {string} id endpoint/participant ID\\n     * @return {number} how long are we going to wait since RTC video muted\\n     * even, before a video track is considered frozen.\\n     * @private\\n     */\\n\\n\\n    _createClass(ParticipantConnectionStatusHandler, [{\\n        key: '_getVideoFrozenTimeout',\\n        value: function _getVideoFrozenTimeout(id) {\\n            return this.rtc.isInLastN(id) ? this.rtcMuteTimeout : this.outOfLastNTimeout;\\n        }\\n\\n        /**\\n         * Initializes <tt>ParticipantConnectionStatus</tt> and bind required event\\n         * listeners.\\n         */\\n\\n    }, {\\n        key: 'init',\\n        value: function init() {\\n\\n            this._onEndpointConnStatusChanged = this.onEndpointConnStatusChanged.bind(this);\\n\\n            this.rtc.addListener(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default.a.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged);\\n\\n            // Handles P2P status changes\\n            this._onP2PStatus = this.refreshConnectionStatusForAll.bind(this);\\n            this.conference.on(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"P2P_STATUS\\\"], this._onP2PStatus);\\n\\n            // On some browsers MediaStreamTrack trigger \\\"onmute\\\"/\\\"onunmute\\\"\\n            // events for video type tracks when they stop receiving data which is\\n            // often a sign that remote user is having connectivity issues\\n            if (__WEBPACK_IMPORTED_MODULE_4__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isVideoMuteOnConnInterruptedSupported()) {\\n\\n                this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this);\\n                this.rtc.addListener(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default.a.REMOTE_TRACK_MUTE, this._onTrackRtcMuted);\\n\\n                this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this);\\n                this.rtc.addListener(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default.a.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted);\\n\\n                // Track added/removed listeners are used to bind \\\"mute\\\"/\\\"unmute\\\"\\n                // event handlers\\n                this._onRemoteTrackAdded = this.onRemoteTrackAdded.bind(this);\\n                this.conference.on(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"TRACK_ADDED\\\"], this._onRemoteTrackAdded);\\n\\n                this._onRemoteTrackRemoved = this.onRemoteTrackRemoved.bind(this);\\n                this.conference.on(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"TRACK_REMOVED\\\"], this._onRemoteTrackRemoved);\\n\\n                // Listened which will be bound to JitsiRemoteTrack to listen for\\n                // signalling mute/unmute events.\\n                this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this);\\n            }\\n\\n            this._onLastNChanged = this._onLastNChanged.bind(this);\\n            this.conference.on(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"LAST_N_ENDPOINTS_CHANGED\\\"], this._onLastNChanged);\\n\\n            this._onLastNValueChanged = this.refreshConnectionStatusForAll.bind(this);\\n            this.rtc.on(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default.a.LASTN_VALUE_CHANGED, this._onLastNValueChanged);\\n        }\\n\\n        /**\\n         * Removes all event listeners and disposes of all resources held by this\\n         * instance.\\n         */\\n\\n    }, {\\n        key: 'dispose',\\n        value: function dispose() {\\n\\n            this.rtc.removeListener(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default.a.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged);\\n\\n            if (__WEBPACK_IMPORTED_MODULE_4__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isVideoMuteOnConnInterruptedSupported()) {\\n                this.rtc.removeListener(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default.a.REMOTE_TRACK_MUTE, this._onTrackRtcMuted);\\n                this.rtc.removeListener(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default.a.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted);\\n\\n                this.conference.off(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"TRACK_ADDED\\\"], this._onRemoteTrackAdded);\\n                this.conference.off(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"TRACK_REMOVED\\\"], this._onRemoteTrackRemoved);\\n            }\\n\\n            this.conference.off(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"LAST_N_ENDPOINTS_CHANGED\\\"], this._onLastNChanged);\\n\\n            this.rtc.removeListener(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default.a.LASTN_VALUE_CHANGED, this._onLastNValueChanged);\\n\\n            this.conference.off(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"P2P_STATUS\\\"], this._onP2PStatus);\\n\\n            var participantIds = Object.keys(this.trackTimers);\\n\\n            var _iteratorNormalCompletion = true;\\n            var _didIteratorError = false;\\n            var _iteratorError = undefined;\\n\\n            try {\\n                for (var _iterator = participantIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                    var participantId = _step.value;\\n\\n                    this.clearTimeout(participantId);\\n                    this.clearRtcMutedTimestamp(participantId);\\n                }\\n\\n                // Clear RTC connection status cache\\n            } catch (err) {\\n                _didIteratorError = true;\\n                _iteratorError = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion && _iterator.return) {\\n                        _iterator.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError) {\\n                        throw _iteratorError;\\n                    }\\n                }\\n            }\\n\\n            this.connStatusFromJvb = {};\\n        }\\n\\n        /**\\n         * Handles RTCEvents.ENDPOINT_CONN_STATUS_CHANGED triggered when we receive\\n         * notification over the data channel from the bridge about endpoint's\\n         * connection status update.\\n         * @param {string} endpointId the endpoint ID(MUC nickname/resource JID)\\n         * @param {boolean} isActive true if the connection is OK or false otherwise\\n         */\\n\\n    }, {\\n        key: 'onEndpointConnStatusChanged',\\n        value: function onEndpointConnStatusChanged(endpointId, isActive) {\\n\\n            logger.debug('Detector RTCEvents.ENDPOINT_CONN_STATUS_CHANGED(' + Date.now() + '): ' + endpointId + ': ' + isActive);\\n\\n            // Filter out events for the local JID for now\\n            if (endpointId !== this.conference.myUserId()) {\\n                // Store the status received over the data channels\\n                this.connStatusFromJvb[endpointId] = isActive;\\n                this.figureOutConnectionStatus(endpointId);\\n            }\\n        }\\n\\n        /**\\n         * Changes connection status.\\n         * @param {JitsiParticipant} participant\\n         * @param newStatus\\n         */\\n\\n    }, {\\n        key: '_changeConnectionStatus',\\n        value: function _changeConnectionStatus(participant, newStatus) {\\n            if (participant.getConnectionStatus() !== newStatus) {\\n\\n                var endpointId = participant.getId();\\n\\n                participant._setConnectionStatus(newStatus);\\n\\n                logger.debug('Emit endpoint conn status(' + Date.now() + ') ' + endpointId + ': ' + newStatus);\\n\\n                // Log the event on CallStats\\n                __WEBPACK_IMPORTED_MODULE_6__statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify({\\n                    id: 'peer.conn.status',\\n                    participant: endpointId,\\n                    status: newStatus\\n                }));\\n\\n                this.conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"PARTICIPANT_CONN_STATUS_CHANGED\\\"], endpointId, newStatus);\\n            }\\n        }\\n\\n        /**\\n         * Reset the postponed \\\"connection interrupted\\\" event which was previously\\n         * scheduled as a timeout on RTC 'onmute' event.\\n         *\\n         * @param {string} participantId the participant for which the \\\"connection\\n         * interrupted\\\" timeout was scheduled\\n         */\\n\\n    }, {\\n        key: 'clearTimeout',\\n        value: function clearTimeout(participantId) {\\n            if (this.trackTimers[participantId]) {\\n                window.clearTimeout(this.trackTimers[participantId]);\\n                this.trackTimers[participantId] = null;\\n            }\\n        }\\n\\n        /**\\n         * Clears the timestamp of the RTC muted event for participant's video track\\n         * @param {string} participantId the id of the conference participant which\\n         * is the same as the Colibri endpoint ID of the video channel allocated for\\n         * the user on the videobridge.\\n         */\\n\\n    }, {\\n        key: 'clearRtcMutedTimestamp',\\n        value: function clearRtcMutedTimestamp(participantId) {\\n            this.rtcMutedTimestamp[participantId] = null;\\n        }\\n\\n        /**\\n         * Bind signalling mute event listeners for video {JitsiRemoteTrack} when\\n         * a new one is added to the conference.\\n         *\\n         * @param {JitsiTrack} remoteTrack the {JitsiTrack} which is being added to\\n         * the conference.\\n         */\\n\\n    }, {\\n        key: 'onRemoteTrackAdded',\\n        value: function onRemoteTrackAdded(remoteTrack) {\\n            if (!remoteTrack.isLocal() && remoteTrack.getType() === __WEBPACK_IMPORTED_MODULE_3__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]) {\\n\\n                logger.debug('Detector on remote track added for: ' + remoteTrack.getParticipantId());\\n\\n                remoteTrack.on(__WEBPACK_IMPORTED_MODULE_2__JitsiTrackEvents__[\\\"TRACK_MUTE_CHANGED\\\"], this._onSignallingMuteChanged);\\n            }\\n        }\\n\\n        /**\\n         * Removes all event listeners bound to the remote video track and clears\\n         * any related timeouts.\\n         *\\n         * @param {JitsiRemoteTrack} remoteTrack the remote track which is being\\n         * removed from the conference.\\n         */\\n\\n    }, {\\n        key: 'onRemoteTrackRemoved',\\n        value: function onRemoteTrackRemoved(remoteTrack) {\\n            if (!remoteTrack.isLocal() && remoteTrack.getType() === __WEBPACK_IMPORTED_MODULE_3__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]) {\\n\\n                var endpointId = remoteTrack.getParticipantId();\\n\\n                logger.debug('Detector on remote track removed: ' + endpointId);\\n\\n                remoteTrack.off(__WEBPACK_IMPORTED_MODULE_2__JitsiTrackEvents__[\\\"TRACK_MUTE_CHANGED\\\"], this._onSignallingMuteChanged);\\n\\n                this.clearTimeout(endpointId);\\n                this.clearRtcMutedTimestamp(endpointId);\\n\\n                this.figureOutConnectionStatus(endpointId);\\n            }\\n        }\\n\\n        /**\\n         * Checks if given participant's video is considered frozen.\\n         * @param {JitsiParticipant} participant\\n         * @return {boolean} <tt>true</tt> if the video has frozen for given\\n         * participant or <tt>false</tt> when it's either not considered frozen\\n         * (yet) or if freeze detection is not supported by the current browser.\\n         *\\n         * FIXME merge this logic with NO_DATA_FROM_SOURCE event\\n         *       implemented in JitsiLocalTrack by extending the event to\\n         *       the remote track and allowing to set different timeout for\\n         *       local and remote tracks.\\n         *\\n         */\\n\\n    }, {\\n        key: 'isVideoTrackFrozen',\\n        value: function isVideoTrackFrozen(participant) {\\n            if (!__WEBPACK_IMPORTED_MODULE_4__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isVideoMuteOnConnInterruptedSupported()) {\\n                return false;\\n            }\\n\\n            var id = participant.getId();\\n            var hasAnyVideoRTCMuted = participant.hasAnyVideoTrackWebRTCMuted();\\n            var rtcMutedTimestamp = this.rtcMutedTimestamp[id];\\n            var timeout = this._getVideoFrozenTimeout(id);\\n\\n            return hasAnyVideoRTCMuted && typeof rtcMutedTimestamp === 'number' && Date.now() - rtcMutedTimestamp >= timeout;\\n        }\\n\\n        /**\\n         * Goes over every participant and updates connectivity status.\\n         * Should be called when a parameter which affects all of the participants\\n         * is changed (P2P for example).\\n         */\\n\\n    }, {\\n        key: 'refreshConnectionStatusForAll',\\n        value: function refreshConnectionStatusForAll() {\\n            var participants = this.conference.getParticipants();\\n\\n            var _iteratorNormalCompletion2 = true;\\n            var _didIteratorError2 = false;\\n            var _iteratorError2 = undefined;\\n\\n            try {\\n                for (var _iterator2 = participants[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                    var participant = _step2.value;\\n\\n                    this.figureOutConnectionStatus(participant.getId());\\n                }\\n            } catch (err) {\\n                _didIteratorError2 = true;\\n                _iteratorError2 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                        _iterator2.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError2) {\\n                        throw _iteratorError2;\\n                    }\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Figures out (and updates) the current connectivity status for\\n         * the participant identified by the given id.\\n         *\\n         * @param {string} id the participant's id (MUC nickname or Colibri endpoint\\n         * ID).\\n         */\\n\\n    }, {\\n        key: 'figureOutConnectionStatus',\\n        value: function figureOutConnectionStatus(id) {\\n            var participant = this.conference.getParticipantById(id);\\n\\n            if (!participant) {\\n                // Probably the participant is no longer in the conference\\n                // (at the time of writing this code, participant is\\n                // detached from the conference and TRACK_REMOVED events are\\n                // fired),\\n                // so we don't care, but let's print the warning for\\n                // debugging purpose\\n                logger.warn('figure out conn status - no participant for: ' + id);\\n\\n                return;\\n            }\\n\\n            var inP2PMode = this.conference.isP2PActive();\\n            var isRestoringTimedOut = this._isRestoringTimedout(id);\\n            var audioOnlyMode = this.rtc.getLastN() === 0;\\n\\n            // NOTE Overriding videoMuted to true for audioOnlyMode should disable\\n            // any detection based on video playback or the last N.\\n            var isVideoMuted = participant.isVideoMuted() || audioOnlyMode;\\n            var isVideoTrackFrozen = this.isVideoTrackFrozen(participant);\\n            var isInLastN = this.rtc.isInLastN(id);\\n            var isConnActiveByJvb = this.connStatusFromJvb[id];\\n\\n            if (typeof isConnActiveByJvb !== 'boolean') {\\n                // If no status was received from the JVB it means that it's active\\n                // (the bridge does not send notification unless there is a problem)\\n                logger.debug('Assuming connection active by JVB - no notification');\\n                isConnActiveByJvb = true;\\n            }\\n\\n            var newState = inP2PMode ? ParticipantConnectionStatusHandler._getNewStateForP2PMode(isVideoMuted, isVideoTrackFrozen) : ParticipantConnectionStatusHandler._getNewStateForJvbMode(isConnActiveByJvb, isInLastN, isRestoringTimedOut, isVideoMuted, isVideoTrackFrozen);\\n\\n            // if the new state is not restoring clear timers and timestamps\\n            // that we use to track the restoring state\\n            if (newState !== ParticipantConnectionStatus.RESTORING) {\\n                this._clearRestoringTimer(id);\\n            }\\n\\n            logger.debug('Figure out conn status for ' + id + ', is video muted: ' + isVideoMuted + ' is active(jvb): ' + isConnActiveByJvb + ' video track frozen: ' + isVideoTrackFrozen + ' p2p mode: ' + inP2PMode + ' is in last N: ' + isInLastN + ' currentStatus => newStatus: ' + participant.getConnectionStatus() + ' => ' + newState);\\n\\n            this._changeConnectionStatus(participant, newState);\\n        }\\n\\n        /**\\n         * On change in Last N set check all leaving and entering participants to\\n         * change their corresponding statuses.\\n         *\\n         * @param {Array<string>} leavingLastN array of ids leaving lastN.\\n         * @param {Array<string>} enteringLastN array of ids entering lastN.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_onLastNChanged',\\n        value: function _onLastNChanged() {\\n            var leavingLastN = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n            var enteringLastN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n\\n            var now = Date.now();\\n\\n            logger.debug('leaving/entering lastN', leavingLastN, enteringLastN, now);\\n\\n            var _iteratorNormalCompletion3 = true;\\n            var _didIteratorError3 = false;\\n            var _iteratorError3 = undefined;\\n\\n            try {\\n                for (var _iterator3 = leavingLastN[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n                    var id = _step3.value;\\n\\n                    this.enteredLastNTimestamp.delete(id);\\n                    this._clearRestoringTimer(id);\\n                    this.figureOutConnectionStatus(id);\\n                }\\n            } catch (err) {\\n                _didIteratorError3 = true;\\n                _iteratorError3 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                        _iterator3.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError3) {\\n                        throw _iteratorError3;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion4 = true;\\n            var _didIteratorError4 = false;\\n            var _iteratorError4 = undefined;\\n\\n            try {\\n                for (var _iterator4 = enteringLastN[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n                    var _id = _step4.value;\\n\\n                    // store the timestamp this id is entering lastN\\n                    this.enteredLastNTimestamp.set(_id, now);\\n                    this.figureOutConnectionStatus(_id);\\n                }\\n            } catch (err) {\\n                _didIteratorError4 = true;\\n                _iteratorError4 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n                        _iterator4.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError4) {\\n                        throw _iteratorError4;\\n                    }\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Clears the restoring timer for participant's video track and the\\n         * timestamp for entering lastN.\\n         *\\n         * @param {string} participantId the id of the conference participant which\\n         * is the same as the Colibri endpoint ID of the video channel allocated for\\n         * the user on the videobridge.\\n         */\\n\\n    }, {\\n        key: '_clearRestoringTimer',\\n        value: function _clearRestoringTimer(participantId) {\\n            var rTimer = this.restoringTimers.get(participantId);\\n\\n            if (rTimer) {\\n                clearTimeout(rTimer);\\n                this.restoringTimers.delete(participantId);\\n            }\\n        }\\n\\n        /**\\n         * Checks whether a track had stayed enough in restoring state, compares\\n         * current time and the time the track entered in lastN. If it hasn't\\n         * timedout and there is no timer added, add new timer in order to give it\\n         * more time to become active or mark it as interrupted on next check.\\n         *\\n         * @param {string} participantId the id of the conference participant which\\n         * is the same as the Colibri endpoint ID of the video channel allocated for\\n         * the user on the videobridge.\\n         * @returns {boolean} <tt>true</tt> if the track was in restoring state\\n         * more than the timeout ({@link DEFAULT_RESTORING_TIMEOUT}.) in order to\\n         * set its status to interrupted.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_isRestoringTimedout',\\n        value: function _isRestoringTimedout(participantId) {\\n            var _this = this;\\n\\n            var enteredLastNTimestamp = this.enteredLastNTimestamp.get(participantId);\\n\\n            if (enteredLastNTimestamp && Date.now() - enteredLastNTimestamp >= DEFAULT_RESTORING_TIMEOUT) {\\n                return true;\\n            }\\n\\n            // still haven't reached timeout, if there is no timer scheduled,\\n            // schedule one so we can track the restoring state and change it after\\n            // reaching the timeout\\n            var rTimer = this.restoringTimers.get(participantId);\\n\\n            if (!rTimer) {\\n                this.restoringTimers.set(participantId, setTimeout(function () {\\n                    return _this.figureOutConnectionStatus(participantId);\\n                }, DEFAULT_RESTORING_TIMEOUT));\\n            }\\n\\n            return false;\\n        }\\n\\n        /**\\n         * Handles RTC 'onmute' event for the video track.\\n         *\\n         * @param {JitsiRemoteTrack} track the video track for which 'onmute' event\\n         * will be processed.\\n         */\\n\\n    }, {\\n        key: 'onTrackRtcMuted',\\n        value: function onTrackRtcMuted(track) {\\n            var _this2 = this;\\n\\n            var participantId = track.getParticipantId();\\n            var participant = this.conference.getParticipantById(participantId);\\n\\n            logger.debug('Detector track RTC muted: ' + participantId, Date.now());\\n            if (!participant) {\\n                logger.error('No participant for id: ' + participantId);\\n\\n                return;\\n            }\\n            this.rtcMutedTimestamp[participantId] = Date.now();\\n            if (!participant.isVideoMuted()) {\\n                // If the user is not muted according to the signalling we'll give\\n                // it some time, before the connection interrupted event is\\n                // triggered.\\n                this.clearTimeout(participantId);\\n\\n                // The timeout is reduced when user is not in the last N\\n                var timeout = this._getVideoFrozenTimeout(participantId);\\n\\n                this.trackTimers[participantId] = window.setTimeout(function () {\\n                    logger.debug('Set RTC mute timeout for: ' + participantId + '                     of ' + timeout + ' ms');\\n                    _this2.clearTimeout(participantId);\\n                    _this2.figureOutConnectionStatus(participantId);\\n                }, timeout);\\n            }\\n        }\\n\\n        /**\\n         * Handles RTC 'onunmute' event for the video track.\\n         *\\n         * @param {JitsiRemoteTrack} track the video track for which 'onunmute'\\n         * event will be processed.\\n         */\\n\\n    }, {\\n        key: 'onTrackRtcUnmuted',\\n        value: function onTrackRtcUnmuted(track) {\\n            var participantId = track.getParticipantId();\\n\\n            logger.debug('Detector track RTC unmuted: ' + participantId, Date.now());\\n\\n            this.clearTimeout(participantId);\\n            this.clearRtcMutedTimestamp(participantId);\\n\\n            this.figureOutConnectionStatus(participantId);\\n        }\\n\\n        /**\\n         * Here the signalling \\\"mute\\\"/\\\"unmute\\\" events are processed.\\n         *\\n         * @param {JitsiRemoteTrack} track the remote video track for which\\n         * the signalling mute/unmute event will be processed.\\n         */\\n\\n    }, {\\n        key: 'onSignallingMuteChanged',\\n        value: function onSignallingMuteChanged(track) {\\n            var participantId = track.getParticipantId();\\n\\n            logger.debug('Detector on track signalling mute changed: ' + participantId, track.isMuted());\\n\\n            this.figureOutConnectionStatus(participantId);\\n        }\\n    }]);\\n\\n    return ParticipantConnectionStatusHandler;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"b\\\"] = (ParticipantConnectionStatusHandler);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/connectivity/ParticipantConnectionStatus.js\\\"))\\n\\n/***/ }),\\n/* 37 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* WEBPACK VAR INJECTION */(function(__filename) {var require;var require;/*! adapterjs - v0.14.0 - 2016-10-03 */\\nvar console = __webpack_require__(0).getLogger(__filename);\\n// Adapter's interface.\\nvar AdapterJS = AdapterJS || {};\\n\\n// Browserify compatibility\\nif(true) {\\n  module.exports = AdapterJS;\\n}\\n\\nAdapterJS.options = AdapterJS.options || {};\\n\\n// uncomment to get virtual webcams\\n// AdapterJS.options.getAllCams = true;\\n\\n// uncomment to prevent the install prompt when the plugin in not yet installed\\n// AdapterJS.options.hidePluginInstallPrompt = true;\\n\\n// AdapterJS version\\nAdapterJS.VERSION = '0.14.0';\\n\\n// This function will be called when the WebRTC API is ready to be used\\n// Whether it is the native implementation (Chrome, Firefox, Opera) or\\n// the plugin\\n// You may Override this function to synchronise the start of your application\\n// with the WebRTC API being ready.\\n// If you decide not to override use this synchronisation, it may result in\\n// an extensive CPU usage on the plugin start (once per tab loaded)\\n// Params:\\n//    - isUsingPlugin: true is the WebRTC plugin is being used, false otherwise\\n//\\nAdapterJS.onwebrtcready = AdapterJS.onwebrtcready || function(isUsingPlugin) {\\n  // The WebRTC API is ready.\\n  // Override me and do whatever you want here\\n};\\n\\n// New interface to store multiple callbacks, private\\nAdapterJS._onwebrtcreadies = [];\\n\\n// Sets a callback function to be called when the WebRTC interface is ready.\\n// The first argument is the function to callback.\\\\\\n// Throws an error if the first argument is not a function\\nAdapterJS.webRTCReady = function (callback) {\\n  if (typeof callback !== 'function') {\\n    throw new Error('Callback provided is not a function');\\n  }\\n\\n  if (true === AdapterJS.onwebrtcreadyDone) {\\n    // All WebRTC interfaces are ready, just call the callback\\n    callback(null !== AdapterJS.WebRTCPlugin.plugin);\\n  } else {\\n    // will be triggered automatically when your browser/plugin is ready.\\n    AdapterJS._onwebrtcreadies.push(callback);\\n  }\\n};\\n\\n// Plugin namespace\\nAdapterJS.WebRTCPlugin = AdapterJS.WebRTCPlugin || {};\\n\\n// The object to store plugin information\\n/* jshint ignore:start */\\nAdapterJS.WebRTCPlugin.pluginInfo = AdapterJS.WebRTCPlugin.pluginInfo || {\\n  prefix : 'Tem',\\n  plugName : 'TemWebRTCPlugin',\\n  pluginId : 'plugin0',\\n  type : 'application/x-temwebrtcplugin',\\n  onload : '__TemWebRTCReady0',\\n  portalLink : 'http://skylink.io/plugin/',\\n  downloadLink : null, //set below\\n  companyName: 'Temasys',\\n  downloadLinks : {\\n    mac: 'http://bit.ly/webrtcpluginpkg',\\n    win: 'http://bit.ly/webrtcpluginmsi'\\n  }\\n};\\nif(typeof AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks !== \\\"undefined\\\" && AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks !== null) {\\n  if(!!navigator.platform.match(/^Mac/i)) {\\n    AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks.mac;\\n  }\\n  else if(!!navigator.platform.match(/^Win/i)) {\\n    AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks.win;\\n  }\\n}\\n\\n/* jshint ignore:end */\\n\\nAdapterJS.WebRTCPlugin.TAGS = {\\n  NONE  : 'none',\\n  AUDIO : 'audio',\\n  VIDEO : 'video'\\n};\\n\\n// Unique identifier of each opened page\\nAdapterJS.WebRTCPlugin.pageId = Math.random().toString(36).slice(2);\\n\\n// Use this whenever you want to call the plugin.\\nAdapterJS.WebRTCPlugin.plugin = null;\\n\\n// Set log level for the plugin once it is ready.\\n// The different values are\\n// This is an asynchronous function that will run when the plugin is ready\\nAdapterJS.WebRTCPlugin.setLogLevel = null;\\n\\n// Defines webrtc's JS interface according to the plugin's implementation.\\n// Define plugin Browsers as WebRTC Interface.\\nAdapterJS.WebRTCPlugin.defineWebRTCInterface = null;\\n\\n// This function detects whether or not a plugin is installed.\\n// Checks if Not IE (firefox, for example), else if it's IE,\\n// we're running IE and do something. If not it is not supported.\\nAdapterJS.WebRTCPlugin.isPluginInstalled = null;\\n\\n // Lets adapter.js wait until the the document is ready before injecting the plugin\\nAdapterJS.WebRTCPlugin.pluginInjectionInterval = null;\\n\\n// Inject the HTML DOM object element into the page.\\nAdapterJS.WebRTCPlugin.injectPlugin = null;\\n\\n// States of readiness that the plugin goes through when\\n// being injected and stated\\nAdapterJS.WebRTCPlugin.PLUGIN_STATES = {\\n  NONE : 0,           // no plugin use\\n  INITIALIZING : 1,   // Detected need for plugin\\n  INJECTING : 2,      // Injecting plugin\\n  INJECTED: 3,        // Plugin element injected but not usable yet\\n  READY: 4            // Plugin ready to be used\\n};\\n\\n// Current state of the plugin. You cannot use the plugin before this is\\n// equal to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY\\nAdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.NONE;\\n\\n// True is AdapterJS.onwebrtcready was already called, false otherwise\\n// Used to make sure AdapterJS.onwebrtcready is only called once\\nAdapterJS.onwebrtcreadyDone = false;\\n\\n// Log levels for the plugin.\\n// To be set by calling AdapterJS.WebRTCPlugin.setLogLevel\\n/*\\nLog outputs are prefixed in some cases.\\n  INFO: Information reported by the plugin.\\n  ERROR: Errors originating from within the plugin.\\n  WEBRTC: Error originating from within the libWebRTC library\\n*/\\n// From the least verbose to the most verbose\\nAdapterJS.WebRTCPlugin.PLUGIN_LOG_LEVELS = {\\n  NONE : 'NONE',\\n  ERROR : 'ERROR',\\n  WARNING : 'WARNING',\\n  INFO: 'INFO',\\n  VERBOSE: 'VERBOSE',\\n  SENSITIVE: 'SENSITIVE'\\n};\\n\\n// Does a waiting check before proceeding to load the plugin.\\nAdapterJS.WebRTCPlugin.WaitForPluginReady = null;\\n\\n// This methid will use an interval to wait for the plugin to be ready.\\nAdapterJS.WebRTCPlugin.callWhenPluginReady = null;\\n\\n// !!!! WARNING: DO NOT OVERRIDE THIS FUNCTION. !!!\\n// This function will be called when plugin is ready. It sends necessary\\n// details to the plugin.\\n// The function will wait for the document to be ready and the set the\\n// plugin state to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY,\\n// indicating that it can start being requested.\\n// This function is not in the IE/Safari condition brackets so that\\n// TemPluginLoaded function might be called on Chrome/Firefox.\\n// This function is the only private function that is not encapsulated to\\n// allow the plugin method to be called.\\n__TemWebRTCReady0 = function () {\\n  if (document.readyState === 'complete') {\\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;\\n    AdapterJS.maybeThroughWebRTCReady();\\n  } else {\\n    var timer = setInterval(function () {\\n      if (document.readyState === 'complete') {\\n        // TODO: update comments, we wait for the document to be ready\\n        clearInterval(timer);\\n        AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;\\n        AdapterJS.maybeThroughWebRTCReady();\\n      }\\n    }, 100);\\n  }\\n};\\n\\nAdapterJS.maybeThroughWebRTCReady = function() {\\n  if (!AdapterJS.onwebrtcreadyDone) {\\n    AdapterJS.onwebrtcreadyDone = true;\\n\\n    // If new interface for multiple callbacks used\\n    if (AdapterJS._onwebrtcreadies.length) {\\n      AdapterJS._onwebrtcreadies.forEach(function (callback) {\\n        if (typeof(callback) === 'function') {\\n          callback(AdapterJS.WebRTCPlugin.plugin !== null);\\n        }\\n      });\\n    // Else if no callbacks on new interface assuming user used old(deprecated) way to set callback through AdapterJS.onwebrtcready = ...\\n    } else if (typeof(AdapterJS.onwebrtcready) === 'function') {\\n      AdapterJS.onwebrtcready(AdapterJS.WebRTCPlugin.plugin !== null);\\n    }\\n  }\\n};\\n\\n// Text namespace\\nAdapterJS.TEXT = {\\n  PLUGIN: {\\n    REQUIRE_INSTALLATION: 'This website requires you to install a WebRTC-enabling plugin ' +\\n      'to work on this browser.',\\n    NOT_SUPPORTED: 'Your browser does not support WebRTC.',\\n    BUTTON: 'Install Now'\\n  },\\n  REFRESH: {\\n    REQUIRE_REFRESH: 'Please refresh page',\\n    BUTTON: 'Refresh Page'\\n  }\\n};\\n\\n// The result of ice connection states.\\n// - starting: Ice connection is starting.\\n// - checking: Ice connection is checking.\\n// - connected Ice connection is connected.\\n// - completed Ice connection is connected.\\n// - done Ice connection has been completed.\\n// - disconnected Ice connection has been disconnected.\\n// - failed Ice connection has failed.\\n// - closed Ice connection is closed.\\nAdapterJS._iceConnectionStates = {\\n  starting : 'starting',\\n  checking : 'checking',\\n  connected : 'connected',\\n  completed : 'connected',\\n  done : 'completed',\\n  disconnected : 'disconnected',\\n  failed : 'failed',\\n  closed : 'closed'\\n};\\n\\n//The IceConnection states that has been fired for each peer.\\nAdapterJS._iceConnectionFiredStates = [];\\n\\n\\n// Check if WebRTC Interface is defined.\\nAdapterJS.isDefined = null;\\n\\n// This function helps to retrieve the webrtc detected browser information.\\n// This sets:\\n// - webrtcDetectedBrowser: The browser agent name.\\n// - webrtcDetectedVersion: The browser version.\\n// - webrtcMinimumVersion: The minimum browser version still supported by AJS.\\n// - webrtcDetectedType: The types of webRTC support.\\n//   - 'moz': Mozilla implementation of webRTC.\\n//   - 'webkit': WebKit implementation of webRTC.\\n//   - 'plugin': Using the plugin implementation.\\nAdapterJS.parseWebrtcDetectedBrowser = function () {\\n  var hasMatch = null;\\n\\n  // Detect Opera (8.0+)\\n  if ((!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) {\\n    hasMatch = navigator.userAgent.match(/OPR\\\\/(\\\\d+)/i) || [];\\n\\n    webrtcDetectedBrowser   = 'opera';\\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\\n    webrtcMinimumVersion    = 26;\\n    webrtcDetectedType      = 'webkit';\\n    webrtcDetectedDCSupport = 'SCTP'; // Opera 20+ uses Chrome 33\\n\\n  // Detect Bowser on iOS\\n  } else if (navigator.userAgent.match(/Bowser\\\\/[0-9.]*/g)) {\\n    hasMatch = navigator.userAgent.match(/Bowser\\\\/[0-9.]*/g) || [];\\n\\n    var chromiumVersion = parseInt((navigator.userAgent.match(/Chrom(e|ium)\\\\/([0-9]+)\\\\./i) || [])[2] || '0', 10);\\n\\n    webrtcDetectedBrowser   = 'bowser';\\n    webrtcDetectedVersion   = parseFloat((hasMatch[0] || '0/0').split('/')[1], 10);\\n    webrtcMinimumVersion    = 0;\\n    webrtcDetectedType      = 'webkit';\\n    webrtcDetectedDCSupport = chromiumVersion > 30 ? 'SCTP' : 'RTP';\\n\\n\\n  // Detect Opera on iOS (does not support WebRTC yet)\\n  } else if (navigator.userAgent.indexOf('OPiOS') > 0) {\\n    hasMatch = navigator.userAgent.match(/OPiOS\\\\/([0-9]+)\\\\./);\\n\\n    // Browser which do not support webrtc yet\\n    webrtcDetectedBrowser   = 'opera';\\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\\n    webrtcMinimumVersion    = 0;\\n    webrtcDetectedType      = null;\\n    webrtcDetectedDCSupport = null;\\n\\n  // Detect Chrome on iOS (does not support WebRTC yet)\\n  } else if (navigator.userAgent.indexOf('CriOS') > 0) {\\n    hasMatch = navigator.userAgent.match(/CriOS\\\\/([0-9]+)\\\\./) || [];\\n\\n    webrtcDetectedBrowser   = 'chrome';\\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\\n    webrtcMinimumVersion    = 0;\\n    webrtcDetectedType      = null;\\n    webrtcDetectedDCSupport = null;\\n\\n  // Detect Firefox on iOS (does not support WebRTC yet)\\n  } else if (navigator.userAgent.indexOf('FxiOS') > 0) {\\n    hasMatch = navigator.userAgent.match(/FxiOS\\\\/([0-9]+)\\\\./) || [];\\n\\n    // Browser which do not support webrtc yet\\n    webrtcDetectedBrowser   = 'firefox';\\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\\n    webrtcMinimumVersion    = 0;\\n    webrtcDetectedType      = null;\\n    webrtcDetectedDCSupport = null;\\n\\n  // Detect IE (6-11)\\n  } else if (/*@cc_on!@*/false || !!document.documentMode) {\\n    hasMatch = /\\\\brv[ :]+(\\\\d+)/g.exec(navigator.userAgent) || [];\\n\\n    webrtcDetectedBrowser   = 'IE';\\n    webrtcDetectedVersion   = parseInt(hasMatch[1], 10);\\n    webrtcMinimumVersion    = 9;\\n    webrtcDetectedType      = 'plugin';\\n    webrtcDetectedDCSupport = 'SCTP';\\n\\n    if (!webrtcDetectedVersion) {\\n      hasMatch = /\\\\bMSIE[ :]+(\\\\d+)/g.exec(navigator.userAgent) || [];\\n\\n      webrtcDetectedVersion = parseInt(hasMatch[1] || '0', 10);\\n    }\\n\\n  // Detect Edge (20+)\\n  } else if (!!window.StyleMedia || navigator.userAgent.match(/Edge\\\\/(\\\\d+).(\\\\d+)$/)) {\\n    hasMatch = navigator.userAgent.match(/Edge\\\\/(\\\\d+).(\\\\d+)$/) || [];\\n\\n    // Previous webrtc/adapter uses minimum version as 10547 but checking in the Edge release history,\\n    // It's close to 13.10547 and ObjectRTC API is fully supported in that version\\n\\n    webrtcDetectedBrowser   = 'edge';\\n    webrtcDetectedVersion   = parseFloat((hasMatch[0] || '0/0').split('/')[1], 10);\\n    webrtcMinimumVersion    = 13.10547;\\n    webrtcDetectedType      = 'ms';\\n    webrtcDetectedDCSupport = null;\\n\\n  // Detect Firefox (1.0+)\\n  // Placed before Safari check to ensure Firefox on Android is detected\\n  } else if (typeof InstallTrigger !== 'undefined' || navigator.userAgent.indexOf('irefox') > 0) {\\n    hasMatch = navigator.userAgent.match(/Firefox\\\\/([0-9]+)\\\\./) || [];\\n\\n    webrtcDetectedBrowser   = 'firefox';\\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\\n    webrtcMinimumVersion    = 31;\\n    webrtcDetectedType      = 'moz';\\n    webrtcDetectedDCSupport = 'SCTP';\\n\\n  // Detect Chrome (1+ and mobile)\\n  // Placed before Safari check to ensure Chrome on Android is detected\\n  } else if ((!!window.chrome && !!window.chrome.webstore) || navigator.userAgent.indexOf('Chrom') > 0) {\\n    hasMatch = navigator.userAgent.match(/Chrom(e|ium)\\\\/([0-9]+)\\\\./i) || [];\\n\\n    webrtcDetectedBrowser   = 'chrome';\\n    webrtcDetectedVersion   = parseInt(hasMatch[2] || '0', 10);\\n    webrtcMinimumVersion    = 38;\\n    webrtcDetectedType      = 'webkit';\\n    webrtcDetectedDCSupport = webrtcDetectedVersion > 30 ? 'SCTP' : 'RTP'; // Chrome 31+ supports SCTP without flags\\n\\n  // Detect Safari\\n  } else if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\\n    hasMatch = navigator.userAgent.match(/version\\\\/(\\\\d+)/i) || [];\\n\\n    var isMobile = navigator.userAgent.match(/(iPhone|iPad)/gi) || [];\\n\\n    webrtcDetectedBrowser   = 'safari';\\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\\n    webrtcMinimumVersion    = 7;\\n    webrtcDetectedType      = isMobile.length === 0 ? 'plugin' : null;\\n    webrtcDetectedDCSupport = isMobile.length === 0 ? 'SCTP' : null;\\n\\n  // Detect WebView on iOS (does not support WebRTC yet)\\n  } else if (/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent)) {\\n    hasMatch = navigator.userAgent.match(/AppleWebKit\\\\/([0-9]+)\\\\./) || [];\\n\\n    webrtcDetectedBrowser   = 'safari';\\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\\n    webrtcMinimumVersion    = 0;\\n    webrtcDetectedType      = null;\\n    webrtcDetectedDCSupport = null;\\n\\n  }\\n\\n  window.webrtcDetectedBrowser   = webrtcDetectedBrowser;\\n  window.webrtcDetectedVersion   = webrtcDetectedVersion;\\n  window.webrtcMinimumVersion    = webrtcMinimumVersion;\\n  window.webrtcDetectedType      = webrtcDetectedType; // Scope it to window for better consistency\\n  window.webrtcDetectedDCSupport = webrtcDetectedDCSupport; // Scope it to window for better consistency\\n};\\n\\nAdapterJS.addEvent = function(elem, evnt, func) {\\n  if (elem.addEventListener) { // W3C DOM\\n    elem.addEventListener(evnt, func, false);\\n  } else if (elem.attachEvent) {// OLD IE DOM\\n    elem.attachEvent('on'+evnt, func);\\n  } else { // No much to do\\n    elem[evnt] = func;\\n  }\\n};\\n\\nAdapterJS.renderNotificationBar = function (text, buttonText, buttonLink, openNewTab, displayRefreshBar) {\\n  // only inject once the page is ready\\n  if (document.readyState !== 'complete') {\\n    return;\\n  }\\n\\n  var w = window;\\n  var i = document.createElement('iframe');\\n  i.name = 'adapterjs-alert';\\n  i.style.position = 'fixed';\\n  i.style.top = '-41px';\\n  i.style.left = 0;\\n  i.style.right = 0;\\n  i.style.width = '100%';\\n  i.style.height = '40px';\\n  i.style.backgroundColor = '#ffffe1';\\n  i.style.border = 'none';\\n  i.style.borderBottom = '1px solid #888888';\\n  i.style.zIndex = '9999999';\\n  if(typeof i.style.webkitTransition === 'string') {\\n    i.style.webkitTransition = 'all .5s ease-out';\\n  } else if(typeof i.style.transition === 'string') {\\n    i.style.transition = 'all .5s ease-out';\\n  }\\n  document.body.appendChild(i);\\n  var c = (i.contentWindow) ? i.contentWindow :\\n    (i.contentDocument.document) ? i.contentDocument.document : i.contentDocument;\\n  c.document.open();\\n  c.document.write('<span style=\\\"display: inline-block; font-family: Helvetica, Arial,' +\\n    'sans-serif; font-size: .9rem; padding: 4px; vertical-align: ' +\\n    'middle; cursor: default;\\\">' + text + '</span>');\\n  if(buttonText && buttonLink) {\\n    c.document.write('<button id=\\\"okay\\\">' + buttonText + '</button><button id=\\\"cancel\\\">Cancel</button>');\\n    c.document.close();\\n\\n    // On click on okay\\n    AdapterJS.addEvent(c.document.getElementById('okay'), 'click', function(e) {\\n      if (!!displayRefreshBar) {\\n        AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION ?\\n          AdapterJS.TEXT.EXTENSION.REQUIRE_REFRESH : AdapterJS.TEXT.REFRESH.REQUIRE_REFRESH,\\n          AdapterJS.TEXT.REFRESH.BUTTON, 'javascript:location.reload()'); // jshint ignore:line\\n      }\\n      window.open(buttonLink, !!openNewTab ? '_blank' : '_top');\\n\\n      e.preventDefault();\\n      try {\\n        e.cancelBubble = true;\\n      } catch(error) { }\\n\\n      var pluginInstallInterval = setInterval(function(){\\n        if(! isIE) {\\n          navigator.plugins.refresh(false);\\n        }\\n        AdapterJS.WebRTCPlugin.isPluginInstalled(\\n          AdapterJS.WebRTCPlugin.pluginInfo.prefix,\\n          AdapterJS.WebRTCPlugin.pluginInfo.plugName,\\n          AdapterJS.WebRTCPlugin.pluginInfo.type,\\n          function() { // plugin now installed\\n            clearInterval(pluginInstallInterval);\\n            AdapterJS.WebRTCPlugin.defineWebRTCInterface();\\n          },\\n          function() {\\n            // still no plugin detected, nothing to do\\n          });\\n      } , 500);\\n    });\\n\\n    // On click on Cancel\\n    AdapterJS.addEvent(c.document.getElementById('cancel'), 'click', function(e) {\\n      w.document.body.removeChild(i);\\n    });\\n  } else {\\n    c.document.close();\\n  }\\n  setTimeout(function() {\\n    if(typeof i.style.webkitTransform === 'string') {\\n      i.style.webkitTransform = 'translateY(40px)';\\n    } else if(typeof i.style.transform === 'string') {\\n      i.style.transform = 'translateY(40px)';\\n    } else {\\n      i.style.top = '0px';\\n    }\\n  }, 300);\\n};\\n\\n// -----------------------------------------------------------\\n// Detected webrtc implementation. Types are:\\n// - 'moz': Mozilla implementation of webRTC.\\n// - 'webkit': WebKit implementation of webRTC.\\n// - 'plugin': Using the plugin implementation.\\nwebrtcDetectedType = null;\\n\\n// Set the settings for creating DataChannels, MediaStream for\\n// Cross-browser compability.\\n// - This is only for SCTP based support browsers.\\n// the 'urls' attribute.\\ncheckMediaDataChannelSettings =\\n  function (peerBrowserAgent, peerBrowserVersion, callback, constraints) {\\n  if (typeof callback !== 'function') {\\n    return;\\n  }\\n  var beOfferer = true;\\n  var isLocalFirefox = webrtcDetectedBrowser === 'firefox';\\n  // Nightly version does not require MozDontOfferDataChannel for interop\\n  var isLocalFirefoxInterop = webrtcDetectedType === 'moz' && webrtcDetectedVersion > 30;\\n  var isPeerFirefox = peerBrowserAgent === 'firefox';\\n  var isPeerFirefoxInterop = peerBrowserAgent === 'firefox' &&\\n    ((peerBrowserVersion) ? (peerBrowserVersion > 30) : false);\\n\\n  // Resends an updated version of constraints for MozDataChannel to work\\n  // If other userAgent is firefox and user is firefox, remove MozDataChannel\\n  if ((isLocalFirefox && isPeerFirefox) || (isLocalFirefoxInterop)) {\\n    try {\\n      delete constraints.mandatory.MozDontOfferDataChannel;\\n    } catch (error) {\\n      console.error('Failed deleting MozDontOfferDataChannel');\\n      console.error(error);\\n    }\\n  } else if ((isLocalFirefox && !isPeerFirefox)) {\\n    constraints.mandatory.MozDontOfferDataChannel = true;\\n  }\\n  if (!isLocalFirefox) {\\n    // temporary measure to remove Moz* constraints in non Firefox browsers\\n    for (var prop in constraints.mandatory) {\\n      if (constraints.mandatory.hasOwnProperty(prop)) {\\n        if (prop.indexOf('Moz') !== -1) {\\n          delete constraints.mandatory[prop];\\n        }\\n      }\\n    }\\n  }\\n  // Firefox (not interopable) cannot offer DataChannel as it will cause problems to the\\n  // interopability of the media stream\\n  if (isLocalFirefox && !isPeerFirefox && !isLocalFirefoxInterop) {\\n    beOfferer = false;\\n  }\\n  callback(beOfferer, constraints);\\n};\\n\\n// Handles the differences for all browsers ice connection state output.\\n// - Tested outcomes are:\\n//   - Chrome (offerer)  : 'checking' > 'completed' > 'completed'\\n//   - Chrome (answerer) : 'checking' > 'connected'\\n//   - Firefox (offerer) : 'checking' > 'connected'\\n//   - Firefox (answerer): 'checking' > 'connected'\\ncheckIceConnectionState = function (peerId, iceConnectionState, callback) {\\n  if (typeof callback !== 'function') {\\n    console.warn('No callback specified in checkIceConnectionState. Aborted.');\\n    return;\\n  }\\n  peerId = (peerId) ? peerId : 'peer';\\n\\n  if (!AdapterJS._iceConnectionFiredStates[peerId] ||\\n    iceConnectionState === AdapterJS._iceConnectionStates.disconnected ||\\n    iceConnectionState === AdapterJS._iceConnectionStates.failed ||\\n    iceConnectionState === AdapterJS._iceConnectionStates.closed) {\\n    AdapterJS._iceConnectionFiredStates[peerId] = [];\\n  }\\n  iceConnectionState = AdapterJS._iceConnectionStates[iceConnectionState];\\n  if (AdapterJS._iceConnectionFiredStates[peerId].indexOf(iceConnectionState) < 0) {\\n    AdapterJS._iceConnectionFiredStates[peerId].push(iceConnectionState);\\n    if (iceConnectionState === AdapterJS._iceConnectionStates.connected) {\\n      setTimeout(function () {\\n        AdapterJS._iceConnectionFiredStates[peerId]\\n          .push(AdapterJS._iceConnectionStates.done);\\n        callback(AdapterJS._iceConnectionStates.done);\\n      }, 1000);\\n    }\\n    callback(iceConnectionState);\\n  }\\n  return;\\n};\\n\\n// Firefox:\\n// - Creates iceServer from the url for Firefox.\\n// - Create iceServer with stun url.\\n// - Create iceServer with turn url.\\n//   - Ignore the transport parameter from TURN url for FF version <=27.\\n//   - Return null for createIceServer if transport=tcp.\\n// - FF 27 and above supports transport parameters in TURN url,\\n// - So passing in the full url to create iceServer.\\n// Chrome:\\n// - Creates iceServer from the url for Chrome M33 and earlier.\\n//   - Create iceServer with stun url.\\n//   - Chrome M28 & above uses below TURN format.\\n// Plugin:\\n// - Creates Ice Server for Plugin Browsers\\n//   - If Stun - Create iceServer with stun url.\\n//   - Else - Create iceServer with turn url\\n//   - This is a WebRTC Function\\ncreateIceServer = null;\\n\\n// Firefox:\\n// - Creates IceServers for Firefox\\n//   - Use .url for FireFox.\\n//   - Multiple Urls support\\n// Chrome:\\n// - Creates iceServers from the urls for Chrome M34 and above.\\n//   - .urls is supported since Chrome M34.\\n//   - Multiple Urls support\\n// Plugin:\\n// - Creates Ice Servers for Plugin Browsers\\n//   - Multiple Urls support\\n//   - This is a WebRTC Function\\ncreateIceServers = null;\\n//------------------------------------------------------------\\n\\n//The RTCPeerConnection object.\\nRTCPeerConnection = null;\\n\\n// Creates RTCSessionDescription object for Plugin Browsers\\nRTCSessionDescription = (typeof RTCSessionDescription === 'function') ?\\n  RTCSessionDescription : null;\\n\\n// Creates RTCIceCandidate object for Plugin Browsers\\nRTCIceCandidate = (typeof RTCIceCandidate === 'function') ?\\n  RTCIceCandidate : null;\\n\\n// Get UserMedia (only difference is the prefix).\\n// Code from Adam Barth.\\ngetUserMedia = null;\\n\\n// Attach a media stream to an element.\\nattachMediaStream = null;\\n\\n// Re-attach a media stream to an element.\\nreattachMediaStream = null;\\n\\n\\n// Detected browser agent name. Types are:\\n// - 'firefox': Firefox browser.\\n// - 'chrome': Chrome browser.\\n// - 'opera': Opera browser.\\n// - 'safari': Safari browser.\\n// - 'IE' - Internet Explorer browser.\\nwebrtcDetectedBrowser = null;\\n\\n// Detected browser version.\\nwebrtcDetectedVersion = null;\\n\\n// The minimum browser version still supported by AJS.\\nwebrtcMinimumVersion  = null;\\n\\n// Check for browser types and react accordingly\\nif ( (navigator.mozGetUserMedia ||\\n      navigator.webkitGetUserMedia ||\\n      (navigator.mediaDevices &&\\n       navigator.userAgent.match(/Edge\\\\/(\\\\d+).(\\\\d+)$/)))\\n    && !((navigator.userAgent.match(/android/ig) || []).length === 0 &&\\n          (navigator.userAgent.match(/chrome/ig) || []).length === 0 && navigator.userAgent.indexOf('Safari/') > 0)) {\\n\\n  ///////////////////////////////////////////////////////////////////\\n  // INJECTION OF GOOGLE'S ADAPTER.JS CONTENT\\n\\n/* jshint ignore:start */\\n  (function(f){if(true){module.exports=f()}else if(typeof define===\\\"function\\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n   /* eslint-env node */\\n  'use strict';\\n\\n  // SDP helpers.\\n  var SDPUtils = {};\\n\\n  // Generate an alphanumeric identifier for cname or mids.\\n  // TODO: use UUIDs instead? https://gist.github.com/jed/982883\\n  SDPUtils.generateIdentifier = function() {\\n    return Math.random().toString(36).substr(2, 10);\\n  };\\n\\n  // The RTCP CNAME used by all peerconnections from the same JS.\\n  SDPUtils.localCName = SDPUtils.generateIdentifier();\\n\\n  // Splits SDP into lines, dealing with both CRLF and LF.\\n  SDPUtils.splitLines = function(blob) {\\n    return blob.trim().split('\\\\n').map(function(line) {\\n      return line.trim();\\n    });\\n  };\\n  // Splits SDP into sessionpart and mediasections. Ensures CRLF.\\n  SDPUtils.splitSections = function(blob) {\\n    var parts = blob.split('\\\\nm=');\\n    return parts.map(function(part, index) {\\n      return (index > 0 ? 'm=' + part : part).trim() + '\\\\r\\\\n';\\n    });\\n  };\\n\\n  // Returns lines that start with a certain prefix.\\n  SDPUtils.matchPrefix = function(blob, prefix) {\\n    return SDPUtils.splitLines(blob).filter(function(line) {\\n      return line.indexOf(prefix) === 0;\\n    });\\n  };\\n\\n  // Parses an ICE candidate line. Sample input:\\n  // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\\n  // rport 55996\\\"\\n  SDPUtils.parseCandidate = function(line) {\\n    var parts;\\n    // Parse both variants.\\n    if (line.indexOf('a=candidate:') === 0) {\\n      parts = line.substring(12).split(' ');\\n    } else {\\n      parts = line.substring(10).split(' ');\\n    }\\n\\n    var candidate = {\\n      foundation: parts[0],\\n      component: parts[1],\\n      protocol: parts[2].toLowerCase(),\\n      priority: parseInt(parts[3], 10),\\n      ip: parts[4],\\n      port: parseInt(parts[5], 10),\\n      // skip parts[6] == 'typ'\\n      type: parts[7]\\n    };\\n\\n    for (var i = 8; i < parts.length; i += 2) {\\n      switch (parts[i]) {\\n        case 'raddr':\\n          candidate.relatedAddress = parts[i + 1];\\n          break;\\n        case 'rport':\\n          candidate.relatedPort = parseInt(parts[i + 1], 10);\\n          break;\\n        case 'tcptype':\\n          candidate.tcpType = parts[i + 1];\\n          break;\\n        default: // Unknown extensions are silently ignored.\\n          break;\\n      }\\n    }\\n    return candidate;\\n  };\\n\\n  // Translates a candidate object into SDP candidate attribute.\\n  SDPUtils.writeCandidate = function(candidate) {\\n    var sdp = [];\\n    sdp.push(candidate.foundation);\\n    sdp.push(candidate.component);\\n    sdp.push(candidate.protocol.toUpperCase());\\n    sdp.push(candidate.priority);\\n    sdp.push(candidate.ip);\\n    sdp.push(candidate.port);\\n\\n    var type = candidate.type;\\n    sdp.push('typ');\\n    sdp.push(type);\\n    if (type !== 'host' && candidate.relatedAddress &&\\n        candidate.relatedPort) {\\n      sdp.push('raddr');\\n      sdp.push(candidate.relatedAddress); // was: relAddr\\n      sdp.push('rport');\\n      sdp.push(candidate.relatedPort); // was: relPort\\n    }\\n    if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\\n      sdp.push('tcptype');\\n      sdp.push(candidate.tcpType);\\n    }\\n    return 'candidate:' + sdp.join(' ');\\n  };\\n\\n  // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\\n  // a=rtpmap:111 opus/48000/2\\n  SDPUtils.parseRtpMap = function(line) {\\n    var parts = line.substr(9).split(' ');\\n    var parsed = {\\n      payloadType: parseInt(parts.shift(), 10) // was: id\\n    };\\n\\n    parts = parts[0].split('/');\\n\\n    parsed.name = parts[0];\\n    parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\\n    // was: channels\\n    parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\\n    return parsed;\\n  };\\n\\n  // Generate an a=rtpmap line from RTCRtpCodecCapability or\\n  // RTCRtpCodecParameters.\\n  SDPUtils.writeRtpMap = function(codec) {\\n    var pt = codec.payloadType;\\n    if (codec.preferredPayloadType !== undefined) {\\n      pt = codec.preferredPayloadType;\\n    }\\n    return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\\n        (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\\\\r\\\\n';\\n  };\\n\\n  // Parses an a=extmap line (headerextension from RFC 5285). Sample input:\\n  // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\\n  SDPUtils.parseExtmap = function(line) {\\n    var parts = line.substr(9).split(' ');\\n    return {\\n      id: parseInt(parts[0], 10),\\n      uri: parts[1]\\n    };\\n  };\\n\\n  // Generates a=extmap line from RTCRtpHeaderExtensionParameters or\\n  // RTCRtpHeaderExtension.\\n  SDPUtils.writeExtmap = function(headerExtension) {\\n    return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\\n         ' ' + headerExtension.uri + '\\\\r\\\\n';\\n  };\\n\\n  // Parses an ftmp line, returns dictionary. Sample input:\\n  // a=fmtp:96 vbr=on;cng=on\\n  // Also deals with vbr=on; cng=on\\n  SDPUtils.parseFmtp = function(line) {\\n    var parsed = {};\\n    var kv;\\n    var parts = line.substr(line.indexOf(' ') + 1).split(';');\\n    for (var j = 0; j < parts.length; j++) {\\n      kv = parts[j].trim().split('=');\\n      parsed[kv[0].trim()] = kv[1];\\n    }\\n    return parsed;\\n  };\\n\\n  // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\\n  SDPUtils.writeFmtp = function(codec) {\\n    var line = '';\\n    var pt = codec.payloadType;\\n    if (codec.preferredPayloadType !== undefined) {\\n      pt = codec.preferredPayloadType;\\n    }\\n    if (codec.parameters && Object.keys(codec.parameters).length) {\\n      var params = [];\\n      Object.keys(codec.parameters).forEach(function(param) {\\n        params.push(param + '=' + codec.parameters[param]);\\n      });\\n      line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\\\r\\\\n';\\n    }\\n    return line;\\n  };\\n\\n  // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\\n  // a=rtcp-fb:98 nack rpsi\\n  SDPUtils.parseRtcpFb = function(line) {\\n    var parts = line.substr(line.indexOf(' ') + 1).split(' ');\\n    return {\\n      type: parts.shift(),\\n      parameter: parts.join(' ')\\n    };\\n  };\\n  // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\\n  SDPUtils.writeRtcpFb = function(codec) {\\n    var lines = '';\\n    var pt = codec.payloadType;\\n    if (codec.preferredPayloadType !== undefined) {\\n      pt = codec.preferredPayloadType;\\n    }\\n    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\\n      // FIXME: special handling for trr-int?\\n      codec.rtcpFeedback.forEach(function(fb) {\\n        lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\\n        (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\\n            '\\\\r\\\\n';\\n      });\\n    }\\n    return lines;\\n  };\\n\\n  // Parses an RFC 5576 ssrc media attribute. Sample input:\\n  // a=ssrc:3735928559 cname:something\\n  SDPUtils.parseSsrcMedia = function(line) {\\n    var sp = line.indexOf(' ');\\n    var parts = {\\n      ssrc: parseInt(line.substr(7, sp - 7), 10)\\n    };\\n    var colon = line.indexOf(':', sp);\\n    if (colon > -1) {\\n      parts.attribute = line.substr(sp + 1, colon - sp - 1);\\n      parts.value = line.substr(colon + 1);\\n    } else {\\n      parts.attribute = line.substr(sp + 1);\\n    }\\n    return parts;\\n  };\\n\\n  // Extracts DTLS parameters from SDP media section or sessionpart.\\n  // FIXME: for consistency with other functions this should only\\n  //   get the fingerprint line as input. See also getIceParameters.\\n  SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\\n    var lines = SDPUtils.splitLines(mediaSection);\\n    // Search in session part, too.\\n    lines = lines.concat(SDPUtils.splitLines(sessionpart));\\n    var fpLine = lines.filter(function(line) {\\n      return line.indexOf('a=fingerprint:') === 0;\\n    })[0].substr(14);\\n    // Note: a=setup line is ignored since we use the 'auto' role.\\n    var dtlsParameters = {\\n      role: 'auto',\\n      fingerprints: [{\\n        algorithm: fpLine.split(' ')[0],\\n        value: fpLine.split(' ')[1]\\n      }]\\n    };\\n    return dtlsParameters;\\n  };\\n\\n  // Serializes DTLS parameters to SDP.\\n  SDPUtils.writeDtlsParameters = function(params, setupType) {\\n    var sdp = 'a=setup:' + setupType + '\\\\r\\\\n';\\n    params.fingerprints.forEach(function(fp) {\\n      sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\\\r\\\\n';\\n    });\\n    return sdp;\\n  };\\n  // Parses ICE information from SDP media section or sessionpart.\\n  // FIXME: for consistency with other functions this should only\\n  //   get the ice-ufrag and ice-pwd lines as input.\\n  SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\\n    var lines = SDPUtils.splitLines(mediaSection);\\n    // Search in session part, too.\\n    lines = lines.concat(SDPUtils.splitLines(sessionpart));\\n    var iceParameters = {\\n      usernameFragment: lines.filter(function(line) {\\n        return line.indexOf('a=ice-ufrag:') === 0;\\n      })[0].substr(12),\\n      password: lines.filter(function(line) {\\n        return line.indexOf('a=ice-pwd:') === 0;\\n      })[0].substr(10)\\n    };\\n    return iceParameters;\\n  };\\n\\n  // Serializes ICE parameters to SDP.\\n  SDPUtils.writeIceParameters = function(params) {\\n    return 'a=ice-ufrag:' + params.usernameFragment + '\\\\r\\\\n' +\\n        'a=ice-pwd:' + params.password + '\\\\r\\\\n';\\n  };\\n\\n  // Parses the SDP media section and returns RTCRtpParameters.\\n  SDPUtils.parseRtpParameters = function(mediaSection) {\\n    var description = {\\n      codecs: [],\\n      headerExtensions: [],\\n      fecMechanisms: [],\\n      rtcp: []\\n    };\\n    var lines = SDPUtils.splitLines(mediaSection);\\n    var mline = lines[0].split(' ');\\n    for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\\n      var pt = mline[i];\\n      var rtpmapline = SDPUtils.matchPrefix(\\n          mediaSection, 'a=rtpmap:' + pt + ' ')[0];\\n      if (rtpmapline) {\\n        var codec = SDPUtils.parseRtpMap(rtpmapline);\\n        var fmtps = SDPUtils.matchPrefix(\\n            mediaSection, 'a=fmtp:' + pt + ' ');\\n        // Only the first a=fmtp:<pt> is considered.\\n        codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\\n        codec.rtcpFeedback = SDPUtils.matchPrefix(\\n            mediaSection, 'a=rtcp-fb:' + pt + ' ')\\n          .map(SDPUtils.parseRtcpFb);\\n        description.codecs.push(codec);\\n        // parse FEC mechanisms from rtpmap lines.\\n        switch (codec.name.toUpperCase()) {\\n          case 'RED':\\n          case 'ULPFEC':\\n            description.fecMechanisms.push(codec.name.toUpperCase());\\n            break;\\n          default: // only RED and ULPFEC are recognized as FEC mechanisms.\\n            break;\\n        }\\n      }\\n    }\\n    SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\\n      description.headerExtensions.push(SDPUtils.parseExtmap(line));\\n    });\\n    // FIXME: parse rtcp.\\n    return description;\\n  };\\n\\n  // Generates parts of the SDP media section describing the capabilities /\\n  // parameters.\\n  SDPUtils.writeRtpDescription = function(kind, caps) {\\n    var sdp = '';\\n\\n    // Build the mline.\\n    sdp += 'm=' + kind + ' ';\\n    sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\\n    sdp += ' UDP/TLS/RTP/SAVPF ';\\n    sdp += caps.codecs.map(function(codec) {\\n      if (codec.preferredPayloadType !== undefined) {\\n        return codec.preferredPayloadType;\\n      }\\n      return codec.payloadType;\\n    }).join(' ') + '\\\\r\\\\n';\\n\\n    sdp += 'c=IN IP4 0.0.0.0\\\\r\\\\n';\\n    sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\\\r\\\\n';\\n\\n    // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\\n    caps.codecs.forEach(function(codec) {\\n      sdp += SDPUtils.writeRtpMap(codec);\\n      sdp += SDPUtils.writeFmtp(codec);\\n      sdp += SDPUtils.writeRtcpFb(codec);\\n    });\\n    // FIXME: add headerExtensions, fecMechanismş and rtcp.\\n    sdp += 'a=rtcp-mux\\\\r\\\\n';\\n    return sdp;\\n  };\\n\\n  // Parses the SDP media section and returns an array of\\n  // RTCRtpEncodingParameters.\\n  SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\\n    var encodingParameters = [];\\n    var description = SDPUtils.parseRtpParameters(mediaSection);\\n    var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\\n    var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\\n\\n    // filter a=ssrc:... cname:, ignore PlanB-msid\\n    var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\\n    .map(function(line) {\\n      return SDPUtils.parseSsrcMedia(line);\\n    })\\n    .filter(function(parts) {\\n      return parts.attribute === 'cname';\\n    });\\n    var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\\n    var secondarySsrc;\\n\\n    var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\\n    .map(function(line) {\\n      var parts = line.split(' ');\\n      parts.shift();\\n      return parts.map(function(part) {\\n        return parseInt(part, 10);\\n      });\\n    });\\n    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\\n      secondarySsrc = flows[0][1];\\n    }\\n\\n    description.codecs.forEach(function(codec) {\\n      if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\\n        var encParam = {\\n          ssrc: primarySsrc,\\n          codecPayloadType: parseInt(codec.parameters.apt, 10),\\n          rtx: {\\n            payloadType: codec.payloadType,\\n            ssrc: secondarySsrc\\n          }\\n        };\\n        encodingParameters.push(encParam);\\n        if (hasRed) {\\n          encParam = JSON.parse(JSON.stringify(encParam));\\n          encParam.fec = {\\n            ssrc: secondarySsrc,\\n            mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\\n          };\\n          encodingParameters.push(encParam);\\n        }\\n      }\\n    });\\n    if (encodingParameters.length === 0 && primarySsrc) {\\n      encodingParameters.push({\\n        ssrc: primarySsrc\\n      });\\n    }\\n\\n    // we support both b=AS and b=TIAS but interpret AS as TIAS.\\n    var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\\n    if (bandwidth.length) {\\n      if (bandwidth[0].indexOf('b=TIAS:') === 0) {\\n        bandwidth = parseInt(bandwidth[0].substr(7), 10);\\n      } else if (bandwidth[0].indexOf('b=AS:') === 0) {\\n        bandwidth = parseInt(bandwidth[0].substr(5), 10);\\n      }\\n      encodingParameters.forEach(function(params) {\\n        params.maxBitrate = bandwidth;\\n      });\\n    }\\n    return encodingParameters;\\n  };\\n\\n  SDPUtils.writeSessionBoilerplate = function() {\\n    // FIXME: sess-id should be an NTP timestamp.\\n    return 'v=0\\\\r\\\\n' +\\n        'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\\\\r\\\\n' +\\n        's=-\\\\r\\\\n' +\\n        't=0 0\\\\r\\\\n';\\n  };\\n\\n  SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\\n    var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\\n\\n    // Map ICE parameters (ufrag, pwd) to SDP.\\n    sdp += SDPUtils.writeIceParameters(\\n        transceiver.iceGatherer.getLocalParameters());\\n\\n    // Map DTLS parameters to SDP.\\n    sdp += SDPUtils.writeDtlsParameters(\\n        transceiver.dtlsTransport.getLocalParameters(),\\n        type === 'offer' ? 'actpass' : 'active');\\n\\n    sdp += 'a=mid:' + transceiver.mid + '\\\\r\\\\n';\\n\\n    if (transceiver.rtpSender && transceiver.rtpReceiver) {\\n      sdp += 'a=sendrecv\\\\r\\\\n';\\n    } else if (transceiver.rtpSender) {\\n      sdp += 'a=sendonly\\\\r\\\\n';\\n    } else if (transceiver.rtpReceiver) {\\n      sdp += 'a=recvonly\\\\r\\\\n';\\n    } else {\\n      sdp += 'a=inactive\\\\r\\\\n';\\n    }\\n\\n    // FIXME: for RTX there might be multiple SSRCs. Not implemented in Edge yet.\\n    if (transceiver.rtpSender) {\\n      var msid = 'msid:' + stream.id + ' ' +\\n          transceiver.rtpSender.track.id + '\\\\r\\\\n';\\n      sdp += 'a=' + msid;\\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\\n          ' ' + msid;\\n    }\\n    // FIXME: this should be written by writeRtpDescription.\\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\\n        ' cname:' + SDPUtils.localCName + '\\\\r\\\\n';\\n    return sdp;\\n  };\\n\\n  // Gets the direction from the mediaSection or the sessionpart.\\n  SDPUtils.getDirection = function(mediaSection, sessionpart) {\\n    // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\\n    var lines = SDPUtils.splitLines(mediaSection);\\n    for (var i = 0; i < lines.length; i++) {\\n      switch (lines[i]) {\\n        case 'a=sendrecv':\\n        case 'a=sendonly':\\n        case 'a=recvonly':\\n        case 'a=inactive':\\n          return lines[i].substr(2);\\n        default:\\n          // FIXME: What should happen here?\\n      }\\n    }\\n    if (sessionpart) {\\n      return SDPUtils.getDirection(sessionpart);\\n    }\\n    return 'sendrecv';\\n  };\\n\\n  // Expose public methods.\\n  module.exports = SDPUtils;\\n\\n  },{}],2:[function(require,module,exports){\\n  /*\\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n   *\\n   *  Use of this source code is governed by a BSD-style license\\n   *  that can be found in the LICENSE file in the root of the source\\n   *  tree.\\n   */\\n   /* eslint-env node */\\n\\n  'use strict';\\n\\n  // Shimming starts here.\\n  (function() {\\n    // Utils.\\n    var logging = require('./utils').log;\\n    var browserDetails = require('./utils').browserDetails;\\n    // Export to the adapter global object visible in the browser.\\n    module.exports.browserDetails = browserDetails;\\n    module.exports.extractVersion = require('./utils').extractVersion;\\n    module.exports.disableLog = require('./utils').disableLog;\\n\\n    // Uncomment the line below if you want logging to occur, including logging\\n    // for the switch statement below. Can also be turned on in the browser via\\n    // adapter.disableLog(false), but then logging from the switch statement below\\n    // will not appear.\\n    // require('./utils').disableLog(false);\\n\\n    // Browser shims.\\n    var chromeShim = require('./chrome/chrome_shim') || null;\\n    var edgeShim = require('./edge/edge_shim') || null;\\n    var firefoxShim = require('./firefox/firefox_shim') || null;\\n    var safariShim = require('./safari/safari_shim') || null;\\n\\n    // Shim browser if found.\\n    switch (browserDetails.browser) {\\n      case 'opera': // fallthrough as it uses chrome shims\\n      case 'chrome':\\n        if (!chromeShim || !chromeShim.shimPeerConnection) {\\n          logging('Chrome shim is not included in this adapter release.');\\n          return;\\n        }\\n        logging('adapter.js shimming chrome.');\\n        // Export to the adapter global object visible in the browser.\\n        module.exports.browserShim = chromeShim;\\n\\n        chromeShim.shimGetUserMedia();\\n        chromeShim.shimMediaStream();\\n        chromeShim.shimSourceObject();\\n        chromeShim.shimPeerConnection();\\n        chromeShim.shimOnTrack();\\n        break;\\n      case 'firefox':\\n        if (!firefoxShim || !firefoxShim.shimPeerConnection) {\\n          logging('Firefox shim is not included in this adapter release.');\\n          return;\\n        }\\n        logging('adapter.js shimming firefox.');\\n        // Export to the adapter global object visible in the browser.\\n        module.exports.browserShim = firefoxShim;\\n\\n        firefoxShim.shimGetUserMedia();\\n        firefoxShim.shimSourceObject();\\n        firefoxShim.shimPeerConnection();\\n        firefoxShim.shimOnTrack();\\n        break;\\n      case 'edge':\\n        if (!edgeShim || !edgeShim.shimPeerConnection) {\\n          logging('MS edge shim is not included in this adapter release.');\\n          return;\\n        }\\n        logging('adapter.js shimming edge.');\\n        // Export to the adapter global object visible in the browser.\\n        module.exports.browserShim = edgeShim;\\n\\n        edgeShim.shimGetUserMedia();\\n        edgeShim.shimPeerConnection();\\n        break;\\n      case 'safari':\\n        if (!safariShim) {\\n          logging('Safari shim is not included in this adapter release.');\\n          return;\\n        }\\n        logging('adapter.js shimming safari.');\\n        // Export to the adapter global object visible in the browser.\\n        module.exports.browserShim = safariShim;\\n\\n        safariShim.shimGetUserMedia();\\n        break;\\n      default:\\n        logging('Unsupported browser!');\\n    }\\n  })();\\n\\n  },{\\\"./chrome/chrome_shim\\\":3,\\\"./edge/edge_shim\\\":5,\\\"./firefox/firefox_shim\\\":7,\\\"./safari/safari_shim\\\":9,\\\"./utils\\\":10}],3:[function(require,module,exports){\\n\\n  /*\\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n   *\\n   *  Use of this source code is governed by a BSD-style license\\n   *  that can be found in the LICENSE file in the root of the source\\n   *  tree.\\n   */\\n   /* eslint-env node */\\n  'use strict';\\n  var logging = require('../utils.js').log;\\n  var browserDetails = require('../utils.js').browserDetails;\\n\\n  var chromeShim = {\\n    shimMediaStream: function() {\\n      window.MediaStream = window.MediaStream || window.webkitMediaStream;\\n    },\\n\\n    shimOnTrack: function() {\\n      if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\\n          window.RTCPeerConnection.prototype)) {\\n        Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\\n          get: function() {\\n            return this._ontrack;\\n          },\\n          set: function(f) {\\n            var self = this;\\n            if (this._ontrack) {\\n              this.removeEventListener('track', this._ontrack);\\n              this.removeEventListener('addstream', this._ontrackpoly);\\n            }\\n            this.addEventListener('track', this._ontrack = f);\\n            this.addEventListener('addstream', this._ontrackpoly = function(e) {\\n              // onaddstream does not fire when a track is added to an existing\\n              // stream. But stream.onaddtrack is implemented so we use that.\\n              e.stream.addEventListener('addtrack', function(te) {\\n                var event = new Event('track');\\n                event.track = te.track;\\n                event.receiver = {track: te.track};\\n                event.streams = [e.stream];\\n                self.dispatchEvent(event);\\n              });\\n              e.stream.getTracks().forEach(function(track) {\\n                var event = new Event('track');\\n                event.track = track;\\n                event.receiver = {track: track};\\n                event.streams = [e.stream];\\n                this.dispatchEvent(event);\\n              }.bind(this));\\n            }.bind(this));\\n          }\\n        });\\n      }\\n    },\\n\\n    shimSourceObject: function() {\\n      if (typeof window === 'object') {\\n        if (window.HTMLMediaElement &&\\n          !('srcObject' in window.HTMLMediaElement.prototype)) {\\n          // Shim the srcObject property, once, when HTMLMediaElement is found.\\n          Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\\n            get: function() {\\n              return this._srcObject;\\n            },\\n            set: function(stream) {\\n              var self = this;\\n              // Use _srcObject as a private property for this shim\\n              this._srcObject = stream;\\n              if (this.src) {\\n                URL.revokeObjectURL(this.src);\\n              }\\n\\n              if (!stream) {\\n                this.src = '';\\n                return;\\n              }\\n              this.src = URL.createObjectURL(stream);\\n              // We need to recreate the blob url when a track is added or\\n              // removed. Doing it manually since we want to avoid a recursion.\\n              stream.addEventListener('addtrack', function() {\\n                if (self.src) {\\n                  URL.revokeObjectURL(self.src);\\n                }\\n                self.src = URL.createObjectURL(stream);\\n              });\\n              stream.addEventListener('removetrack', function() {\\n                if (self.src) {\\n                  URL.revokeObjectURL(self.src);\\n                }\\n                self.src = URL.createObjectURL(stream);\\n              });\\n            }\\n          });\\n        }\\n      }\\n    },\\n\\n    shimPeerConnection: function() {\\n      // The RTCPeerConnection object.\\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\\n        // Translate iceTransportPolicy to iceTransports,\\n        // see https://code.google.com/p/webrtc/issues/detail?id=4869\\n        logging('PeerConnection');\\n        if (pcConfig && pcConfig.iceTransportPolicy) {\\n          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\\n        }\\n\\n        var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints);\\n        var origGetStats = pc.getStats.bind(pc);\\n        pc.getStats = function(selector, successCallback, errorCallback) {\\n          var self = this;\\n          var args = arguments;\\n\\n          // If selector is a function then we are in the old style stats so just\\n          // pass back the original getStats format to avoid breaking old users.\\n          if (arguments.length > 0 && typeof selector === 'function') {\\n            return origGetStats(selector, successCallback);\\n          }\\n\\n          var fixChromeStats_ = function(response) {\\n            var standardReport = {};\\n            var reports = response.result();\\n            reports.forEach(function(report) {\\n              var standardStats = {\\n                id: report.id,\\n                timestamp: report.timestamp,\\n                type: report.type\\n              };\\n              report.names().forEach(function(name) {\\n                standardStats[name] = report.stat(name);\\n              });\\n              standardReport[standardStats.id] = standardStats;\\n            });\\n\\n            return standardReport;\\n          };\\n\\n          // shim getStats with maplike support\\n          var makeMapStats = function(stats, legacyStats) {\\n            var map = new Map(Object.keys(stats).map(function(key) {\\n              return[key, stats[key]];\\n            }));\\n            legacyStats = legacyStats || stats;\\n            Object.keys(legacyStats).forEach(function(key) {\\n              map[key] = legacyStats[key];\\n            });\\n            return map;\\n          };\\n\\n          if (arguments.length >= 2) {\\n            var successCallbackWrapper_ = function(response) {\\n              args[1](makeMapStats(fixChromeStats_(response)));\\n            };\\n\\n            return origGetStats.apply(this, [successCallbackWrapper_,\\n                arguments[0]]);\\n          }\\n\\n          // promise-support\\n          return new Promise(function(resolve, reject) {\\n            if (args.length === 1 && typeof selector === 'object') {\\n              origGetStats.apply(self, [\\n                function(response) {\\n                  resolve(makeMapStats(fixChromeStats_(response)));\\n                }, reject]);\\n            } else {\\n              // Preserve legacy chrome stats only on legacy access of stats obj\\n              origGetStats.apply(self, [\\n                function(response) {\\n                  resolve(makeMapStats(fixChromeStats_(response),\\n                      response.result()));\\n                }, reject]);\\n            }\\n          }).then(successCallback, errorCallback);\\n        };\\n\\n        return pc;\\n      };\\n      window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype;\\n\\n      // wrap static methods. Currently just generateCertificate.\\n      if (webkitRTCPeerConnection.generateCertificate) {\\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\\n          get: function() {\\n            return webkitRTCPeerConnection.generateCertificate;\\n          }\\n        });\\n      }\\n\\n      ['createOffer', 'createAnswer'].forEach(function(method) {\\n        var nativeMethod = webkitRTCPeerConnection.prototype[method];\\n        webkitRTCPeerConnection.prototype[method] = function() {\\n          var self = this;\\n          if (arguments.length < 1 || (arguments.length === 1 &&\\n              typeof arguments[0] === 'object')) {\\n            var opts = arguments.length === 1 ? arguments[0] : undefined;\\n            return new Promise(function(resolve, reject) {\\n              nativeMethod.apply(self, [resolve, reject, opts]);\\n            });\\n          }\\n          return nativeMethod.apply(this, arguments);\\n        };\\n      });\\n\\n      // add promise support -- natively available in Chrome 51\\n      if (browserDetails.version < 51) {\\n        ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\\n            .forEach(function(method) {\\n              var nativeMethod = webkitRTCPeerConnection.prototype[method];\\n              webkitRTCPeerConnection.prototype[method] = function() {\\n                var args = arguments;\\n                var self = this;\\n                var promise = new Promise(function(resolve, reject) {\\n                  nativeMethod.apply(self, [args[0], resolve, reject]);\\n                });\\n                if (args.length < 2) {\\n                  return promise;\\n                }\\n                return promise.then(function() {\\n                  args[1].apply(null, []);\\n                },\\n                function(err) {\\n                  if (args.length >= 3) {\\n                    args[2].apply(null, [err]);\\n                  }\\n                });\\n              };\\n            });\\n      }\\n\\n      // shim implicit creation of RTCSessionDescription/RTCIceCandidate\\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\\n          .forEach(function(method) {\\n            var nativeMethod = webkitRTCPeerConnection.prototype[method];\\n            webkitRTCPeerConnection.prototype[method] = function() {\\n              arguments[0] = new ((method === 'addIceCandidate') ?\\n                  RTCIceCandidate : RTCSessionDescription)(arguments[0]);\\n              return nativeMethod.apply(this, arguments);\\n            };\\n          });\\n\\n      // support for addIceCandidate(null)\\n      var nativeAddIceCandidate =\\n          RTCPeerConnection.prototype.addIceCandidate;\\n      RTCPeerConnection.prototype.addIceCandidate = function() {\\n        return arguments[0] === null ? Promise.resolve()\\n            : nativeAddIceCandidate.apply(this, arguments);\\n      };\\n    }\\n  };\\n\\n\\n  // Expose public methods.\\n  module.exports = {\\n    shimMediaStream: chromeShim.shimMediaStream,\\n    shimOnTrack: chromeShim.shimOnTrack,\\n    shimSourceObject: chromeShim.shimSourceObject,\\n    shimPeerConnection: chromeShim.shimPeerConnection,\\n    shimGetUserMedia: require('./getusermedia')\\n  };\\n\\n  },{\\\"../utils.js\\\":10,\\\"./getusermedia\\\":4}],4:[function(require,module,exports){\\n  /*\\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n   *\\n   *  Use of this source code is governed by a BSD-style license\\n   *  that can be found in the LICENSE file in the root of the source\\n   *  tree.\\n   */\\n   /* eslint-env node */\\n  'use strict';\\n  var logging = require('../utils.js').log;\\n\\n  // Expose public methods.\\n  module.exports = function() {\\n    var constraintsToChrome_ = function(c) {\\n      if (typeof c !== 'object' || c.mandatory || c.optional) {\\n        return c;\\n      }\\n      var cc = {};\\n      Object.keys(c).forEach(function(key) {\\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\\n          return;\\n        }\\n        var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\\n        if (r.exact !== undefined && typeof r.exact === 'number') {\\n          r.min = r.max = r.exact;\\n        }\\n        var oldname_ = function(prefix, name) {\\n          if (prefix) {\\n            return prefix + name.charAt(0).toUpperCase() + name.slice(1);\\n          }\\n          return (name === 'deviceId') ? 'sourceId' : name;\\n        };\\n        if (r.ideal !== undefined) {\\n          cc.optional = cc.optional || [];\\n          var oc = {};\\n          if (typeof r.ideal === 'number') {\\n            oc[oldname_('min', key)] = r.ideal;\\n            cc.optional.push(oc);\\n            oc = {};\\n            oc[oldname_('max', key)] = r.ideal;\\n            cc.optional.push(oc);\\n          } else {\\n            oc[oldname_('', key)] = r.ideal;\\n            cc.optional.push(oc);\\n          }\\n        }\\n        if (r.exact !== undefined && typeof r.exact !== 'number') {\\n          cc.mandatory = cc.mandatory || {};\\n          cc.mandatory[oldname_('', key)] = r.exact;\\n        } else {\\n          ['min', 'max'].forEach(function(mix) {\\n            if (r[mix] !== undefined) {\\n              cc.mandatory = cc.mandatory || {};\\n              cc.mandatory[oldname_(mix, key)] = r[mix];\\n            }\\n          });\\n        }\\n      });\\n      if (c.advanced) {\\n        cc.optional = (cc.optional || []).concat(c.advanced);\\n      }\\n      return cc;\\n    };\\n\\n    var shimConstraints_ = function(constraints, func) {\\n      constraints = JSON.parse(JSON.stringify(constraints));\\n      if (constraints && constraints.audio) {\\n        constraints.audio = constraintsToChrome_(constraints.audio);\\n      }\\n      if (constraints && typeof constraints.video === 'object') {\\n        // Shim facingMode for mobile, where it defaults to \\\"user\\\".\\n        var face = constraints.video.facingMode;\\n        face = face && ((typeof face === 'object') ? face : {ideal: face});\\n\\n        if ((face && (face.exact === 'user' || face.exact === 'environment' ||\\n                      face.ideal === 'user' || face.ideal === 'environment')) &&\\n            !(navigator.mediaDevices.getSupportedConstraints &&\\n              navigator.mediaDevices.getSupportedConstraints().facingMode)) {\\n          delete constraints.video.facingMode;\\n          if (face.exact === 'environment' || face.ideal === 'environment') {\\n            // Look for \\\"back\\\" in label, or use last cam (typically back cam).\\n            return navigator.mediaDevices.enumerateDevices()\\n            .then(function(devices) {\\n              devices = devices.filter(function(d) {\\n                return d.kind === 'videoinput';\\n              });\\n              var back = devices.find(function(d) {\\n                return d.label.toLowerCase().indexOf('back') !== -1;\\n              }) || (devices.length && devices[devices.length - 1]);\\n              if (back) {\\n                constraints.video.deviceId = face.exact ? {exact: back.deviceId} :\\n                                                          {ideal: back.deviceId};\\n              }\\n              constraints.video = constraintsToChrome_(constraints.video);\\n              logging('chrome: ' + JSON.stringify(constraints));\\n              return func(constraints);\\n            });\\n          }\\n        }\\n        constraints.video = constraintsToChrome_(constraints.video);\\n      }\\n      logging('chrome: ' + JSON.stringify(constraints));\\n      return func(constraints);\\n    };\\n\\n    var shimError_ = function(e) {\\n      return {\\n        name: {\\n          PermissionDeniedError: 'NotAllowedError',\\n          ConstraintNotSatisfiedError: 'OverconstrainedError'\\n        }[e.name] || e.name,\\n        message: e.message,\\n        constraint: e.constraintName,\\n        toString: function() {\\n          return this.name + (this.message && ': ') + this.message;\\n        }\\n      };\\n    };\\n\\n    var getUserMedia_ = function(constraints, onSuccess, onError) {\\n      shimConstraints_(constraints, function(c) {\\n        navigator.webkitGetUserMedia(c, onSuccess, function(e) {\\n          onError(shimError_(e));\\n        });\\n      });\\n    };\\n\\n    navigator.getUserMedia = getUserMedia_;\\n\\n    // Returns the result of getUserMedia as a Promise.\\n    var getUserMediaPromise_ = function(constraints) {\\n      return new Promise(function(resolve, reject) {\\n        navigator.getUserMedia(constraints, resolve, reject);\\n      });\\n    };\\n\\n    if (!navigator.mediaDevices) {\\n      navigator.mediaDevices = {\\n        getUserMedia: getUserMediaPromise_,\\n        enumerateDevices: function() {\\n          return new Promise(function(resolve) {\\n            var kinds = {audio: 'audioinput', video: 'videoinput'};\\n            return MediaStreamTrack.getSources(function(devices) {\\n              resolve(devices.map(function(device) {\\n                return {label: device.label,\\n                        kind: kinds[device.kind],\\n                        deviceId: device.id,\\n                        groupId: ''};\\n              }));\\n            });\\n          });\\n        }\\n      };\\n    }\\n\\n    // A shim for getUserMedia method on the mediaDevices object.\\n    // TODO(KaptenJansson) remove once implemented in Chrome stable.\\n    if (!navigator.mediaDevices.getUserMedia) {\\n      navigator.mediaDevices.getUserMedia = function(constraints) {\\n        return getUserMediaPromise_(constraints);\\n      };\\n    } else {\\n      // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\\n      // function which returns a Promise, it does not accept spec-style\\n      // constraints.\\n      var origGetUserMedia = navigator.mediaDevices.getUserMedia.\\n          bind(navigator.mediaDevices);\\n      navigator.mediaDevices.getUserMedia = function(cs) {\\n        return shimConstraints_(cs, function(c) {\\n          return origGetUserMedia(c).catch(function(e) {\\n            return Promise.reject(shimError_(e));\\n          });\\n        });\\n      };\\n    }\\n\\n    // Dummy devicechange event methods.\\n    // TODO(KaptenJansson) remove once implemented in Chrome stable.\\n    if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\\n      navigator.mediaDevices.addEventListener = function() {\\n        logging('Dummy mediaDevices.addEventListener called.');\\n      };\\n    }\\n    if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\\n      navigator.mediaDevices.removeEventListener = function() {\\n        logging('Dummy mediaDevices.removeEventListener called.');\\n      };\\n    }\\n  };\\n\\n  },{\\\"../utils.js\\\":10}],5:[function(require,module,exports){\\n  /*\\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n   *\\n   *  Use of this source code is governed by a BSD-style license\\n   *  that can be found in the LICENSE file in the root of the source\\n   *  tree.\\n   */\\n   /* eslint-env node */\\n  'use strict';\\n\\n  var SDPUtils = require('sdp');\\n  var browserDetails = require('../utils').browserDetails;\\n\\n  var edgeShim = {\\n    shimPeerConnection: function() {\\n      if (window.RTCIceGatherer) {\\n        // ORTC defines an RTCIceCandidate object but no constructor.\\n        // Not implemented in Edge.\\n        if (!window.RTCIceCandidate) {\\n          window.RTCIceCandidate = function(args) {\\n            return args;\\n          };\\n        }\\n        // ORTC does not have a session description object but\\n        // other browsers (i.e. Chrome) that will support both PC and ORTC\\n        // in the future might have this defined already.\\n        if (!window.RTCSessionDescription) {\\n          window.RTCSessionDescription = function(args) {\\n            return args;\\n          };\\n        }\\n      }\\n\\n      window.RTCPeerConnection = function(config) {\\n        var self = this;\\n\\n        var _eventTarget = document.createDocumentFragment();\\n        ['addEventListener', 'removeEventListener', 'dispatchEvent']\\n            .forEach(function(method) {\\n              self[method] = _eventTarget[method].bind(_eventTarget);\\n            });\\n\\n        this.onicecandidate = null;\\n        this.onaddstream = null;\\n        this.ontrack = null;\\n        this.onremovestream = null;\\n        this.onsignalingstatechange = null;\\n        this.oniceconnectionstatechange = null;\\n        this.onnegotiationneeded = null;\\n        this.ondatachannel = null;\\n\\n        this.localStreams = [];\\n        this.remoteStreams = [];\\n        this.getLocalStreams = function() {\\n          return self.localStreams;\\n        };\\n        this.getRemoteStreams = function() {\\n          return self.remoteStreams;\\n        };\\n\\n        this.localDescription = new RTCSessionDescription({\\n          type: '',\\n          sdp: ''\\n        });\\n        this.remoteDescription = new RTCSessionDescription({\\n          type: '',\\n          sdp: ''\\n        });\\n        this.signalingState = 'stable';\\n        this.iceConnectionState = 'new';\\n        this.iceGatheringState = 'new';\\n\\n        this.iceOptions = {\\n          gatherPolicy: 'all',\\n          iceServers: []\\n        };\\n        if (config && config.iceTransportPolicy) {\\n          switch (config.iceTransportPolicy) {\\n            case 'all':\\n            case 'relay':\\n              this.iceOptions.gatherPolicy = config.iceTransportPolicy;\\n              break;\\n            case 'none':\\n              // FIXME: remove once implementation and spec have added this.\\n              throw new TypeError('iceTransportPolicy \\\"none\\\" not supported');\\n            default:\\n              // don't set iceTransportPolicy.\\n              break;\\n          }\\n        }\\n        this.usingBundle = config && config.bundlePolicy === 'max-bundle';\\n\\n        if (config && config.iceServers) {\\n          // Edge does not like\\n          // 1) stun:\\n          // 2) turn: that does not have all of turn:host:port?transport=udp\\n          // 3) turn: with ipv6 addresses\\n          var iceServers = JSON.parse(JSON.stringify(config.iceServers));\\n          this.iceOptions.iceServers = iceServers.filter(function(server) {\\n            if (server && server.urls) {\\n              var urls = server.urls;\\n              if (typeof urls === 'string') {\\n                urls = [urls];\\n              }\\n              urls = urls.filter(function(url) {\\n                return (url.indexOf('turn:') === 0 &&\\n                    url.indexOf('transport=udp') !== -1 &&\\n                    url.indexOf('turn:[') === -1) ||\\n                    (url.indexOf('stun:') === 0 &&\\n                      browserDetails.version >= 14393);\\n              })[0];\\n              return !!urls;\\n            }\\n            return false;\\n          });\\n        }\\n\\n        // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\\n        // everything that is needed to describe a SDP m-line.\\n        this.transceivers = [];\\n\\n        // since the iceGatherer is currently created in createOffer but we\\n        // must not emit candidates until after setLocalDescription we buffer\\n        // them in this array.\\n        this._localIceCandidatesBuffer = [];\\n      };\\n\\n      window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {\\n        var self = this;\\n        var sections = SDPUtils.splitSections(self.localDescription.sdp);\\n        // FIXME: need to apply ice candidates in a way which is async but\\n        // in-order\\n        this._localIceCandidatesBuffer.forEach(function(event) {\\n          var end = !event.candidate || Object.keys(event.candidate).length === 0;\\n          if (end) {\\n            for (var j = 1; j < sections.length; j++) {\\n              if (sections[j].indexOf('\\\\r\\\\na=end-of-candidates\\\\r\\\\n') === -1) {\\n                sections[j] += 'a=end-of-candidates\\\\r\\\\n';\\n              }\\n            }\\n          } else if (event.candidate.candidate.indexOf('typ endOfCandidates')\\n              === -1) {\\n            sections[event.candidate.sdpMLineIndex + 1] +=\\n                'a=' + event.candidate.candidate + '\\\\r\\\\n';\\n          }\\n          self.localDescription.sdp = sections.join('');\\n          self.dispatchEvent(event);\\n          if (self.onicecandidate !== null) {\\n            self.onicecandidate(event);\\n          }\\n          if (!event.candidate && self.iceGatheringState !== 'complete') {\\n            var complete = self.transceivers.every(function(transceiver) {\\n              return transceiver.iceGatherer &&\\n                  transceiver.iceGatherer.state === 'completed';\\n            });\\n            if (complete) {\\n              self.iceGatheringState = 'complete';\\n            }\\n          }\\n        });\\n        this._localIceCandidatesBuffer = [];\\n      };\\n\\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\\n        // Clone is necessary for local demos mostly, attaching directly\\n        // to two different senders does not work (build 10547).\\n        this.localStreams.push(stream.clone());\\n        this._maybeFireNegotiationNeeded();\\n      };\\n\\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\\n        var idx = this.localStreams.indexOf(stream);\\n        if (idx > -1) {\\n          this.localStreams.splice(idx, 1);\\n          this._maybeFireNegotiationNeeded();\\n        }\\n      };\\n\\n      window.RTCPeerConnection.prototype.getSenders = function() {\\n        return this.transceivers.filter(function(transceiver) {\\n          return !!transceiver.rtpSender;\\n        })\\n        .map(function(transceiver) {\\n          return transceiver.rtpSender;\\n        });\\n      };\\n\\n      window.RTCPeerConnection.prototype.getReceivers = function() {\\n        return this.transceivers.filter(function(transceiver) {\\n          return !!transceiver.rtpReceiver;\\n        })\\n        .map(function(transceiver) {\\n          return transceiver.rtpReceiver;\\n        });\\n      };\\n\\n      // Determines the intersection of local and remote capabilities.\\n      window.RTCPeerConnection.prototype._getCommonCapabilities =\\n          function(localCapabilities, remoteCapabilities) {\\n            var commonCapabilities = {\\n              codecs: [],\\n              headerExtensions: [],\\n              fecMechanisms: []\\n            };\\n            localCapabilities.codecs.forEach(function(lCodec) {\\n              for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\\n                var rCodec = remoteCapabilities.codecs[i];\\n                if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\\n                    lCodec.clockRate === rCodec.clockRate &&\\n                    lCodec.numChannels === rCodec.numChannels) {\\n                  // push rCodec so we reply with offerer payload type\\n                  commonCapabilities.codecs.push(rCodec);\\n\\n                  // determine common feedback mechanisms\\n                  rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\\n                    for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\\n                      if (lCodec.rtcpFeedback[j].type === fb.type &&\\n                          lCodec.rtcpFeedback[j].parameter === fb.parameter) {\\n                        return true;\\n                      }\\n                    }\\n                    return false;\\n                  });\\n                  // FIXME: also need to determine .parameters\\n                  //  see https://github.com/openpeer/ortc/issues/569\\n                  break;\\n                }\\n              }\\n            });\\n\\n            localCapabilities.headerExtensions\\n                .forEach(function(lHeaderExtension) {\\n                  for (var i = 0; i < remoteCapabilities.headerExtensions.length;\\n                       i++) {\\n                    var rHeaderExtension = remoteCapabilities.headerExtensions[i];\\n                    if (lHeaderExtension.uri === rHeaderExtension.uri) {\\n                      commonCapabilities.headerExtensions.push(rHeaderExtension);\\n                      break;\\n                    }\\n                  }\\n                });\\n\\n            // FIXME: fecMechanisms\\n            return commonCapabilities;\\n          };\\n\\n      // Create ICE gatherer, ICE transport and DTLS transport.\\n      window.RTCPeerConnection.prototype._createIceAndDtlsTransports =\\n          function(mid, sdpMLineIndex) {\\n            var self = this;\\n            var iceGatherer = new RTCIceGatherer(self.iceOptions);\\n            var iceTransport = new RTCIceTransport(iceGatherer);\\n            iceGatherer.onlocalcandidate = function(evt) {\\n              var event = new Event('icecandidate');\\n              event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\\n\\n              var cand = evt.candidate;\\n              var end = !cand || Object.keys(cand).length === 0;\\n              // Edge emits an empty object for RTCIceCandidateComplete‥\\n              if (end) {\\n                // polyfill since RTCIceGatherer.state is not implemented in\\n                // Edge 10547 yet.\\n                if (iceGatherer.state === undefined) {\\n                  iceGatherer.state = 'completed';\\n                }\\n\\n                // Emit a candidate with type endOfCandidates to make the samples\\n                // work. Edge requires addIceCandidate with this empty candidate\\n                // to start checking. The real solution is to signal\\n                // end-of-candidates to the other side when getting the null\\n                // candidate but some apps (like the samples) don't do that.\\n                event.candidate.candidate =\\n                    'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';\\n              } else {\\n                // RTCIceCandidate doesn't have a component, needs to be added\\n                cand.component = iceTransport.component === 'RTCP' ? 2 : 1;\\n                event.candidate.candidate = SDPUtils.writeCandidate(cand);\\n              }\\n\\n              // update local description.\\n              var sections = SDPUtils.splitSections(self.localDescription.sdp);\\n              if (event.candidate.candidate.indexOf('typ endOfCandidates')\\n                  === -1) {\\n                sections[event.candidate.sdpMLineIndex + 1] +=\\n                    'a=' + event.candidate.candidate + '\\\\r\\\\n';\\n              } else {\\n                sections[event.candidate.sdpMLineIndex + 1] +=\\n                    'a=end-of-candidates\\\\r\\\\n';\\n              }\\n              self.localDescription.sdp = sections.join('');\\n\\n              var complete = self.transceivers.every(function(transceiver) {\\n                return transceiver.iceGatherer &&\\n                    transceiver.iceGatherer.state === 'completed';\\n              });\\n\\n              // Emit candidate if localDescription is set.\\n              // Also emits null candidate when all gatherers are complete.\\n              switch (self.iceGatheringState) {\\n                case 'new':\\n                  self._localIceCandidatesBuffer.push(event);\\n                  if (end && complete) {\\n                    self._localIceCandidatesBuffer.push(\\n                        new Event('icecandidate'));\\n                  }\\n                  break;\\n                case 'gathering':\\n                  self._emitBufferedCandidates();\\n                  self.dispatchEvent(event);\\n                  if (self.onicecandidate !== null) {\\n                    self.onicecandidate(event);\\n                  }\\n                  if (complete) {\\n                    self.dispatchEvent(new Event('icecandidate'));\\n                    if (self.onicecandidate !== null) {\\n                      self.onicecandidate(new Event('icecandidate'));\\n                    }\\n                    self.iceGatheringState = 'complete';\\n                  }\\n                  break;\\n                case 'complete':\\n                  // should not happen... currently!\\n                  break;\\n                default: // no-op.\\n                  break;\\n              }\\n            };\\n            iceTransport.onicestatechange = function() {\\n              self._updateConnectionState();\\n            };\\n\\n            var dtlsTransport = new RTCDtlsTransport(iceTransport);\\n            dtlsTransport.ondtlsstatechange = function() {\\n              self._updateConnectionState();\\n            };\\n            dtlsTransport.onerror = function() {\\n              // onerror does not set state to failed by itself.\\n              dtlsTransport.state = 'failed';\\n              self._updateConnectionState();\\n            };\\n\\n            return {\\n              iceGatherer: iceGatherer,\\n              iceTransport: iceTransport,\\n              dtlsTransport: dtlsTransport\\n            };\\n          };\\n\\n      // Start the RTP Sender and Receiver for a transceiver.\\n      window.RTCPeerConnection.prototype._transceive = function(transceiver,\\n          send, recv) {\\n        var params = this._getCommonCapabilities(transceiver.localCapabilities,\\n            transceiver.remoteCapabilities);\\n        if (send && transceiver.rtpSender) {\\n          params.encodings = transceiver.sendEncodingParameters;\\n          params.rtcp = {\\n            cname: SDPUtils.localCName\\n          };\\n          if (transceiver.recvEncodingParameters.length) {\\n            params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\\n          }\\n          transceiver.rtpSender.send(params);\\n        }\\n        if (recv && transceiver.rtpReceiver) {\\n          params.encodings = transceiver.recvEncodingParameters;\\n          params.rtcp = {\\n            cname: transceiver.cname\\n          };\\n          if (transceiver.sendEncodingParameters.length) {\\n            params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\\n          }\\n          transceiver.rtpReceiver.receive(params);\\n        }\\n      };\\n\\n      window.RTCPeerConnection.prototype.setLocalDescription =\\n          function(description) {\\n            var self = this;\\n            var sections;\\n            var sessionpart;\\n            if (description.type === 'offer') {\\n              // FIXME: What was the purpose of this empty if statement?\\n              // if (!this._pendingOffer) {\\n              // } else {\\n              if (this._pendingOffer) {\\n                // VERY limited support for SDP munging. Limited to:\\n                // * changing the order of codecs\\n                sections = SDPUtils.splitSections(description.sdp);\\n                sessionpart = sections.shift();\\n                sections.forEach(function(mediaSection, sdpMLineIndex) {\\n                  var caps = SDPUtils.parseRtpParameters(mediaSection);\\n                  self._pendingOffer[sdpMLineIndex].localCapabilities = caps;\\n                });\\n                this.transceivers = this._pendingOffer;\\n                delete this._pendingOffer;\\n              }\\n            } else if (description.type === 'answer') {\\n              sections = SDPUtils.splitSections(self.remoteDescription.sdp);\\n              sessionpart = sections.shift();\\n              var isIceLite = SDPUtils.matchPrefix(sessionpart,\\n                  'a=ice-lite').length > 0;\\n              sections.forEach(function(mediaSection, sdpMLineIndex) {\\n                var transceiver = self.transceivers[sdpMLineIndex];\\n                var iceGatherer = transceiver.iceGatherer;\\n                var iceTransport = transceiver.iceTransport;\\n                var dtlsTransport = transceiver.dtlsTransport;\\n                var localCapabilities = transceiver.localCapabilities;\\n                var remoteCapabilities = transceiver.remoteCapabilities;\\n\\n                var rejected = mediaSection.split('\\\\n', 1)[0]\\n                    .split(' ', 2)[1] === '0';\\n\\n                if (!rejected && !transceiver.isDatachannel) {\\n                  var remoteIceParameters = SDPUtils.getIceParameters(\\n                      mediaSection, sessionpart);\\n                  if (isIceLite) {\\n                    var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\\n                    .map(function(cand) {\\n                      return SDPUtils.parseCandidate(cand);\\n                    })\\n                    .filter(function(cand) {\\n                      return cand.component === '1';\\n                    });\\n                    // ice-lite only includes host candidates in the SDP so we can\\n                    // use setRemoteCandidates (which implies an\\n                    // RTCIceCandidateComplete)\\n                    if (cands.length) {\\n                      iceTransport.setRemoteCandidates(cands);\\n                    }\\n                  }\\n                  var remoteDtlsParameters = SDPUtils.getDtlsParameters(\\n                      mediaSection, sessionpart);\\n                  if (isIceLite) {\\n                    remoteDtlsParameters.role = 'server';\\n                  }\\n\\n                  if (!self.usingBundle || sdpMLineIndex === 0) {\\n                    iceTransport.start(iceGatherer, remoteIceParameters,\\n                        isIceLite ? 'controlling' : 'controlled');\\n                    dtlsTransport.start(remoteDtlsParameters);\\n                  }\\n\\n                  // Calculate intersection of capabilities.\\n                  var params = self._getCommonCapabilities(localCapabilities,\\n                      remoteCapabilities);\\n\\n                  // Start the RTCRtpSender. The RTCRtpReceiver for this\\n                  // transceiver has already been started in setRemoteDescription.\\n                  self._transceive(transceiver,\\n                      params.codecs.length > 0,\\n                      false);\\n                }\\n              });\\n            }\\n\\n            this.localDescription = {\\n              type: description.type,\\n              sdp: description.sdp\\n            };\\n            switch (description.type) {\\n              case 'offer':\\n                this._updateSignalingState('have-local-offer');\\n                break;\\n              case 'answer':\\n                this._updateSignalingState('stable');\\n                break;\\n              default:\\n                throw new TypeError('unsupported type \\\"' + description.type +\\n                    '\\\"');\\n            }\\n\\n            // If a success callback was provided, emit ICE candidates after it\\n            // has been executed. Otherwise, emit callback after the Promise is\\n            // resolved.\\n            var hasCallback = arguments.length > 1 &&\\n              typeof arguments[1] === 'function';\\n            if (hasCallback) {\\n              var cb = arguments[1];\\n              window.setTimeout(function() {\\n                cb();\\n                if (self.iceGatheringState === 'new') {\\n                  self.iceGatheringState = 'gathering';\\n                }\\n                self._emitBufferedCandidates();\\n              }, 0);\\n            }\\n            var p = Promise.resolve();\\n            p.then(function() {\\n              if (!hasCallback) {\\n                if (self.iceGatheringState === 'new') {\\n                  self.iceGatheringState = 'gathering';\\n                }\\n                // Usually candidates will be emitted earlier.\\n                window.setTimeout(self._emitBufferedCandidates.bind(self), 500);\\n              }\\n            });\\n            return p;\\n          };\\n\\n      window.RTCPeerConnection.prototype.setRemoteDescription =\\n          function(description) {\\n            var self = this;\\n            var stream = new MediaStream();\\n            var receiverList = [];\\n            var sections = SDPUtils.splitSections(description.sdp);\\n            var sessionpart = sections.shift();\\n            var isIceLite = SDPUtils.matchPrefix(sessionpart,\\n                'a=ice-lite').length > 0;\\n            this.usingBundle = SDPUtils.matchPrefix(sessionpart,\\n                'a=group:BUNDLE ').length > 0;\\n            sections.forEach(function(mediaSection, sdpMLineIndex) {\\n              var lines = SDPUtils.splitLines(mediaSection);\\n              var mline = lines[0].substr(2).split(' ');\\n              var kind = mline[0];\\n              var rejected = mline[1] === '0';\\n              var direction = SDPUtils.getDirection(mediaSection, sessionpart);\\n\\n              var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:');\\n              if (mid.length) {\\n                mid = mid[0].substr(6);\\n              } else {\\n                mid = SDPUtils.generateIdentifier();\\n              }\\n\\n              // Reject datachannels which are not implemented yet.\\n              if (kind === 'application' && mline[2] === 'DTLS/SCTP') {\\n                self.transceivers[sdpMLineIndex] = {\\n                  mid: mid,\\n                  isDatachannel: true\\n                };\\n                return;\\n              }\\n\\n              var transceiver;\\n              var iceGatherer;\\n              var iceTransport;\\n              var dtlsTransport;\\n              var rtpSender;\\n              var rtpReceiver;\\n              var sendEncodingParameters;\\n              var recvEncodingParameters;\\n              var localCapabilities;\\n\\n              var track;\\n              // FIXME: ensure the mediaSection has rtcp-mux set.\\n              var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\\n              var remoteIceParameters;\\n              var remoteDtlsParameters;\\n              if (!rejected) {\\n                remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\\n                    sessionpart);\\n                remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\\n                    sessionpart);\\n                remoteDtlsParameters.role = 'client';\\n              }\\n              recvEncodingParameters =\\n                  SDPUtils.parseRtpEncodingParameters(mediaSection);\\n\\n              var cname;\\n              // Gets the first SSRC. Note that with RTX there might be multiple\\n              // SSRCs.\\n              var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\\n                  .map(function(line) {\\n                    return SDPUtils.parseSsrcMedia(line);\\n                  })\\n                  .filter(function(obj) {\\n                    return obj.attribute === 'cname';\\n                  })[0];\\n              if (remoteSsrc) {\\n                cname = remoteSsrc.value;\\n              }\\n\\n              var isComplete = SDPUtils.matchPrefix(mediaSection,\\n                  'a=end-of-candidates', sessionpart).length > 0;\\n              var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\\n                  .map(function(cand) {\\n                    return SDPUtils.parseCandidate(cand);\\n                  })\\n                  .filter(function(cand) {\\n                    return cand.component === '1';\\n                  });\\n              if (description.type === 'offer' && !rejected) {\\n                var transports = self.usingBundle && sdpMLineIndex > 0 ? {\\n                  iceGatherer: self.transceivers[0].iceGatherer,\\n                  iceTransport: self.transceivers[0].iceTransport,\\n                  dtlsTransport: self.transceivers[0].dtlsTransport\\n                } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);\\n\\n                if (isComplete) {\\n                  transports.iceTransport.setRemoteCandidates(cands);\\n                }\\n\\n                localCapabilities = RTCRtpReceiver.getCapabilities(kind);\\n                sendEncodingParameters = [{\\n                  ssrc: (2 * sdpMLineIndex + 2) * 1001\\n                }];\\n\\n                rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);\\n\\n                track = rtpReceiver.track;\\n                receiverList.push([track, rtpReceiver]);\\n                // FIXME: not correct when there are multiple streams but that is\\n                // not currently supported in this shim.\\n                stream.addTrack(track);\\n\\n                // FIXME: look at direction.\\n                if (self.localStreams.length > 0 &&\\n                    self.localStreams[0].getTracks().length >= sdpMLineIndex) {\\n                  var localTrack;\\n                  if (kind === 'audio') {\\n                    localTrack = self.localStreams[0].getAudioTracks()[0];\\n                  } else if (kind === 'video') {\\n                    localTrack = self.localStreams[0].getVideoTracks()[0];\\n                  }\\n                  if (localTrack) {\\n                    rtpSender = new RTCRtpSender(localTrack,\\n                        transports.dtlsTransport);\\n                  }\\n                }\\n\\n                self.transceivers[sdpMLineIndex] = {\\n                  iceGatherer: transports.iceGatherer,\\n                  iceTransport: transports.iceTransport,\\n                  dtlsTransport: transports.dtlsTransport,\\n                  localCapabilities: localCapabilities,\\n                  remoteCapabilities: remoteCapabilities,\\n                  rtpSender: rtpSender,\\n                  rtpReceiver: rtpReceiver,\\n                  kind: kind,\\n                  mid: mid,\\n                  cname: cname,\\n                  sendEncodingParameters: sendEncodingParameters,\\n                  recvEncodingParameters: recvEncodingParameters\\n                };\\n                // Start the RTCRtpReceiver now. The RTPSender is started in\\n                // setLocalDescription.\\n                self._transceive(self.transceivers[sdpMLineIndex],\\n                    false,\\n                    direction === 'sendrecv' || direction === 'sendonly');\\n              } else if (description.type === 'answer' && !rejected) {\\n                transceiver = self.transceivers[sdpMLineIndex];\\n                iceGatherer = transceiver.iceGatherer;\\n                iceTransport = transceiver.iceTransport;\\n                dtlsTransport = transceiver.dtlsTransport;\\n                rtpSender = transceiver.rtpSender;\\n                rtpReceiver = transceiver.rtpReceiver;\\n                sendEncodingParameters = transceiver.sendEncodingParameters;\\n                localCapabilities = transceiver.localCapabilities;\\n\\n                self.transceivers[sdpMLineIndex].recvEncodingParameters =\\n                    recvEncodingParameters;\\n                self.transceivers[sdpMLineIndex].remoteCapabilities =\\n                    remoteCapabilities;\\n                self.transceivers[sdpMLineIndex].cname = cname;\\n\\n                if ((isIceLite || isComplete) && cands.length) {\\n                  iceTransport.setRemoteCandidates(cands);\\n                }\\n                if (!self.usingBundle || sdpMLineIndex === 0) {\\n                  iceTransport.start(iceGatherer, remoteIceParameters,\\n                      'controlling');\\n                  dtlsTransport.start(remoteDtlsParameters);\\n                }\\n\\n                self._transceive(transceiver,\\n                    direction === 'sendrecv' || direction === 'recvonly',\\n                    direction === 'sendrecv' || direction === 'sendonly');\\n\\n                if (rtpReceiver &&\\n                    (direction === 'sendrecv' || direction === 'sendonly')) {\\n                  track = rtpReceiver.track;\\n                  receiverList.push([track, rtpReceiver]);\\n                  stream.addTrack(track);\\n                } else {\\n                  // FIXME: actually the receiver should be created later.\\n                  delete transceiver.rtpReceiver;\\n                }\\n              }\\n            });\\n\\n            this.remoteDescription = {\\n              type: description.type,\\n              sdp: description.sdp\\n            };\\n            switch (description.type) {\\n              case 'offer':\\n                this._updateSignalingState('have-remote-offer');\\n                break;\\n              case 'answer':\\n                this._updateSignalingState('stable');\\n                break;\\n              default:\\n                throw new TypeError('unsupported type \\\"' + description.type +\\n                    '\\\"');\\n            }\\n            if (stream.getTracks().length) {\\n              self.remoteStreams.push(stream);\\n              window.setTimeout(function() {\\n                var event = new Event('addstream');\\n                event.stream = stream;\\n                self.dispatchEvent(event);\\n                if (self.onaddstream !== null) {\\n                  window.setTimeout(function() {\\n                    self.onaddstream(event);\\n                  }, 0);\\n                }\\n\\n                receiverList.forEach(function(item) {\\n                  var track = item[0];\\n                  var receiver = item[1];\\n                  var trackEvent = new Event('track');\\n                  trackEvent.track = track;\\n                  trackEvent.receiver = receiver;\\n                  trackEvent.streams = [stream];\\n                  self.dispatchEvent(event);\\n                  if (self.ontrack !== null) {\\n                    window.setTimeout(function() {\\n                      self.ontrack(trackEvent);\\n                    }, 0);\\n                  }\\n                });\\n              }, 0);\\n            }\\n            if (arguments.length > 1 && typeof arguments[1] === 'function') {\\n              window.setTimeout(arguments[1], 0);\\n            }\\n            return Promise.resolve();\\n          };\\n\\n      window.RTCPeerConnection.prototype.close = function() {\\n        this.transceivers.forEach(function(transceiver) {\\n          /* not yet\\n          if (transceiver.iceGatherer) {\\n            transceiver.iceGatherer.close();\\n          }\\n          */\\n          if (transceiver.iceTransport) {\\n            transceiver.iceTransport.stop();\\n          }\\n          if (transceiver.dtlsTransport) {\\n            transceiver.dtlsTransport.stop();\\n          }\\n          if (transceiver.rtpSender) {\\n            transceiver.rtpSender.stop();\\n          }\\n          if (transceiver.rtpReceiver) {\\n            transceiver.rtpReceiver.stop();\\n          }\\n        });\\n        // FIXME: clean up tracks, local streams, remote streams, etc\\n        this._updateSignalingState('closed');\\n      };\\n\\n      // Update the signaling state.\\n      window.RTCPeerConnection.prototype._updateSignalingState =\\n          function(newState) {\\n            this.signalingState = newState;\\n            var event = new Event('signalingstatechange');\\n            this.dispatchEvent(event);\\n            if (this.onsignalingstatechange !== null) {\\n              this.onsignalingstatechange(event);\\n            }\\n          };\\n\\n      // Determine whether to fire the negotiationneeded event.\\n      window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded =\\n          function() {\\n            // Fire away (for now).\\n            var event = new Event('negotiationneeded');\\n            this.dispatchEvent(event);\\n            if (this.onnegotiationneeded !== null) {\\n              this.onnegotiationneeded(event);\\n            }\\n          };\\n\\n      // Update the connection state.\\n      window.RTCPeerConnection.prototype._updateConnectionState = function() {\\n        var self = this;\\n        var newState;\\n        var states = {\\n          'new': 0,\\n          closed: 0,\\n          connecting: 0,\\n          checking: 0,\\n          connected: 0,\\n          completed: 0,\\n          failed: 0\\n        };\\n        this.transceivers.forEach(function(transceiver) {\\n          states[transceiver.iceTransport.state]++;\\n          states[transceiver.dtlsTransport.state]++;\\n        });\\n        // ICETransport.completed and connected are the same for this purpose.\\n        states.connected += states.completed;\\n\\n        newState = 'new';\\n        if (states.failed > 0) {\\n          newState = 'failed';\\n        } else if (states.connecting > 0 || states.checking > 0) {\\n          newState = 'connecting';\\n        } else if (states.disconnected > 0) {\\n          newState = 'disconnected';\\n        } else if (states.new > 0) {\\n          newState = 'new';\\n        } else if (states.connected > 0 || states.completed > 0) {\\n          newState = 'connected';\\n        }\\n\\n        if (newState !== self.iceConnectionState) {\\n          self.iceConnectionState = newState;\\n          var event = new Event('iceconnectionstatechange');\\n          this.dispatchEvent(event);\\n          if (this.oniceconnectionstatechange !== null) {\\n            this.oniceconnectionstatechange(event);\\n          }\\n        }\\n      };\\n\\n      window.RTCPeerConnection.prototype.createOffer = function() {\\n        var self = this;\\n        if (this._pendingOffer) {\\n          throw new Error('createOffer called while there is a pending offer.');\\n        }\\n        var offerOptions;\\n        if (arguments.length === 1 && typeof arguments[0] !== 'function') {\\n          offerOptions = arguments[0];\\n        } else if (arguments.length === 3) {\\n          offerOptions = arguments[2];\\n        }\\n\\n        var tracks = [];\\n        var numAudioTracks = 0;\\n        var numVideoTracks = 0;\\n        // Default to sendrecv.\\n        if (this.localStreams.length) {\\n          numAudioTracks = this.localStreams[0].getAudioTracks().length;\\n          numVideoTracks = this.localStreams[0].getVideoTracks().length;\\n        }\\n        // Determine number of audio and video tracks we need to send/recv.\\n        if (offerOptions) {\\n          // Reject Chrome legacy constraints.\\n          if (offerOptions.mandatory || offerOptions.optional) {\\n            throw new TypeError(\\n                'Legacy mandatory/optional constraints not supported.');\\n          }\\n          if (offerOptions.offerToReceiveAudio !== undefined) {\\n            numAudioTracks = offerOptions.offerToReceiveAudio;\\n          }\\n          if (offerOptions.offerToReceiveVideo !== undefined) {\\n            numVideoTracks = offerOptions.offerToReceiveVideo;\\n          }\\n        }\\n        if (this.localStreams.length) {\\n          // Push local streams.\\n          this.localStreams[0].getTracks().forEach(function(track) {\\n            tracks.push({\\n              kind: track.kind,\\n              track: track,\\n              wantReceive: track.kind === 'audio' ?\\n                  numAudioTracks > 0 : numVideoTracks > 0\\n            });\\n            if (track.kind === 'audio') {\\n              numAudioTracks--;\\n            } else if (track.kind === 'video') {\\n              numVideoTracks--;\\n            }\\n          });\\n        }\\n        // Create M-lines for recvonly streams.\\n        while (numAudioTracks > 0 || numVideoTracks > 0) {\\n          if (numAudioTracks > 0) {\\n            tracks.push({\\n              kind: 'audio',\\n              wantReceive: true\\n            });\\n            numAudioTracks--;\\n          }\\n          if (numVideoTracks > 0) {\\n            tracks.push({\\n              kind: 'video',\\n              wantReceive: true\\n            });\\n            numVideoTracks--;\\n          }\\n        }\\n\\n        var sdp = SDPUtils.writeSessionBoilerplate();\\n        var transceivers = [];\\n        tracks.forEach(function(mline, sdpMLineIndex) {\\n          // For each track, create an ice gatherer, ice transport,\\n          // dtls transport, potentially rtpsender and rtpreceiver.\\n          var track = mline.track;\\n          var kind = mline.kind;\\n          var mid = SDPUtils.generateIdentifier();\\n\\n          var transports = self.usingBundle && sdpMLineIndex > 0 ? {\\n            iceGatherer: transceivers[0].iceGatherer,\\n            iceTransport: transceivers[0].iceTransport,\\n            dtlsTransport: transceivers[0].dtlsTransport\\n          } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);\\n\\n          var localCapabilities = RTCRtpSender.getCapabilities(kind);\\n          var rtpSender;\\n          var rtpReceiver;\\n\\n          // generate an ssrc now, to be used later in rtpSender.send\\n          var sendEncodingParameters = [{\\n            ssrc: (2 * sdpMLineIndex + 1) * 1001\\n          }];\\n          if (track) {\\n            rtpSender = new RTCRtpSender(track, transports.dtlsTransport);\\n          }\\n\\n          if (mline.wantReceive) {\\n            rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);\\n          }\\n\\n          transceivers[sdpMLineIndex] = {\\n            iceGatherer: transports.iceGatherer,\\n            iceTransport: transports.iceTransport,\\n            dtlsTransport: transports.dtlsTransport,\\n            localCapabilities: localCapabilities,\\n            remoteCapabilities: null,\\n            rtpSender: rtpSender,\\n            rtpReceiver: rtpReceiver,\\n            kind: kind,\\n            mid: mid,\\n            sendEncodingParameters: sendEncodingParameters,\\n            recvEncodingParameters: null\\n          };\\n        });\\n        if (this.usingBundle) {\\n          sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) {\\n            return t.mid;\\n          }).join(' ') + '\\\\r\\\\n';\\n        }\\n        tracks.forEach(function(mline, sdpMLineIndex) {\\n          var transceiver = transceivers[sdpMLineIndex];\\n          sdp += SDPUtils.writeMediaSection(transceiver,\\n              transceiver.localCapabilities, 'offer', self.localStreams[0]);\\n        });\\n\\n        this._pendingOffer = transceivers;\\n        var desc = new RTCSessionDescription({\\n          type: 'offer',\\n          sdp: sdp\\n        });\\n        if (arguments.length && typeof arguments[0] === 'function') {\\n          window.setTimeout(arguments[0], 0, desc);\\n        }\\n        return Promise.resolve(desc);\\n      };\\n\\n      window.RTCPeerConnection.prototype.createAnswer = function() {\\n        var self = this;\\n\\n        var sdp = SDPUtils.writeSessionBoilerplate();\\n        if (this.usingBundle) {\\n          sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {\\n            return t.mid;\\n          }).join(' ') + '\\\\r\\\\n';\\n        }\\n        this.transceivers.forEach(function(transceiver) {\\n          if (transceiver.isDatachannel) {\\n            sdp += 'm=application 0 DTLS/SCTP 5000\\\\r\\\\n' +\\n                'c=IN IP4 0.0.0.0\\\\r\\\\n' +\\n                'a=mid:' + transceiver.mid + '\\\\r\\\\n';\\n            return;\\n          }\\n          // Calculate intersection of capabilities.\\n          var commonCapabilities = self._getCommonCapabilities(\\n              transceiver.localCapabilities,\\n              transceiver.remoteCapabilities);\\n\\n          sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,\\n              'answer', self.localStreams[0]);\\n        });\\n\\n        var desc = new RTCSessionDescription({\\n          type: 'answer',\\n          sdp: sdp\\n        });\\n        if (arguments.length && typeof arguments[0] === 'function') {\\n          window.setTimeout(arguments[0], 0, desc);\\n        }\\n        return Promise.resolve(desc);\\n      };\\n\\n      window.RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\\n        if (candidate === null) {\\n          this.transceivers.forEach(function(transceiver) {\\n            transceiver.iceTransport.addRemoteCandidate({});\\n          });\\n        } else {\\n          var mLineIndex = candidate.sdpMLineIndex;\\n          if (candidate.sdpMid) {\\n            for (var i = 0; i < this.transceivers.length; i++) {\\n              if (this.transceivers[i].mid === candidate.sdpMid) {\\n                mLineIndex = i;\\n                break;\\n              }\\n            }\\n          }\\n          var transceiver = this.transceivers[mLineIndex];\\n          if (transceiver) {\\n            var cand = Object.keys(candidate.candidate).length > 0 ?\\n                SDPUtils.parseCandidate(candidate.candidate) : {};\\n            // Ignore Chrome's invalid candidates since Edge does not like them.\\n            if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\\n              return;\\n            }\\n            // Ignore RTCP candidates, we assume RTCP-MUX.\\n            if (cand.component !== '1') {\\n              return;\\n            }\\n            // A dirty hack to make samples work.\\n            if (cand.type === 'endOfCandidates') {\\n              cand = {};\\n            }\\n            transceiver.iceTransport.addRemoteCandidate(cand);\\n\\n            // update the remoteDescription.\\n            var sections = SDPUtils.splitSections(this.remoteDescription.sdp);\\n            sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim()\\n                : 'a=end-of-candidates') + '\\\\r\\\\n';\\n            this.remoteDescription.sdp = sections.join('');\\n          }\\n        }\\n        if (arguments.length > 1 && typeof arguments[1] === 'function') {\\n          window.setTimeout(arguments[1], 0);\\n        }\\n        return Promise.resolve();\\n      };\\n\\n      window.RTCPeerConnection.prototype.getStats = function() {\\n        var promises = [];\\n        this.transceivers.forEach(function(transceiver) {\\n          ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\\n              'dtlsTransport'].forEach(function(method) {\\n                if (transceiver[method]) {\\n                  promises.push(transceiver[method].getStats());\\n                }\\n              });\\n        });\\n        var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&\\n            arguments[1];\\n        return new Promise(function(resolve) {\\n          // shim getStats with maplike support\\n          var results = new Map();\\n          Promise.all(promises).then(function(res) {\\n            res.forEach(function(result) {\\n              Object.keys(result).forEach(function(id) {\\n                results.set(id, result[id]);\\n                results[id] = result[id];\\n              });\\n            });\\n            if (cb) {\\n              window.setTimeout(cb, 0, results);\\n            }\\n            resolve(results);\\n          });\\n        });\\n      };\\n    }\\n  };\\n\\n  // Expose public methods.\\n  module.exports = {\\n    shimPeerConnection: edgeShim.shimPeerConnection,\\n    shimGetUserMedia: require('./getusermedia')\\n  };\\n\\n  },{\\\"../utils\\\":10,\\\"./getusermedia\\\":6,\\\"sdp\\\":1}],6:[function(require,module,exports){\\n  /*\\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n   *\\n   *  Use of this source code is governed by a BSD-style license\\n   *  that can be found in the LICENSE file in the root of the source\\n   *  tree.\\n   */\\n   /* eslint-env node */\\n  'use strict';\\n\\n  // Expose public methods.\\n  module.exports = function() {\\n    var shimError_ = function(e) {\\n      return {\\n        name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\\n        message: e.message,\\n        constraint: e.constraint,\\n        toString: function() {\\n          return this.name;\\n        }\\n      };\\n    };\\n\\n    // getUserMedia error shim.\\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\\n        bind(navigator.mediaDevices);\\n    navigator.mediaDevices.getUserMedia = function(c) {\\n      return origGetUserMedia(c).catch(function(e) {\\n        return Promise.reject(shimError_(e));\\n      });\\n    };\\n  };\\n\\n  },{}],7:[function(require,module,exports){\\n  /*\\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n   *\\n   *  Use of this source code is governed by a BSD-style license\\n   *  that can be found in the LICENSE file in the root of the source\\n   *  tree.\\n   */\\n   /* eslint-env node */\\n  'use strict';\\n\\n  var browserDetails = require('../utils').browserDetails;\\n\\n  var firefoxShim = {\\n    shimOnTrack: function() {\\n      if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\\n          window.RTCPeerConnection.prototype)) {\\n        Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\\n          get: function() {\\n            return this._ontrack;\\n          },\\n          set: function(f) {\\n            if (this._ontrack) {\\n              this.removeEventListener('track', this._ontrack);\\n              this.removeEventListener('addstream', this._ontrackpoly);\\n            }\\n            this.addEventListener('track', this._ontrack = f);\\n            this.addEventListener('addstream', this._ontrackpoly = function(e) {\\n              e.stream.getTracks().forEach(function(track) {\\n                var event = new Event('track');\\n                event.track = track;\\n                event.receiver = {track: track};\\n                event.streams = [e.stream];\\n                this.dispatchEvent(event);\\n              }.bind(this));\\n            }.bind(this));\\n          }\\n        });\\n      }\\n    },\\n\\n    shimSourceObject: function() {\\n      // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\\n      if (typeof window === 'object') {\\n        if (window.HTMLMediaElement &&\\n          !('srcObject' in window.HTMLMediaElement.prototype)) {\\n          // Shim the srcObject property, once, when HTMLMediaElement is found.\\n          Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\\n            get: function() {\\n              return this.mozSrcObject;\\n            },\\n            set: function(stream) {\\n              this.mozSrcObject = stream;\\n            }\\n          });\\n        }\\n      }\\n    },\\n\\n    shimPeerConnection: function() {\\n      if (typeof window !== 'object' || !(window.RTCPeerConnection ||\\n          window.mozRTCPeerConnection)) {\\n        return; // probably media.peerconnection.enabled=false in about:config\\n      }\\n      // The RTCPeerConnection object.\\n      if (!window.RTCPeerConnection) {\\n        window.RTCPeerConnection = function(pcConfig, pcConstraints) {\\n          if (browserDetails.version < 38) {\\n            // .urls is not supported in FF < 38.\\n            // create RTCIceServers with a single url.\\n            if (pcConfig && pcConfig.iceServers) {\\n              var newIceServers = [];\\n              for (var i = 0; i < pcConfig.iceServers.length; i++) {\\n                var server = pcConfig.iceServers[i];\\n                if (server.hasOwnProperty('urls')) {\\n                  for (var j = 0; j < server.urls.length; j++) {\\n                    var newServer = {\\n                      url: server.urls[j]\\n                    };\\n                    if (server.urls[j].indexOf('turn') === 0) {\\n                      newServer.username = server.username;\\n                      newServer.credential = server.credential;\\n                    }\\n                    newIceServers.push(newServer);\\n                  }\\n                } else {\\n                  newIceServers.push(pcConfig.iceServers[i]);\\n                }\\n              }\\n              pcConfig.iceServers = newIceServers;\\n            }\\n          }\\n          return new mozRTCPeerConnection(pcConfig, pcConstraints);\\n        };\\n        window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype;\\n\\n        // wrap static methods. Currently just generateCertificate.\\n        if (mozRTCPeerConnection.generateCertificate) {\\n          Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\\n            get: function() {\\n              return mozRTCPeerConnection.generateCertificate;\\n            }\\n          });\\n        }\\n\\n        window.RTCSessionDescription = mozRTCSessionDescription;\\n        window.RTCIceCandidate = mozRTCIceCandidate;\\n      }\\n\\n      // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\\n          .forEach(function(method) {\\n            var nativeMethod = RTCPeerConnection.prototype[method];\\n            RTCPeerConnection.prototype[method] = function() {\\n              arguments[0] = new ((method === 'addIceCandidate') ?\\n                  RTCIceCandidate : RTCSessionDescription)(arguments[0]);\\n              return nativeMethod.apply(this, arguments);\\n            };\\n          });\\n\\n      // support for addIceCandidate(null)\\n      var nativeAddIceCandidate =\\n          RTCPeerConnection.prototype.addIceCandidate;\\n      RTCPeerConnection.prototype.addIceCandidate = function() {\\n        return arguments[0] === null ? Promise.resolve()\\n            : nativeAddIceCandidate.apply(this, arguments);\\n      };\\n\\n      // shim getStats with maplike support\\n      var makeMapStats = function(stats) {\\n        var map = new Map();\\n        Object.keys(stats).forEach(function(key) {\\n          map.set(key, stats[key]);\\n          map[key] = stats[key];\\n        });\\n        return map;\\n      };\\n\\n      var nativeGetStats = RTCPeerConnection.prototype.getStats;\\n      RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) {\\n        return nativeGetStats.apply(this, [selector || null])\\n          .then(function(stats) {\\n            return makeMapStats(stats);\\n          })\\n          .then(onSucc, onErr);\\n      };\\n    }\\n  };\\n\\n  // Expose public methods.\\n  module.exports = {\\n    shimOnTrack: firefoxShim.shimOnTrack,\\n    shimSourceObject: firefoxShim.shimSourceObject,\\n    shimPeerConnection: firefoxShim.shimPeerConnection,\\n    shimGetUserMedia: require('./getusermedia')\\n  };\\n\\n  },{\\\"../utils\\\":10,\\\"./getusermedia\\\":8}],8:[function(require,module,exports){\\n  /*\\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n   *\\n   *  Use of this source code is governed by a BSD-style license\\n   *  that can be found in the LICENSE file in the root of the source\\n   *  tree.\\n   */\\n   /* eslint-env node */\\n  'use strict';\\n\\n  var logging = require('../utils').log;\\n  var browserDetails = require('../utils').browserDetails;\\n\\n  // Expose public methods.\\n  module.exports = function() {\\n    var shimError_ = function(e) {\\n      return {\\n        name: {\\n          SecurityError: 'NotAllowedError',\\n          PermissionDeniedError: 'NotAllowedError'\\n        }[e.name] || e.name,\\n        message: {\\n          'The operation is insecure.': 'The request is not allowed by the ' +\\n          'user agent or the platform in the current context.'\\n        }[e.message] || e.message,\\n        constraint: e.constraint,\\n        toString: function() {\\n          return this.name + (this.message && ': ') + this.message;\\n        }\\n      };\\n    };\\n\\n    // getUserMedia constraints shim.\\n    var getUserMedia_ = function(constraints, onSuccess, onError) {\\n      var constraintsToFF37_ = function(c) {\\n        if (typeof c !== 'object' || c.require) {\\n          return c;\\n        }\\n        var require = [];\\n        Object.keys(c).forEach(function(key) {\\n          if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\\n            return;\\n          }\\n          var r = c[key] = (typeof c[key] === 'object') ?\\n              c[key] : {ideal: c[key]};\\n          if (r.min !== undefined ||\\n              r.max !== undefined || r.exact !== undefined) {\\n            require.push(key);\\n          }\\n          if (r.exact !== undefined) {\\n            if (typeof r.exact === 'number') {\\n              r. min = r.max = r.exact;\\n            } else {\\n              c[key] = r.exact;\\n            }\\n            delete r.exact;\\n          }\\n          if (r.ideal !== undefined) {\\n            c.advanced = c.advanced || [];\\n            var oc = {};\\n            if (typeof r.ideal === 'number') {\\n              oc[key] = {min: r.ideal, max: r.ideal};\\n            } else {\\n              oc[key] = r.ideal;\\n            }\\n            c.advanced.push(oc);\\n            delete r.ideal;\\n            if (!Object.keys(r).length) {\\n              delete c[key];\\n            }\\n          }\\n        });\\n        if (require.length) {\\n          c.require = require;\\n        }\\n        return c;\\n      };\\n      constraints = JSON.parse(JSON.stringify(constraints));\\n      if (browserDetails.version < 38) {\\n        logging('spec: ' + JSON.stringify(constraints));\\n        if (constraints.audio) {\\n          constraints.audio = constraintsToFF37_(constraints.audio);\\n        }\\n        if (constraints.video) {\\n          constraints.video = constraintsToFF37_(constraints.video);\\n        }\\n        logging('ff37: ' + JSON.stringify(constraints));\\n      }\\n      return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {\\n        onError(shimError_(e));\\n      });\\n    };\\n\\n    // Returns the result of getUserMedia as a Promise.\\n    var getUserMediaPromise_ = function(constraints) {\\n      return new Promise(function(resolve, reject) {\\n        getUserMedia_(constraints, resolve, reject);\\n      });\\n    };\\n\\n    // Shim for mediaDevices on older versions.\\n    if (!navigator.mediaDevices) {\\n      navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,\\n        addEventListener: function() { },\\n        removeEventListener: function() { }\\n      };\\n    }\\n    navigator.mediaDevices.enumerateDevices =\\n        navigator.mediaDevices.enumerateDevices || function() {\\n          return new Promise(function(resolve) {\\n            var infos = [\\n              {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},\\n              {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}\\n            ];\\n            resolve(infos);\\n          });\\n        };\\n\\n    if (browserDetails.version < 41) {\\n      // Work around http://bugzil.la/1169665\\n      var orgEnumerateDevices =\\n          navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\\n      navigator.mediaDevices.enumerateDevices = function() {\\n        return orgEnumerateDevices().then(undefined, function(e) {\\n          if (e.name === 'NotFoundError') {\\n            return [];\\n          }\\n          throw e;\\n        });\\n      };\\n    }\\n    if (browserDetails.version < 49) {\\n      var origGetUserMedia = navigator.mediaDevices.getUserMedia.\\n          bind(navigator.mediaDevices);\\n      navigator.mediaDevices.getUserMedia = function(c) {\\n        return origGetUserMedia(c).catch(function(e) {\\n          return Promise.reject(shimError_(e));\\n        });\\n      };\\n    }\\n    navigator.getUserMedia = function(constraints, onSuccess, onError) {\\n      if (browserDetails.version < 44) {\\n        return getUserMedia_(constraints, onSuccess, onError);\\n      }\\n      // Replace Firefox 44+'s deprecation warning with unprefixed version.\\n      console.warn('navigator.getUserMedia has been replaced by ' +\\n                   'navigator.mediaDevices.getUserMedia');\\n      navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\\n    };\\n  };\\n\\n  },{\\\"../utils\\\":10}],9:[function(require,module,exports){\\n  /*\\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n   *\\n   *  Use of this source code is governed by a BSD-style license\\n   *  that can be found in the LICENSE file in the root of the source\\n   *  tree.\\n   */\\n  'use strict';\\n  var safariShim = {\\n    // TODO: DrAlex, should be here, double check against LayoutTests\\n    // shimOnTrack: function() { },\\n\\n    // TODO: once the back-end for the mac port is done, add.\\n    // TODO: check for webkitGTK+\\n    // shimPeerConnection: function() { },\\n\\n    shimGetUserMedia: function() {\\n      navigator.getUserMedia = navigator.webkitGetUserMedia;\\n    }\\n  };\\n\\n  // Expose public methods.\\n  module.exports = {\\n    shimGetUserMedia: safariShim.shimGetUserMedia\\n    // TODO\\n    // shimOnTrack: safariShim.shimOnTrack,\\n    // shimPeerConnection: safariShim.shimPeerConnection\\n  };\\n\\n  },{}],10:[function(require,module,exports){\\n  /*\\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n   *\\n   *  Use of this source code is governed by a BSD-style license\\n   *  that can be found in the LICENSE file in the root of the source\\n   *  tree.\\n   */\\n   /* eslint-env node */\\n  'use strict';\\n\\n  var logDisabled_ = true;\\n\\n  // Utility methods.\\n  var utils = {\\n    disableLog: function(bool) {\\n      if (typeof bool !== 'boolean') {\\n        return new Error('Argument type: ' + typeof bool +\\n            '. Please use a boolean.');\\n      }\\n      logDisabled_ = bool;\\n      return (bool) ? 'adapter.js logging disabled' :\\n          'adapter.js logging enabled';\\n    },\\n\\n    log: function() {\\n      if (typeof window === 'object') {\\n        if (logDisabled_) {\\n          return;\\n        }\\n        if (typeof console !== 'undefined' && typeof console.log === 'function') {\\n          console.log.apply(console, arguments);\\n        }\\n      }\\n    },\\n\\n    /**\\n     * Extract browser version out of the provided user agent string.\\n     *\\n     * @param {!string} uastring userAgent string.\\n     * @param {!string} expr Regular expression used as match criteria.\\n     * @param {!number} pos position in the version string to be returned.\\n     * @return {!number} browser version.\\n     */\\n    extractVersion: function(uastring, expr, pos) {\\n      var match = uastring.match(expr);\\n      return match && match.length >= pos && parseInt(match[pos], 10);\\n    },\\n\\n    /**\\n     * Browser detector.\\n     *\\n     * @return {object} result containing browser and version\\n     *     properties.\\n     */\\n    detectBrowser: function() {\\n      // Returned result object.\\n      var result = {};\\n      result.browser = null;\\n      result.version = null;\\n\\n      // Fail early if it's not a browser\\n      if (typeof window === 'undefined' || !window.navigator) {\\n        result.browser = 'Not a browser.';\\n        return result;\\n      }\\n\\n      // Firefox.\\n      if (navigator.mozGetUserMedia) {\\n        result.browser = 'firefox';\\n        result.version = this.extractVersion(navigator.userAgent,\\n            /Firefox\\\\/([0-9]+)\\\\./, 1);\\n\\n      // all webkit-based browsers\\n      } else if (navigator.webkitGetUserMedia) {\\n        // Chrome, Chromium, Webview, Opera, all use the chrome shim for now\\n        if (window.webkitRTCPeerConnection) {\\n          result.browser = 'chrome';\\n          result.version = this.extractVersion(navigator.userAgent,\\n            /Chrom(e|ium)\\\\/([0-9]+)\\\\./, 2);\\n\\n        // Safari or unknown webkit-based\\n        // for the time being Safari has support for MediaStreams but not webRTC\\n        } else {\\n          // Safari UA substrings of interest for reference:\\n          // - webkit version:           AppleWebKit/602.1.25 (also used in Op,Cr)\\n          // - safari UI version:        Version/9.0.3 (unique to Safari)\\n          // - safari UI webkit version: Safari/601.4.4 (also used in Op,Cr)\\n          //\\n          // if the webkit version and safari UI webkit versions are equals,\\n          // ... this is a stable version.\\n          //\\n          // only the internal webkit version is important today to know if\\n          // media streams are supported\\n          //\\n          if (navigator.userAgent.match(/Version\\\\/(\\\\d+).(\\\\d+)/)) {\\n            result.browser = 'safari';\\n            result.version = this.extractVersion(navigator.userAgent,\\n              /AppleWebKit\\\\/([0-9]+)\\\\./, 1);\\n\\n          // unknown webkit-based browser\\n          } else {\\n            result.browser = 'Unsupported webkit-based browser ' +\\n                'with GUM support but no WebRTC support.';\\n            return result;\\n          }\\n        }\\n\\n      // Edge.\\n      } else if (navigator.mediaDevices &&\\n          navigator.userAgent.match(/Edge\\\\/(\\\\d+).(\\\\d+)$/)) {\\n        result.browser = 'edge';\\n        result.version = this.extractVersion(navigator.userAgent,\\n            /Edge\\\\/(\\\\d+).(\\\\d+)$/, 2);\\n\\n      // Default fallthrough: not supported.\\n      } else {\\n        result.browser = 'Not a supported browser.';\\n        return result;\\n      }\\n\\n      return result;\\n    }\\n  };\\n\\n  // Export.\\n  module.exports = {\\n    log: utils.log,\\n    disableLog: utils.disableLog,\\n    browserDetails: utils.detectBrowser(),\\n    extractVersion: utils.extractVersion\\n  };\\n\\n  },{}]},{},[2])(2)\\n});\\n/* jshint ignore:end */\\n\\n  // END OF INJECTION OF GOOGLE'S ADAPTER.JS CONTENT\\n  ///////////////////////////////////////////////////////////////////\\n\\n  AdapterJS.parseWebrtcDetectedBrowser();\\n\\n  ///////////////////////////////////////////////////////////////////\\n  // EXTENSION FOR CHROME, FIREFOX AND EDGE\\n  // Includes legacy functions\\n  // -- createIceServer\\n  // -- createIceServers\\n  // -- MediaStreamTrack.getSources\\n  //\\n  // and additional shims\\n  // -- attachMediaStream\\n  // -- reattachMediaStream\\n  // -- requestUserMedia\\n  // -- a call to AdapterJS.maybeThroughWebRTCReady (notifies WebRTC is ready)\\n\\n  // Add support for legacy functions createIceServer and createIceServers\\n  if ( navigator.mozGetUserMedia ) {\\n    // Shim for MediaStreamTrack.getSources.\\n    MediaStreamTrack.getSources = function(successCb) {\\n      setTimeout(function() {\\n        var infos = [\\n          { kind: 'audio', id: 'default', label:'', facing:'' },\\n          { kind: 'video', id: 'default', label:'', facing:'' }\\n        ];\\n        successCb(infos);\\n      }, 0);\\n    };\\n\\n    // Attach a media stream to an element.\\n    attachMediaStream = function(element, stream) {\\n      element.srcObject = stream;\\n      return element;\\n    };\\n\\n    reattachMediaStream = function(to, from) {\\n      to.srcObject = from.srcObject;\\n      return to;\\n    };\\n\\n    createIceServer = function (url, username, password) {\\n      console.warn('createIceServer is deprecated. It should be replaced with an application level implementation.');\\n      // Note: Google's import of AJS will auto-reverse to 'url': '...' for FF < 38\\n\\n      var iceServer = null;\\n      var urlParts = url.split(':');\\n      if (urlParts[0].indexOf('stun') === 0) {\\n        iceServer = { urls : [url] };\\n      } else if (urlParts[0].indexOf('turn') === 0) {\\n        if (webrtcDetectedVersion < 27) {\\n          var turnUrlParts = url.split('?');\\n          if (turnUrlParts.length === 1 ||\\n            turnUrlParts[1].indexOf('transport=udp') === 0) {\\n            iceServer = {\\n              urls : [turnUrlParts[0]],\\n              credential : password,\\n              username : username\\n            };\\n          }\\n        } else {\\n          iceServer = {\\n            urls : [url],\\n            credential : password,\\n            username : username\\n          };\\n        }\\n      }\\n      return iceServer;\\n    };\\n\\n    createIceServers = function (urls, username, password) {\\n      console.warn('createIceServers is deprecated. It should be replaced with an application level implementation.');\\n\\n      var iceServers = [];\\n      for (i = 0; i < urls.length; i++) {\\n        var iceServer = createIceServer(urls[i], username, password);\\n        if (iceServer !== null) {\\n          iceServers.push(iceServer);\\n        }\\n      }\\n      return iceServers;\\n    };\\n  } else if ( navigator.webkitGetUserMedia ) {\\n    // Attach a media stream to an element.\\n    attachMediaStream = function(element, stream) {\\n      if (webrtcDetectedVersion >= 43) {\\n        element.srcObject = stream;\\n      } else if (typeof element.src !== 'undefined') {\\n        element.src = URL.createObjectURL(stream);\\n      } else {\\n        console.error('Error attaching stream to element.');\\n        // logging('Error attaching stream to element.');\\n      }\\n      return element;\\n    };\\n\\n    reattachMediaStream = function(to, from) {\\n      if (webrtcDetectedVersion >= 43) {\\n        to.srcObject = from.srcObject;\\n      } else {\\n        to.src = from.src;\\n      }\\n      return to;\\n    };\\n\\n    createIceServer = function (url, username, password) {\\n      console.warn('createIceServer is deprecated. It should be replaced with an application level implementation.');\\n\\n      var iceServer = null;\\n      var urlParts = url.split(':');\\n      if (urlParts[0].indexOf('stun') === 0) {\\n        iceServer = { 'url' : url };\\n      } else if (urlParts[0].indexOf('turn') === 0) {\\n        iceServer = {\\n          'url' : url,\\n          'credential' : password,\\n          'username' : username\\n        };\\n      }\\n      return iceServer;\\n    };\\n\\n    createIceServers = function (urls, username, password) {\\n      console.warn('createIceServers is deprecated. It should be replaced with an application level implementation.');\\n\\n      var iceServers = [];\\n      if (webrtcDetectedVersion >= 34) {\\n        iceServers = {\\n          'urls' : urls,\\n          'credential' : password,\\n          'username' : username\\n        };\\n      } else {\\n        for (i = 0; i < urls.length; i++) {\\n          var iceServer = createIceServer(urls[i], username, password);\\n          if (iceServer !== null) {\\n            iceServers.push(iceServer);\\n          }\\n        }\\n      }\\n      return iceServers;\\n    };\\n  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\\\/(\\\\d+).(\\\\d+)$/)) {\\n    // Attach a media stream to an element.\\n    attachMediaStream = function(element, stream) {\\n      element.srcObject = stream;\\n      return element;\\n    };\\n\\n    reattachMediaStream = function(to, from) {\\n      to.srcObject = from.srcObject;\\n      return to;\\n    };\\n  }\\n\\n  // Need to override attachMediaStream and reattachMediaStream\\n  // to support the plugin's logic\\n  attachMediaStream_base = attachMediaStream;\\n\\n  if (webrtcDetectedBrowser === 'opera') {\\n    attachMediaStream_base = function (element, stream) {\\n      if (webrtcDetectedVersion > 38) {\\n        element.srcObject = stream;\\n      } else if (typeof element.src !== 'undefined') {\\n        element.src = URL.createObjectURL(stream);\\n      }\\n      // Else it doesn't work\\n    };\\n  }\\n\\n  attachMediaStream = function (element, stream) {\\n    if ((webrtcDetectedBrowser === 'chrome' ||\\n         webrtcDetectedBrowser === 'opera') &&\\n        !stream) {\\n      // Chrome does not support \\\"src = null\\\"\\n      element.src = '';\\n    } else {\\n      attachMediaStream_base(element, stream);\\n    }\\n    return element;\\n  };\\n  reattachMediaStream_base = reattachMediaStream;\\n  reattachMediaStream = function (to, from) {\\n    reattachMediaStream_base(to, from);\\n    return to;\\n  };\\n\\n  // Propagate attachMediaStream and gUM in window and AdapterJS\\n  window.attachMediaStream      = attachMediaStream;\\n  window.reattachMediaStream    = reattachMediaStream;\\n  window.getUserMedia           = function(constraints, onSuccess, onFailure) {\\n    navigator.getUserMedia(constraints, onSuccess, onFailure);\\n  };\\n  AdapterJS.attachMediaStream   = attachMediaStream;\\n  AdapterJS.reattachMediaStream = reattachMediaStream;\\n  AdapterJS.getUserMedia        = getUserMedia;\\n\\n  // Removed Google defined promises when promise is not defined\\n  if (typeof Promise === 'undefined') {\\n    requestUserMedia = null;\\n  }\\n\\n  AdapterJS.maybeThroughWebRTCReady();\\n\\n  // END OF EXTENSION OF CHROME, FIREFOX AND EDGE\\n  ///////////////////////////////////////////////////////////////////\\n\\n} else { // TRY TO USE PLUGIN\\n\\n  ///////////////////////////////////////////////////////////////////\\n  // WEBRTC PLUGIN SHIM\\n  // Will automatically check if the plugin is available and inject it\\n  // into the DOM if it is.\\n  // When the plugin is not available, will prompt a banner to suggest installing it\\n  // Use AdapterJS.options.hidePluginInstallPrompt to prevent this banner from popping\\n  //\\n  // Shims the follwing:\\n  // -- getUserMedia\\n  // -- MediaStreamTrack\\n  // -- MediaStreamTrack.getSources\\n  // -- RTCPeerConnection\\n  // -- RTCSessionDescription\\n  // -- RTCIceCandidate\\n  // -- createIceServer\\n  // -- createIceServers\\n  // -- attachMediaStream\\n  // -- reattachMediaStream\\n  // -- webrtcDetectedBrowser\\n  // -- webrtcDetectedVersion\\n\\n  // IE 9 is not offering an implementation of console.log until you open a console\\n  if (typeof console !== 'object' || typeof console.log !== 'function') {\\n    /* jshint -W020 */\\n    console = {} || console;\\n    // Implemented based on console specs from MDN\\n    // You may override these functions\\n    console.log = function (arg) {};\\n    console.info = function (arg) {};\\n    console.error = function (arg) {};\\n    console.dir = function (arg) {};\\n    console.exception = function (arg) {};\\n    console.trace = function (arg) {};\\n    console.warn = function (arg) {};\\n    console.count = function (arg) {};\\n    console.debug = function (arg) {};\\n    console.count = function (arg) {};\\n    console.time = function (arg) {};\\n    console.timeEnd = function (arg) {};\\n    console.group = function (arg) {};\\n    console.groupCollapsed = function (arg) {};\\n    console.groupEnd = function (arg) {};\\n    /* jshint +W020 */\\n  }\\n  AdapterJS.parseWebrtcDetectedBrowser();\\n  isIE = webrtcDetectedBrowser === 'IE';\\n\\n  /* jshint -W035 */\\n  AdapterJS.WebRTCPlugin.WaitForPluginReady = function() {\\n    while (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\\n      /* empty because it needs to prevent the function from running. */\\n    }\\n  };\\n  /* jshint +W035 */\\n\\n  AdapterJS.WebRTCPlugin.callWhenPluginReady = function (callback) {\\n    if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\\n      // Call immediately if possible\\n      // Once the plugin is set, the code will always take this path\\n      callback();\\n    } else {\\n      // otherwise start a 100ms interval\\n      var checkPluginReadyState = setInterval(function () {\\n        if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\\n          clearInterval(checkPluginReadyState);\\n          callback();\\n        }\\n      }, 100);\\n    }\\n  };\\n\\n  AdapterJS.WebRTCPlugin.setLogLevel = function(logLevel) {\\n    AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\\n      AdapterJS.WebRTCPlugin.plugin.setLogLevel(logLevel);\\n    });\\n  };\\n\\n  AdapterJS.WebRTCPlugin.injectPlugin = function () {\\n    // only inject once the page is ready\\n    if (document.readyState !== 'complete') {\\n      return;\\n    }\\n\\n    // Prevent multiple injections\\n    if (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING) {\\n      return;\\n    }\\n\\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTING;\\n\\n    if (webrtcDetectedBrowser === 'IE' && webrtcDetectedVersion <= 10) {\\n      var frag = document.createDocumentFragment();\\n      AdapterJS.WebRTCPlugin.plugin = document.createElement('div');\\n      AdapterJS.WebRTCPlugin.plugin.innerHTML = '<object id=\\\"' +\\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\\\" type=\\\"' +\\n        AdapterJS.WebRTCPlugin.pluginInfo.type + '\\\" ' + 'width=\\\"1\\\" height=\\\"1\\\">' +\\n        '<param name=\\\"pluginId\\\" value=\\\"' +\\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\\\" /> ' +\\n        '<param name=\\\"windowless\\\" value=\\\"false\\\" /> ' +\\n        '<param name=\\\"pageId\\\" value=\\\"' + AdapterJS.WebRTCPlugin.pageId + '\\\" /> ' +\\n        '<param name=\\\"onload\\\" value=\\\"' + AdapterJS.WebRTCPlugin.pluginInfo.onload + '\\\" />' +\\n        '<param name=\\\"tag\\\" value=\\\"' + AdapterJS.WebRTCPlugin.TAGS.NONE + '\\\" />' +\\n        // uncomment to be able to use virtual cams\\n        (AdapterJS.options.getAllCams ? '<param name=\\\"forceGetAllCams\\\" value=\\\"True\\\" />':'') +\\n\\n        '</object>';\\n      while (AdapterJS.WebRTCPlugin.plugin.firstChild) {\\n        frag.appendChild(AdapterJS.WebRTCPlugin.plugin.firstChild);\\n      }\\n      document.body.appendChild(frag);\\n\\n      // Need to re-fetch the plugin\\n      AdapterJS.WebRTCPlugin.plugin =\\n        document.getElementById(AdapterJS.WebRTCPlugin.pluginInfo.pluginId);\\n    } else {\\n      // Load Plugin\\n      AdapterJS.WebRTCPlugin.plugin = document.createElement('object');\\n      AdapterJS.WebRTCPlugin.plugin.id =\\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId;\\n      // IE will only start the plugin if it's ACTUALLY visible\\n      if (isIE) {\\n        AdapterJS.WebRTCPlugin.plugin.width = '1px';\\n        AdapterJS.WebRTCPlugin.plugin.height = '1px';\\n      } else { // The size of the plugin on Safari should be 0x0px\\n              // so that the autorisation prompt is at the top\\n        AdapterJS.WebRTCPlugin.plugin.width = '0px';\\n        AdapterJS.WebRTCPlugin.plugin.height = '0px';\\n      }\\n      AdapterJS.WebRTCPlugin.plugin.type = AdapterJS.WebRTCPlugin.pluginInfo.type;\\n      AdapterJS.WebRTCPlugin.plugin.innerHTML = '<param name=\\\"onload\\\" value=\\\"' +\\n        AdapterJS.WebRTCPlugin.pluginInfo.onload + '\\\">' +\\n        '<param name=\\\"pluginId\\\" value=\\\"' +\\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\\\">' +\\n        '<param name=\\\"windowless\\\" value=\\\"false\\\" /> ' +\\n        (AdapterJS.options.getAllCams ? '<param name=\\\"forceGetAllCams\\\" value=\\\"True\\\" />':'') +\\n        '<param name=\\\"pageId\\\" value=\\\"' + AdapterJS.WebRTCPlugin.pageId + '\\\">' +\\n        '<param name=\\\"tag\\\" value=\\\"' + AdapterJS.WebRTCPlugin.TAGS.NONE + '\\\" />';\\n      document.body.appendChild(AdapterJS.WebRTCPlugin.plugin);\\n    }\\n\\n\\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTED;\\n  };\\n\\n  AdapterJS.WebRTCPlugin.isPluginInstalled =\\n    function (comName, plugName, plugType, installedCb, notInstalledCb) {\\n    if (!isIE) {\\n      var pluginArray = navigator.mimeTypes;\\n      for (var i = 0; i < pluginArray.length; i++) {\\n        if (pluginArray[i].type.indexOf(plugType) >= 0) {\\n          installedCb();\\n          return;\\n        }\\n      }\\n      notInstalledCb();\\n    } else {\\n      try {\\n        var axo = new ActiveXObject(comName + '.' + plugName);\\n      } catch (e) {\\n        notInstalledCb();\\n        return;\\n      }\\n      installedCb();\\n    }\\n  };\\n\\n  AdapterJS.WebRTCPlugin.defineWebRTCInterface = function () {\\n    if (AdapterJS.WebRTCPlugin.pluginState ===\\n        AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\\n      console.error('AdapterJS - WebRTC interface has already been defined');\\n      return;\\n    }\\n\\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING;\\n\\n    AdapterJS.isDefined = function (variable) {\\n      return variable !== null && variable !== undefined;\\n    };\\n\\n    createIceServer = function (url, username, password) {\\n      var iceServer = null;\\n      var urlParts = url.split(':');\\n      if (urlParts[0].indexOf('stun') === 0) {\\n        iceServer = {\\n          'url' : url,\\n          'hasCredentials' : false\\n        };\\n      } else if (urlParts[0].indexOf('turn') === 0) {\\n        iceServer = {\\n          'url' : url,\\n          'hasCredentials' : true,\\n          'credential' : password,\\n          'username' : username\\n        };\\n      }\\n      return iceServer;\\n    };\\n\\n    createIceServers = function (urls, username, password) {\\n      var iceServers = [];\\n      for (var i = 0; i < urls.length; ++i) {\\n        iceServers.push(createIceServer(urls[i], username, password));\\n      }\\n      return iceServers;\\n    };\\n\\n    RTCSessionDescription = function (info) {\\n      AdapterJS.WebRTCPlugin.WaitForPluginReady();\\n      return AdapterJS.WebRTCPlugin.plugin.\\n        ConstructSessionDescription(info.type, info.sdp);\\n    };\\n\\n    RTCPeerConnection = function (servers, constraints) {\\n      // Validate server argumenr\\n      if (!(servers === undefined ||\\n            servers === null ||\\n            Array.isArray(servers.iceServers))) {\\n        throw new Error('Failed to construct \\\\'RTCPeerConnection\\\\': Malformed RTCConfiguration');\\n      }\\n\\n      // Validate constraints argument\\n      if (typeof constraints !== 'undefined' && constraints !== null) {\\n        var invalidConstraits = false;\\n        invalidConstraits |= typeof constraints !== 'object';\\n        invalidConstraits |= constraints.hasOwnProperty('mandatory') &&\\n                              constraints.mandatory !== undefined &&\\n                              constraints.mandatory !== null &&\\n                              constraints.mandatory.constructor !== Object;\\n        invalidConstraits |= constraints.hasOwnProperty('optional') &&\\n                              constraints.optional !== undefined &&\\n                              constraints.optional !== null &&\\n                              !Array.isArray(constraints.optional);\\n        if (invalidConstraits) {\\n          throw new Error('Failed to construct \\\\'RTCPeerConnection\\\\': Malformed constraints object');\\n        }\\n      }\\n\\n      // Call relevant PeerConnection constructor according to plugin version\\n      AdapterJS.WebRTCPlugin.WaitForPluginReady();\\n\\n      // RTCPeerConnection prototype from the old spec\\n      var iceServers = null;\\n      if (servers && Array.isArray(servers.iceServers)) {\\n        iceServers = servers.iceServers;\\n        for (var i = 0; i < iceServers.length; i++) {\\n          // Legacy plugin versions compatibility\\n          if (iceServers[i].urls && !iceServers[i].url) {\\n            iceServers[i].url = iceServers[i].urls;\\n          }\\n          iceServers[i].hasCredentials = AdapterJS.\\n            isDefined(iceServers[i].username) &&\\n            AdapterJS.isDefined(iceServers[i].credential);\\n        }\\n      }\\n\\n      if (AdapterJS.WebRTCPlugin.plugin.PEER_CONNECTION_VERSION &&\\n          AdapterJS.WebRTCPlugin.plugin.PEER_CONNECTION_VERSION > 1) {\\n        // RTCPeerConnection prototype from the new spec\\n        if (iceServers) {\\n          servers.iceServers = iceServers;\\n        }\\n        return AdapterJS.WebRTCPlugin.plugin.PeerConnection(servers);\\n      } else {\\n        var mandatory = (constraints && constraints.mandatory) ?\\n          constraints.mandatory : null;\\n        var optional = (constraints && constraints.optional) ?\\n          constraints.optional : null;\\n        return AdapterJS.WebRTCPlugin.plugin.\\n          PeerConnection(AdapterJS.WebRTCPlugin.pageId,\\n          iceServers, mandatory, optional);\\n      }\\n    };\\n\\n    MediaStreamTrack = function(){};\\n    MediaStreamTrack.getSources = function (callback) {\\n      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\\n        AdapterJS.WebRTCPlugin.plugin.GetSources(callback);\\n      });\\n    };\\n\\n    // getUserMedia constraints shim.\\n    // Copied from Chrome\\n    var constraintsToPlugin = function(c) {\\n      if (typeof c !== 'object' || c.mandatory || c.optional) {\\n        return c;\\n      }\\n      var cc = {};\\n      Object.keys(c).forEach(function(key) {\\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\\n          return;\\n        }\\n        var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\\n        if (r.exact !== undefined && typeof r.exact === 'number') {\\n          r.min = r.max = r.exact;\\n        }\\n        var oldname = function(prefix, name) {\\n          if (prefix) {\\n            return prefix + name.charAt(0).toUpperCase() + name.slice(1);\\n          }\\n          return (name === 'deviceId') ? 'sourceId' : name;\\n        };\\n        if (r.ideal !== undefined) {\\n          cc.optional = cc.optional || [];\\n          var oc = {};\\n          if (typeof r.ideal === 'number') {\\n            oc[oldname('min', key)] = r.ideal;\\n            cc.optional.push(oc);\\n            oc = {};\\n            oc[oldname('max', key)] = r.ideal;\\n            cc.optional.push(oc);\\n          } else {\\n            oc[oldname('', key)] = r.ideal;\\n            cc.optional.push(oc);\\n          }\\n        }\\n        if (r.exact !== undefined && typeof r.exact !== 'number') {\\n          cc.mandatory = cc.mandatory || {};\\n          cc.mandatory[oldname('', key)] = r.exact;\\n        } else {\\n          ['min', 'max'].forEach(function(mix) {\\n            if (r[mix] !== undefined) {\\n              cc.mandatory = cc.mandatory || {};\\n              cc.mandatory[oldname(mix, key)] = r[mix];\\n            }\\n          });\\n        }\\n      });\\n      if (c.advanced) {\\n        cc.optional = (cc.optional || []).concat(c.advanced);\\n      }\\n      return cc;\\n    };\\n\\n    getUserMedia = function (constraints, successCallback, failureCallback) {\\n      var cc = {};\\n      cc.audio = constraints.audio ?\\n        constraintsToPlugin(constraints.audio) : false;\\n      cc.video = constraints.video ?\\n        constraintsToPlugin(constraints.video) : false;\\n\\n      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\\n        AdapterJS.WebRTCPlugin.plugin.\\n          getUserMedia(cc, successCallback, failureCallback);\\n      });\\n    };\\n    window.navigator.getUserMedia = getUserMedia;\\n\\n    // Defined mediaDevices when promises are available\\n    if ( !navigator.mediaDevices &&\\n      typeof Promise !== 'undefined') {\\n      requestUserMedia = function(constraints) {\\n        return new Promise(function(resolve, reject) {\\n          getUserMedia(constraints, resolve, reject);\\n        });\\n      };\\n      navigator.mediaDevices = {getUserMedia: requestUserMedia,\\n                                enumerateDevices: function() {\\n        return new Promise(function(resolve) {\\n          var kinds = {audio: 'audioinput', video: 'videoinput'};\\n          return MediaStreamTrack.getSources(function(devices) {\\n            resolve(devices.map(function(device) {\\n              return {label: device.label,\\n                      kind: kinds[device.kind],\\n                      id: device.id,\\n                      deviceId: device.id,\\n                      groupId: ''};\\n            }));\\n          });\\n        });\\n      }};\\n    }\\n\\n    attachMediaStream = function (element, stream) {\\n      if (!element || !element.parentNode) {\\n        return;\\n      }\\n\\n      var streamId;\\n      if (stream === null) {\\n        streamId = '';\\n      } else {\\n        if (typeof stream.enableSoundTracks !== 'undefined') {\\n          stream.enableSoundTracks(true);\\n        }\\n        streamId = stream.id;\\n      }\\n\\n      var elementId = element.id.length === 0 ? Math.random().toString(36).slice(2) : element.id;\\n      var nodeName = element.nodeName.toLowerCase();\\n      if (nodeName !== 'object') { // not a plugin <object> tag yet\\n        var tag;\\n        switch(nodeName) {\\n          case 'audio':\\n            tag = AdapterJS.WebRTCPlugin.TAGS.AUDIO;\\n            break;\\n          case 'video':\\n            tag = AdapterJS.WebRTCPlugin.TAGS.VIDEO;\\n            break;\\n          default:\\n            tag = AdapterJS.WebRTCPlugin.TAGS.NONE;\\n          }\\n\\n        var frag = document.createDocumentFragment();\\n        var temp = document.createElement('div');\\n        var classHTML = '';\\n        if (element.className) {\\n          classHTML = 'class=\\\"' + element.className + '\\\" ';\\n        } else if (element.attributes && element.attributes['class']) {\\n          classHTML = 'class=\\\"' + element.attributes['class'].value + '\\\" ';\\n        }\\n\\n        temp.innerHTML = '<object id=\\\"' + elementId + '\\\" ' + classHTML +\\n          'type=\\\"' + AdapterJS.WebRTCPlugin.pluginInfo.type + '\\\">' +\\n          '<param name=\\\"pluginId\\\" value=\\\"' + elementId + '\\\" /> ' +\\n          '<param name=\\\"pageId\\\" value=\\\"' + AdapterJS.WebRTCPlugin.pageId + '\\\" /> ' +\\n          '<param name=\\\"windowless\\\" value=\\\"true\\\" /> ' +\\n          '<param name=\\\"streamId\\\" value=\\\"' + streamId + '\\\" /> ' +\\n          '<param name=\\\"tag\\\" value=\\\"' + tag + '\\\" /> ' +\\n          '</object>';\\n        while (temp.firstChild) {\\n          frag.appendChild(temp.firstChild);\\n        }\\n\\n        var height = '';\\n        var width = '';\\n        if (element.clientWidth || element.clientHeight) {\\n          width = element.clientWidth;\\n          height = element.clientHeight;\\n        }\\n        else if (element.width || element.height) {\\n          width = element.width;\\n          height = element.height;\\n        }\\n\\n        element.parentNode.insertBefore(frag, element);\\n        frag = document.getElementById(elementId);\\n        frag.width = width;\\n        frag.height = height;\\n        element.parentNode.removeChild(element);\\n      } else { // already an <object> tag, just change the stream id\\n        var children = element.children;\\n        for (var i = 0; i !== children.length; ++i) {\\n          if (children[i].name === 'streamId') {\\n            children[i].value = streamId;\\n            break;\\n          }\\n        }\\n        element.setStreamId(streamId);\\n      }\\n      var newElement = document.getElementById(elementId);\\n      AdapterJS.forwardEventHandlers(newElement, element, Object.getPrototypeOf(element));\\n\\n      return newElement;\\n    };\\n\\n    reattachMediaStream = function (to, from) {\\n      var stream = null;\\n      var children = from.children;\\n      for (var i = 0; i !== children.length; ++i) {\\n        if (children[i].name === 'streamId') {\\n          AdapterJS.WebRTCPlugin.WaitForPluginReady();\\n          stream = AdapterJS.WebRTCPlugin.plugin\\n            .getStreamWithId(AdapterJS.WebRTCPlugin.pageId, children[i].value);\\n          break;\\n        }\\n      }\\n      if (stream !== null) {\\n        return attachMediaStream(to, stream);\\n      } else {\\n        console.log('Could not find the stream associated with this element');\\n      }\\n    };\\n\\n    // Propagate attachMediaStream and gUM in window and AdapterJS\\n    window.attachMediaStream      = attachMediaStream;\\n    window.reattachMediaStream    = reattachMediaStream;\\n    window.getUserMedia           = getUserMedia;\\n    AdapterJS.attachMediaStream   = attachMediaStream;\\n    AdapterJS.reattachMediaStream = reattachMediaStream;\\n    AdapterJS.getUserMedia        = getUserMedia;\\n\\n    AdapterJS.forwardEventHandlers = function (destElem, srcElem, prototype) {\\n      properties = Object.getOwnPropertyNames( prototype );\\n      for(var prop in properties) {\\n        if (prop) {\\n          propName = properties[prop];\\n\\n          if (typeof propName.slice === 'function' &&\\n              propName.slice(0,2) === 'on' &&\\n              typeof srcElem[propName] === 'function') {\\n              AdapterJS.addEvent(destElem, propName.slice(2), srcElem[propName]);\\n          }\\n        }\\n      }\\n      var subPrototype = Object.getPrototypeOf(prototype);\\n      if(!!subPrototype) {\\n        AdapterJS.forwardEventHandlers(destElem, srcElem, subPrototype);\\n      }\\n    };\\n\\n    RTCIceCandidate = function (candidate) {\\n      if (!candidate.sdpMid) {\\n        candidate.sdpMid = '';\\n      }\\n\\n      AdapterJS.WebRTCPlugin.WaitForPluginReady();\\n      return AdapterJS.WebRTCPlugin.plugin.ConstructIceCandidate(\\n        candidate.sdpMid, candidate.sdpMLineIndex, candidate.candidate\\n      );\\n    };\\n\\n    // inject plugin\\n    AdapterJS.addEvent(document, 'readystatechange', AdapterJS.WebRTCPlugin.injectPlugin);\\n    AdapterJS.WebRTCPlugin.injectPlugin();\\n  };\\n\\n  // This function will be called if the plugin is needed (browser different\\n  // from Chrome or Firefox), but the plugin is not installed.\\n  AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb = AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb ||\\n    function() {\\n      AdapterJS.addEvent(document,\\n                        'readystatechange',\\n                         AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv);\\n      AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv();\\n    };\\n\\n  AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv = function () {\\n    if (AdapterJS.options.hidePluginInstallPrompt) {\\n      return;\\n    }\\n\\n    var downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLink;\\n    if(downloadLink) { // if download link\\n      var popupString;\\n      if (AdapterJS.WebRTCPlugin.pluginInfo.portalLink) { // is portal link\\n       popupString = 'This website requires you to install the ' +\\n        ' <a href=\\\"' + AdapterJS.WebRTCPlugin.pluginInfo.portalLink +\\n        '\\\" target=\\\"_blank\\\">' + AdapterJS.WebRTCPlugin.pluginInfo.companyName +\\n        ' WebRTC Plugin</a>' +\\n        ' to work on this browser.';\\n      } else { // no portal link, just print a generic explanation\\n       popupString = AdapterJS.TEXT.PLUGIN.REQUIRE_INSTALLATION;\\n      }\\n\\n      AdapterJS.renderNotificationBar(popupString, AdapterJS.TEXT.PLUGIN.BUTTON, downloadLink);\\n    } else { // no download link, just print a generic explanation\\n      AdapterJS.renderNotificationBar(AdapterJS.TEXT.PLUGIN.NOT_SUPPORTED);\\n    }\\n  };\\n\\n\\n  // Try to detect the plugin and act accordingly\\n  AdapterJS.WebRTCPlugin.isPluginInstalled(\\n    AdapterJS.WebRTCPlugin.pluginInfo.prefix,\\n    AdapterJS.WebRTCPlugin.pluginInfo.plugName,\\n    AdapterJS.WebRTCPlugin.pluginInfo.type,\\n    AdapterJS.WebRTCPlugin.defineWebRTCInterface,\\n    AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb);\\n\\n  // END OF WEBRTC PLUGIN SHIM\\n  ///////////////////////////////////////////////////////////////////\\n}\\n\\n(function () {\\n\\n  'use strict';\\n\\n  var baseGetUserMedia = null;\\n\\n  AdapterJS.TEXT.EXTENSION = {\\n    REQUIRE_INSTALLATION_FF: 'To enable screensharing you need to install the Skylink WebRTC tools Firefox Add-on.',\\n    REQUIRE_INSTALLATION_CHROME: 'To enable screensharing you need to install the Skylink WebRTC tools Chrome Extension.',\\n    REQUIRE_REFRESH: 'Please refresh this page after the Skylink WebRTC tools extension has been installed.',\\n    BUTTON_FF: 'Install Now',\\n    BUTTON_CHROME: 'Go to Chrome Web Store'\\n  };\\n\\n  var clone = function(obj) {\\n    if (null === obj || 'object' !== typeof obj) {\\n      return obj;\\n    }\\n    var copy = obj.constructor();\\n    for (var attr in obj) {\\n      if (obj.hasOwnProperty(attr)) {\\n        copy[attr] = obj[attr];\\n      }\\n    }\\n    return copy;\\n  };\\n\\n  if (window.navigator.mozGetUserMedia) {\\n    baseGetUserMedia = window.navigator.getUserMedia;\\n\\n    navigator.getUserMedia = function (constraints, successCb, failureCb) {\\n\\n      if (constraints && constraints.video && !!constraints.video.mediaSource) {\\n        // intercepting screensharing requests\\n\\n        // Invalid mediaSource for firefox, only \\\"screen\\\" and \\\"window\\\" are supported\\n        if (constraints.video.mediaSource !== 'screen' && constraints.video.mediaSource !== 'window') {\\n          failureCb(new Error('GetUserMedia: Only \\\"screen\\\" and \\\"window\\\" are supported as mediaSource constraints'));\\n          return;\\n        }\\n\\n        var updatedConstraints = clone(constraints);\\n\\n        //constraints.video.mediaSource = constraints.video.mediaSource;\\n        updatedConstraints.video.mozMediaSource = updatedConstraints.video.mediaSource;\\n\\n        // so generally, it requires for document.readyState to be completed before the getUserMedia could be invoked.\\n        // strange but this works anyway\\n        var checkIfReady = setInterval(function () {\\n          if (document.readyState === 'complete') {\\n            clearInterval(checkIfReady);\\n\\n            baseGetUserMedia(updatedConstraints, successCb, function (error) {\\n              if (['PermissionDeniedError', 'SecurityError'].indexOf(error.name) > -1 && window.parent.location.protocol === 'https:') {\\n                AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION.REQUIRE_INSTALLATION_FF,\\n                  AdapterJS.TEXT.EXTENSION.BUTTON_FF,\\n                  'https://addons.mozilla.org/en-US/firefox/addon/skylink-webrtc-tools/', true, true);\\n              } else {\\n                failureCb(error);\\n              }\\n            });\\n          }\\n        }, 1);\\n\\n      } else { // regular GetUserMediaRequest\\n        baseGetUserMedia(constraints, successCb, failureCb);\\n      }\\n    };\\n\\n    AdapterJS.getUserMedia = window.getUserMedia = navigator.getUserMedia;\\n    /* Comment out to prevent recursive errors\\n    navigator.mediaDevices.getUserMedia = function(constraints) {\\n      return new Promise(function(resolve, reject) {\\n        window.getUserMedia(constraints, resolve, reject);\\n      });\\n    };*/\\n\\n  } else if (window.navigator.webkitGetUserMedia && window.webrtcDetectedBrowser !== 'safari') {\\n    baseGetUserMedia = window.navigator.getUserMedia;\\n\\n    navigator.getUserMedia = function (constraints, successCb, failureCb) {\\n      if (constraints && constraints.video && !!constraints.video.mediaSource) {\\n        if (window.webrtcDetectedBrowser !== 'chrome') {\\n          // This is Opera, which does not support screensharing\\n          failureCb(new Error('Current browser does not support screensharing'));\\n          return;\\n        }\\n\\n        // would be fine since no methods\\n        var updatedConstraints = clone(constraints);\\n\\n        var chromeCallback = function(error, sourceId) {\\n          if(!error) {\\n            updatedConstraints.video.mandatory = updatedConstraints.video.mandatory || {};\\n            updatedConstraints.video.mandatory.chromeMediaSource = 'desktop';\\n            updatedConstraints.video.mandatory.maxWidth = window.screen.width > 1920 ? window.screen.width : 1920;\\n            updatedConstraints.video.mandatory.maxHeight = window.screen.height > 1080 ? window.screen.height : 1080;\\n\\n            if (sourceId) {\\n              updatedConstraints.video.mandatory.chromeMediaSourceId = sourceId;\\n            }\\n\\n            delete updatedConstraints.video.mediaSource;\\n\\n            baseGetUserMedia(updatedConstraints, successCb, failureCb);\\n\\n          } else { // GUM failed\\n            if (error === 'permission-denied') {\\n              failureCb(new Error('Permission denied for screen retrieval'));\\n            } else {\\n              // NOTE(J-O): I don't think we ever pass in here.\\n              // A failure to capture the screen does not lead here.\\n              failureCb(new Error('Failed retrieving selected screen'));\\n            }\\n          }\\n        };\\n\\n        var onIFrameCallback = function (event) {\\n          if (!event.data) {\\n            return;\\n          }\\n\\n          if (event.data.chromeMediaSourceId) {\\n            if (event.data.chromeMediaSourceId === 'PermissionDeniedError') {\\n                chromeCallback('permission-denied');\\n            } else {\\n              chromeCallback(null, event.data.chromeMediaSourceId);\\n            }\\n          }\\n\\n          if (event.data.chromeExtensionStatus) {\\n            if (event.data.chromeExtensionStatus === 'not-installed') {\\n              AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION.REQUIRE_INSTALLATION_CHROME,\\n                AdapterJS.TEXT.EXTENSION.BUTTON_CHROME,\\n                event.data.data, true, true);\\n            } else {\\n              chromeCallback(event.data.chromeExtensionStatus, null);\\n            }\\n          }\\n\\n          // this event listener is no more needed\\n          window.removeEventListener('message', onIFrameCallback);\\n        };\\n\\n        window.addEventListener('message', onIFrameCallback);\\n\\n        postFrameMessage({\\n          captureSourceId: true\\n        });\\n\\n      } else {\\n        baseGetUserMedia(constraints, successCb, failureCb);\\n      }\\n    };\\n\\n    AdapterJS.getUserMedia = window.getUserMedia = navigator.getUserMedia;\\n    navigator.mediaDevices.getUserMedia = function(constraints) {\\n      return new Promise(function(resolve, reject) {\\n        window.getUserMedia(constraints, resolve, reject);\\n      });\\n    };\\n\\n  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\\\/(\\\\d+).(\\\\d+)$/)) {\\n    // nothing here because edge does not support screensharing\\n    console.warn('Edge does not support screensharing feature in getUserMedia');\\n\\n  } else {\\n    baseGetUserMedia = window.navigator.getUserMedia;\\n\\n    navigator.getUserMedia = function (constraints, successCb, failureCb) {\\n      if (constraints && constraints.video && !!constraints.video.mediaSource) {\\n        // would be fine since no methods\\n        var updatedConstraints = clone(constraints);\\n\\n        // wait for plugin to be ready\\n        AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\\n          // check if screensharing feature is available\\n          if (!!AdapterJS.WebRTCPlugin.plugin.HasScreensharingFeature &&\\n            !!AdapterJS.WebRTCPlugin.plugin.isScreensharingAvailable) {\\n            // set the constraints\\n            updatedConstraints.video.optional = updatedConstraints.video.optional || [];\\n            updatedConstraints.video.optional.push({\\n              sourceId: AdapterJS.WebRTCPlugin.plugin.screensharingKey || 'Screensharing'\\n            });\\n\\n            delete updatedConstraints.video.mediaSource;\\n          } else {\\n            failureCb(new Error('Your version of the WebRTC plugin does not support screensharing'));\\n            return;\\n          }\\n          baseGetUserMedia(updatedConstraints, successCb, failureCb);\\n        });\\n      } else {\\n        baseGetUserMedia(constraints, successCb, failureCb);\\n      }\\n    };\\n\\n    AdapterJS.getUserMedia = getUserMedia =\\n       window.getUserMedia = navigator.getUserMedia;\\n    if ( navigator.mediaDevices &&\\n      typeof Promise !== 'undefined') {\\n      navigator.mediaDevices.getUserMedia = typeof requestUserMedia === 'undefined' ? undefined : requestUserMedia;\\n    }\\n  }\\n\\n  // For chrome, use an iframe to load the screensharing extension\\n  // in the correct domain.\\n  // Modify here for custom screensharing extension in chrome\\n  if (window.webrtcDetectedBrowser === 'chrome') {\\n    var iframe = document.createElement('iframe');\\n\\n    iframe.onload = function() {\\n      iframe.isLoaded = true;\\n    };\\n\\n    iframe.src = 'https://cdn.temasys.com.sg/skylink/extensions/detectRTC.html';\\n    iframe.style.display = 'none';\\n\\n    (document.body || document.documentElement).appendChild(iframe);\\n\\n    var postFrameMessage = function (object) { // jshint ignore:line\\n      object = object || {};\\n\\n      if (!iframe.isLoaded) {\\n        setTimeout(function () {\\n          iframe.contentWindow.postMessage(object, '*');\\n        }, 100);\\n        return;\\n      }\\n\\n      iframe.contentWindow.postMessage(object, '*');\\n    };\\n  } else if (window.webrtcDetectedBrowser === 'opera') {\\n    console.warn('Opera does not support screensharing feature in getUserMedia');\\n  }\\n})();\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, \\\"modules/RTC/adapter.screenshare.js\\\"))\\n\\n/***/ }),\\n/* 38 */\\n/***/ (function(module, exports) {\\n\\n/* Copyright @ 2015 Atlassian Pty Ltd\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n/**\\n * Ordered log levels.\\n */\\nvar levels = {\\n    \\\"trace\\\": 0,\\n    \\\"debug\\\": 1,\\n    \\\"info\\\": 2,\\n    \\\"log\\\": 3,\\n    \\\"warn\\\": 4,\\n    \\\"error\\\": 5\\n};\\n\\n/**\\n * The default transport - console\\n * @type LoggerTransport\\n */\\nLogger.consoleTransport = console;\\n\\n/**\\n * The array which stores currently registered global transports.\\n * @type {[LoggerTransport]}\\n */\\nvar globalTransports = [ Logger.consoleTransport ];\\n\\n/**\\n * Adds given {@link LoggerTransport} instance to the list of global\\n * transports which means that it'll be used by all {@link Logger}s\\n * @param {LoggerTransport} transport\\n */\\nLogger.addGlobalTransport = function(transport) {\\n    if (globalTransports.indexOf(transport) === -1) {\\n        globalTransports.push(transport);\\n    }\\n};\\n\\n/**\\n * Removes given {@link LoggerTransport} instance from the list of global\\n * transports\\n * @param {LoggerTransport} transport\\n */\\nLogger.removeGlobalTransport = function(transport) {\\n    var transportIdx = globalTransports.indexOf(transport);\\n    if (transportIdx !== -1) {\\n        globalTransports.splice(transportIdx, 1);\\n    }\\n};\\n\\n/**\\n * Parses Error's object stack trace and extracts information about the last\\n * caller before the log method was called.\\n * @returns JS object with info about the caller - method name, file location,\\n * line and column.\\n */\\nfunction getCallerInfo() {\\n    var callerInfo = {\\n        methodName: \\\"\\\",\\n        fileLocation: \\\"\\\",\\n        line: null,\\n        column: null\\n    };\\n    //gets the part of the stack without the logger wrappers\\n    var error = new Error();\\n    var stack = error.stack? error.stack.split(\\\"\\\\n\\\") : [];\\n    if(!stack || stack.length < 1) {\\n        return callerInfo;\\n    }\\n    var m = null;\\n    if(stack[3]) {\\n        m = stack[3].match(/\\\\s*at\\\\s*(.+?)\\\\s*\\\\((\\\\S*)\\\\s*:(\\\\d*)\\\\s*:(\\\\d*)\\\\)/);\\n    }\\n    if(!m || m.length <= 4) {\\n        //Firefox && Safari\\n        if(stack[2].indexOf(\\\"log@\\\") === 0){\\n            //Safari\\n            callerInfo.methodName = stack[3].substr(0, stack[3].indexOf(\\\"@\\\"));\\n        } else {\\n            //Firefox\\n            callerInfo.methodName = stack[2].substr(0, stack[2].indexOf(\\\"@\\\"));\\n        }\\n        return callerInfo;\\n    }\\n\\n    callerInfo.methodName = m[1];\\n    callerInfo.fileLocation = m[2];\\n    callerInfo.line = m[3];\\n    callerInfo.column = m[4];\\n    return callerInfo;\\n}\\n\\n/**\\n * Logs messages using the transports and level from the logger.\\n * @param logger a logger instance.\\n * @param level the log level of the message. See the levels variable.\\n * @param arguments array with arguments that will be logged.\\n */\\nfunction log() {\\n    var logger = arguments[0], level = arguments[1],\\n        args = Array.prototype.slice.call(arguments, 2);\\n    if(levels[level] < logger.level) {\\n        return;\\n    }\\n\\n    var callerInfo = getCallerInfo();\\n    var transports = globalTransports.concat(logger.transports);\\n    for(var i = 0; i < transports.length; i++) {\\n        var t = transports[i];\\n        var l = t[level];\\n        if(l && typeof(l) === \\\"function\\\") {\\n            l.bind(t, logger.id? \\\"[\\\" + logger.id + \\\"]\\\" : \\\"\\\", \\\"<\\\" + callerInfo.methodName + \\\">: \\\")\\n                .apply(t, args);\\n        }\\n    }\\n}\\n\\n/**\\n *\\n * Constructs new logger object.\\n * @param level the logging level for the new logger\\n * @param id optional identifier for the logger instance.\\n * @param {LoggerTransport} transports optional list of handlers(objects) for\\n * the logs. The handlers must support - log, warn, error, debug, info, trace.\\n * @param format optional (NOT implemented) string.\\n */\\nfunction Logger(level, id, transports, format) {\\n    this.id = id;\\n    this.format = format;\\n    this.transports = transports;\\n    if(!this.transports) {\\n        this.transports = [];\\n    }\\n    this.level = levels[level];\\n    var methods = Object.keys(levels);\\n    for(var i = 0; i < methods.length; i++){\\n        this[methods[i]] =\\n            log.bind(null, this, methods[i]);\\n    }\\n}\\n\\n/**\\n * Sets the log level for the logger.\\n * @param level the new log level.\\n */\\nLogger.prototype.setLevel = function (level) {\\n    this.level = levels[level];\\n};\\nmodule.exports = Logger;\\n\\n/**\\n * Enum for the supported log levels.\\n */\\nLogger.levels = {\\n    TRACE: \\\"trace\\\",\\n    DEBUG: \\\"debug\\\",\\n    INFO: \\\"info\\\",\\n    LOG: \\\"log\\\",\\n    WARN: \\\"warn\\\",\\n    ERROR: \\\"error\\\"\\n};\\n\\n\\n/***/ }),\\n/* 39 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar apply = Function.prototype.apply;\\n\\n// DOM APIs, for completeness\\n\\nexports.setTimeout = function() {\\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\\n};\\nexports.setInterval = function() {\\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\\n};\\nexports.clearTimeout =\\nexports.clearInterval = function(timeout) {\\n  if (timeout) {\\n    timeout.close();\\n  }\\n};\\n\\nfunction Timeout(id, clearFn) {\\n  this._id = id;\\n  this._clearFn = clearFn;\\n}\\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\\nTimeout.prototype.close = function() {\\n  this._clearFn.call(window, this._id);\\n};\\n\\n// Does not start the time, just sets up the members needed.\\nexports.enroll = function(item, msecs) {\\n  clearTimeout(item._idleTimeoutId);\\n  item._idleTimeout = msecs;\\n};\\n\\nexports.unenroll = function(item) {\\n  clearTimeout(item._idleTimeoutId);\\n  item._idleTimeout = -1;\\n};\\n\\nexports._unrefActive = exports.active = function(item) {\\n  clearTimeout(item._idleTimeoutId);\\n\\n  var msecs = item._idleTimeout;\\n  if (msecs >= 0) {\\n    item._idleTimeoutId = setTimeout(function onTimeout() {\\n      if (item._onTimeout)\\n        item._onTimeout();\\n    }, msecs);\\n  }\\n};\\n\\n// setimmediate attaches itself to the global object\\n__webpack_require__(85);\\nexports.setImmediate = setImmediate;\\nexports.clearImmediate = clearImmediate;\\n\\n\\n/***/ }),\\n/* 40 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\\\"Cannot call a class as a function\\\")}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0});var _createClass=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,\\\"value\\\"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),Promise=__webpack_require__(25),TurnTest=function(){function e(t){_classCallCheck(this,e),this.connection=t,this.active=!1,this.results={}}return _createClass(e,[{key:\\\"getResults\\\",value:function(){return this.results}},{key:\\\"start\\\",value:function(){var e=this,t=new Promise(function(t,n){e.resolveCb=t,e.rejectCb=n});return this.connection.setMessageCallback(this.handleMessage.bind(this)),this.connection.setErrorCallback(this.handleError.bind(this)),this.active=!0,this.forceStopped=!1,this.initiate(),t}},{key:\\\"stop\\\",value:function(){this.active=!1}},{key:\\\"forceStop\\\",value:function(){this.forceStopped=!0,this.stop(),this.finished()}},{key:\\\"isActive\\\",value:function(){return this.active}},{key:\\\"initiate\\\",value:function(){}},{key:\\\"handleMessage\\\",value:function(e){}},{key:\\\"handleError\\\",value:function(e){}},{key:\\\"send\\\",value:function(e){this.connection.send(e)}},{key:\\\"finished\\\",value:function(){this.active=!1,this.resolveCb()}},{key:\\\"failed\\\",value:function(e){this.active=!1,this.rejectCb(e)}}]),e}();exports.TurnTest=TurnTest;\\n\\n/***/ }),\\n/* 41 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _interopRequireWildcard(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\\\"Cannot call a class as a function\\\")}function randomAsciiString(e){for(var t=\\\"\\\",r=0;r<e;r++)t+=String.fromCharCode(35+58*Math.random());return t}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.randomAsciiString=exports.MessageMaker=void 0;var _createClass=function(){function e(e,t){for(var r=0;r<t.length;r++){var s=t[r];s.enumerable=s.enumerable||!1,s.configurable=!0,\\\"value\\\"in s&&(s.writable=!0),Object.defineProperty(e,s.key,s)}}return function(t,r,s){return r&&e(t.prototype,r),s&&e(t,s),t}}(),_timestamps=__webpack_require__(22),Timestamps=_interopRequireWildcard(_timestamps),MessageMaker=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1200;_classCallCheck(this,e),this.message={timestamp:\\\"\\\",sentBytes:1e4,padding:\\\"\\\"};var r=randomAsciiString(t-Timestamps.getCurrent().toString().length-JSON.stringify(this.message).length);this.message.padding=r}return _createClass(e,[{key:\\\"make\\\",value:function(e){return this.message.timestamp=Timestamps.getCurrent(),this.message.sentBytes=e,JSON.stringify(this.message)}}]),e}();exports.MessageMaker=MessageMaker,exports.randomAsciiString=randomAsciiString;\\n\\n/***/ }),\\n/* 42 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = LocalStatsCollector;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__ = __webpack_require__(1);\\n/**\\n * Provides statistics for the local stream.\\n */\\n\\n\\n\\n/**\\n * Size of the webaudio analyzer buffer.\\n * @type {number}\\n */\\nvar WEBAUDIO_ANALYZER_FFT_SIZE = 2048;\\n\\n/**\\n * Value of the webaudio analyzer smoothing time parameter.\\n * @type {number}\\n */\\nvar WEBAUDIO_ANALYZER_SMOOTING_TIME = 0.8;\\n\\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\\n\\nvar context = null;\\n\\nif (window.AudioContext) {\\n    context = new AudioContext();\\n\\n    // XXX Not all browsers define a suspend method on AudioContext. As the\\n    // invocation is at the (ES6 module) global execution level, it breaks the\\n    // loading of the lib-jitsi-meet library in such browsers and, consequently,\\n    // the loading of the very Web app that uses the lib-jitsi-meet library. For\\n    // example, Google Chrome 40 on Android does not define the method but we\\n    // still want to be able to load the lib-jitsi-meet library there and\\n    // display a page which notifies the user that the Web app is not supported\\n    // there.\\n    context.suspend && context.suspend();\\n}\\n\\n/**\\n * Converts time domain data array to audio level.\\n * @param samples the time domain data array.\\n * @returns {number} the audio level\\n */\\nfunction timeDomainDataToAudioLevel(samples) {\\n\\n    var maxVolume = 0;\\n\\n    var length = samples.length;\\n\\n    for (var i = 0; i < length; i++) {\\n        if (maxVolume < samples[i]) {\\n            maxVolume = samples[i];\\n        }\\n    }\\n\\n    return parseFloat(((maxVolume - 127) / 128).toFixed(3));\\n}\\n\\n/**\\n * Animates audio level change\\n * @param newLevel the new audio level\\n * @param lastLevel the last audio level\\n * @returns {Number} the audio level to be set\\n */\\nfunction animateLevel(newLevel, lastLevel) {\\n    var value = 0;\\n    var diff = lastLevel - newLevel;\\n\\n    if (diff > 0.2) {\\n        value = lastLevel - 0.2;\\n    } else if (diff < -0.4) {\\n        value = lastLevel + 0.4;\\n    } else {\\n        value = newLevel;\\n    }\\n\\n    return parseFloat(value.toFixed(3));\\n}\\n\\n/**\\n * <tt>LocalStatsCollector</tt> calculates statistics for the local stream.\\n *\\n * @param stream the local stream\\n * @param interval stats refresh interval given in ms.\\n * @param callback function that receives the audio levels.\\n * @constructor\\n */\\nfunction LocalStatsCollector(stream, interval, callback) {\\n    this.stream = stream;\\n    this.intervalId = null;\\n    this.intervalMilis = interval;\\n    this.audioLevel = 0;\\n    this.callback = callback;\\n}\\n\\n/**\\n * Starts the collecting the statistics.\\n */\\nLocalStatsCollector.prototype.start = function () {\\n    if (!LocalStatsCollector.isLocalStatsSupported()) {\\n        return;\\n    }\\n    context.resume();\\n    var analyser = context.createAnalyser();\\n\\n    analyser.smoothingTimeConstant = WEBAUDIO_ANALYZER_SMOOTING_TIME;\\n    analyser.fftSize = WEBAUDIO_ANALYZER_FFT_SIZE;\\n\\n    var source = context.createMediaStreamSource(this.stream);\\n\\n    source.connect(analyser);\\n\\n    var self = this;\\n\\n    this.intervalId = setInterval(function () {\\n        var array = new Uint8Array(analyser.frequencyBinCount);\\n\\n        analyser.getByteTimeDomainData(array);\\n        var audioLevel = timeDomainDataToAudioLevel(array);\\n\\n        if (audioLevel !== self.audioLevel) {\\n            self.audioLevel = animateLevel(audioLevel, self.audioLevel);\\n            self.callback(self.audioLevel);\\n        }\\n    }, this.intervalMilis);\\n};\\n\\n/**\\n * Stops collecting the statistics.\\n */\\nLocalStatsCollector.prototype.stop = function () {\\n    if (this.intervalId) {\\n        clearInterval(this.intervalId);\\n        this.intervalId = null;\\n    }\\n};\\n\\n/**\\n * Checks if the environment has the necessary conditions to support\\n * collecting stats from local streams.\\n *\\n * @returns {boolean}\\n */\\nLocalStatsCollector.isLocalStatsSupported = function () {\\n    return Boolean(context && !__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed());\\n};\\n\\n/***/ }),\\n/* 43 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return AUDIO_LEVEL; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return BEFORE_DISPOSED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"c\\\", function() { return BYTE_SENT_STATS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"d\\\", function() { return CONNECTION_STATS; });\\n/**\\n * Notifies about audio level in RTP statistics by SSRC.\\n *\\n * @param ssrc - The synchronization source identifier (SSRC) of the\\n * endpoint/participant whose audio level is being reported.\\n * @param {number} audioLevel - The audio level of <tt>ssrc</tt> according to\\n * RTP statistics.\\n * @param {boolean} isLocal - <tt>true</tt> if <tt>ssrc</tt> identifies the\\n * local endpoint/participant; otherwise, <tt>false</tt>.\\n */\\nvar AUDIO_LEVEL = 'statistics.audioLevel';\\n\\n/**\\n * An event fired just before the statistics module gets disposes and it's\\n * the last chance to submit some logs that will end up in stats services like\\n * CallStats (if enabled).\\n */\\nvar BEFORE_DISPOSED = 'statistics.before_disposed';\\n\\n/**\\n * An event carrying all statistics by ssrc.\\n */\\nvar BYTE_SENT_STATS = 'statistics.byte_sent_stats';\\n\\n/**\\n * An event carrying connection statistics.\\n *\\n * @param {object} connectionStats - The connection statistics carried by the\\n * event such as <tt>bandwidth</tt>, <tt>bitrate</tt>, <tt>packetLoss</tt>,\\n * <tt>resolution</tt>, and <tt>transport</tt>.\\n */\\nvar CONNECTION_STATS = 'statistics.connectionstats';\\n\\n/***/ }),\\n/* 44 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar currentExecutingScript = __webpack_require__(91);\\n\\n/* eslint-disable max-params */\\n\\n/**\\n * Implements utility functions which facilitate the dealing with scripts such\\n * as the download and execution of a JavaScript file.\\n */\\nvar ScriptUtil = {\\n    /**\\n     * Loads a script from a specific source.\\n     *\\n     * @param src the source from the which the script is to be (down)loaded\\n     * @param async true to asynchronously load the script or false to\\n     * synchronously load the script\\n     * @param prepend true to schedule the loading of the script as soon as\\n     * possible or false to schedule the loading of the script at the end of the\\n     * scripts known at the time\\n     * @param relativeURL whether we need load the library from url relative\\n     * to the url that lib-jitsi-meet was loaded. Useful when sourcing the\\n     * library from different location than the app that is using it\\n     * @param loadCallback on load callback function\\n     * @param errorCallback callback to be called on error loading the script\\n     */\\n    loadScript: function loadScript(src, async, prepend, relativeURL, loadCallback, errorCallback) {\\n        var d = document;\\n        var tagName = 'script';\\n        var script = d.createElement(tagName);\\n        var referenceNode = d.getElementsByTagName(tagName)[0];\\n\\n        script.async = async;\\n\\n        if (relativeURL) {\\n            // finds the src url of the current loaded script\\n            // and use it as base of the src supplied argument\\n            var scriptEl = currentExecutingScript();\\n\\n            if (scriptEl) {\\n                var scriptSrc = scriptEl.src;\\n                var baseScriptSrc = scriptSrc.substring(0, scriptSrc.lastIndexOf('/') + 1);\\n\\n                if (scriptSrc && baseScriptSrc) {\\n                    // eslint-disable-next-line no-param-reassign\\n                    src = baseScriptSrc + src;\\n                }\\n            }\\n        }\\n\\n        if (loadCallback) {\\n            script.onload = loadCallback;\\n        }\\n        if (errorCallback) {\\n            script.onerror = errorCallback;\\n        }\\n\\n        script.src = src;\\n        if (prepend) {\\n            referenceNode.parentNode.insertBefore(script, referenceNode);\\n        } else {\\n            referenceNode.parentNode.appendChild(script);\\n        }\\n    }\\n};\\n\\n/* eslint-enable max-params */\\n\\nmodule.exports = ScriptUtil;\\n\\n/***/ }),\\n/* 45 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_strophejs_plugin_disco__ = __webpack_require__(96);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_strophejs_plugin_disco___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_strophejs_plugin_disco__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_RandomUtil__ = __webpack_require__(20);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_RandomUtil___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__util_RandomUtil__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__JitsiConnectionErrors__ = __webpack_require__(46);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__JitsiConnectionEvents__ = __webpack_require__(26);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__strophe_emuc__ = __webpack_require__(97);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__strophe_jingle__ = __webpack_require__(100);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__strophe_util__ = __webpack_require__(108);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__strophe_ping__ = __webpack_require__(109);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__strophe_rayo__ = __webpack_require__(110);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__strophe_logger__ = __webpack_require__(111);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__util_Listenable__ = __webpack_require__(10);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__Caps__ = __webpack_require__(112);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global $ */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n *\\n * @param token\\n * @param bosh\\n */\\nfunction createConnection(token) {\\n    var bosh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/http-bind';\\n\\n    // Append token as URL param\\n    if (token) {\\n        // eslint-disable-next-line no-param-reassign\\n        bosh += (bosh.indexOf('?') === -1 ? '?' : '&') + 'token=' + token;\\n    }\\n\\n    var conn = new __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Connection(bosh);\\n\\n    // The default maxRetries is 5, which is too long.\\n    conn.maxRetries = 3;\\n\\n    return conn;\\n}\\n\\n/**\\n *\\n */\\n\\nvar XMPP = function (_Listenable) {\\n    _inherits(XMPP, _Listenable);\\n\\n    /**\\n     * FIXME describe all options\\n     * @param {Object} options\\n     * @param {Array<Object>} options.p2pStunServers see\\n     * {@link JingleConnectionPlugin} for more details.\\n     * @param token\\n     */\\n    function XMPP(options, token) {\\n        _classCallCheck(this, XMPP);\\n\\n        var _this = _possibleConstructorReturn(this, (XMPP.__proto__ || Object.getPrototypeOf(XMPP)).call(this));\\n\\n        _this.connection = null;\\n        _this.disconnectInProgress = false;\\n        _this.connectionTimes = {};\\n        _this.options = options;\\n        _this.token = token;\\n        _this.authenticatedUser = false;\\n        _this._initStrophePlugins(_this);\\n\\n        _this.connection = createConnection(token, options.bosh);\\n\\n        _this.caps = new __WEBPACK_IMPORTED_MODULE_14__Caps__[\\\"a\\\" /* default */](_this.connection, _this.options.clientNode);\\n\\n        // Initialize features advertised in disco-info\\n        _this.initFeaturesList();\\n\\n        // Setup a disconnect on unload as a way to facilitate API consumers. It\\n        // sounds like they would want that. A problem for them though may be if\\n        // they wanted to utilize the connected connection in an unload handler\\n        // of their own. However, it should be fairly easy for them to do that\\n        // by registering their unload handler before us.\\n        $(window).on('beforeunload unload', _this.disconnect.bind(_this));\\n        return _this;\\n    }\\n\\n    /**\\n     * Initializes the list of feature advertised through the disco-info\\n     * mechanism.\\n     */\\n\\n\\n    _createClass(XMPP, [{\\n        key: 'initFeaturesList',\\n        value: function initFeaturesList() {\\n            // http://xmpp.org/extensions/xep-0167.html#support\\n            // http://xmpp.org/extensions/xep-0176.html#support\\n            this.caps.addFeature('urn:xmpp:jingle:1');\\n            this.caps.addFeature('urn:xmpp:jingle:apps:rtp:1');\\n            this.caps.addFeature('urn:xmpp:jingle:transports:ice-udp:1');\\n            this.caps.addFeature('urn:xmpp:jingle:apps:dtls:0');\\n            this.caps.addFeature('urn:xmpp:jingle:transports:dtls-sctp:1');\\n            this.caps.addFeature('urn:xmpp:jingle:apps:rtp:audio');\\n            this.caps.addFeature('urn:xmpp:jingle:apps:rtp:video');\\n\\n            if (!this.options.disableRtx && __WEBPACK_IMPORTED_MODULE_6__RTC_RTCBrowserType__[\\\"a\\\" /* default */].supportsRtx()) {\\n                this.caps.addFeature('urn:ietf:rfc:4588');\\n            }\\n\\n            // this is dealt with by SDP O/A so we don't need to announce this\\n            // XEP-0293\\n            // this.caps.addFeature('urn:xmpp:jingle:apps:rtp:rtcp-fb:0');\\n            // XEP-0294\\n            // this.caps.addFeature('urn:xmpp:jingle:apps:rtp:rtp-hdrext:0');\\n\\n            this.caps.addFeature('urn:ietf:rfc:5761'); // rtcp-mux\\n            this.caps.addFeature('urn:ietf:rfc:5888'); // a=group, e.g. bundle\\n\\n            // this.caps.addFeature('urn:ietf:rfc:5576'); // a=ssrc\\n\\n            // Enable Lipsync ?\\n            if (__WEBPACK_IMPORTED_MODULE_6__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isChrome() && this.options.enableLipSync !== false) {\\n                logger.info('Lip-sync enabled !');\\n                this.caps.addFeature('http://jitsi.org/meet/lipsync');\\n            }\\n\\n            if (this.connection.rayo) {\\n                this.caps.addFeature('urn:xmpp:rayo:client:1');\\n            }\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'getConnection',\\n        value: function getConnection() {\\n            return this.connection;\\n        }\\n\\n        /**\\n         * Receive connection status changes and handles them.\\n         *\\n         * @param {Object} credentials\\n         * @param {string} credentials.jid - The user's XMPP ID passed to the\\n         * connect method. For example, 'user@xmpp.com'.\\n         * @param {string} credentials.password - The password passed to the connect\\n         * method.\\n         * @param {string} status - One of Strophe's connection status strings.\\n         * @param {string} [msg] - The connection error message provided by Strophe.\\n         */\\n\\n    }, {\\n        key: 'connectionHandler',\\n        value: function connectionHandler() {\\n            var credentials = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n            var _this2 = this;\\n\\n            var status = arguments[1];\\n            var msg = arguments[2];\\n\\n            var now = window.performance.now();\\n            var statusStr = __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getStatusString(status).toLowerCase();\\n\\n            this.connectionTimes[statusStr] = now;\\n            logger.log('(TIME) Strophe ' + statusStr + (msg ? '[' + msg + ']' : '') + ':\\\\t', now);\\n            if (status === __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.CONNECTED || status === __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.ATTACHED) {\\n                if (this.options.useStunTurn || this.options.p2p && this.options.p2p.useStunTurn) {\\n                    this.connection.jingle.getStunAndTurnCredentials();\\n                }\\n\\n                logger.info('My Jabber ID: ' + this.connection.jid);\\n\\n                // Schedule ping ?\\n                var pingJid = this.connection.domain;\\n\\n                this.connection.ping.hasPingSupport(pingJid, function (hasPing) {\\n                    if (hasPing) {\\n                        _this2.connection.ping.startInterval(pingJid);\\n                    } else {\\n                        logger.warn('Ping NOT supported by ' + pingJid);\\n                    }\\n                });\\n\\n                if (credentials.password) {\\n                    this.authenticatedUser = true;\\n                }\\n                if (this.connection && this.connection.connected && __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(this.connection.jid)) {\\n                    // .connected is true while connecting?\\n                    // this.connection.send($pres());\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_5__JitsiConnectionEvents__[\\\"CONNECTION_ESTABLISHED\\\"], __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(this.connection.jid));\\n                }\\n            } else if (status === __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.CONNFAIL) {\\n                if (msg === 'x-strophe-bad-non-anon-jid') {\\n                    this.anonymousConnectionFailed = true;\\n                } else {\\n                    this.connectionFailed = true;\\n                }\\n                this.lastErrorMsg = msg;\\n                if (msg === 'giving-up') {\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_5__JitsiConnectionEvents__[\\\"CONNECTION_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_4__JitsiConnectionErrors__[\\\"OTHER_ERROR\\\"], msg);\\n                }\\n            } else if (status === __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.DISCONNECTED) {\\n                // Stop ping interval\\n                this.connection.ping.stopInterval();\\n                var wasIntentionalDisconnect = this.disconnectInProgress;\\n                var errMsg = msg || this.lastErrorMsg;\\n\\n                this.disconnectInProgress = false;\\n                if (this.anonymousConnectionFailed) {\\n                    // prompt user for username and password\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_5__JitsiConnectionEvents__[\\\"CONNECTION_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_4__JitsiConnectionErrors__[\\\"PASSWORD_REQUIRED\\\"]);\\n                } else if (this.connectionFailed) {\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_5__JitsiConnectionEvents__[\\\"CONNECTION_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_4__JitsiConnectionErrors__[\\\"OTHER_ERROR\\\"], errMsg);\\n                } else if (wasIntentionalDisconnect) {\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_5__JitsiConnectionEvents__[\\\"CONNECTION_DISCONNECTED\\\"], errMsg);\\n                } else {\\n                    // XXX if Strophe drops the connection while not being asked to,\\n                    // it means that most likely some serious error has occurred.\\n                    // One currently known case is when a BOSH request fails for\\n                    // more than 4 times. The connection is dropped without\\n                    // supplying a reason(error message/event) through the API.\\n                    logger.error('XMPP connection dropped!');\\n\\n                    // XXX if the last request error is within 5xx range it means it\\n                    // was a server failure\\n                    var lastErrorStatus = __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getLastErrorStatus();\\n\\n                    if (lastErrorStatus >= 500 && lastErrorStatus < 600) {\\n                        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_5__JitsiConnectionEvents__[\\\"CONNECTION_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_4__JitsiConnectionErrors__[\\\"SERVER_ERROR\\\"], errMsg || 'server-error');\\n                    } else {\\n                        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_5__JitsiConnectionEvents__[\\\"CONNECTION_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_4__JitsiConnectionErrors__[\\\"CONNECTION_DROPPED_ERROR\\\"], errMsg || 'connection-dropped-error');\\n                    }\\n                }\\n            } else if (status === __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.AUTHFAIL) {\\n                // wrong password or username, prompt user\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_5__JitsiConnectionEvents__[\\\"CONNECTION_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_4__JitsiConnectionErrors__[\\\"PASSWORD_REQUIRED\\\"], msg, credentials);\\n            }\\n        }\\n\\n        /**\\n         *\\n         * @param jid\\n         * @param password\\n         */\\n\\n    }, {\\n        key: '_connect',\\n        value: function _connect(jid, password) {\\n            // connection.connect() starts the connection process.\\n            //\\n            // As the connection process proceeds, the user supplied callback will\\n            // be triggered multiple times with status updates. The callback should\\n            // take two arguments - the status code and the error condition.\\n            //\\n            // The status code will be one of the values in the Strophe.Status\\n            // constants. The error condition will be one of the conditions defined\\n            // in RFC 3920 or the condition ‘strophe-parsererror’.\\n            //\\n            // The Parameters wait, hold and route are optional and only relevant\\n            // for BOSH connections. Please see XEP 124 for a more detailed\\n            // explanation of the optional parameters.\\n            //\\n            // Connection status constants for use by the connection handler\\n            // callback.\\n            //\\n            //  Status.ERROR - An error has occurred (websockets specific)\\n            //  Status.CONNECTING - The connection is currently being made\\n            //  Status.CONNFAIL - The connection attempt failed\\n            //  Status.AUTHENTICATING - The connection is authenticating\\n            //  Status.AUTHFAIL - The authentication attempt failed\\n            //  Status.CONNECTED - The connection has succeeded\\n            //  Status.DISCONNECTED - The connection has been terminated\\n            //  Status.DISCONNECTING - The connection is currently being terminated\\n            //  Status.ATTACHED - The connection has been attached\\n\\n            this.anonymousConnectionFailed = false;\\n            this.connectionFailed = false;\\n            this.lastErrorMsg = undefined;\\n            this.connection.connect(jid, password, this.connectionHandler.bind(this, {\\n                jid: jid,\\n                password: password\\n            }));\\n        }\\n\\n        /**\\n         * Attach to existing connection. Can be used for optimizations. For\\n         * example: if the connection is created on the server we can attach to it\\n         * and start using it.\\n         *\\n         * @param options {object} connecting options - rid, sid, jid and password.\\n         */\\n\\n    }, {\\n        key: 'attach',\\n        value: function attach(options) {\\n            var now = this.connectionTimes.attaching = window.performance.now();\\n\\n            logger.log('(TIME) Strophe Attaching\\\\t:' + now);\\n            this.connection.attach(options.jid, options.sid, parseInt(options.rid, 10) + 1, this.connectionHandler.bind(this, {\\n                jid: options.jid,\\n                password: options.password\\n            }));\\n        }\\n\\n        /**\\n         *\\n         * @param jid\\n         * @param password\\n         */\\n\\n    }, {\\n        key: 'connect',\\n        value: function connect(jid, password) {\\n            if (!jid) {\\n                var _options$hosts = this.options.hosts,\\n                    anonymousdomain = _options$hosts.anonymousdomain,\\n                    domain = _options$hosts.domain;\\n\\n                var configDomain = anonymousdomain || domain;\\n\\n                // Force authenticated domain if room is appended with '?login=true'\\n                // or if we're joining with the token\\n\\n                // FIXME Do not rely on window.location because (1) React Native\\n                // does not have a window.location by default and (2) here we cannot\\n                // know for sure that query/search has not be stripped from\\n                // window.location by the time the following executes.\\n                var _window = window,\\n                    location = _window.location;\\n\\n\\n                if (anonymousdomain) {\\n                    var search = location && location.search;\\n\\n                    if (search && search.indexOf('login=true') !== -1 || this.token) {\\n                        configDomain = domain;\\n                    }\\n                }\\n\\n                // eslint-disable-next-line no-param-reassign\\n                jid = configDomain || location && location.hostname;\\n            }\\n\\n            return this._connect(jid, password);\\n        }\\n\\n        /**\\n         *\\n         * @param roomName\\n         * @param options\\n         */\\n\\n    }, {\\n        key: 'createRoom',\\n        value: function createRoom(roomName, options) {\\n            // By default MUC nickname is the resource part of the JID\\n            var mucNickname = __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getNodeFromJid(this.connection.jid);\\n            var roomjid = roomName + '@' + this.options.hosts.muc + '/';\\n            var cfgNickname = options.useNicks && options.nick ? options.nick : null;\\n\\n            if (cfgNickname) {\\n                // Use nick if it's defined\\n                mucNickname = options.nick;\\n            } else if (!this.authenticatedUser) {\\n                // node of the anonymous JID is very long - here we trim it a bit\\n                mucNickname = mucNickname.substr(0, 8);\\n            }\\n\\n            // Constant JIDs need some random part to be appended in order to be\\n            // able to join the MUC more than once.\\n            if (this.authenticatedUser || cfgNickname !== null) {\\n                mucNickname += '-' + __WEBPACK_IMPORTED_MODULE_3__util_RandomUtil___default.a.randomHexString(6);\\n            }\\n\\n            roomjid += mucNickname;\\n\\n            return this.connection.emuc.createRoom(roomjid, null, options);\\n        }\\n\\n        /**\\n         * Returns the logs from strophe.jingle.\\n         * @returns {Object}\\n         */\\n\\n    }, {\\n        key: 'getJingleLog',\\n        value: function getJingleLog() {\\n            var jingle = this.connection.jingle;\\n\\n            return jingle ? jingle.getLog() : {};\\n        }\\n\\n        /**\\n         * Returns the logs from strophe.\\n         */\\n\\n    }, {\\n        key: 'getXmppLog',\\n        value: function getXmppLog() {\\n            return (this.connection.logger || {}).log || null;\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'dial',\\n        value: function dial() {\\n            var _connection$rayo;\\n\\n            (_connection$rayo = this.connection.rayo).dial.apply(_connection$rayo, arguments);\\n        }\\n\\n        /**\\n         *\\n         * @param jid\\n         * @param mute\\n         */\\n\\n    }, {\\n        key: 'setMute',\\n        value: function setMute(jid, mute) {\\n            this.connection.moderate.setMute(jid, mute);\\n        }\\n\\n        /**\\n         *\\n         * @param jid\\n         */\\n\\n    }, {\\n        key: 'eject',\\n        value: function eject(jid) {\\n            this.connection.moderate.eject(jid);\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'getSessions',\\n        value: function getSessions() {\\n            return this.connection.jingle.sessions;\\n        }\\n\\n        /**\\n         * Disconnects this from the XMPP server (if this is connected).\\n         *\\n         * @param ev optionally, the event which triggered the necessity to\\n         * disconnect from the XMPP server (e.g. beforeunload, unload).\\n         */\\n\\n    }, {\\n        key: 'disconnect',\\n        value: function disconnect(ev) {\\n            if (this.disconnectInProgress || !this.connection || !this.connection.connected) {\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_5__JitsiConnectionEvents__[\\\"WRONG_STATE\\\"]);\\n\\n                return;\\n            }\\n\\n            this.disconnectInProgress = true;\\n\\n            // XXX Strophe is asynchronously sending by default. Unfortunately, that\\n            // means that there may not be enough time to send an unavailable\\n            // presence or disconnect at all. Switching Strophe to synchronous\\n            // sending is not much of an option because it may lead to a noticeable\\n            // delay in navigating away from the current location. As a compromise,\\n            // we will try to increase the chances of sending an unavailable\\n            // presence and/or disconecting within the short time span that we have\\n            // upon unloading by invoking flush() on the connection. We flush() once\\n            // before disconnect() in order to attemtp to have its unavailable\\n            // presence at the top of the send queue. We flush() once more after\\n            // disconnect() in order to attempt to have its unavailable presence\\n            // sent as soon as possible.\\n            this.connection.flush();\\n\\n            if (ev !== null && typeof ev !== 'undefined') {\\n                var evType = ev.type;\\n\\n                if (evType === 'beforeunload' || evType === 'unload') {\\n                    // XXX Whatever we said above, synchronous sending is the best\\n                    // (known) way to properly disconnect from the XMPP server.\\n                    // Consequently, it may be fine to have the source code and\\n                    // comment it in or out depending on whether we want to run with\\n                    // it for some time.\\n                    this.connection.options.sync = true;\\n                }\\n            }\\n\\n            this.connection.disconnect();\\n\\n            if (this.connection.options.sync !== true) {\\n                this.connection.flush();\\n            }\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: '_initStrophePlugins',\\n        value: function _initStrophePlugins() {\\n            var iceConfig = {\\n                jvb: { iceServers: [] },\\n                p2p: { iceServers: [] }\\n            };\\n\\n            // FIXME: remove once we have a default config template. -saghul\\n            var defaultStunServers = [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }, { urls: 'stun:stun2.l.google.com:19302' }];\\n\\n            var p2pStunServers = this.options.p2p && this.options.p2p.stunServers || defaultStunServers;\\n\\n            if (Array.isArray(p2pStunServers)) {\\n                logger.info('P2P STUN servers: ', p2pStunServers);\\n                iceConfig.p2p.iceServers = p2pStunServers;\\n            }\\n\\n            if (this.options.p2p && this.options.p2p.iceTransportPolicy) {\\n                logger.info('P2P ICE transport policy: ', this.options.p2p.iceTransportPolicy);\\n\\n                iceConfig.p2p.iceTransportPolicy = this.options.p2p.iceTransportPolicy;\\n            }\\n\\n            Object(__WEBPACK_IMPORTED_MODULE_7__strophe_emuc__[\\\"a\\\" /* default */])(this);\\n            Object(__WEBPACK_IMPORTED_MODULE_8__strophe_jingle__[\\\"a\\\" /* default */])(this, this.eventEmitter, iceConfig);\\n            Object(__WEBPACK_IMPORTED_MODULE_9__strophe_util__[\\\"a\\\" /* default */])();\\n            Object(__WEBPACK_IMPORTED_MODULE_10__strophe_ping__[\\\"a\\\" /* default */])(this);\\n            Object(__WEBPACK_IMPORTED_MODULE_11__strophe_rayo__[\\\"a\\\" /* default */])();\\n            Object(__WEBPACK_IMPORTED_MODULE_12__strophe_logger__[\\\"a\\\" /* default */])();\\n        }\\n    }]);\\n\\n    return XMPP;\\n}(__WEBPACK_IMPORTED_MODULE_13__util_Listenable__[\\\"a\\\" /* default */]);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (XMPP);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/xmpp.js\\\"))\\n\\n/***/ }),\\n/* 46 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CONNECTION_DROPPED_ERROR\\\", function() { return CONNECTION_DROPPED_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OTHER_ERROR\\\", function() { return OTHER_ERROR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PASSWORD_REQUIRED\\\", function() { return PASSWORD_REQUIRED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SERVER_ERROR\\\", function() { return SERVER_ERROR; });\\n/**\\n * The errors for the connection.\\n */\\n\\n/**\\n * Indicates that the connection was dropped with an error which was most likely\\n * caused by some networking issues. The dropped term in this context means that\\n * the connection was closed unexpectedly (not on user's request).\\n *\\n * One example is 'item-not-found' error thrown by Prosody when the BOSH session\\n * times out after 60 seconds of inactivity. On the other hand 'item-not-found'\\n * could also happen when BOSH request is sent to the server with the session-id\\n * that is not know to the server. But this should not happen in lib-jitsi-meet\\n * case as long as the service is configured correctly (there is no bug).\\n */\\nvar CONNECTION_DROPPED_ERROR = 'connection.droppedError';\\n\\n/**\\n * Not specified errors.\\n */\\nvar OTHER_ERROR = 'connection.otherError';\\n\\n/**\\n * Indicates that a password is required in order to join the conference.\\n */\\nvar PASSWORD_REQUIRED = 'connection.passwordRequired';\\n\\n/**\\n * Indicates that the connection was dropped, because of too many 5xx HTTP\\n * errors on BOSH requests.\\n */\\nvar SERVER_ERROR = 'connection.serverError';\\n\\n/***/ }),\\n/* 47 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ON\\\", function() { return ON; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"OFF\\\", function() { return OFF; });\\n/**\\n * The transciption is on.\\n *\\n * @type {String}\\n */\\nvar ON = 'on';\\n\\n/**\\n * The transciption is off.\\n *\\n * @type {String}\\n */\\nvar OFF = 'off';\\n\\n/***/ }),\\n/* 48 */\\n/***/ (function(module, exports) {\\n\\nvar AuthenticationEvents = {\\n  /**\\n   * Event callback arguments:\\n   * function(authenticationEnabled, userIdentity)\\n   * authenticationEnabled - indicates whether authentication has been enabled\\n   *                         in this session\\n   * userIdentity - if user has been logged in then it contains user name. If\\n   *                contains 'null' or 'undefined' then user is not logged in.\\n   */\\n  IDENTITY_UPDATED: 'authentication.identity_updated'\\n};\\n\\nmodule.exports = AuthenticationEvents;\\n\\n/***/ }),\\n/* 49 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = Recording;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_strophe_js__);\\n/* global $ */\\n\\n\\n\\n\\nvar XMPPEvents = __webpack_require__(8);\\nvar JitsiRecorderErrors = __webpack_require__(50);\\nvar GlobalOnErrorHandler = __webpack_require__(3);\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Extracts the error details from given error element/node.\\n *\\n * @param {Element|Object} errorIqNode - Either DOM element or the structure\\n * from ChatRoom packet2JSON.\\n * @return {{\\n *     code: string,\\n *     type: string,\\n *     message: string\\n * }}\\n */\\nfunction getJibriErrorDetails(errorIqNode) {\\n    if (typeof errorIqNode.querySelector === 'function') {\\n        var _error = errorIqNode.querySelector('error');\\n        var _errorText = _error && _error.querySelector('text');\\n\\n        return _error && {\\n            code: _error.attributes.code && _error.attributes.code.value,\\n            type: _error.attributes.type && _error.attributes.type.value,\\n            message: _errorText && _errorText.textContent\\n        };\\n    }\\n\\n    var error = null;\\n\\n    var _iteratorNormalCompletion = true;\\n    var _didIteratorError = false;\\n    var _iteratorError = undefined;\\n\\n    try {\\n        for (var _iterator = errorIqNode.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n            var child = _step.value;\\n\\n            if (child.tagName === 'error') {\\n                error = child;\\n                break;\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError = true;\\n        _iteratorError = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion && _iterator.return) {\\n                _iterator.return();\\n            }\\n        } finally {\\n            if (_didIteratorError) {\\n                throw _iteratorError;\\n            }\\n        }\\n    }\\n\\n    if (!error) {\\n        return null;\\n    }\\n\\n    var errorText = null;\\n\\n    var _iteratorNormalCompletion2 = true;\\n    var _didIteratorError2 = false;\\n    var _iteratorError2 = undefined;\\n\\n    try {\\n        for (var _iterator2 = error.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n            var errorChild = _step2.value;\\n\\n            if (errorChild.tagName === 'text') {\\n                errorText = errorChild.value;\\n                break;\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError2 = true;\\n        _iteratorError2 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                _iterator2.return();\\n            }\\n        } finally {\\n            if (_didIteratorError2) {\\n                throw _iteratorError2;\\n            }\\n        }\\n    }\\n\\n    return {\\n        code: error.attributes.code,\\n        type: error.attributes.type,\\n        message: errorText\\n    };\\n}\\n\\n/* eslint-disable max-params */\\n\\n/**\\n *\\n * @param type\\n * @param eventEmitter\\n * @param connection\\n * @param focusMucJid\\n * @param jirecon\\n * @param roomjid\\n */\\nfunction Recording(type, eventEmitter, connection, focusMucJid, jirecon, roomjid) {\\n    this.eventEmitter = eventEmitter;\\n    this.connection = connection;\\n    this.state = null;\\n    this.focusMucJid = focusMucJid;\\n    this.jirecon = jirecon;\\n    this.url = null;\\n    this.type = type;\\n    this._isSupported = !(type === Recording.types.JIRECON && !this.jirecon || type !== Recording.types.JIBRI && type !== Recording.types.JIBRI_FILE && type !== Recording.types.COLIBRI);\\n\\n    /**\\n     * The ID of the jirecon recording session. Jirecon generates it when we\\n     * initially start recording, and it needs to be used in subsequent requests\\n     * to jirecon.\\n     */\\n    this.jireconRid = null;\\n    this.roomjid = roomjid;\\n}\\n\\n/* eslint-enable max-params */\\n\\nRecording.types = {\\n    COLIBRI: 'colibri',\\n    JIRECON: 'jirecon',\\n    JIBRI: 'jibri',\\n    JIBRI_FILE: 'jibri_file'\\n};\\n\\nRecording.status = {\\n    ON: 'on',\\n    OFF: 'off',\\n    AVAILABLE: 'available',\\n    UNAVAILABLE: 'unavailable',\\n    PENDING: 'pending',\\n    RETRYING: 'retrying',\\n    ERROR: 'error',\\n    BUSY: 'busy',\\n    FAILED: 'failed'\\n};\\n\\nRecording.action = {\\n    START: 'start',\\n    STOP: 'stop'\\n};\\n\\nRecording.prototype.handleJibriPresence = function (jibri) {\\n    var attributes = jibri.attributes;\\n\\n    if (!attributes) {\\n        return;\\n    }\\n\\n    var newState = attributes.status;\\n    var errorDetails = getJibriErrorDetails(jibri);\\n\\n    logger.log('Handle Jibri presence : ' + newState, errorDetails);\\n\\n    if (newState === this.state) {\\n        return;\\n    }\\n\\n    if (newState === 'undefined') {\\n        this.state = Recording.status.UNAVAILABLE;\\n    } else if (newState === Recording.status.OFF) {\\n        if (!this.state || this.state === 'undefined' || this.state === Recording.status.UNAVAILABLE) {\\n            this.state = Recording.status.AVAILABLE;\\n        } else {\\n            this.state = Recording.status.OFF;\\n        }\\n    } else {\\n        this.state = newState;\\n    }\\n\\n    this.eventEmitter.emit(XMPPEvents.RECORDER_STATE_CHANGED, this.state);\\n};\\n\\n/* eslint-disable max-params */\\n\\nRecording.prototype.setRecordingJibri = function (state, callback, errCallback) {\\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\\n\\n    if (state === this.state) {\\n        errCallback(JitsiRecorderErrors.INVALID_STATE);\\n    }\\n\\n    // FIXME jibri does not accept IQ without 'url' attribute set ?\\n    var iq = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({\\n        to: this.focusMucJid,\\n        type: 'set'\\n    }).c('jibri', {\\n        'xmlns': 'http://jitsi.org/protocol/jibri',\\n        'action': state === Recording.status.ON ? Recording.action.START : Recording.action.STOP,\\n        'recording_mode': this.type === Recording.types.JIBRI_FILE ? 'file' : 'stream',\\n        'streamid': this.type === Recording.types.JIBRI ? options.streamId : undefined\\n    }).up();\\n\\n    logger.log('Set jibri recording: ' + state, iq.nodeTree);\\n    logger.log(iq.nodeTree);\\n    this.connection.sendIQ(iq, function (result) {\\n        logger.log('Result', result);\\n\\n        var jibri = $(result).find('jibri');\\n\\n        callback(jibri.attr('state'), jibri.attr('url'));\\n    }, function (error) {\\n        logger.log('Failed to start recording, error: ', getJibriErrorDetails(error));\\n        errCallback(error);\\n    });\\n};\\n\\n/* eslint-enable max-params */\\n\\nRecording.prototype.setRecordingJirecon = function (state, callback, errCallback) {\\n    if (state === this.state) {\\n        errCallback(new Error('Invalid state!'));\\n    }\\n\\n    var iq = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({\\n        to: this.jirecon,\\n        type: 'set'\\n    }).c('recording', { xmlns: 'http://jitsi.org/protocol/jirecon',\\n        action: state === Recording.status.ON ? Recording.action.START : Recording.action.STOP,\\n        mucjid: this.roomjid });\\n\\n    if (state === Recording.status.OFF) {\\n        iq.attrs({ rid: this.jireconRid });\\n    }\\n\\n    logger.log('Start recording');\\n    var self = this;\\n\\n    this.connection.sendIQ(iq, function (result) {\\n        // TODO wait for an IQ with the real status, since this is\\n        // provisional?\\n        // eslint-disable-next-line newline-per-chained-call\\n        self.jireconRid = $(result).find('recording').attr('rid');\\n\\n        var stateStr = state === Recording.status.ON ? 'started' : 'stopped';\\n\\n        logger.log('Recording ' + stateStr + '(jirecon)' + result);\\n\\n        self.state = state;\\n        if (state === Recording.status.OFF) {\\n            self.jireconRid = null;\\n        }\\n\\n        callback(state);\\n    }, function (error) {\\n        logger.log('Failed to start recording, error: ', error);\\n        errCallback(error);\\n    });\\n};\\n\\n/* eslint-disable max-params */\\n\\n// Sends a COLIBRI message which enables or disables (according to 'state')\\n// the recording on the bridge. Waits for the result IQ and calls 'callback'\\n// with the new recording state, according to the IQ.\\nRecording.prototype.setRecordingColibri = function (state, callback, errCallback, options) {\\n    var elem = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({\\n        to: this.focusMucJid,\\n        type: 'set'\\n    });\\n\\n    elem.c('conference', {\\n        xmlns: 'http://jitsi.org/protocol/colibri'\\n    });\\n    elem.c('recording', {\\n        state: state,\\n        token: options.token\\n    });\\n\\n    var self = this;\\n\\n    this.connection.sendIQ(elem, function (result) {\\n        logger.log('Set recording \\\"', state, '\\\". Result:', result);\\n        var recordingElem = $(result).find('>conference>recording');\\n        var newState = recordingElem.attr('state');\\n\\n        self.state = newState;\\n        callback(newState);\\n\\n        if (newState === 'pending') {\\n            self.connection.addHandler(function (iq) {\\n                // eslint-disable-next-line newline-per-chained-call\\n                var s = $(iq).find('recording').attr('state');\\n\\n                if (s) {\\n                    self.state = newState;\\n                    callback(s);\\n                }\\n            }, 'http://jitsi.org/protocol/colibri', 'iq', null, null, null);\\n        }\\n    }, function (error) {\\n        logger.warn(error);\\n        errCallback(error);\\n    });\\n};\\n\\n/* eslint-enable max-params */\\n\\nRecording.prototype.setRecording = function () {\\n    switch (this.type) {\\n        case Recording.types.JIRECON:\\n            this.setRecordingJirecon.apply(this, arguments);\\n            break;\\n        case Recording.types.COLIBRI:\\n            this.setRecordingColibri.apply(this, arguments);\\n            break;\\n        case Recording.types.JIBRI:\\n        case Recording.types.JIBRI_FILE:\\n            this.setRecordingJibri.apply(this, arguments);\\n            break;\\n        default:\\n            {\\n                var errmsg = 'Unknown recording type!';\\n\\n                GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\\n                logger.error(errmsg);\\n                break;\\n            }\\n    }\\n};\\n\\n/**\\n * Starts/stops the recording.\\n * @param {Object} options\\n * @param {string} options.token token for authentication\\n * @param {string} options.streamId the stream ID to be used with Jibri in\\n * the streaming mode.\\n * @param statusChangeHandler {function} receives the new status as argument.\\n */\\nRecording.prototype.toggleRecording = function () {\\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n    var statusChangeHandler = arguments[1];\\n\\n    var oldState = this.state;\\n\\n    // If the recorder is currently unavailable we throw an error.\\n    if (oldState === Recording.status.UNAVAILABLE || oldState === Recording.status.FAILED) {\\n        statusChangeHandler(Recording.status.FAILED, JitsiRecorderErrors.RECORDER_UNAVAILABLE);\\n    } else if (oldState === Recording.status.BUSY) {\\n        statusChangeHandler(Recording.status.BUSY, JitsiRecorderErrors.RECORDER_BUSY);\\n    }\\n\\n    // If we're about to turn ON the recording we need either a streamId or\\n    // an authentication token depending on the recording type. If we don't\\n    // have any of those we throw an error.\\n    if ((oldState === Recording.status.OFF || oldState === Recording.status.AVAILABLE) && (!options.token && this.type === Recording.types.COLIBRI || !options.streamId && this.type === Recording.types.JIBRI)) {\\n        statusChangeHandler(Recording.status.FAILED, JitsiRecorderErrors.NO_TOKEN);\\n        logger.error('No token passed!');\\n\\n        return;\\n    }\\n\\n    var newState = oldState === Recording.status.AVAILABLE || oldState === Recording.status.OFF ? Recording.status.ON : Recording.status.OFF;\\n\\n    var self = this;\\n\\n    logger.log('Toggle recording (old state, new state): ', oldState, newState);\\n    this.setRecording(newState, function (state, url) {\\n        // If the state is undefined we're going to wait for presence\\n        // update.\\n        if (state && state !== oldState) {\\n            self.state = state;\\n            self.url = url;\\n            statusChangeHandler(state);\\n        }\\n    }, function (error) {\\n        return statusChangeHandler(Recording.status.FAILED, error);\\n    }, options);\\n};\\n\\n/**\\n * Returns true if the recording is supproted and false if not.\\n */\\nRecording.prototype.isSupported = function () {\\n    return this._isSupported;\\n};\\n\\n/**\\n * Returns null if the recording is not supported, \\\"on\\\" if the recording started\\n * and \\\"off\\\" if the recording is not started.\\n */\\nRecording.prototype.getState = function () {\\n    return this.state;\\n};\\n\\n/**\\n * Returns the url of the recorded video.\\n */\\nRecording.prototype.getURL = function () {\\n    return this.url;\\n};\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/recording.js\\\"))\\n\\n/***/ }),\\n/* 50 */\\n/***/ (function(module, exports) {\\n\\n/**\\n * Enumeration with the errors for the conference.\\n * @type {{string: string}}\\n */\\nvar JitsiRecorderErrors = {\\n  /**\\n   * Indicates that the recorder is currently unavailable.\\n   */\\n  RECORDER_UNAVAILABLE: 'recorder.unavailable',\\n\\n  /**\\n   * Indicates that all available recorders are currently busy.\\n   */\\n  RECORDER_BUSY: 'recorder.busy',\\n\\n  /**\\n   * Indicates that the authentication token is missing.\\n   */\\n  NO_TOKEN: 'recorder.noToken',\\n\\n  /**\\n   * Indicates that a state change failed.\\n   */\\n  STATE_CHANGE_FAILED: 'recorder.stateChangeFailed',\\n\\n  /**\\n   * Indicates an invalid state.\\n   */\\n  INVALID_STATE: 'recorder.invalidState'\\n};\\n\\nmodule.exports = JitsiRecorderErrors;\\n\\n/***/ }),\\n/* 51 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"c\\\", function() { return PENDING; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return ACTIVE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return ENDED; });\\n/**\\n * The pending Jingle session state which means the session as defined in\\n * XEP-0166(before 'session-invite/session-accept' took place).\\n *\\n * @type {string}\\n */\\nvar PENDING = 'pending';\\n\\n/**\\n * The active Jingle session state as defined in XEP-0166\\n * (after 'session-invite'/'session-accept').\\n *\\n * @type {string}\\n */\\nvar ACTIVE = 'active';\\n\\n/**\\n * The ended Jingle session state as defined in XEP-0166\\n * (after 'session-terminate').\\n * @type {string}\\n */\\nvar ENDED = 'ended';\\n\\n/***/ }),\\n/* 52 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = SDP;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SDPUtil__ = __webpack_require__(14);\\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\\\"return\\\"]) _i[\\\"return\\\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\"); } }; }();\\n\\n/* global $ */\\n\\n\\n\\n/**\\n *\\n * @param sdp\\n */\\nfunction SDP(sdp) {\\n    var media = sdp.split('\\\\r\\\\nm=');\\n\\n    for (var i = 1, length = media.length; i < length; i++) {\\n        var mediaI = 'm=' + media[i];\\n\\n        if (i !== length - 1) {\\n            mediaI += '\\\\r\\\\n';\\n        }\\n        media[i] = mediaI;\\n    }\\n    var session = media.shift() + '\\\\r\\\\n';\\n\\n    this.media = media;\\n    this.raw = session + media.join('');\\n    this.session = session;\\n}\\n\\n/**\\n * A flag will make {@link transportToJingle} and {@link jingle2media} replace\\n * ICE candidates IPs with invalid value of '1.1.1.1' which will cause ICE\\n * failure. The flag is used in the automated testing.\\n * @type {boolean}\\n */\\nSDP.prototype.failICE = false;\\n\\n/**\\n * Whether or not to remove TCP ice candidates when translating from/to jingle.\\n * @type {boolean}\\n */\\nSDP.prototype.removeTcpCandidates = false;\\n\\n/**\\n * Whether or not to remove UDP ice candidates when translating from/to jingle.\\n * @type {boolean}\\n */\\nSDP.prototype.removeUdpCandidates = false;\\n\\n/**\\n * Returns map of MediaChannel mapped per channel idx.\\n */\\nSDP.prototype.getMediaSsrcMap = function () {\\n    var self = this;\\n    var mediaSSRCs = {};\\n    var tmp = void 0;\\n\\n    var _loop = function _loop(mediaindex) {\\n        tmp = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(self.media[mediaindex], 'a=ssrc:');\\n        var mid = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseMID(__WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(self.media[mediaindex], 'a=mid:'));\\n        var media = {\\n            mediaindex: mediaindex,\\n            mid: mid,\\n            ssrcs: {},\\n            ssrcGroups: []\\n        };\\n\\n        mediaSSRCs[mediaindex] = media;\\n        tmp.forEach(function (line) {\\n            var linessrc = line.substring(7).split(' ')[0];\\n\\n            // allocate new ChannelSsrc\\n\\n            if (!media.ssrcs[linessrc]) {\\n                media.ssrcs[linessrc] = {\\n                    ssrc: linessrc,\\n                    lines: []\\n                };\\n            }\\n            media.ssrcs[linessrc].lines.push(line);\\n        });\\n        tmp = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(self.media[mediaindex], 'a=ssrc-group:');\\n        tmp.forEach(function (line) {\\n            var idx = line.indexOf(' ');\\n            var semantics = line.substr(0, idx).substr(13);\\n            var ssrcs = line.substr(14 + semantics.length).split(' ');\\n\\n            if (ssrcs.length) {\\n                media.ssrcGroups.push({\\n                    semantics: semantics,\\n                    ssrcs: ssrcs\\n                });\\n            }\\n        });\\n    };\\n\\n    for (var mediaindex = 0; mediaindex < self.media.length; mediaindex++) {\\n        _loop(mediaindex);\\n    }\\n\\n    return mediaSSRCs;\\n};\\n\\n/**\\n * Returns <tt>true</tt> if this SDP contains given SSRC.\\n * @param ssrc the ssrc to check.\\n * @returns {boolean} <tt>true</tt> if this SDP contains given SSRC.\\n */\\nSDP.prototype.containsSSRC = function (ssrc) {\\n    // FIXME this code is really strange - improve it if you can\\n    var medias = this.getMediaSsrcMap();\\n    var result = false;\\n\\n    Object.keys(medias).forEach(function (mediaindex) {\\n        if (result) {\\n            return;\\n        }\\n        if (medias[mediaindex].ssrcs[ssrc]) {\\n            result = true;\\n        }\\n    });\\n\\n    return result;\\n};\\n\\n// remove iSAC and CN from SDP\\nSDP.prototype.mangle = function () {\\n    var i = void 0,\\n        j = void 0,\\n        lines = void 0,\\n        mline = void 0,\\n        newdesc = void 0,\\n        rtpmap = void 0;\\n\\n    for (i = 0; i < this.media.length; i++) {\\n        lines = this.media[i].split('\\\\r\\\\n');\\n        lines.pop(); // remove empty last element\\n        mline = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseMLine(lines.shift());\\n        if (mline.media !== 'audio') {\\n            continue; // eslint-disable-line no-continue\\n        }\\n        newdesc = '';\\n        mline.fmt.length = 0;\\n        for (j = 0; j < lines.length; j++) {\\n            if (lines[j].substr(0, 9) === 'a=rtpmap:') {\\n                rtpmap = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseRTPMap(lines[j]);\\n                if (rtpmap.name === 'CN' || rtpmap.name === 'ISAC') {\\n                    continue; // eslint-disable-line no-continue\\n                }\\n                mline.fmt.push(rtpmap.id);\\n            }\\n            newdesc += lines[j] + '\\\\r\\\\n';\\n        }\\n        this.media[i] = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].buildMLine(mline) + '\\\\r\\\\n' + newdesc;\\n    }\\n    this.raw = this.session + this.media.join('');\\n};\\n\\n// remove lines matching prefix from session section\\nSDP.prototype.removeSessionLines = function (prefix) {\\n    var self = this;\\n    var lines = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(this.session, prefix);\\n\\n    lines.forEach(function (line) {\\n        self.session = self.session.replace(line + '\\\\r\\\\n', '');\\n    });\\n    this.raw = this.session + this.media.join('');\\n\\n    return lines;\\n};\\n\\n// remove lines matching prefix from a media section specified by mediaindex\\n// TODO: non-numeric mediaindex could match mid\\nSDP.prototype.removeMediaLines = function (mediaindex, prefix) {\\n    var self = this;\\n    var lines = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(this.media[mediaindex], prefix);\\n\\n    lines.forEach(function (line) {\\n        self.media[mediaindex] = self.media[mediaindex].replace(line + '\\\\r\\\\n', '');\\n    });\\n    this.raw = this.session + this.media.join('');\\n\\n    return lines;\\n};\\n\\n// add content's to a jingle element\\nSDP.prototype.toJingle = function (elem, thecreator) {\\n    var i = void 0,\\n        j = void 0,\\n        k = void 0,\\n        lines = void 0,\\n        mline = void 0,\\n        rtpmap = void 0,\\n        ssrc = void 0,\\n        tmp = void 0;\\n\\n    // new bundle plan\\n\\n    lines = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(this.session, 'a=group:');\\n    if (lines.length) {\\n        for (i = 0; i < lines.length; i++) {\\n            tmp = lines[i].split(' ');\\n            var semantics = tmp.shift().substr(8);\\n\\n            elem.c('group', { xmlns: 'urn:xmpp:jingle:apps:grouping:0',\\n                semantics: semantics });\\n            for (j = 0; j < tmp.length; j++) {\\n                elem.c('content', { name: tmp[j] }).up();\\n            }\\n            elem.up();\\n        }\\n    }\\n    for (i = 0; i < this.media.length; i++) {\\n        mline = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseMLine(this.media[i].split('\\\\r\\\\n')[0]);\\n        if (!(mline.media === 'audio' || mline.media === 'video' || mline.media === 'application')) {\\n            continue; // eslint-disable-line no-continue\\n        }\\n        var assrcline = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(this.media[i], 'a=ssrc:');\\n\\n        if (assrcline) {\\n            ssrc = assrcline.substring(7).split(' ')[0]; // take the first\\n        } else {\\n            ssrc = false;\\n        }\\n\\n        elem.c('content', { creator: thecreator,\\n            name: mline.media });\\n        var amidline = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(this.media[i], 'a=mid:');\\n\\n        if (amidline) {\\n            // prefer identifier from a=mid if present\\n            var mid = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseMID(amidline);\\n\\n            elem.attrs({ name: mid });\\n        }\\n\\n        if (__WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(this.media[i], 'a=rtpmap:').length) {\\n            elem.c('description', { xmlns: 'urn:xmpp:jingle:apps:rtp:1',\\n                media: mline.media });\\n            if (ssrc) {\\n                elem.attrs({ ssrc: ssrc });\\n            }\\n            for (j = 0; j < mline.fmt.length; j++) {\\n                rtpmap = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(this.media[i], 'a=rtpmap:' + mline.fmt[j]);\\n                elem.c('payload-type', __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseRTPMap(rtpmap));\\n\\n                // put any 'a=fmtp:' + mline.fmt[j] lines into <param name=foo\\n                // value=bar/>\\n                var afmtpline = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(this.media[i], 'a=fmtp:' + mline.fmt[j]);\\n\\n                if (afmtpline) {\\n                    tmp = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseFmtp(afmtpline);\\n\\n                    // eslint-disable-next-line max-depth\\n                    for (k = 0; k < tmp.length; k++) {\\n                        elem.c('parameter', tmp[k]).up();\\n                    }\\n                }\\n\\n                // XEP-0293 -- map a=rtcp-fb\\n                this.rtcpFbToJingle(i, elem, mline.fmt[j]);\\n\\n                elem.up();\\n            }\\n            var crypto = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(this.media[i], 'a=crypto:', this.session);\\n\\n            if (crypto.length) {\\n                elem.c('encryption', { required: 1 });\\n                crypto.forEach(function (line) {\\n                    return elem.c('crypto', __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseCrypto(line)).up();\\n                });\\n                elem.up(); // end of encryption\\n            }\\n\\n            if (ssrc) {\\n                var ssrcMap = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseSSRC(this.media[i]);\\n\\n                var _iteratorNormalCompletion = true;\\n                var _didIteratorError = false;\\n                var _iteratorError = undefined;\\n\\n                try {\\n                    for (var _iterator = ssrcMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                        var _ref = _step.value;\\n\\n                        var _ref2 = _slicedToArray(_ref, 2);\\n\\n                        var availableSsrc = _ref2[0];\\n                        var ssrcParameters = _ref2[1];\\n\\n                        elem.c('source', {\\n                            ssrc: availableSsrc,\\n                            xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'\\n                        });\\n\\n                        ssrcParameters.forEach(function (ssrcSdpLine) {\\n                            // get everything after first space\\n                            var idx = ssrcSdpLine.indexOf(' ');\\n                            var kv = ssrcSdpLine.substr(idx + 1);\\n\\n                            elem.c('parameter');\\n                            if (kv.indexOf(':') === -1) {\\n                                elem.attrs({ name: kv });\\n                            } else {\\n                                var name = kv.split(':', 2)[0];\\n\\n                                elem.attrs({ name: name });\\n\\n                                var v = kv.split(':', 2)[1];\\n\\n                                v = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].filterSpecialChars(v);\\n                                elem.attrs({ value: v });\\n                            }\\n                            elem.up();\\n                        });\\n\\n                        elem.up();\\n                    }\\n\\n                    // XEP-0339 handle ssrc-group attributes\\n                } catch (err) {\\n                    _didIteratorError = true;\\n                    _iteratorError = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion && _iterator.return) {\\n                            _iterator.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError) {\\n                            throw _iteratorError;\\n                        }\\n                    }\\n                }\\n\\n                var ssrcGroupLines = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(this.media[i], 'a=ssrc-group:');\\n\\n                ssrcGroupLines.forEach(function (line) {\\n                    var idx = line.indexOf(' ');\\n                    var semantics = line.substr(0, idx).substr(13);\\n                    var ssrcs = line.substr(14 + semantics.length).split(' ');\\n\\n                    if (ssrcs.length) {\\n                        elem.c('ssrc-group', { semantics: semantics,\\n                            xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\\n                        ssrcs.forEach(function (s) {\\n                            return elem.c('source', { ssrc: s }).up();\\n                        });\\n                        elem.up();\\n                    }\\n                });\\n            }\\n\\n            var ridLines = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(this.media[i], 'a=rid');\\n\\n            if (ridLines.length) {\\n                // Map a line which looks like \\\"a=rid:2 send\\\" to just\\n                // the rid (\\\"2\\\")\\n                var rids = ridLines.map(function (ridLine) {\\n                    return ridLine.split(':')[1];\\n                }).map(function (ridInfo) {\\n                    return ridInfo.split(' ')[0];\\n                });\\n\\n                rids.forEach(function (rid) {\\n                    elem.c('source', {\\n                        rid: rid,\\n                        xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'\\n                    });\\n                    elem.up();\\n                });\\n                var unifiedSimulcast = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(this.media[i], 'a=simulcast');\\n\\n                if (unifiedSimulcast) {\\n                    elem.c('rid-group', {\\n                        semantics: 'SIM',\\n                        xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'\\n                    });\\n                    rids.forEach(function (rid) {\\n                        elem.c('source', { rid: rid }).up();\\n                    });\\n                    elem.up();\\n                }\\n            }\\n\\n            if (__WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(this.media[i], 'a=rtcp-mux')) {\\n                elem.c('rtcp-mux').up();\\n            }\\n\\n            // XEP-0293 -- map a=rtcp-fb:*\\n            this.rtcpFbToJingle(i, elem, '*');\\n\\n            // XEP-0294\\n            lines = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(this.media[i], 'a=extmap:');\\n            if (lines.length) {\\n                for (j = 0; j < lines.length; j++) {\\n                    tmp = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseExtmap(lines[j]);\\n                    elem.c('rtp-hdrext', {\\n                        xmlns: 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',\\n                        uri: tmp.uri,\\n                        id: tmp.value\\n                    });\\n\\n                    // eslint-disable-next-line max-depth\\n                    if (tmp.hasOwnProperty('direction')) {\\n\\n                        // eslint-disable-next-line max-depth\\n                        switch (tmp.direction) {\\n                            case 'sendonly':\\n                                elem.attrs({ senders: 'responder' });\\n                                break;\\n                            case 'recvonly':\\n                                elem.attrs({ senders: 'initiator' });\\n                                break;\\n                            case 'sendrecv':\\n                                elem.attrs({ senders: 'both' });\\n                                break;\\n                            case 'inactive':\\n                                elem.attrs({ senders: 'none' });\\n                                break;\\n                        }\\n                    }\\n\\n                    // TODO: handle params\\n                    elem.up();\\n                }\\n            }\\n            elem.up(); // end of description\\n        }\\n\\n        // map ice-ufrag/pwd, dtls fingerprint, candidates\\n        this.transportToJingle(i, elem);\\n\\n        var m = this.media[i];\\n\\n        if (__WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(m, 'a=sendrecv', this.session)) {\\n            elem.attrs({ senders: 'both' });\\n        } else if (__WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(m, 'a=sendonly', this.session)) {\\n            elem.attrs({ senders: 'initiator' });\\n        } else if (__WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(m, 'a=recvonly', this.session)) {\\n            elem.attrs({ senders: 'responder' });\\n        } else if (__WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(m, 'a=inactive', this.session)) {\\n            elem.attrs({ senders: 'none' });\\n        }\\n        if (mline.port === '0') {\\n            // estos hack to reject an m-line\\n            elem.attrs({ senders: 'rejected' });\\n        }\\n        elem.up(); // end of content\\n    }\\n    elem.up();\\n\\n    return elem;\\n};\\n\\nSDP.prototype.transportToJingle = function (mediaindex, elem) {\\n    var tmp = void 0;\\n    var self = this;\\n\\n    elem.c('transport');\\n\\n    // XEP-0343 DTLS/SCTP\\n    var sctpmap = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(this.media[mediaindex], 'a=sctpmap:', self.session);\\n\\n    if (sctpmap) {\\n        var sctpAttrs = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseSCTPMap(sctpmap);\\n\\n        elem.c('sctpmap', {\\n            xmlns: 'urn:xmpp:jingle:transports:dtls-sctp:1',\\n            number: sctpAttrs[0], /* SCTP port */\\n            protocol: sctpAttrs[1] /* protocol */\\n        });\\n\\n        // Optional stream count attribute\\n        if (sctpAttrs.length > 2) {\\n            elem.attrs({ streams: sctpAttrs[2] });\\n        }\\n        elem.up();\\n    }\\n\\n    // XEP-0320\\n    var fingerprints = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(this.media[mediaindex], 'a=fingerprint:', this.session);\\n\\n    fingerprints.forEach(function (line) {\\n        tmp = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseFingerprint(line);\\n        tmp.xmlns = 'urn:xmpp:jingle:apps:dtls:0';\\n        elem.c('fingerprint').t(tmp.fingerprint);\\n        delete tmp.fingerprint;\\n\\n        // eslint-disable-next-line no-param-reassign\\n        line = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLine(self.media[mediaindex], 'a=setup:', self.session);\\n        if (line) {\\n            tmp.setup = line.substr(8);\\n        }\\n        elem.attrs(tmp);\\n        elem.up(); // end of fingerprint\\n    });\\n    tmp = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].iceparams(this.media[mediaindex], this.session);\\n    if (tmp) {\\n        tmp.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\\n        elem.attrs(tmp);\\n\\n        // XEP-0176\\n        var lines = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(this.media[mediaindex], 'a=candidate:', this.session);\\n\\n        if (lines.length) {\\n            // add any a=candidate lines\\n            lines.forEach(function (line) {\\n                var candidate = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].candidateToJingle(line);\\n\\n                if (self.failICE) {\\n                    candidate.ip = '1.1.1.1';\\n                }\\n                var protocol = candidate && typeof candidate.protocol === 'string' ? candidate.protocol.toLowerCase() : '';\\n\\n                if (self.removeTcpCandidates && (protocol === 'tcp' || protocol === 'ssltcp') || self.removeUdpCandidates && protocol === 'udp') {\\n                    return;\\n                }\\n                elem.c('candidate', candidate).up();\\n            });\\n        }\\n    }\\n    elem.up(); // end of transport\\n};\\n\\n// XEP-0293\\nSDP.prototype.rtcpFbToJingle = function (mediaindex, elem, payloadtype) {\\n    var lines = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].findLines(this.media[mediaindex], 'a=rtcp-fb:' + payloadtype);\\n\\n    lines.forEach(function (line) {\\n        var tmp = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].parseRTCPFB(line);\\n\\n        if (tmp.type === 'trr-int') {\\n            elem.c('rtcp-fb-trr-int', {\\n                xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',\\n                value: tmp.params[0]\\n            });\\n            elem.up();\\n        } else {\\n            elem.c('rtcp-fb', {\\n                xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',\\n                type: tmp.type\\n            });\\n            if (tmp.params.length > 0) {\\n                elem.attrs({ 'subtype': tmp.params[0] });\\n            }\\n            elem.up();\\n        }\\n    });\\n};\\n\\nSDP.prototype.rtcpFbFromJingle = function (elem, payloadtype) {\\n    // XEP-0293\\n    var media = '';\\n    var tmp = elem.find('>rtcp-fb-trr-int[xmlns=\\\"urn:xmpp:jingle:apps:rtp:rtcp-fb:0\\\"]');\\n\\n    if (tmp.length) {\\n        media += 'a=rtcp-fb:* trr-int ';\\n        if (tmp.attr('value')) {\\n            media += tmp.attr('value');\\n        } else {\\n            media += '0';\\n        }\\n        media += '\\\\r\\\\n';\\n    }\\n    tmp = elem.find('>rtcp-fb[xmlns=\\\"urn:xmpp:jingle:apps:rtp:rtcp-fb:0\\\"]');\\n    tmp.each(function () {\\n        /* eslint-disable no-invalid-this */\\n        media += 'a=rtcp-fb:' + payloadtype + ' ' + $(this).attr('type');\\n        if ($(this).attr('subtype')) {\\n            media += ' ' + $(this).attr('subtype');\\n        }\\n        media += '\\\\r\\\\n';\\n\\n        /* eslint-enable no-invalid-this */\\n    });\\n\\n    return media;\\n};\\n\\n// construct an SDP from a jingle stanza\\nSDP.prototype.fromJingle = function (jingle) {\\n    var self = this;\\n\\n    this.raw = 'v=0\\\\r\\\\n' + 'o=- 1923518516 2 IN IP4 0.0.0.0\\\\r\\\\n' // FIXME\\n    + 's=-\\\\r\\\\n' + 't=0 0\\\\r\\\\n';\\n\\n    // http://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-04\\n    // #section-8\\n    var groups = $(jingle).find('>group[xmlns=\\\"urn:xmpp:jingle:apps:grouping:0\\\"]');\\n\\n    if (groups.length) {\\n        groups.each(function (idx, group) {\\n            var contents = $(group).find('>content').map(function (_, content) {\\n                return content.getAttribute('name');\\n            }).get();\\n\\n            if (contents.length > 0) {\\n                self.raw += 'a=group:' + (group.getAttribute('semantics') || group.getAttribute('type')) + ' ' + contents.join(' ') + '\\\\r\\\\n';\\n            }\\n        });\\n    }\\n\\n    this.session = this.raw;\\n    jingle.find('>content').each(function () {\\n        // eslint-disable-next-line no-invalid-this\\n        var m = self.jingle2media($(this));\\n\\n        self.media.push(m);\\n    });\\n\\n    // reconstruct msid-semantic -- apparently not necessary\\n    /*\\n     var msid = SDPUtil.parseSSRC(this.raw);\\n     if (msid.hasOwnProperty('mslabel')) {\\n     this.session += \\\"a=msid-semantic: WMS \\\" + msid.mslabel + \\\"\\\\r\\\\n\\\";\\n     }\\n     */\\n\\n    this.raw = this.session + this.media.join('');\\n};\\n\\n// translate a jingle content element into an an SDP media part\\nSDP.prototype.jingle2media = function (content) {\\n    var desc = content.find('description');\\n    var media = '';\\n    var self = this;\\n    var sctp = content.find('>transport>sctpmap[xmlns=\\\"urn:xmpp:jingle:transports:dtls-sctp:1\\\"]');\\n\\n    var tmp = { media: desc.attr('media') };\\n\\n    tmp.port = '1';\\n    if (content.attr('senders') === 'rejected') {\\n        // estos hack to reject an m-line.\\n        tmp.port = '0';\\n    }\\n    if (content.find('>transport>fingerprint').length || desc.find('encryption').length) {\\n        tmp.proto = sctp.length ? 'DTLS/SCTP' : 'RTP/SAVPF';\\n    } else {\\n        tmp.proto = 'RTP/AVPF';\\n    }\\n    if (sctp.length) {\\n        media += 'm=application 1 DTLS/SCTP ' + sctp.attr('number') + '\\\\r\\\\n';\\n        media += 'a=sctpmap:' + sctp.attr('number') + ' ' + sctp.attr('protocol');\\n\\n        var streamCount = sctp.attr('streams');\\n\\n        if (streamCount) {\\n            media += ' ' + streamCount + '\\\\r\\\\n';\\n        } else {\\n            media += '\\\\r\\\\n';\\n        }\\n    } else {\\n        tmp.fmt = desc.find('payload-type').map(function () {\\n            // eslint-disable-next-line no-invalid-this\\n            return this.getAttribute('id');\\n        }).get();\\n        media += __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].buildMLine(tmp) + '\\\\r\\\\n';\\n    }\\n\\n    media += 'c=IN IP4 0.0.0.0\\\\r\\\\n';\\n    if (!sctp.length) {\\n        media += 'a=rtcp:1 IN IP4 0.0.0.0\\\\r\\\\n';\\n    }\\n    tmp = content.find('>transport[xmlns=\\\"urn:xmpp:jingle:transports:ice-udp:1\\\"]');\\n    if (tmp.length) {\\n        if (tmp.attr('ufrag')) {\\n            media += __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].buildICEUfrag(tmp.attr('ufrag')) + '\\\\r\\\\n';\\n        }\\n        if (tmp.attr('pwd')) {\\n            media += __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].buildICEPwd(tmp.attr('pwd')) + '\\\\r\\\\n';\\n        }\\n        tmp.find('>fingerprint').each(function () {\\n            /* eslint-disable no-invalid-this */\\n            // FIXME: check namespace at some point\\n            media += 'a=fingerprint:' + this.getAttribute('hash');\\n            media += ' ' + $(this).text();\\n            media += '\\\\r\\\\n';\\n            if (this.getAttribute('setup')) {\\n                media += 'a=setup:' + this.getAttribute('setup') + '\\\\r\\\\n';\\n            }\\n\\n            /* eslint-enable no-invalid-this */\\n        });\\n    }\\n    switch (content.attr('senders')) {\\n        case 'initiator':\\n            media += 'a=sendonly\\\\r\\\\n';\\n            break;\\n        case 'responder':\\n            media += 'a=recvonly\\\\r\\\\n';\\n            break;\\n        case 'none':\\n            media += 'a=inactive\\\\r\\\\n';\\n            break;\\n        case 'both':\\n            media += 'a=sendrecv\\\\r\\\\n';\\n            break;\\n    }\\n    media += 'a=mid:' + content.attr('name') + '\\\\r\\\\n';\\n\\n    // <description><rtcp-mux/></description>\\n    // see http://code.google.com/p/libjingle/issues/detail?id=309 -- no spec\\n    // though\\n    // and http://mail.jabber.org/pipermail/jingle/2011-December/001761.html\\n    if (desc.find('rtcp-mux').length) {\\n        media += 'a=rtcp-mux\\\\r\\\\n';\\n    }\\n\\n    if (desc.find('encryption').length) {\\n        desc.find('encryption>crypto').each(function () {\\n            /* eslint-disable no-invalid-this */\\n            media += 'a=crypto:' + this.getAttribute('tag');\\n            media += ' ' + this.getAttribute('crypto-suite');\\n            media += ' ' + this.getAttribute('key-params');\\n            if (this.getAttribute('session-params')) {\\n                media += ' ' + this.getAttribute('session-params');\\n            }\\n            media += '\\\\r\\\\n';\\n\\n            /* eslint-enable no-invalid-this */\\n        });\\n    }\\n    desc.find('payload-type').each(function () {\\n        /* eslint-disable no-invalid-this */\\n        media += __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].buildRTPMap(this) + '\\\\r\\\\n';\\n        if ($(this).find('>parameter').length) {\\n            media += 'a=fmtp:' + this.getAttribute('id') + ' ';\\n            media += $(this).find('parameter').map(function () {\\n                var name = this.getAttribute('name');\\n\\n                return (name ? name + '=' : '') + this.getAttribute('value');\\n            }).get().join('; ');\\n            media += '\\\\r\\\\n';\\n        }\\n\\n        // xep-0293\\n        media += self.rtcpFbFromJingle($(this), this.getAttribute('id'));\\n\\n        /* eslint-enable no-invalid-this */\\n    });\\n\\n    // xep-0293\\n    media += self.rtcpFbFromJingle(desc, '*');\\n\\n    // xep-0294\\n    tmp = desc.find('>rtp-hdrext[xmlns=\\\"urn:xmpp:jingle:apps:rtp:rtp-hdrext:0\\\"]');\\n    tmp.each(function () {\\n        /* eslint-disable no-invalid-this */\\n        media += 'a=extmap:' + this.getAttribute('id') + ' ' + this.getAttribute('uri') + '\\\\r\\\\n';\\n\\n        /* eslint-enable no-invalid-this */\\n    });\\n\\n    content.find('>transport[xmlns=\\\"urn:xmpp:jingle:transports:ice-udp:1\\\"]' + '>candidate').each(function () {\\n        /* eslint-disable no-invalid-this */\\n        var protocol = this.getAttribute('protocol');\\n\\n        protocol = typeof protocol === 'string' ? protocol.toLowerCase() : '';\\n\\n        if (self.removeTcpCandidates && (protocol === 'tcp' || protocol === 'ssltcp') || self.removeUdpCandidates && protocol === 'udp') {\\n            return;\\n        } else if (self.failICE) {\\n            this.setAttribute('ip', '1.1.1.1');\\n        }\\n\\n        media += __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].candidateFromJingle(this);\\n\\n        /* eslint-enable no-invalid-this */\\n    });\\n\\n    // XEP-0339 handle ssrc-group attributes\\n    content.find('description>ssrc-group[xmlns=\\\"urn:xmpp:jingle:apps:rtp:ssma:0\\\"]').each(function () {\\n        /* eslint-disable no-invalid-this */\\n        var semantics = this.getAttribute('semantics');\\n        var ssrcs = $(this).find('>source').map(function () {\\n            return this.getAttribute('ssrc');\\n        }).get();\\n\\n        if (ssrcs.length) {\\n            media += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\\\\r\\\\n';\\n        }\\n\\n        /* eslint-enable no-invalid-this */\\n    });\\n\\n    tmp = content.find('description>source[xmlns=\\\"urn:xmpp:jingle:apps:rtp:ssma:0\\\"]');\\n    tmp.each(function () {\\n        /* eslint-disable no-invalid-this */\\n        var ssrc = this.getAttribute('ssrc');\\n\\n        // eslint-disable-next-line newline-per-chained-call\\n        $(this).find('>parameter').each(function () {\\n            var name = this.getAttribute('name');\\n            var value = this.getAttribute('value');\\n\\n            value = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].filterSpecialChars(value);\\n            media += 'a=ssrc:' + ssrc + ' ' + name;\\n            if (value && value.length) {\\n                media += ':' + value;\\n            }\\n            media += '\\\\r\\\\n';\\n        });\\n\\n        /* eslint-enable no-invalid-this */\\n    });\\n\\n    return media;\\n};\\n\\n/***/ }),\\n/* 53 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return PEER_MUTED_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"b\\\", function() { return PEER_VIDEO_TYPE_CHANGED; });\\n/**\\n * Event triggered when participant's muted status changes.\\n * @param {string} endpointId the track owner's identifier (MUC nickname)\\n * @param {MediaType} mediaType \\\"audio\\\" or \\\"video\\\"\\n * @param {boolean} isMuted the new muted state\\n */\\nvar PEER_MUTED_CHANGED = 'signaling.peerMuted';\\n\\n/**\\n * Event triggered when participant's video type changes.\\n * @param {string} endpointId the video owner's ID (MUC nickname)\\n * @param {VideoType} videoType the new value\\n */\\nvar PEER_VIDEO_TYPE_CHANGED = 'signaling.peerVideoType';\\n\\n/***/ }),\\n/* 54 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events__ = __webpack_require__(16);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_events__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__JitsiTrackEvents__ = __webpack_require__(18);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__RTCUtils__ = __webpack_require__(28);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global __filename, module */\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Maps our handler types to MediaStreamTrack properties.\\n */\\nvar trackHandler2Prop = {\\n    'track_mute': 'onmute', // Not supported on FF\\n    'track_unmute': 'onunmute',\\n    'track_ended': 'onended'\\n};\\n\\n/**\\n * Adds onended/oninactive handler to a MediaStream.\\n * @param mediaStream a MediaStream to attach onended/oninactive handler\\n * @param handler the handler\\n */\\nfunction addMediaStreamInactiveHandler(mediaStream, handler) {\\n    // Temasys will use onended\\n    if (typeof mediaStream.active === 'undefined') {\\n        mediaStream.onended = handler;\\n    } else {\\n        mediaStream.oninactive = handler;\\n    }\\n}\\n\\n/**\\n * Represents a single media track (either audio or video).\\n */\\n\\nvar JitsiTrack = function (_EventEmitter) {\\n    _inherits(JitsiTrack, _EventEmitter);\\n\\n    /* eslint-disable max-params */\\n    /**\\n     * Represents a single media track (either audio or video).\\n     * @constructor\\n     * @param conference the rtc instance\\n     * @param stream the WebRTC MediaStream instance\\n     * @param track the WebRTC MediaStreamTrack instance, must be part of\\n     * the given <tt>stream</tt>.\\n     * @param streamInactiveHandler the function that will handle\\n     *        onended/oninactive events of the stream.\\n     * @param trackMediaType the media type of the JitsiTrack\\n     * @param videoType the VideoType for this track if any\\n     */\\n    function JitsiTrack(conference, stream, track, streamInactiveHandler, trackMediaType, videoType) {\\n        _classCallCheck(this, JitsiTrack);\\n\\n        // aliases for addListener/removeListener\\n        var _this = _possibleConstructorReturn(this, (JitsiTrack.__proto__ || Object.getPrototypeOf(JitsiTrack)).call(this));\\n\\n        _this.addEventListener = _this.addListener;\\n        _this.removeEventListener = _this.off = _this.removeListener;\\n\\n        /**\\n         * Array with the HTML elements that are displaying the streams.\\n         * @type {Array}\\n         */\\n        _this.containers = [];\\n        _this.conference = conference;\\n        _this.audioLevel = -1;\\n        _this.type = trackMediaType;\\n        _this.track = track;\\n        _this.videoType = videoType;\\n        _this.handlers = new Map();\\n\\n        /**\\n         * Indicates whether this JitsiTrack has been disposed. If true, this\\n         * JitsiTrack is to be considered unusable and operations involving it\\n         * are to fail (e.g. {@link JitsiConference#addTrack(JitsiTrack)},\\n         * {@link JitsiConference#removeTrack(JitsiTrack)}).\\n         * @type {boolean}\\n         */\\n        _this.disposed = false;\\n\\n        /**\\n         * The inactive handler which will be triggered when the underlying\\n         * <tt>MediaStream</tt> ends.\\n         *\\n         * @private\\n         * @type {Function}\\n         */\\n        _this._streamInactiveHandler = streamInactiveHandler;\\n\\n        _this._setStream(stream);\\n        return _this;\\n    }\\n\\n    /* eslint-enable max-params */\\n\\n    /**\\n     * Sets handler to the WebRTC MediaStream or MediaStreamTrack object\\n     * depending on the passed type.\\n     * @param {string} type the type of the handler that is going to be set\\n     * @param {Function} handler the handler.\\n     */\\n\\n\\n    _createClass(JitsiTrack, [{\\n        key: '_setHandler',\\n        value: function _setHandler(type, handler) {\\n            if (!trackHandler2Prop.hasOwnProperty(type)) {\\n                logger.error('Invalid handler type ' + type);\\n\\n                return;\\n            }\\n            if (handler) {\\n                this.handlers.set(type, handler);\\n            } else {\\n                this.handlers.delete(type);\\n            }\\n\\n            if (this.stream) {\\n                // FIXME Why only video tracks?\\n                var _iteratorNormalCompletion = true;\\n                var _didIteratorError = false;\\n                var _iteratorError = undefined;\\n\\n                try {\\n                    for (var _iterator = this.stream.getVideoTracks()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                        var track = _step.value;\\n\\n                        track[trackHandler2Prop[type]] = handler;\\n                    }\\n                } catch (err) {\\n                    _didIteratorError = true;\\n                    _iteratorError = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion && _iterator.return) {\\n                            _iterator.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError) {\\n                            throw _iteratorError;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Unregisters all event handlers bound to the underlying media stream/track\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_unregisterHandlers',\\n        value: function _unregisterHandlers() {\\n            if (!this.stream) {\\n                logger.warn(this + ': unable to unregister handlers - no stream object');\\n\\n                return;\\n            }\\n\\n            var _iteratorNormalCompletion2 = true;\\n            var _didIteratorError2 = false;\\n            var _iteratorError2 = undefined;\\n\\n            try {\\n                for (var _iterator2 = this.handlers.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                    var type = _step2.value;\\n\\n                    // FIXME Why only video tracks?\\n                    var _iteratorNormalCompletion3 = true;\\n                    var _didIteratorError3 = false;\\n                    var _iteratorError3 = undefined;\\n\\n                    try {\\n                        for (var _iterator3 = this.stream.getVideoTracks()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n                            var videoTrack = _step3.value;\\n\\n                            videoTrack[trackHandler2Prop[type]] = undefined;\\n                        }\\n                    } catch (err) {\\n                        _didIteratorError3 = true;\\n                        _iteratorError3 = err;\\n                    } finally {\\n                        try {\\n                            if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                                _iterator3.return();\\n                            }\\n                        } finally {\\n                            if (_didIteratorError3) {\\n                                throw _iteratorError3;\\n                            }\\n                        }\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError2 = true;\\n                _iteratorError2 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                        _iterator2.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError2) {\\n                        throw _iteratorError2;\\n                    }\\n                }\\n            }\\n\\n            if (this._streamInactiveHandler) {\\n                addMediaStreamInactiveHandler(this.stream, undefined);\\n            }\\n        }\\n\\n        /**\\n         * Sets the stream property of JitsiTrack object and sets all stored\\n         * handlers to it.\\n         *\\n         * @param {MediaStream} stream the new stream.\\n         * @protected\\n         */\\n\\n    }, {\\n        key: '_setStream',\\n        value: function _setStream(stream) {\\n            if (this.stream === stream) {\\n                return;\\n            }\\n\\n            this.stream = stream;\\n\\n            // TODO Practically, that's like the opposite of _unregisterHandlers\\n            // i.e. may be abstracted into a function/method called\\n            // _registerHandlers for clarity and easing the maintenance of the two\\n            // pieces of source code.\\n            if (this.stream) {\\n                var _iteratorNormalCompletion4 = true;\\n                var _didIteratorError4 = false;\\n                var _iteratorError4 = undefined;\\n\\n                try {\\n                    for (var _iterator4 = this.handlers.keys()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n                        var type = _step4.value;\\n\\n                        this._setHandler(type, this.handlers.get(type));\\n                    }\\n                } catch (err) {\\n                    _didIteratorError4 = true;\\n                    _iteratorError4 = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n                            _iterator4.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError4) {\\n                            throw _iteratorError4;\\n                        }\\n                    }\\n                }\\n\\n                if (this._streamInactiveHandler) {\\n                    addMediaStreamInactiveHandler(this.stream, this._streamInactiveHandler);\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Returns the type (audio or video) of this track.\\n         */\\n\\n    }, {\\n        key: 'getType',\\n        value: function getType() {\\n            return this.type;\\n        }\\n\\n        /**\\n         * Check if this is an audio track.\\n         */\\n\\n    }, {\\n        key: 'isAudioTrack',\\n        value: function isAudioTrack() {\\n            return this.getType() === __WEBPACK_IMPORTED_MODULE_3__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */];\\n        }\\n\\n        /**\\n         * Checks whether the underlying WebRTC <tt>MediaStreamTrack</tt> is muted\\n         * according to it's 'muted' field status.\\n         * @return {boolean} <tt>true</tt> if the underlying\\n         * <tt>MediaStreamTrack</tt> is muted or <tt>false</tt> otherwise.\\n         */\\n\\n    }, {\\n        key: 'isWebRTCTrackMuted',\\n        value: function isWebRTCTrackMuted() {\\n            return this.track && this.track.muted;\\n        }\\n\\n        /**\\n         * Check if this is a video track.\\n         */\\n\\n    }, {\\n        key: 'isVideoTrack',\\n        value: function isVideoTrack() {\\n            return this.getType() === __WEBPACK_IMPORTED_MODULE_3__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */];\\n        }\\n\\n        /**\\n         * Checks whether this is a local track.\\n         * @abstract\\n         * @return {boolean} 'true' if it's a local track or 'false' otherwise.\\n         */\\n\\n    }, {\\n        key: 'isLocal',\\n        value: function isLocal() {\\n            throw new Error('Not implemented by subclass');\\n        }\\n\\n        /**\\n         * Returns the WebRTC MediaStream instance.\\n         */\\n\\n    }, {\\n        key: 'getOriginalStream',\\n        value: function getOriginalStream() {\\n            return this.stream;\\n        }\\n\\n        /**\\n         * Returns the ID of the underlying WebRTC Media Stream(if any)\\n         * @returns {String|null}\\n         */\\n\\n    }, {\\n        key: 'getStreamId',\\n        value: function getStreamId() {\\n            return this.stream ? this.stream.id : null;\\n        }\\n\\n        /**\\n         * Return the underlying WebRTC MediaStreamTrack\\n         * @returns {MediaStreamTrack}\\n         */\\n\\n    }, {\\n        key: 'getTrack',\\n        value: function getTrack() {\\n            return this.track;\\n        }\\n\\n        /**\\n         * Returns the ID of the underlying WebRTC MediaStreamTrack(if any)\\n         * @returns {String|null}\\n         */\\n\\n    }, {\\n        key: 'getTrackId',\\n        value: function getTrackId() {\\n            return this.track ? this.track.id : null;\\n        }\\n\\n        /**\\n         * Return meaningful usage label for this track depending on it's media and\\n         * eventual video type.\\n         * @returns {string}\\n         */\\n\\n    }, {\\n        key: 'getUsageLabel',\\n        value: function getUsageLabel() {\\n            if (this.isAudioTrack()) {\\n                return 'mic';\\n            }\\n\\n            return this.videoType ? this.videoType : 'default';\\n        }\\n\\n        /**\\n         * Eventually will trigger RTCEvents.TRACK_ATTACHED event.\\n         * @param container the video/audio container to which this stream is\\n         *        attached and for which event will be fired.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_maybeFireTrackAttached',\\n        value: function _maybeFireTrackAttached(container) {\\n            if (this.conference && container) {\\n                this.conference._onTrackAttach(this, container);\\n            }\\n        }\\n\\n        /**\\n         * Attaches the MediaStream of this track to an HTML container.\\n         * Adds the container to the list of containers that are displaying the\\n         * track. Note that Temasys plugin will replace original audio/video element\\n         * with 'object' when stream is being attached to the container for the\\n         * first time.\\n         * * NOTE * if given container element is not visible when the stream is\\n         * being attached it will be shown back given that Temasys plugin is\\n         * currently in use.\\n         *\\n         * @param container the HTML container which can be 'video' or 'audio'\\n         * element. It can also be 'object' element if Temasys plugin is in use and\\n         * this method has been called previously on video or audio HTML element.\\n         *\\n         * @returns potentially new instance of container if it was replaced by the\\n         *          library. That's the case when Temasys plugin is in use.\\n         */\\n\\n    }, {\\n        key: 'attach',\\n        value: function attach(container) {\\n            var c = container;\\n\\n            if (this.stream) {\\n                c = __WEBPACK_IMPORTED_MODULE_4__RTCUtils__[\\\"a\\\" /* default */].attachMediaStream(container, this.stream);\\n            }\\n            this.containers.push(c);\\n            this._maybeFireTrackAttached(c);\\n            this._attachTTFMTracker(c);\\n\\n            return c;\\n        }\\n\\n        /**\\n         * Removes this JitsiTrack from the passed HTML container.\\n         *\\n         * @param container the HTML container to detach from this JitsiTrack. If\\n         * <tt>null</tt> or <tt>undefined</tt>, all containers are removed. A\\n         * container can be a 'video', 'audio' or 'object' HTML element instance to\\n         * which this JitsiTrack is currently attached.\\n         */\\n\\n    }, {\\n        key: 'detach',\\n        value: function detach(container) {\\n            for (var cs = this.containers, i = cs.length - 1; i >= 0; --i) {\\n                var c = cs[i];\\n\\n                if (!container) {\\n                    __WEBPACK_IMPORTED_MODULE_4__RTCUtils__[\\\"a\\\" /* default */].attachMediaStream(c, null);\\n                }\\n                if (!container || c === container) {\\n                    cs.splice(i, 1);\\n                }\\n            }\\n\\n            if (container) {\\n                __WEBPACK_IMPORTED_MODULE_4__RTCUtils__[\\\"a\\\" /* default */].attachMediaStream(container, null);\\n            }\\n        }\\n\\n        /**\\n         * Attach time to first media tracker only if there is conference and only\\n         * for the first element.\\n         *\\n         * @param {HTMLElement} container the HTML container which can be 'video' or\\n         * 'audio' element. It can also be 'object' element if Temasys plugin is in\\n         * use and this method has been called previously on video or audio HTML\\n         * element.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_attachTTFMTracker',\\n        value: function _attachTTFMTracker(container) {} // eslint-disable-line no-unused-vars\\n        // Should be defined by the classes that are extending JitsiTrack\\n\\n\\n        /**\\n         * Removes attached event listeners.\\n         *\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: 'dispose',\\n        value: function dispose() {\\n            this.removeAllListeners();\\n\\n            this.disposed = true;\\n\\n            return Promise.resolve();\\n        }\\n\\n        /**\\n         * Returns true if this is a video track and the source of the video is a\\n         * screen capture as opposed to a camera.\\n         */\\n\\n    }, {\\n        key: 'isScreenSharing',\\n        value: function isScreenSharing() {}\\n        // FIXME: Should be fixed or removed.\\n\\n\\n        /**\\n         * Returns id of the track.\\n         * @returns {string|null} id of the track or null if this is fake track.\\n         */\\n\\n    }, {\\n        key: 'getId',\\n        value: function getId() {\\n            if (this.stream) {\\n                return __WEBPACK_IMPORTED_MODULE_4__RTCUtils__[\\\"a\\\" /* default */].getStreamID(this.stream);\\n            }\\n\\n            return null;\\n        }\\n\\n        /**\\n         * Checks whether the MediaStream is active/not ended.\\n         * When there is no check for active we don't have information and so\\n         * will return that stream is active (in case of FF).\\n         * @returns {boolean} whether MediaStream is active.\\n         */\\n\\n    }, {\\n        key: 'isActive',\\n        value: function isActive() {\\n            if (typeof this.stream.active !== 'undefined') {\\n                return this.stream.active;\\n            }\\n\\n            return true;\\n        }\\n\\n        /**\\n         * Sets the audio level for the stream\\n         * @param {number} audioLevel value between 0 and 1\\n         * @param {TraceablePeerConnection} [tpc] the peerconnection instance which\\n         * is source for the audio level. It can be <tt>undefined</tt> for\\n         * a local track if the audio level was measured outside of the\\n         * peerconnection (see /modules/statistics/LocalStatsCollector.js).\\n         */\\n\\n    }, {\\n        key: 'setAudioLevel',\\n        value: function setAudioLevel(audioLevel, tpc) {\\n            if (this.audioLevel !== audioLevel) {\\n                this.audioLevel = audioLevel;\\n                this.emit(__WEBPACK_IMPORTED_MODULE_2__JitsiTrackEvents__[\\\"TRACK_AUDIO_LEVEL_CHANGED\\\"], audioLevel, tpc);\\n            }\\n        }\\n\\n        /**\\n         * Returns the msid of the stream attached to the JitsiTrack object or null\\n         * if no stream is attached.\\n         */\\n\\n    }, {\\n        key: 'getMSID',\\n        value: function getMSID() {\\n            var streamId = this.getStreamId();\\n            var trackId = this.getTrackId();\\n\\n            return streamId && trackId ? streamId + ' ' + trackId : null;\\n        }\\n\\n        /**\\n         * Sets new audio output device for track's DOM elements. Video tracks are\\n         * ignored.\\n         * @param {string} audioOutputDeviceId - id of 'audiooutput' device from\\n         *      navigator.mediaDevices.enumerateDevices(), '' for default device\\n         * @emits JitsiTrackEvents.TRACK_AUDIO_OUTPUT_CHANGED\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: 'setAudioOutput',\\n        value: function setAudioOutput(audioOutputDeviceId) {\\n            var _this2 = this;\\n\\n            if (!__WEBPACK_IMPORTED_MODULE_4__RTCUtils__[\\\"a\\\" /* default */].isDeviceChangeAvailable('output')) {\\n                return Promise.reject(new Error('Audio output device change is not supported'));\\n            }\\n\\n            // All audio communication is done through audio tracks, so ignore\\n            // changing audio output for video tracks at all.\\n            if (this.isVideoTrack()) {\\n                return Promise.resolve();\\n            }\\n\\n            return Promise.all(this.containers.map(function (element) {\\n                return element.setSinkId(audioOutputDeviceId).catch(function (error) {\\n                    logger.warn('Failed to change audio output device on' + ' element. Default or previously set' + ' audio output device will be used.', element, error);\\n                    throw error;\\n                });\\n            })).then(function () {\\n                _this2.emit(__WEBPACK_IMPORTED_MODULE_2__JitsiTrackEvents__[\\\"TRACK_AUDIO_OUTPUT_CHANGED\\\"], audioOutputDeviceId);\\n            });\\n        }\\n    }]);\\n\\n    return JitsiTrack;\\n}(__WEBPACK_IMPORTED_MODULE_0_events___default.a);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (JitsiTrack);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/JitsiTrack.js\\\"))\\n\\n/***/ }),\\n/* 55 */\\n/***/ (function(module, exports) {\\n\\n/**\\n * The possible camera facing modes. For now support only 'user' and\\n * 'environment' because 'left' and 'right' are not used anywhere in our\\n * projects at the time of this writing. For more information please refer to\\n * https://w3c.github.io/mediacapture-main/getusermedia.html\\n * #def-constraint-facingMode.\\n *\\n * @enum {string}\\n */\\nvar CameraFacingMode = {\\n  /**\\n   * The mode which specifies the environment-facing camera.\\n   */\\n  ENVIRONMENT: 'environment',\\n\\n  /**\\n   * The mode which specifies the user-facing camera.\\n   */\\n  USER: 'user'\\n};\\n\\nmodule.exports = CameraFacingMode;\\n\\n/***/ }),\\n/* 56 */\\n/***/ (function(module, exports) {\\n\\nvar grammar = module.exports = {\\n  v: [{\\n    name: 'version',\\n    reg: /^(\\\\d*)$/\\n  }],\\n  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\\n    // NB: sessionId will be a String in most cases because it is huge\\n    name: 'origin',\\n    reg: /^(\\\\S*) (\\\\d*) (\\\\d*) (\\\\S*) IP(\\\\d) (\\\\S*)/,\\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\\n    format: '%s %s %d %s IP%d %s'\\n  }],\\n  // default parsing of these only (though some of these feel outdated)\\n  s: [{ name: 'name' }],\\n  i: [{ name: 'description' }],\\n  u: [{ name: 'uri' }],\\n  e: [{ name: 'email' }],\\n  p: [{ name: 'phone' }],\\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\\n  //k: [{}], // outdated thing ignored\\n  t: [{ //t=0 0\\n    name: 'timing',\\n    reg: /^(\\\\d*) (\\\\d*)/,\\n    names: ['start', 'stop'],\\n    format: '%d %d'\\n  }],\\n  c: [{ //c=IN IP4 10.47.197.26\\n    name: 'connection',\\n    reg: /^IN IP(\\\\d) (\\\\S*)/,\\n    names: ['version', 'ip'],\\n    format: 'IN IP%d %s'\\n  }],\\n  b: [{ //b=AS:4000\\n    push: 'bandwidth',\\n    reg: /^(TIAS|AS|CT|RR|RS):(\\\\d*)/,\\n    names: ['type', 'limit'],\\n    format: '%s:%s'\\n  }],\\n  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\\n    // NB: special - pushes to session\\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\\n    reg: /^(\\\\w*) (\\\\d*) ([\\\\w\\\\/]*)(?: (.*))?/,\\n    names: ['type', 'port', 'protocol', 'payloads'],\\n    format: '%s %d %s %s'\\n  }],\\n  a: [\\n    { //a=rtpmap:110 opus/48000/2\\n      push: 'rtp',\\n      reg: /^rtpmap:(\\\\d*) ([\\\\w\\\\-\\\\.]*)(?:\\\\s*\\\\/(\\\\d*)(?:\\\\s*\\\\/(\\\\S*))?)?/,\\n      names: ['payload', 'codec', 'rate', 'encoding'],\\n      format: function (o) {\\n        return (o.encoding) ?\\n          'rtpmap:%d %s/%s/%s':\\n          o.rate ?\\n          'rtpmap:%d %s/%s':\\n          'rtpmap:%d %s';\\n      }\\n    },\\n    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\\n      //a=fmtp:111 minptime=10; useinbandfec=1\\n      push: 'fmtp',\\n      reg: /^fmtp:(\\\\d*) ([\\\\S| ]*)/,\\n      names: ['payload', 'config'],\\n      format: 'fmtp:%d %s'\\n    },\\n    { //a=control:streamid=0\\n      name: 'control',\\n      reg: /^control:(.*)/,\\n      format: 'control:%s'\\n    },\\n    { //a=rtcp:65179 IN IP4 193.84.77.194\\n      name: 'rtcp',\\n      reg: /^rtcp:(\\\\d*)(?: (\\\\S*) IP(\\\\d) (\\\\S*))?/,\\n      names: ['port', 'netType', 'ipVer', 'address'],\\n      format: function (o) {\\n        return (o.address != null) ?\\n          'rtcp:%d %s IP%d %s':\\n          'rtcp:%d';\\n      }\\n    },\\n    { //a=rtcp-fb:98 trr-int 100\\n      push: 'rtcpFbTrrInt',\\n      reg: /^rtcp-fb:(\\\\*|\\\\d*) trr-int (\\\\d*)/,\\n      names: ['payload', 'value'],\\n      format: 'rtcp-fb:%d trr-int %d'\\n    },\\n    { //a=rtcp-fb:98 nack rpsi\\n      push: 'rtcpFb',\\n      reg: /^rtcp-fb:(\\\\*|\\\\d*) ([\\\\w-_]*)(?: ([\\\\w-_]*))?/,\\n      names: ['payload', 'type', 'subtype'],\\n      format: function (o) {\\n        return (o.subtype != null) ?\\n          'rtcp-fb:%s %s %s':\\n          'rtcp-fb:%s %s';\\n      }\\n    },\\n    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\\n      //a=extmap:1/recvonly URI-gps-string\\n      push: 'ext',\\n      reg: /^extmap:(\\\\d+)(?:\\\\/(\\\\w+))? (\\\\S*)(?: (\\\\S*))?/,\\n      names: ['value', 'direction', 'uri', 'config'],\\n      format: function (o) {\\n        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');\\n      }\\n    },\\n    { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\\n      push: 'crypto',\\n      reg: /^crypto:(\\\\d*) ([\\\\w_]*) (\\\\S*)(?: (\\\\S*))?/,\\n      names: ['id', 'suite', 'config', 'sessionConfig'],\\n      format: function (o) {\\n        return (o.sessionConfig != null) ?\\n          'crypto:%d %s %s %s':\\n          'crypto:%d %s %s';\\n      }\\n    },\\n    { //a=setup:actpass\\n      name: 'setup',\\n      reg: /^setup:(\\\\w*)/,\\n      format: 'setup:%s'\\n    },\\n    { //a=mid:1\\n      name: 'mid',\\n      reg: /^mid:([^\\\\s]*)/,\\n      format: 'mid:%s'\\n    },\\n    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\\n      name: 'msid',\\n      reg: /^msid:(.*)/,\\n      format: 'msid:%s'\\n    },\\n    { //a=ptime:20\\n      name: 'ptime',\\n      reg: /^ptime:(\\\\d*)/,\\n      format: 'ptime:%d'\\n    },\\n    { //a=maxptime:60\\n      name: 'maxptime',\\n      reg: /^maxptime:(\\\\d*)/,\\n      format: 'maxptime:%d'\\n    },\\n    { //a=sendrecv\\n      name: 'direction',\\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\\n    },\\n    { //a=ice-lite\\n      name: 'icelite',\\n      reg: /^(ice-lite)/\\n    },\\n    { //a=ice-ufrag:F7gI\\n      name: 'iceUfrag',\\n      reg: /^ice-ufrag:(\\\\S*)/,\\n      format: 'ice-ufrag:%s'\\n    },\\n    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\\n      name: 'icePwd',\\n      reg: /^ice-pwd:(\\\\S*)/,\\n      format: 'ice-pwd:%s'\\n    },\\n    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\\n      name: 'fingerprint',\\n      reg: /^fingerprint:(\\\\S*) (\\\\S*)/,\\n      names: ['type', 'hash'],\\n      format: 'fingerprint:%s %s'\\n    },\\n    { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\\n      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\\n      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\\n      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\\n      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\\n      push:'candidates',\\n      reg: /^candidate:(\\\\S*) (\\\\d*) (\\\\S*) (\\\\d*) (\\\\S*) (\\\\d*) typ (\\\\S*)(?: raddr (\\\\S*) rport (\\\\d*))?(?: tcptype (\\\\S*))?(?: generation (\\\\d*))?(?: network-id (\\\\d*))?(?: network-cost (\\\\d*))?/,\\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\\n      format: function (o) {\\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\\n\\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\\n\\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\\n\\n        if (o.generation != null) {\\n          str += ' generation %d';\\n        }\\n\\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\\n        return str;\\n      }\\n    },\\n    { //a=end-of-candidates (keep after the candidates line for readability)\\n      name: 'endOfCandidates',\\n      reg: /^(end-of-candidates)/\\n    },\\n    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\\n      name: 'remoteCandidates',\\n      reg: /^remote-candidates:(.*)/,\\n      format: 'remote-candidates:%s'\\n    },\\n    { //a=ice-options:google-ice\\n      name: 'iceOptions',\\n      reg: /^ice-options:(\\\\S*)/,\\n      format: 'ice-options:%s'\\n    },\\n    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\\n      push: 'ssrcs',\\n      reg: /^ssrc:(\\\\d*) ([\\\\w_]*)(?::(.*))?/,\\n      names: ['id', 'attribute', 'value'],\\n      format: function (o) {\\n        var str = 'ssrc:%d';\\n        if (o.attribute != null) {\\n          str += ' %s';\\n          if (o.value != null) {\\n            str += ':%s';\\n          }\\n        }\\n        return str;\\n      }\\n    },\\n    { //a=ssrc-group:FEC 1 2\\n      //a=ssrc-group:FEC-FR 3004364195 1080772241\\n      push: 'ssrcGroups',\\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\\n      reg: /^ssrc-group:([\\\\x21\\\\x23\\\\x24\\\\x25\\\\x26\\\\x27\\\\x2A\\\\x2B\\\\x2D\\\\x2E\\\\w]*) (.*)/,\\n      names: ['semantics', 'ssrcs'],\\n      format: 'ssrc-group:%s %s'\\n    },\\n    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\\n      name: 'msidSemantic',\\n      reg: /^msid-semantic:\\\\s?(\\\\w*) (\\\\S*)/,\\n      names: ['semantic', 'token'],\\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\\n    },\\n    { //a=group:BUNDLE audio video\\n      push: 'groups',\\n      reg: /^group:(\\\\w*) (.*)/,\\n      names: ['type', 'mids'],\\n      format: 'group:%s %s'\\n    },\\n    { //a=rtcp-mux\\n      name: 'rtcpMux',\\n      reg: /^(rtcp-mux)/\\n    },\\n    { //a=rtcp-rsize\\n      name: 'rtcpRsize',\\n      reg: /^(rtcp-rsize)/\\n    },\\n    { //a=sctpmap:5000 webrtc-datachannel 1024\\n      name: 'sctpmap',\\n      reg: /^sctpmap:([\\\\w_\\\\/]*) (\\\\S*)(?: (\\\\S*))?/,\\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\\n      format: function (o) {\\n        return (o.maxMessageSize != null) ?\\n          'sctpmap:%s %s %s' :\\n          'sctpmap:%s %s';\\n      }\\n    },\\n    { //a=x-google-flag:conference\\n      name: 'xGoogleFlag',\\n      reg: /^x-google-flag:([^\\\\s]*)/,\\n      format: 'x-google-flag:%s'\\n    },\\n    { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\\n      push: 'rids',\\n      reg: /^rid:([\\\\d\\\\w]+) (\\\\w+)(?: ([\\\\S| ]*))?/,\\n      names: ['id', 'direction', 'params'],\\n      format: function (o) {\\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\\n      }\\n    },\\n    { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\\n      //a=imageattr:* send [x=800,y=640] recv *\\n      //a=imageattr:100 recv [x=320,y=240]\\n      push: 'imageattrs',\\n      reg: new RegExp(\\n        //a=imageattr:97\\n        '^imageattr:(\\\\\\\\d+|\\\\\\\\*)' +\\n        //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\\n        '[\\\\\\\\s\\\\\\\\t]+(send|recv)[\\\\\\\\s\\\\\\\\t]+(\\\\\\\\*|\\\\\\\\[\\\\\\\\S+\\\\\\\\](?:[\\\\\\\\s\\\\\\\\t]+\\\\\\\\[\\\\\\\\S+\\\\\\\\])*)' +\\n        //recv [x=330,y=250]\\n        '(?:[\\\\\\\\s\\\\\\\\t]+(recv|send)[\\\\\\\\s\\\\\\\\t]+(\\\\\\\\*|\\\\\\\\[\\\\\\\\S+\\\\\\\\](?:[\\\\\\\\s\\\\\\\\t]+\\\\\\\\[\\\\\\\\S+\\\\\\\\])*))?'\\n      ),\\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\\n      format: function (o) {\\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\\n      }\\n    },\\n    { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\\n      //a=simulcast:recv 1;4,5 send 6;7\\n      name: 'simulcast',\\n      reg: new RegExp(\\n        //a=simulcast:\\n        '^simulcast:' +\\n        //send 1,2,3;~4,~5\\n        '(send|recv) ([a-zA-Z0-9\\\\\\\\-_~;,]+)' +\\n        //space + recv 6;~7,~8\\n        '(?:\\\\\\\\s?(send|recv) ([a-zA-Z0-9\\\\\\\\-_~;,]+))?' +\\n        //end\\n        '$'\\n      ),\\n      names: ['dir1', 'list1', 'dir2', 'list2'],\\n      format: function (o) {\\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\\n      }\\n    },\\n    { //Old simulcast draft 03 (implemented by Firefox)\\n      //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\\n      //a=simulcast: recv pt=97;98 send pt=97\\n      //a=simulcast: send rid=5;6;7 paused=6,7\\n      name: 'simulcast_03',\\n      reg: /^simulcast:[\\\\s\\\\t]+([\\\\S+\\\\s\\\\t]+)$/,\\n      names: ['value'],\\n      format: 'simulcast: %s'\\n    },\\n    {\\n      //a=framerate:25\\n      //a=framerate:29.97\\n      name: 'framerate',\\n      reg: /^framerate:(\\\\d+(?:$|\\\\.\\\\d+))/,\\n      format: 'framerate:%s'\\n    },\\n    { // any a= that we don't understand is kepts verbatim on media.invalid\\n      push: 'invalid',\\n      names: ['value']\\n    }\\n  ]\\n};\\n\\n// set sensible defaults to avoid polluting the grammar with boring details\\nObject.keys(grammar).forEach(function (key) {\\n  var objs = grammar[key];\\n  objs.forEach(function (obj) {\\n    if (!obj.reg) {\\n      obj.reg = /(.*)/;\\n    }\\n    if (!obj.format) {\\n      obj.format = '%s';\\n    }\\n  });\\n});\\n\\n\\n/***/ }),\\n/* 57 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n /* eslint-env node */\\n\\n\\n// SDP helpers.\\nvar SDPUtils = {};\\n\\n// Generate an alphanumeric identifier for cname or mids.\\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\\nSDPUtils.generateIdentifier = function() {\\n  return Math.random().toString(36).substr(2, 10);\\n};\\n\\n// The RTCP CNAME used by all peerconnections from the same JS.\\nSDPUtils.localCName = SDPUtils.generateIdentifier();\\n\\n// Splits SDP into lines, dealing with both CRLF and LF.\\nSDPUtils.splitLines = function(blob) {\\n  return blob.trim().split('\\\\n').map(function(line) {\\n    return line.trim();\\n  });\\n};\\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\\nSDPUtils.splitSections = function(blob) {\\n  var parts = blob.split('\\\\nm=');\\n  return parts.map(function(part, index) {\\n    return (index > 0 ? 'm=' + part : part).trim() + '\\\\r\\\\n';\\n  });\\n};\\n\\n// Returns lines that start with a certain prefix.\\nSDPUtils.matchPrefix = function(blob, prefix) {\\n  return SDPUtils.splitLines(blob).filter(function(line) {\\n    return line.indexOf(prefix) === 0;\\n  });\\n};\\n\\n// Parses an ICE candidate line. Sample input:\\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\\n// rport 55996\\\"\\nSDPUtils.parseCandidate = function(line) {\\n  var parts;\\n  // Parse both variants.\\n  if (line.indexOf('a=candidate:') === 0) {\\n    parts = line.substring(12).split(' ');\\n  } else {\\n    parts = line.substring(10).split(' ');\\n  }\\n\\n  var candidate = {\\n    foundation: parts[0],\\n    component: parseInt(parts[1], 10),\\n    protocol: parts[2].toLowerCase(),\\n    priority: parseInt(parts[3], 10),\\n    ip: parts[4],\\n    port: parseInt(parts[5], 10),\\n    // skip parts[6] == 'typ'\\n    type: parts[7]\\n  };\\n\\n  for (var i = 8; i < parts.length; i += 2) {\\n    switch (parts[i]) {\\n      case 'raddr':\\n        candidate.relatedAddress = parts[i + 1];\\n        break;\\n      case 'rport':\\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\\n        break;\\n      case 'tcptype':\\n        candidate.tcpType = parts[i + 1];\\n        break;\\n      case 'ufrag':\\n        candidate.ufrag = parts[i + 1]; // for backward compability.\\n        candidate.usernameFragment = parts[i + 1];\\n        break;\\n      default: // extension handling, in particular ufrag\\n        candidate[parts[i]] = parts[i + 1];\\n        break;\\n    }\\n  }\\n  return candidate;\\n};\\n\\n// Translates a candidate object into SDP candidate attribute.\\nSDPUtils.writeCandidate = function(candidate) {\\n  var sdp = [];\\n  sdp.push(candidate.foundation);\\n  sdp.push(candidate.component);\\n  sdp.push(candidate.protocol.toUpperCase());\\n  sdp.push(candidate.priority);\\n  sdp.push(candidate.ip);\\n  sdp.push(candidate.port);\\n\\n  var type = candidate.type;\\n  sdp.push('typ');\\n  sdp.push(type);\\n  if (type !== 'host' && candidate.relatedAddress &&\\n      candidate.relatedPort) {\\n    sdp.push('raddr');\\n    sdp.push(candidate.relatedAddress); // was: relAddr\\n    sdp.push('rport');\\n    sdp.push(candidate.relatedPort); // was: relPort\\n  }\\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\\n    sdp.push('tcptype');\\n    sdp.push(candidate.tcpType);\\n  }\\n  if (candidate.ufrag) {\\n    sdp.push('ufrag');\\n    sdp.push(candidate.ufrag);\\n  }\\n  return 'candidate:' + sdp.join(' ');\\n};\\n\\n// Parses an ice-options line, returns an array of option tags.\\n// a=ice-options:foo bar\\nSDPUtils.parseIceOptions = function(line) {\\n  return line.substr(14).split(' ');\\n}\\n\\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\\n// a=rtpmap:111 opus/48000/2\\nSDPUtils.parseRtpMap = function(line) {\\n  var parts = line.substr(9).split(' ');\\n  var parsed = {\\n    payloadType: parseInt(parts.shift(), 10) // was: id\\n  };\\n\\n  parts = parts[0].split('/');\\n\\n  parsed.name = parts[0];\\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\\n  // was: channels\\n  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\\n  return parsed;\\n};\\n\\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\\n// RTCRtpCodecParameters.\\nSDPUtils.writeRtpMap = function(codec) {\\n  var pt = codec.payloadType;\\n  if (codec.preferredPayloadType !== undefined) {\\n    pt = codec.preferredPayloadType;\\n  }\\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\\n      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\\\\r\\\\n';\\n};\\n\\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\\nSDPUtils.parseExtmap = function(line) {\\n  var parts = line.substr(9).split(' ');\\n  return {\\n    id: parseInt(parts[0], 10),\\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\\n    uri: parts[1]\\n  };\\n};\\n\\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\\n// RTCRtpHeaderExtension.\\nSDPUtils.writeExtmap = function(headerExtension) {\\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\\n          ? '/' + headerExtension.direction\\n          : '') +\\n      ' ' + headerExtension.uri + '\\\\r\\\\n';\\n};\\n\\n// Parses an ftmp line, returns dictionary. Sample input:\\n// a=fmtp:96 vbr=on;cng=on\\n// Also deals with vbr=on; cng=on\\nSDPUtils.parseFmtp = function(line) {\\n  var parsed = {};\\n  var kv;\\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\\n  for (var j = 0; j < parts.length; j++) {\\n    kv = parts[j].trim().split('=');\\n    parsed[kv[0].trim()] = kv[1];\\n  }\\n  return parsed;\\n};\\n\\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\\nSDPUtils.writeFmtp = function(codec) {\\n  var line = '';\\n  var pt = codec.payloadType;\\n  if (codec.preferredPayloadType !== undefined) {\\n    pt = codec.preferredPayloadType;\\n  }\\n  if (codec.parameters && Object.keys(codec.parameters).length) {\\n    var params = [];\\n    Object.keys(codec.parameters).forEach(function(param) {\\n      params.push(param + '=' + codec.parameters[param]);\\n    });\\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\\\r\\\\n';\\n  }\\n  return line;\\n};\\n\\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\\n// a=rtcp-fb:98 nack rpsi\\nSDPUtils.parseRtcpFb = function(line) {\\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\\n  return {\\n    type: parts.shift(),\\n    parameter: parts.join(' ')\\n  };\\n};\\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\\nSDPUtils.writeRtcpFb = function(codec) {\\n  var lines = '';\\n  var pt = codec.payloadType;\\n  if (codec.preferredPayloadType !== undefined) {\\n    pt = codec.preferredPayloadType;\\n  }\\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\\n    // FIXME: special handling for trr-int?\\n    codec.rtcpFeedback.forEach(function(fb) {\\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\\n          '\\\\r\\\\n';\\n    });\\n  }\\n  return lines;\\n};\\n\\n// Parses an RFC 5576 ssrc media attribute. Sample input:\\n// a=ssrc:3735928559 cname:something\\nSDPUtils.parseSsrcMedia = function(line) {\\n  var sp = line.indexOf(' ');\\n  var parts = {\\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\\n  };\\n  var colon = line.indexOf(':', sp);\\n  if (colon > -1) {\\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\\n    parts.value = line.substr(colon + 1);\\n  } else {\\n    parts.attribute = line.substr(sp + 1);\\n  }\\n  return parts;\\n};\\n\\n// Extracts the MID (RFC 5888) from a media section.\\n// returns the MID or undefined if no mid line was found.\\nSDPUtils.getMid = function(mediaSection) {\\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\\n  if (mid) {\\n    return mid.substr(6);\\n  }\\n}\\n\\nSDPUtils.parseFingerprint = function(line) {\\n  var parts = line.substr(14).split(' ');\\n  return {\\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\\n    value: parts[1]\\n  };\\n};\\n\\n// Extracts DTLS parameters from SDP media section or sessionpart.\\n// FIXME: for consistency with other functions this should only\\n//   get the fingerprint line as input. See also getIceParameters.\\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\\n      'a=fingerprint:');\\n  // Note: a=setup line is ignored since we use the 'auto' role.\\n  // Note2: 'algorithm' is not case sensitive except in Edge.\\n  return {\\n    role: 'auto',\\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\\n  };\\n};\\n\\n// Serializes DTLS parameters to SDP.\\nSDPUtils.writeDtlsParameters = function(params, setupType) {\\n  var sdp = 'a=setup:' + setupType + '\\\\r\\\\n';\\n  params.fingerprints.forEach(function(fp) {\\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\\\r\\\\n';\\n  });\\n  return sdp;\\n};\\n// Parses ICE information from SDP media section or sessionpart.\\n// FIXME: for consistency with other functions this should only\\n//   get the ice-ufrag and ice-pwd lines as input.\\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\\n  var lines = SDPUtils.splitLines(mediaSection);\\n  // Search in session part, too.\\n  lines = lines.concat(SDPUtils.splitLines(sessionpart));\\n  var iceParameters = {\\n    usernameFragment: lines.filter(function(line) {\\n      return line.indexOf('a=ice-ufrag:') === 0;\\n    })[0].substr(12),\\n    password: lines.filter(function(line) {\\n      return line.indexOf('a=ice-pwd:') === 0;\\n    })[0].substr(10)\\n  };\\n  return iceParameters;\\n};\\n\\n// Serializes ICE parameters to SDP.\\nSDPUtils.writeIceParameters = function(params) {\\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\\\r\\\\n' +\\n      'a=ice-pwd:' + params.password + '\\\\r\\\\n';\\n};\\n\\n// Parses the SDP media section and returns RTCRtpParameters.\\nSDPUtils.parseRtpParameters = function(mediaSection) {\\n  var description = {\\n    codecs: [],\\n    headerExtensions: [],\\n    fecMechanisms: [],\\n    rtcp: []\\n  };\\n  var lines = SDPUtils.splitLines(mediaSection);\\n  var mline = lines[0].split(' ');\\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\\n    var pt = mline[i];\\n    var rtpmapline = SDPUtils.matchPrefix(\\n        mediaSection, 'a=rtpmap:' + pt + ' ')[0];\\n    if (rtpmapline) {\\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\\n      var fmtps = SDPUtils.matchPrefix(\\n          mediaSection, 'a=fmtp:' + pt + ' ');\\n      // Only the first a=fmtp:<pt> is considered.\\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\\n          mediaSection, 'a=rtcp-fb:' + pt + ' ')\\n        .map(SDPUtils.parseRtcpFb);\\n      description.codecs.push(codec);\\n      // parse FEC mechanisms from rtpmap lines.\\n      switch (codec.name.toUpperCase()) {\\n        case 'RED':\\n        case 'ULPFEC':\\n          description.fecMechanisms.push(codec.name.toUpperCase());\\n          break;\\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\\n          break;\\n      }\\n    }\\n  }\\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\\n  });\\n  // FIXME: parse rtcp.\\n  return description;\\n};\\n\\n// Generates parts of the SDP media section describing the capabilities /\\n// parameters.\\nSDPUtils.writeRtpDescription = function(kind, caps) {\\n  var sdp = '';\\n\\n  // Build the mline.\\n  sdp += 'm=' + kind + ' ';\\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\\n  sdp += ' UDP/TLS/RTP/SAVPF ';\\n  sdp += caps.codecs.map(function(codec) {\\n    if (codec.preferredPayloadType !== undefined) {\\n      return codec.preferredPayloadType;\\n    }\\n    return codec.payloadType;\\n  }).join(' ') + '\\\\r\\\\n';\\n\\n  sdp += 'c=IN IP4 0.0.0.0\\\\r\\\\n';\\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\\\r\\\\n';\\n\\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\\n  caps.codecs.forEach(function(codec) {\\n    sdp += SDPUtils.writeRtpMap(codec);\\n    sdp += SDPUtils.writeFmtp(codec);\\n    sdp += SDPUtils.writeRtcpFb(codec);\\n  });\\n  var maxptime = 0;\\n  caps.codecs.forEach(function(codec) {\\n    if (codec.maxptime > maxptime) {\\n      maxptime = codec.maxptime;\\n    }\\n  });\\n  if (maxptime > 0) {\\n    sdp += 'a=maxptime:' + maxptime + '\\\\r\\\\n';\\n  }\\n  sdp += 'a=rtcp-mux\\\\r\\\\n';\\n\\n  caps.headerExtensions.forEach(function(extension) {\\n    sdp += SDPUtils.writeExtmap(extension);\\n  });\\n  // FIXME: write fecMechanisms.\\n  return sdp;\\n};\\n\\n// Parses the SDP media section and returns an array of\\n// RTCRtpEncodingParameters.\\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\\n  var encodingParameters = [];\\n  var description = SDPUtils.parseRtpParameters(mediaSection);\\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\\n\\n  // filter a=ssrc:... cname:, ignore PlanB-msid\\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\\n  .map(function(line) {\\n    return SDPUtils.parseSsrcMedia(line);\\n  })\\n  .filter(function(parts) {\\n    return parts.attribute === 'cname';\\n  });\\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\\n  var secondarySsrc;\\n\\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\\n  .map(function(line) {\\n    var parts = line.split(' ');\\n    parts.shift();\\n    return parts.map(function(part) {\\n      return parseInt(part, 10);\\n    });\\n  });\\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\\n    secondarySsrc = flows[0][1];\\n  }\\n\\n  description.codecs.forEach(function(codec) {\\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\\n      var encParam = {\\n        ssrc: primarySsrc,\\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\\n        rtx: {\\n          ssrc: secondarySsrc\\n        }\\n      };\\n      encodingParameters.push(encParam);\\n      if (hasRed) {\\n        encParam = JSON.parse(JSON.stringify(encParam));\\n        encParam.fec = {\\n          ssrc: secondarySsrc,\\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\\n        };\\n        encodingParameters.push(encParam);\\n      }\\n    }\\n  });\\n  if (encodingParameters.length === 0 && primarySsrc) {\\n    encodingParameters.push({\\n      ssrc: primarySsrc\\n    });\\n  }\\n\\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\\n  if (bandwidth.length) {\\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\\n      // use formula from JSEP to convert b=AS to TIAS value.\\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\\n          - (50 * 40 * 8);\\n    } else {\\n      bandwidth = undefined;\\n    }\\n    encodingParameters.forEach(function(params) {\\n      params.maxBitrate = bandwidth;\\n    });\\n  }\\n  return encodingParameters;\\n};\\n\\n// parses http://draft.ortc.org/#rtcrtcpparameters*\\nSDPUtils.parseRtcpParameters = function(mediaSection) {\\n  var rtcpParameters = {};\\n\\n  var cname;\\n  // Gets the first SSRC. Note that with RTX there might be multiple\\n  // SSRCs.\\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\\n      .map(function(line) {\\n        return SDPUtils.parseSsrcMedia(line);\\n      })\\n      .filter(function(obj) {\\n        return obj.attribute === 'cname';\\n      })[0];\\n  if (remoteSsrc) {\\n    rtcpParameters.cname = remoteSsrc.value;\\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\\n  }\\n\\n  // Edge uses the compound attribute instead of reducedSize\\n  // compound is !reducedSize\\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\\n  rtcpParameters.reducedSize = rsize.length > 0;\\n  rtcpParameters.compound = rsize.length === 0;\\n\\n  // parses the rtcp-mux attrіbute.\\n  // Note that Edge does not support unmuxed RTCP.\\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\\n  rtcpParameters.mux = mux.length > 0;\\n\\n  return rtcpParameters;\\n};\\n\\n// parses either a=msid: or a=ssrc:... msid lines and returns\\n// the id of the MediaStream and MediaStreamTrack.\\nSDPUtils.parseMsid = function(mediaSection) {\\n  var parts;\\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\\n  if (spec.length === 1) {\\n    parts = spec[0].substr(7).split(' ');\\n    return {stream: parts[0], track: parts[1]};\\n  }\\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\\n  .map(function(line) {\\n    return SDPUtils.parseSsrcMedia(line);\\n  })\\n  .filter(function(parts) {\\n    return parts.attribute === 'msid';\\n  });\\n  if (planB.length > 0) {\\n    parts = planB[0].value.split(' ');\\n    return {stream: parts[0], track: parts[1]};\\n  }\\n};\\n\\n// Generate a session ID for SDP.\\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\\n// recommends using a cryptographically random +ve 64-bit value\\n// but right now this should be acceptable and within the right range\\nSDPUtils.generateSessionId = function() {\\n  return Math.random().toString().substr(2, 21);\\n};\\n\\n// Write boilder plate for start of SDP\\n// sessId argument is optional - if not supplied it will\\n// be generated randomly\\n// sessVersion is optional and defaults to 2\\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {\\n  var sessionId;\\n  var version = sessVer !== undefined ? sessVer : 2;\\n  if (sessId) {\\n    sessionId = sessId;\\n  } else {\\n    sessionId = SDPUtils.generateSessionId();\\n  }\\n  // FIXME: sess-id should be an NTP timestamp.\\n  return 'v=0\\\\r\\\\n' +\\n      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\\\r\\\\n' +\\n      's=-\\\\r\\\\n' +\\n      't=0 0\\\\r\\\\n';\\n};\\n\\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\\n\\n  // Map ICE parameters (ufrag, pwd) to SDP.\\n  sdp += SDPUtils.writeIceParameters(\\n      transceiver.iceGatherer.getLocalParameters());\\n\\n  // Map DTLS parameters to SDP.\\n  sdp += SDPUtils.writeDtlsParameters(\\n      transceiver.dtlsTransport.getLocalParameters(),\\n      type === 'offer' ? 'actpass' : 'active');\\n\\n  sdp += 'a=mid:' + transceiver.mid + '\\\\r\\\\n';\\n\\n  if (transceiver.direction) {\\n    sdp += 'a=' + transceiver.direction + '\\\\r\\\\n';\\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\\n    sdp += 'a=sendrecv\\\\r\\\\n';\\n  } else if (transceiver.rtpSender) {\\n    sdp += 'a=sendonly\\\\r\\\\n';\\n  } else if (transceiver.rtpReceiver) {\\n    sdp += 'a=recvonly\\\\r\\\\n';\\n  } else {\\n    sdp += 'a=inactive\\\\r\\\\n';\\n  }\\n\\n  if (transceiver.rtpSender) {\\n    // spec.\\n    var msid = 'msid:' + stream.id + ' ' +\\n        transceiver.rtpSender.track.id + '\\\\r\\\\n';\\n    sdp += 'a=' + msid;\\n\\n    // for Chrome.\\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\\n        ' ' + msid;\\n    if (transceiver.sendEncodingParameters[0].rtx) {\\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\\n          ' ' + msid;\\n      sdp += 'a=ssrc-group:FID ' +\\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\\n          '\\\\r\\\\n';\\n    }\\n  }\\n  // FIXME: this should be written by writeRtpDescription.\\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\\n      ' cname:' + SDPUtils.localCName + '\\\\r\\\\n';\\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\\n        ' cname:' + SDPUtils.localCName + '\\\\r\\\\n';\\n  }\\n  return sdp;\\n};\\n\\n// Gets the direction from the mediaSection or the sessionpart.\\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\\n  var lines = SDPUtils.splitLines(mediaSection);\\n  for (var i = 0; i < lines.length; i++) {\\n    switch (lines[i]) {\\n      case 'a=sendrecv':\\n      case 'a=sendonly':\\n      case 'a=recvonly':\\n      case 'a=inactive':\\n        return lines[i].substr(2);\\n      default:\\n        // FIXME: What should happen here?\\n    }\\n  }\\n  if (sessionpart) {\\n    return SDPUtils.getDirection(sessionpart);\\n  }\\n  return 'sendrecv';\\n};\\n\\nSDPUtils.getKind = function(mediaSection) {\\n  var lines = SDPUtils.splitLines(mediaSection);\\n  var mline = lines[0].split(' ');\\n  return mline[0].substr(2);\\n};\\n\\nSDPUtils.isRejected = function(mediaSection) {\\n  return mediaSection.split(' ', 2)[1] === '0';\\n};\\n\\nSDPUtils.parseMLine = function(mediaSection) {\\n  var lines = SDPUtils.splitLines(mediaSection);\\n  var mline = lines[0].split(' ');\\n  return {\\n    kind: mline[0].substr(2),\\n    port: parseInt(mline[1], 10),\\n    protocol: mline[2],\\n    fmt: mline.slice(3).join(' ')\\n  };\\n};\\n\\n// Expose public methods.\\nif (true) {\\n  module.exports = SDPUtils;\\n}\\n\\n\\n/***/ }),\\n/* 58 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* global MediaRecorder, MediaStream, webkitMediaStream */\\n\\nvar RecordingResult = __webpack_require__(155);\\n\\n/**\\n * Possible audio formats MIME types\\n */\\nvar AUDIO_WEBM = 'audio/webm'; // Supported in chrome\\nvar AUDIO_OGG = 'audio/ogg'; // Supported in firefox\\n\\n/**\\n * A TrackRecorder object holds all the information needed for recording a\\n * single JitsiTrack (either remote or local)\\n * @param track The JitsiTrack the object is going to hold\\n */\\nvar TrackRecorder = function TrackRecorder(track) {\\n    // The JitsiTrack holding the stream\\n    this.track = track;\\n\\n    // The MediaRecorder recording the stream\\n    this.recorder = null;\\n\\n    // The array of data chunks recorded from the stream\\n    // acts as a buffer until the data is stored on disk\\n    this.data = null;\\n\\n    // the name of the person of the JitsiTrack. This can be undefined and/or\\n    // not unique\\n    this.name = null;\\n\\n    // the time of the start of the recording\\n    this.startTime = null;\\n};\\n\\n/**\\n * Starts the recording of a JitsiTrack in a TrackRecorder object.\\n * This will also define the timestamp and try to update the name\\n * @param trackRecorder the TrackRecorder to start\\n */\\nfunction startRecorder(trackRecorder) {\\n    if (trackRecorder.recorder === undefined) {\\n        throw new Error('Passed an object to startRecorder which is not a ' + 'TrackRecorder object');\\n    }\\n    trackRecorder.recorder.start();\\n    trackRecorder.startTime = new Date();\\n}\\n\\n/**\\n * Stops the recording of a JitsiTrack in a TrackRecorder object.\\n * This will also try to update the name\\n * @param trackRecorder the TrackRecorder to stop\\n */\\nfunction stopRecorder(trackRecorder) {\\n    if (trackRecorder.recorder === undefined) {\\n        throw new Error('Passed an object to stopRecorder which is not a ' + 'TrackRecorder object');\\n    }\\n    trackRecorder.recorder.stop();\\n}\\n\\n/**\\n * Determines which kind of audio recording the browser supports\\n * chrome supports \\\"audio/webm\\\" and firefox supports \\\"audio/ogg\\\"\\n */\\nfunction determineCorrectFileType() {\\n    if (MediaRecorder.isTypeSupported(AUDIO_WEBM)) {\\n        return AUDIO_WEBM;\\n    } else if (MediaRecorder.isTypeSupported(AUDIO_OGG)) {\\n        return AUDIO_OGG;\\n    }\\n    throw new Error('unable to create a MediaRecorder with the right mimetype!');\\n}\\n\\n/**\\n * main exported object of the file, holding all\\n * relevant functions and variables for the outside world\\n * @param jitsiConference the jitsiConference which this object\\n * is going to record\\n */\\nfunction AudioRecorder(jitsiConference) {\\n    // array of TrackRecorders, where each trackRecorder\\n    // holds the JitsiTrack, MediaRecorder and recorder data\\n    this.recorders = [];\\n\\n    // get which file type is supported by the current browser\\n    this.fileType = determineCorrectFileType();\\n\\n    // boolean flag for active recording\\n    this.isRecording = false;\\n\\n    // the jitsiconference the object is recording\\n    this.jitsiConference = jitsiConference;\\n}\\n\\n/**\\n * Add the the exported module so that it can be accessed by other files\\n */\\nAudioRecorder.determineCorrectFileType = determineCorrectFileType;\\n\\n/**\\n * Adds a new TrackRecorder object to the array.\\n *\\n * @param track the track potentially holding an audio stream\\n */\\nAudioRecorder.prototype.addTrack = function (track) {\\n    if (track.isAudioTrack()) {\\n        // create the track recorder\\n        var trackRecorder = this.instantiateTrackRecorder(track);\\n\\n        // push it to the local array of all recorders\\n\\n        this.recorders.push(trackRecorder);\\n\\n        // update the name of the trackRecorders\\n        this.updateNames();\\n\\n        // If we're already recording, immediately start recording this new\\n        // track.\\n        if (this.isRecording) {\\n            startRecorder(trackRecorder);\\n        }\\n    }\\n};\\n\\n/**\\n * Creates a TrackRecorder object. Also creates the MediaRecorder and\\n * data array for the trackRecorder.\\n * @param track the JitsiTrack holding the audio MediaStream(s)\\n */\\nAudioRecorder.prototype.instantiateTrackRecorder = function (track) {\\n    var trackRecorder = new TrackRecorder(track);\\n\\n    // Create a new stream which only holds the audio track\\n    var originalStream = trackRecorder.track.getOriginalStream();\\n    var stream = createEmptyStream();\\n\\n    originalStream.getAudioTracks().forEach(function (t) {\\n        return stream.addTrack(t);\\n    });\\n\\n    // Create the MediaRecorder\\n    trackRecorder.recorder = new MediaRecorder(stream, { mimeType: this.fileType });\\n\\n    // array for holding the recorder data. Resets it when\\n    // audio already has been recorder once\\n    trackRecorder.data = [];\\n\\n    // function handling a dataEvent, e.g the stream gets new data\\n    trackRecorder.recorder.ondataavailable = function (dataEvent) {\\n        if (dataEvent.data.size > 0) {\\n            trackRecorder.data.push(dataEvent.data);\\n        }\\n    };\\n\\n    return trackRecorder;\\n};\\n\\n/**\\n * Notifies the module that a specific track has stopped, e.g participant left\\n * the conference.\\n * if the recording has not started yet, the TrackRecorder will be removed from\\n * the array. If the recording has started, the recorder will stop recording\\n * but not removed from the array so that the recorded stream can still be\\n * accessed\\n *\\n * @param {JitsiTrack} track the JitsiTrack to remove from the recording session\\n */\\nAudioRecorder.prototype.removeTrack = function (track) {\\n    if (track.isVideoTrack()) {\\n        return;\\n    }\\n\\n    var array = this.recorders;\\n    var i = void 0;\\n\\n    for (i = 0; i < array.length; i++) {\\n        if (array[i].track.getParticipantId() === track.getParticipantId()) {\\n            var recorderToRemove = array[i];\\n\\n            if (this.isRecording) {\\n                stopRecorder(recorderToRemove);\\n            } else {\\n                // remove the TrackRecorder from the array\\n                array.splice(i, 1);\\n            }\\n        }\\n    }\\n\\n    // make sure the names are up to date\\n    this.updateNames();\\n};\\n\\n/**\\n * Tries to update the name value of all TrackRecorder in the array.\\n * If it hasn't changed,it will keep the exiting name. If it changes to a\\n * undefined value, the old value will also be kept.\\n */\\nAudioRecorder.prototype.updateNames = function () {\\n    var conference = this.jitsiConference;\\n\\n    this.recorders.forEach(function (trackRecorder) {\\n        if (trackRecorder.track.isLocal()) {\\n            trackRecorder.name = 'the transcriber';\\n        } else {\\n            var id = trackRecorder.track.getParticipantId();\\n            var participant = conference.getParticipantById(id);\\n            var newName = participant.getDisplayName();\\n\\n            if (newName !== 'undefined') {\\n                trackRecorder.name = newName;\\n            }\\n        }\\n    });\\n};\\n\\n/**\\n * Starts the audio recording of every local and remote track\\n */\\nAudioRecorder.prototype.start = function () {\\n    if (this.isRecording) {\\n        throw new Error('audiorecorder is already recording');\\n    }\\n\\n    // set boolean isRecording flag to true so if new participants join the\\n    // conference, that track can instantly start recording as well\\n    this.isRecording = true;\\n\\n    // start all the mediaRecorders\\n    this.recorders.forEach(function (trackRecorder) {\\n        return startRecorder(trackRecorder);\\n    });\\n\\n    // log that recording has started\\n    console.log('Started the recording of the audio. There are currently ' + this.recorders.length + ' recorders active.');\\n};\\n\\n/**\\n * Stops the audio recording of every local and remote track\\n */\\nAudioRecorder.prototype.stop = function () {\\n    // set the boolean flag to false\\n    this.isRecording = false;\\n\\n    // stop all recorders\\n    this.recorders.forEach(function (trackRecorder) {\\n        return stopRecorder(trackRecorder);\\n    });\\n    console.log('stopped recording');\\n};\\n\\n/**\\n * link hacking to download all recorded audio streams\\n */\\nAudioRecorder.prototype.download = function () {\\n    var _this = this;\\n\\n    this.recorders.forEach(function (trackRecorder) {\\n        var blob = new Blob(trackRecorder.data, { type: _this.fileType });\\n        var url = URL.createObjectURL(blob);\\n        var a = document.createElement('a');\\n\\n        document.body.appendChild(a);\\n        a.style = 'display: none';\\n        a.href = url;\\n        a.download = 'test.' + _this.fileType.split('/')[1];\\n        a.click();\\n        window.URL.revokeObjectURL(url);\\n    });\\n};\\n\\n/**\\n * returns the audio files of all recorders as an array of objects,\\n * which include the name of the owner of the track and the starting time stamp\\n * @returns {Array} an array of RecordingResult objects\\n */\\nAudioRecorder.prototype.getRecordingResults = function () {\\n    var _this2 = this;\\n\\n    if (this.isRecording) {\\n        throw new Error('cannot get blobs because the AudioRecorder is still recording!');\\n    }\\n\\n    // make sure the names are up to date before sending them off\\n    this.updateNames();\\n\\n    var array = [];\\n\\n    this.recorders.forEach(function (recorder) {\\n        return array.push(new RecordingResult(new Blob(recorder.data, { type: _this2.fileType }), recorder.name, recorder.startTime));\\n    });\\n\\n    return array;\\n};\\n\\n/**\\n * Gets the mime type of the recorder audio\\n * @returns {String} the mime type of the recorder audio\\n */\\nAudioRecorder.prototype.getFileType = function () {\\n    return this.fileType;\\n};\\n\\n/**\\n * Creates a empty MediaStream object which can be used\\n * to add MediaStreamTracks to\\n * @returns MediaStream\\n */\\nfunction createEmptyStream() {\\n    // Firefox supports the MediaStream object, Chrome webkitMediaStream\\n    if (typeof MediaStream !== 'undefined') {\\n        return new MediaStream();\\n    } else if (typeof webkitMediaStream !== 'undefined') {\\n        return new webkitMediaStream(); // eslint-disable-line new-cap\\n    }\\n    throw new Error('cannot create a clean mediaStream');\\n}\\n\\n/**\\n * export the main object AudioRecorder\\n */\\nmodule.exports = AudioRecorder;\\n\\n/***/ }),\\n/* 59 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DEVICE_LIST_CHANGED\\\", function() { return DEVICE_LIST_CHANGED; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PERMISSION_PROMPT_IS_SHOWN\\\", function() { return PERMISSION_PROMPT_IS_SHOWN; });\\n/**\\n * The events for the media devices.\\n */\\n\\n/**\\n * Indicates that the list of available media devices has been changed. The\\n * event provides the following parameters to its listeners:\\n *\\n * @param {MediaDeviceInfo[]} devices - array of MediaDeviceInfo or\\n *  MediaDeviceInfo-like objects that are currently connected.\\n *  @see https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo\\n */\\nvar DEVICE_LIST_CHANGED = 'mediaDevices.devicechange';\\n\\n/**\\n * Indicates that the environment is currently showing permission prompt to\\n * access camera and/or microphone. The event provides the following\\n * parameters to its listeners:\\n *\\n * @param {'chrome'|'opera'|'firefox'|'iexplorer'|'safari'|'nwjs'\\n *  |'react-native'|'android'} environmentType - type of browser or\\n *  other execution environment.\\n */\\nvar PERMISSION_PROMPT_IS_SHOWN = 'mediaDevices.permissionPromptIsShown';\\n\\n/***/ }),\\n/* 60 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n// For legacy purposes, preserve the UMD of the public API of the Jitsi Meet\\n// library (a.k.a. JitsiMeetJS).\\nmodule.exports = __webpack_require__(61).default;\\n\\n/***/ }),\\n/* 61 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__modules_util_AuthUtil__ = __webpack_require__(62);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__modules_util_AuthUtil___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__modules_util_AuthUtil__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__service_connectivity_ConnectionQualityEvents__ = __webpack_require__(31);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__modules_util_GlobalOnErrorHandler__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__JitsiConferenceErrors__ = __webpack_require__(32);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceEvents__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__JitsiConnection__ = __webpack_require__(63);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__JitsiConnectionErrors__ = __webpack_require__(46);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__JitsiConnectionEvents__ = __webpack_require__(26);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__JitsiMediaDevices__ = __webpack_require__(163);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__JitsiMediaDevicesEvents__ = __webpack_require__(59);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__JitsiRecorderErrors__ = __webpack_require__(50);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__JitsiRecorderErrors___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__JitsiRecorderErrors__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__JitsiTrackError__ = __webpack_require__(12);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__JitsiTrackErrors__ = __webpack_require__(17);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__JitsiTrackEvents__ = __webpack_require__(18);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__JitsiTranscriptionStatus__ = __webpack_require__(47);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__modules_statistics_LocalStatsCollector__ = __webpack_require__(42);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__modules_xmpp_recording__ = __webpack_require__(49);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__service_RTC_Resolutions__ = __webpack_require__(35);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__service_RTC_Resolutions___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20__service_RTC_Resolutions__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__modules_connectivity_ParticipantConnectionStatus__ = __webpack_require__(36);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__modules_RTC_RTC__ = __webpack_require__(27);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__modules_RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__modules_RTC_RTCUIHelper__ = __webpack_require__(164);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__modules_util_ScriptUtil__ = __webpack_require__(44);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__modules_util_ScriptUtil___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_25__modules_util_ScriptUtil__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__modules_settings_Settings__ = __webpack_require__(19);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__modules_videosipgw_VideoSIPGWConstants__ = __webpack_require__(30);\\n/* global __filename */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = __WEBPACK_IMPORTED_MODULE_18_jitsi_meet_logger___default.a.getLogger(__filename);\\n\\n// The amount of time to wait until firing\\n// JitsiMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN event\\nvar USER_MEDIA_PERMISSION_PROMPT_TIMEOUT = 1000;\\n\\n/**\\n *\\n * @param resolution\\n */\\nfunction getLowerResolution(resolution) {\\n    if (!__WEBPACK_IMPORTED_MODULE_20__service_RTC_Resolutions___default.a[resolution]) {\\n        return null;\\n    }\\n    var order = __WEBPACK_IMPORTED_MODULE_20__service_RTC_Resolutions___default.a[resolution].order;\\n    var res = null;\\n    var resName = null;\\n\\n    Object.keys(__WEBPACK_IMPORTED_MODULE_20__service_RTC_Resolutions___default.a).forEach(function (r) {\\n        var value = __WEBPACK_IMPORTED_MODULE_20__service_RTC_Resolutions___default.a[r];\\n\\n        if (!res || res.order < value.order && value.order < order) {\\n            resName = r;\\n            res = value;\\n        }\\n    });\\n\\n    return resName;\\n}\\n\\n/**\\n * Checks the available devices in options and concatenate the data to the\\n * name, which will be used as analytics event name. Adds resolution for the\\n * devices.\\n * @param name name of event\\n * @param options gum options\\n * @returns {*}\\n */\\nfunction addDeviceTypeToAnalyticsEvent(name, options) {\\n    var ret = name;\\n\\n    if (options.devices.indexOf('audio') !== -1) {\\n        ret += '.audio';\\n    }\\n    if (options.devices.indexOf('desktop') !== -1) {\\n        ret += '.desktop';\\n    }\\n    if (options.devices.indexOf('video') !== -1) {\\n        // we have video add resolution\\n        ret += '.video.' + options.resolution;\\n    }\\n\\n    return ret;\\n}\\n\\n/**\\n * The public API of the Jitsi Meet library (a.k.a. JitsiMeetJS).\\n */\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = ({\\n\\n    version: 'development',\\n\\n    JitsiConnection: __WEBPACK_IMPORTED_MODULE_6__JitsiConnection__[\\\"a\\\" /* default */],\\n    constants: {\\n        participantConnectionStatus: __WEBPACK_IMPORTED_MODULE_21__modules_connectivity_ParticipantConnectionStatus__[\\\"a\\\" /* ParticipantConnectionStatus */],\\n        recordingStatus: __WEBPACK_IMPORTED_MODULE_17__modules_xmpp_recording__[\\\"a\\\" /* default */].status,\\n        recordingTypes: __WEBPACK_IMPORTED_MODULE_17__modules_xmpp_recording__[\\\"a\\\" /* default */].types,\\n        sipVideoGW: __WEBPACK_IMPORTED_MODULE_28__modules_videosipgw_VideoSIPGWConstants__,\\n        transcriptionStatus: __WEBPACK_IMPORTED_MODULE_15__JitsiTranscriptionStatus__\\n    },\\n    events: {\\n        conference: __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceEvents__,\\n        connection: __WEBPACK_IMPORTED_MODULE_8__JitsiConnectionEvents__,\\n        track: __WEBPACK_IMPORTED_MODULE_14__JitsiTrackEvents__,\\n        mediaDevices: __WEBPACK_IMPORTED_MODULE_10__JitsiMediaDevicesEvents__,\\n        connectionQuality: __WEBPACK_IMPORTED_MODULE_2__service_connectivity_ConnectionQualityEvents__\\n    },\\n    errors: {\\n        conference: __WEBPACK_IMPORTED_MODULE_4__JitsiConferenceErrors__,\\n        connection: __WEBPACK_IMPORTED_MODULE_7__JitsiConnectionErrors__,\\n        recorder: __WEBPACK_IMPORTED_MODULE_11__JitsiRecorderErrors___default.a,\\n        track: __WEBPACK_IMPORTED_MODULE_13__JitsiTrackErrors__\\n    },\\n    errorTypes: {\\n        JitsiTrackError: __WEBPACK_IMPORTED_MODULE_12__JitsiTrackError__[\\\"a\\\" /* default */]\\n    },\\n    logLevels: __WEBPACK_IMPORTED_MODULE_18_jitsi_meet_logger___default.a.levels,\\n    mediaDevices: __WEBPACK_IMPORTED_MODULE_9__JitsiMediaDevices__[\\\"a\\\" /* default */],\\n    analytics: __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics,\\n    init: function init(options) {\\n        __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].init(options);\\n\\n        // Initialize global window.connectionTimes\\n        // FIXME do not use 'window'\\n        if (!window.connectionTimes) {\\n            window.connectionTimes = {};\\n        }\\n\\n        if (options.enableAnalyticsLogging !== true) {\\n            this.analytics.dispose();\\n        }\\n\\n        if (options.enableWindowOnErrorHandler) {\\n            __WEBPACK_IMPORTED_MODULE_3__modules_util_GlobalOnErrorHandler___default.a.addHandler(this.getGlobalOnErrorHandler.bind(this));\\n        }\\n\\n        // Log deployment-specific information, if available.\\n        // Defined outside the application by individual deployments\\n        var aprops = options.deploymentInfo;\\n\\n        if (aprops && Object.keys(aprops).length > 0) {\\n            var logObject = {};\\n\\n            for (var attr in aprops) {\\n                if (aprops.hasOwnProperty(attr)) {\\n                    logObject[attr] = aprops[attr];\\n                }\\n            }\\n\\n            logObject.id = 'deployment_info';\\n            __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify(logObject));\\n        }\\n\\n        if (this.version) {\\n            var _logObject = {\\n                id: 'component_version',\\n                component: 'lib-jitsi-meet',\\n                version: this.version\\n            };\\n\\n            __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify(_logObject));\\n        }\\n\\n        return __WEBPACK_IMPORTED_MODULE_22__modules_RTC_RTC__[\\\"a\\\" /* default */].init(options || {});\\n    },\\n\\n\\n    /**\\n     * Returns whether the desktop sharing is enabled or not.\\n     * @returns {boolean}\\n     */\\n    isDesktopSharingEnabled: function isDesktopSharingEnabled() {\\n        return __WEBPACK_IMPORTED_MODULE_22__modules_RTC_RTC__[\\\"a\\\" /* default */].isDesktopSharingEnabled();\\n    },\\n    setLogLevel: function setLogLevel(level) {\\n        __WEBPACK_IMPORTED_MODULE_18_jitsi_meet_logger___default.a.setLogLevel(level);\\n    },\\n\\n\\n    /**\\n     * Sets the log level to the <tt>Logger</tt> instance with given id.\\n     * @param {Logger.levels} level the logging level to be set\\n     * @param {string} id the logger id to which new logging level will be set.\\n     * Usually it's the name of the JavaScript source file including the path\\n     * ex. \\\"modules/xmpp/ChatRoom.js\\\"\\n     */\\n    setLogLevelById: function setLogLevelById(level, id) {\\n        __WEBPACK_IMPORTED_MODULE_18_jitsi_meet_logger___default.a.setLogLevelById(level, id);\\n    },\\n\\n\\n    /**\\n     * Registers new global logger transport to the library logging framework.\\n     * @param globalTransport\\n     * @see Logger.addGlobalTransport\\n     */\\n    addGlobalLogTransport: function addGlobalLogTransport(globalTransport) {\\n        __WEBPACK_IMPORTED_MODULE_18_jitsi_meet_logger___default.a.addGlobalTransport(globalTransport);\\n    },\\n\\n\\n    /**\\n     * Removes global logging transport from the library logging framework.\\n     * @param globalTransport\\n     * @see Logger.removeGlobalTransport\\n     */\\n    removeGlobalLogTransport: function removeGlobalLogTransport(globalTransport) {\\n        __WEBPACK_IMPORTED_MODULE_18_jitsi_meet_logger___default.a.removeGlobalTransport(globalTransport);\\n    },\\n\\n\\n    /**\\n     * Creates the media tracks and returns them trough the callback.\\n     * @param options Object with properties / settings specifying the tracks\\n     * which should be created. should be created or some additional\\n     * configurations about resolution for example.\\n     * @param {Array} options.devices the devices that will be requested\\n     * @param {string} options.resolution resolution constraints\\n     * @param {bool} options.dontCreateJitsiTrack if <tt>true</tt> objects with\\n     * the following structure {stream: the Media Stream, type: \\\"audio\\\" or\\n     * \\\"video\\\", videoType: \\\"camera\\\" or \\\"desktop\\\"} will be returned trough the\\n     * Promise, otherwise JitsiTrack objects will be returned.\\n     * @param {string} options.cameraDeviceId\\n     * @param {string} options.micDeviceId\\n     * @param {object} options.desktopSharingExtensionExternalInstallation -\\n     * enables external installation process for desktop sharing extension if\\n     * the inline installation is not posible. The following properties should\\n     * be provided:\\n     * @param {intiger} interval - the interval (in ms) for\\n     * checking whether the desktop sharing extension is installed or not\\n     * @param {Function} checkAgain - returns boolean. While checkAgain()==true\\n     * createLocalTracks will wait and check on every \\\"interval\\\" ms for the\\n     * extension. If the desktop extension is not install and checkAgain()==true\\n     * createLocalTracks will finish with rejected Promise.\\n     * @param {Function} listener - The listener will be called to notify the\\n     * user of lib-jitsi-meet that createLocalTracks is starting external\\n     * extension installation process.\\n     * NOTE: If the inline installation process is not possible and external\\n     * installation is enabled the listener property will be called to notify\\n     * the start of external installation process. After that createLocalTracks\\n     * will start to check for the extension on every interval ms until the\\n     * plugin is installed or until checkAgain return false. If the extension\\n     * is found createLocalTracks will try to get the desktop sharing track and\\n     * will finish the execution. If checkAgain returns false, createLocalTracks\\n     * will finish the execution with rejected Promise.\\n     *\\n     * @param {boolean} (firePermissionPromptIsShownEvent) - if event\\n     *      JitsiMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN should be fired\\n     * @returns {Promise.<{Array.<JitsiTrack>}, JitsiConferenceError>}\\n     *     A promise that returns an array of created JitsiTracks if resolved,\\n     *     or a JitsiConferenceError if rejected.\\n     */\\n    createLocalTracks: function createLocalTracks() {\\n        var _this = this;\\n\\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n        var firePermissionPromptIsShownEvent = arguments[1];\\n\\n        var promiseFulfilled = false;\\n\\n        if (firePermissionPromptIsShownEvent === true) {\\n            window.setTimeout(function () {\\n                if (!promiseFulfilled) {\\n                    __WEBPACK_IMPORTED_MODULE_9__JitsiMediaDevices__[\\\"a\\\" /* default */].emitEvent(__WEBPACK_IMPORTED_MODULE_10__JitsiMediaDevicesEvents__[\\\"PERMISSION_PROMPT_IS_SHOWN\\\"], __WEBPACK_IMPORTED_MODULE_23__modules_RTC_RTCBrowserType__[\\\"a\\\" /* default */].getBrowserName());\\n                }\\n            }, USER_MEDIA_PERMISSION_PROMPT_TIMEOUT);\\n        }\\n\\n        if (!window.connectionTimes) {\\n            window.connectionTimes = {};\\n        }\\n        window.connectionTimes['obtainPermissions.start'] = window.performance.now();\\n\\n        return __WEBPACK_IMPORTED_MODULE_22__modules_RTC_RTC__[\\\"a\\\" /* default */].obtainAudioAndVideoPermissions(options).then(function (tracks) {\\n            promiseFulfilled = true;\\n\\n            window.connectionTimes['obtainPermissions.end'] = window.performance.now();\\n\\n            __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(addDeviceTypeToAnalyticsEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"o\\\" /* GET_USER_MEDIA_SUCCESS_ */], options), { value: options });\\n\\n            if (!__WEBPACK_IMPORTED_MODULE_22__modules_RTC_RTC__[\\\"a\\\" /* default */].options.disableAudioLevels) {\\n                var _loop = function _loop(i) {\\n                    var track = tracks[i];\\n                    var mStream = track.getOriginalStream();\\n\\n                    if (track.getType() === __WEBPACK_IMPORTED_MODULE_19__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]) {\\n                        __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].startLocalStats(mStream, track.setAudioLevel.bind(track));\\n                        track.addEventListener(__WEBPACK_IMPORTED_MODULE_14__JitsiTrackEvents__[\\\"LOCAL_TRACK_STOPPED\\\"], function () {\\n                            __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].stopLocalStats(mStream);\\n                        });\\n                    }\\n                };\\n\\n                for (var i = 0; i < tracks.length; i++) {\\n                    _loop(i);\\n                }\\n            }\\n\\n            // set real device ids\\n            var currentlyAvailableMediaDevices = __WEBPACK_IMPORTED_MODULE_22__modules_RTC_RTC__[\\\"a\\\" /* default */].getCurrentlyAvailableMediaDevices();\\n\\n            if (currentlyAvailableMediaDevices) {\\n                for (var i = 0; i < tracks.length; i++) {\\n                    var _track = tracks[i];\\n\\n                    _track._setRealDeviceIdFromDeviceList(currentlyAvailableMediaDevices);\\n                }\\n            }\\n\\n            return tracks;\\n        }).catch(function (error) {\\n            promiseFulfilled = true;\\n\\n            if (error.name === __WEBPACK_IMPORTED_MODULE_13__JitsiTrackErrors__[\\\"UNSUPPORTED_RESOLUTION\\\"] && !__WEBPACK_IMPORTED_MODULE_23__modules_RTC_RTCBrowserType__[\\\"a\\\" /* default */].usesNewGumFlow()) {\\n                var oldResolution = options.resolution || '720';\\n                var newResolution = getLowerResolution(oldResolution);\\n\\n                if (newResolution !== null) {\\n                    options.resolution = newResolution;\\n\\n                    logger.debug('Retry createLocalTracks with resolution', newResolution);\\n\\n                    __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"n\\\" /* GET_USER_MEDIA_FAIL_ */] + '.resolution.' + oldResolution);\\n\\n                    return _this.createLocalTracks(options);\\n                }\\n            }\\n\\n            if (__WEBPACK_IMPORTED_MODULE_13__JitsiTrackErrors__[\\\"CHROME_EXTENSION_USER_CANCELED\\\"] === error.name) {\\n                // User cancelled action is not really an error, so only\\n                // log it as an event to avoid having conference classified\\n                // as partially failed\\n                var logObject = {\\n                    id: 'chrome_extension_user_canceled',\\n                    message: error.message\\n                };\\n\\n                __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify(logObject));\\n                __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"p\\\" /* GET_USER_MEDIA_USER_CANCEL_ */] + '.extensionInstall');\\n            } else if (__WEBPACK_IMPORTED_MODULE_13__JitsiTrackErrors__[\\\"NOT_FOUND\\\"] === error.name) {\\n                // logs not found devices with just application log to cs\\n                var _logObject2 = {\\n                    id: 'usermedia_missing_device',\\n                    status: error.gum.devices\\n                };\\n\\n                __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify(_logObject2));\\n                __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"l\\\" /* GET_USER_MEDIA_DEVICE_NOT_FOUND_ */] + '.' + error.gum.devices.join('.'));\\n            } else {\\n                // Report gUM failed to the stats\\n                __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].sendGetUserMediaFailed(error);\\n                var eventName = addDeviceTypeToAnalyticsEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"m\\\" /* GET_USER_MEDIA_FAILED_ */], options);\\n\\n                __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(eventName + '.' + error.name, { value: options });\\n            }\\n\\n            window.connectionTimes['obtainPermissions.end'] = window.performance.now();\\n\\n            return Promise.reject(error);\\n        });\\n    },\\n\\n\\n    /**\\n     * Checks if its possible to enumerate available cameras/microphones.\\n     * @returns {Promise<boolean>} a Promise which will be resolved only once\\n     * the WebRTC stack is ready, either with true if the device listing is\\n     * available available or with false otherwise.\\n     * @deprecated use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead\\n     */\\n    isDeviceListAvailable: function isDeviceListAvailable() {\\n        logger.warn('This method is deprecated, use ' + 'JitsiMeetJS.mediaDevices.isDeviceListAvailable instead');\\n\\n        return this.mediaDevices.isDeviceListAvailable();\\n    },\\n\\n\\n    /**\\n     * Returns true if changing the input (camera / microphone) or output\\n     * (audio) device is supported and false if not.\\n     * @params {string} [deviceType] - type of device to change. Default is\\n     *      undefined or 'input', 'output' - for audio output device change.\\n     * @returns {boolean} true if available, false otherwise.\\n     * @deprecated use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead\\n     */\\n    isDeviceChangeAvailable: function isDeviceChangeAvailable(deviceType) {\\n        logger.warn('This method is deprecated, use ' + 'JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead');\\n\\n        return this.mediaDevices.isDeviceChangeAvailable(deviceType);\\n    },\\n\\n\\n    /**\\n     * Checks if the current environment supports having multiple audio\\n     * input devices in use simultaneously.\\n     *\\n     * @returns {boolean} True if multiple audio input devices can be used.\\n     */\\n    isMultipleAudioInputSupported: function isMultipleAudioInputSupported() {\\n        return this.mediaDevices.isMultipleAudioInputSupported();\\n    },\\n\\n\\n    /**\\n     * Checks if local tracks can collect stats and collection is enabled.\\n     *\\n     * @param {boolean} True if stats are being collected for local tracks.\\n     */\\n    isCollectingLocalStats: function isCollectingLocalStats() {\\n        return __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].audioLevelsEnabled && __WEBPACK_IMPORTED_MODULE_16__modules_statistics_LocalStatsCollector__[\\\"a\\\" /* default */].isLocalStatsSupported();\\n    },\\n\\n\\n    /**\\n     * Executes callback with list of media devices connected.\\n     * @param {function} callback\\n     * @deprecated use JitsiMeetJS.mediaDevices.enumerateDevices instead\\n     */\\n    enumerateDevices: function enumerateDevices(callback) {\\n        logger.warn('This method is deprecated, use ' + 'JitsiMeetJS.mediaDevices.enumerateDevices instead');\\n        this.mediaDevices.enumerateDevices(callback);\\n    },\\n\\n\\n    /* eslint-disable max-params */\\n\\n    /**\\n     * @returns function that can be used to be attached to window.onerror and\\n     * if options.enableWindowOnErrorHandler is enabled returns\\n     * the function used by the lib.\\n     * (function(message, source, lineno, colno, error)).\\n     */\\n    getGlobalOnErrorHandler: function getGlobalOnErrorHandler(message, source, lineno, colno, error) {\\n        logger.error('UnhandledError: ' + message, 'Script: ' + source, 'Line: ' + lineno, 'Column: ' + colno, 'StackTrace: ', error);\\n        __WEBPACK_IMPORTED_MODULE_27__modules_statistics_statistics__[\\\"a\\\" /* default */].reportGlobalError(error);\\n    },\\n\\n\\n    /* eslint-enable max-params */\\n\\n    /**\\n     * Returns current machine id saved from the local storage.\\n     * @returns {string} the machine id\\n     */\\n    getMachineId: function getMachineId() {\\n        return __WEBPACK_IMPORTED_MODULE_26__modules_settings_Settings__[\\\"a\\\" /* default */].machineId;\\n    },\\n\\n\\n    /**\\n     * Represents a hub/namespace for utility functionality which may be of\\n     * interest to lib-jitsi-meet clients.\\n     */\\n    util: {\\n        AuthUtil: __WEBPACK_IMPORTED_MODULE_1__modules_util_AuthUtil___default.a,\\n        RTCUIHelper: __WEBPACK_IMPORTED_MODULE_24__modules_RTC_RTCUIHelper__[\\\"a\\\" /* default */],\\n        ScriptUtil: __WEBPACK_IMPORTED_MODULE_25__modules_util_ScriptUtil___default.a\\n    }\\n});\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"JitsiMeetJS.js\\\"))\\n\\n/***/ }),\\n/* 62 */\\n/***/ (function(module, exports) {\\n\\nvar AuthUtil = {\\n    /**\\n     * Creates the URL pointing to JWT token authentication service. It is\\n     * formatted from the 'urlPattern' argument which can contain the following\\n     * constants:\\n     * '{room}' - name of the conference room passed as <tt>roomName</tt>\\n     * argument to this method.\\n     * '{roleUpgrade}' - will contain 'true' if the URL will be used for\\n     * the role upgrade scenario, where user connects from anonymous domain and\\n     * then gets upgraded to the moderator by logging-in from the popup window.\\n     *\\n     * @param urlPattern a URL pattern pointing to the login service\\n     * @param roomName the name of the conference room for which the user will\\n     * be authenticated\\n     * @param {bool} roleUpgrade <tt>true</tt> if the URL will be used for role\\n     * upgrade scenario, where the user logs-in from the popup window in order\\n     * to have the moderator rights granted\\n     *\\n     * @returns {string|null} the URL pointing to JWT login service or\\n     * <tt>null</tt> if 'urlPattern' is not a string and the URL can not be\\n     * constructed.\\n     */\\n    getTokenAuthUrl: function getTokenAuthUrl(urlPattern, roomName, roleUpgrade) {\\n        var url = urlPattern;\\n\\n        if (typeof url !== 'string') {\\n            return null;\\n        }\\n\\n        return url.replace('{room}', roomName).replace('{roleUpgrade}', roleUpgrade === true);\\n    }\\n};\\n\\nmodule.exports = AuthUtil;\\n\\n/***/ }),\\n/* 63 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = JitsiConnection;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JitsiConference__ = __webpack_require__(64);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__JitsiConnectionEvents__ = __webpack_require__(26);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_statistics_statistics__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__modules_xmpp_xmpp__ = __webpack_require__(45);\\n\\n\\n\\n\\n\\n\\n/**\\n * Creates a new connection object for the Jitsi Meet server side video\\n * conferencing service. Provides access to the JitsiConference interface.\\n * @param appID identification for the provider of Jitsi Meet video conferencing\\n * services.\\n * @param token the JWT token used to authenticate with the server(optional)\\n * @param options Object with properties / settings related to connection with\\n * the server.\\n * @constructor\\n */\\nfunction JitsiConnection(appID, token, options) {\\n    this.appID = appID;\\n    this.token = token;\\n    this.options = options;\\n    this.xmpp = new __WEBPACK_IMPORTED_MODULE_4__modules_xmpp_xmpp__[\\\"a\\\" /* default */](options, token);\\n\\n    this.addEventListener(__WEBPACK_IMPORTED_MODULE_2__JitsiConnectionEvents__[\\\"CONNECTION_FAILED\\\"], function (errType, msg) {\\n        __WEBPACK_IMPORTED_MODULE_3__modules_statistics_statistics__[\\\"a\\\" /* default */].sendEventToAll(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"e\\\" /* CONNECTION_FAILED_ */] + '.' + errType, { label: msg });\\n    });\\n\\n    this.addEventListener(__WEBPACK_IMPORTED_MODULE_2__JitsiConnectionEvents__[\\\"CONNECTION_DISCONNECTED\\\"], function (msg) {\\n        // we can see disconnects from normal tab closing of the browser\\n        // and then there are no msgs, but we want to log only disconnects\\n        // when there is real error\\n        if (msg) {\\n            __WEBPACK_IMPORTED_MODULE_3__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"d\\\" /* CONNECTION_DISCONNECTED_ */] + '.' + msg);\\n        }\\n        __WEBPACK_IMPORTED_MODULE_3__modules_statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify({ id: 'connection.disconnected',\\n            msg: msg }));\\n    });\\n}\\n\\n/**\\n * Connect the client with the server.\\n * @param options {object} connecting options\\n * (for example authentications parameters).\\n */\\nJitsiConnection.prototype.connect = function () {\\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n    this.xmpp.connect(options.id, options.password);\\n};\\n\\n/**\\n * Attach to existing connection. Can be used for optimizations. For example:\\n * if the connection is created on the server we can attach to it and start\\n * using it.\\n *\\n * @param options {object} connecting options - rid, sid and jid.\\n */\\nJitsiConnection.prototype.attach = function (options) {\\n    this.xmpp.attach(options);\\n};\\n\\n/**\\n * Disconnect the client from the server.\\n */\\nJitsiConnection.prototype.disconnect = function () {\\n    var _xmpp;\\n\\n    // XXX Forward any arguments passed to JitsiConnection.disconnect to\\n    // XMPP.disconnect. For example, the caller of JitsiConnection.disconnect\\n    // may optionally pass the event which triggered the disconnect in order to\\n    // provide the implementation with finer-grained context.\\n    (_xmpp = this.xmpp).disconnect.apply(_xmpp, arguments);\\n};\\n\\n/**\\n * This method allows renewal of the tokens if they are expiring.\\n * @param token the new token.\\n */\\nJitsiConnection.prototype.setToken = function (token) {\\n    this.token = token;\\n};\\n\\n/**\\n * Creates and joins new conference.\\n * @param name the name of the conference; if null - a generated name will be\\n * provided from the api\\n * @param options Object with properties / settings related to the conference\\n * that will be created.\\n * @returns {JitsiConference} returns the new conference object.\\n */\\nJitsiConnection.prototype.initJitsiConference = function (name, options) {\\n    return new __WEBPACK_IMPORTED_MODULE_1__JitsiConference__[\\\"a\\\" /* default */]({\\n        name: name,\\n        config: options,\\n        connection: this\\n    });\\n};\\n\\n/**\\n * Subscribes the passed listener to the event.\\n * @param event {JitsiConnectionEvents} the connection event.\\n * @param listener {Function} the function that will receive the event\\n */\\nJitsiConnection.prototype.addEventListener = function (event, listener) {\\n    this.xmpp.addListener(event, listener);\\n};\\n\\n/**\\n * Unsubscribes the passed handler.\\n * @param event {JitsiConnectionEvents} the connection event.\\n * @param listener {Function} the function that will receive the event\\n */\\nJitsiConnection.prototype.removeEventListener = function (event, listener) {\\n    this.xmpp.removeListener(event, listener);\\n};\\n\\n/**\\n * Returns measured connectionTimes.\\n */\\nJitsiConnection.prototype.getConnectionTimes = function () {\\n    return this.xmpp.connectionTimes;\\n};\\n\\n/**\\n * Adds new feature to the list of supported features for the local\\n * participant.\\n * @param {String} feature the name of the feature.\\n * @param {boolean} submit if true - the new list of features will be\\n * immediately submitted to the others.\\n */\\nJitsiConnection.prototype.addFeature = function (feature) {\\n    var submit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n    return this.xmpp.caps.addFeature(feature, submit);\\n};\\n\\n/**\\n * Removes a feature from the list of supported features for the local\\n * participant\\n * @param {String} feature the name of the feature.\\n * @param {boolean} submit if true - the new list of features will be\\n * immediately submitted to the others.\\n */\\nJitsiConnection.prototype.removeFeature = function (feature) {\\n    var submit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n    return this.xmpp.caps.removeFeature(feature, submit);\\n};\\n\\n/***/ }),\\n/* 64 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = JitsiConference;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__modules_statistics_AvgRTPStatsReporter__ = __webpack_require__(65);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_version_ComponentsVersions__ = __webpack_require__(93);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__modules_connectivity_ConnectionQuality__ = __webpack_require__(94);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__modules_util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__modules_util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__modules_util_GlobalOnErrorHandler__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_events__ = __webpack_require__(16);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_events__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__authenticateAndUpgradeRole__ = __webpack_require__(95);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__JitsiConferenceErrors__ = __webpack_require__(32);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__JitsiConferenceEventManager__ = __webpack_require__(113);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__modules_DTMF_JitsiDTMFManager__ = __webpack_require__(115);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__modules_DTMF_JitsiDTMFManager___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12__modules_DTMF_JitsiDTMFManager__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__JitsiParticipant__ = __webpack_require__(116);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__JitsiTrackError__ = __webpack_require__(12);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__JitsiTrackErrors__ = __webpack_require__(17);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__JitsiTrackEvents__ = __webpack_require__(18);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__modules_event_Jvb121EventGenerator__ = __webpack_require__(117);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__modules_connectivity_ParticipantConnectionStatus__ = __webpack_require__(36);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__modules_P2PDominantSpeakerDetection__ = __webpack_require__(118);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__modules_RTC_RTC__ = __webpack_require__(27);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__modules_RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__service_RTC_RTCEvents__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__service_RTC_RTCEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_23__service_RTC_RTCEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__modules_TalkMutedDetection__ = __webpack_require__(153);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__modules_transcription_transcriber__ = __webpack_require__(154);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__modules_transcription_transcriber___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_26__modules_transcription_transcriber__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__service_RTC_VideoType__ = __webpack_require__(13);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__service_RTC_VideoType___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_27__service_RTC_VideoType__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__modules_videosipgw_VideoSIPGW__ = __webpack_require__(159);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__modules_videosipgw_VideoSIPGWConstants__ = __webpack_require__(30);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__service_xmpp_XMPPEvents__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__service_xmpp_XMPPEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_30__service_xmpp_XMPPEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__modules_statistics_SpeakerStatsCollector__ = __webpack_require__(161);\\n/* global __filename, $, Promise */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_5_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Creates a JitsiConference object with the given name and properties.\\n * Note: this constructor is not a part of the public API (objects should be\\n * created using JitsiConnection.createConference).\\n * @param options.config properties / settings related to the conference that\\n * will be created.\\n * @param options.name the name of the conference\\n * @param options.connection the JitsiConnection object for this\\n * JitsiConference.\\n * @param {number} [options.config.avgRtpStatsN=15] how many samples are to be\\n * collected by {@link AvgRTPStatsReporter}, before arithmetic mean is\\n * calculated and submitted to the analytics module.\\n * @param {boolean} [options.config.p2p.enabled] when set to <tt>true</tt>\\n * the peer to peer mode will be enabled. It means that when there are only 2\\n * participants in the conference an attempt to make direct connection will be\\n * made. If the connection succeeds the conference will stop sending data\\n * through the JVB connection and will use the direct one instead.\\n * @param {number} [options.config.p2p.backToP2PDelay=5] a delay given in\\n * seconds, before the conference switches back to P2P, after the 3rd\\n * participant has left the room.\\n * @param {number} [options.config.channelLastN=-1] The requested amount of\\n * videos are going to be delivered after the value is in effect. Set to -1 for\\n * unlimited or all available videos.\\n * @param {number} [options.config.forceJVB121Ratio]\\n * \\\"Math.random() < forceJVB121Ratio\\\" will determine whether a 2 people\\n * conference should be moved to the JVB instead of P2P. The decision is made on\\n * the responder side, after ICE succeeds on the P2P connection.\\n * @param {*} [options.config.openBridgeChannel] Which kind of communication to\\n * open with the videobridge. Values can be \\\"datachannel\\\", \\\"websocket\\\", true\\n * (treat it as \\\"datachannel\\\"), undefined (treat it as \\\"datachannel\\\") and false\\n * (don't open any channel).\\n * @constructor\\n *\\n * FIXME Make all methods which are called from lib-internal classes\\n *       to non-public (use _). To name a few:\\n *       {@link JitsiConference.onLocalRoleChanged}\\n *       {@link JitsiConference.onUserRoleChanged}\\n *       {@link JitsiConference.onMemberLeft}\\n *       and so on...\\n */\\nfunction JitsiConference(options) {\\n    if (!options.name || options.name.toLowerCase() !== options.name) {\\n        var errmsg = 'Invalid conference name (no conference name passed or it ' + 'contains invalid characters like capital letters)!';\\n\\n        logger.error(errmsg);\\n        throw new Error(errmsg);\\n    }\\n    this.eventEmitter = new __WEBPACK_IMPORTED_MODULE_7_events___default.a();\\n    this.options = options;\\n    this.eventManager = new __WEBPACK_IMPORTED_MODULE_10__JitsiConferenceEventManager__[\\\"a\\\" /* default */](this);\\n    this.participants = {};\\n    this._init(options);\\n    this.componentsVersions = new __WEBPACK_IMPORTED_MODULE_3__modules_version_ComponentsVersions__[\\\"a\\\" /* default */](this);\\n\\n    /**\\n     * Jingle session instance for the JVB connection.\\n     * @type {JingleSessionPC}\\n     */\\n    this.jvbJingleSession = null;\\n    this.lastDominantSpeaker = null;\\n    this.dtmfManager = null;\\n    this.somebodySupportsDTMF = false;\\n    this.authEnabled = false;\\n    this.startAudioMuted = false;\\n    this.startVideoMuted = false;\\n    this.startMutedPolicy = {\\n        audio: false,\\n        video: false\\n    };\\n    this.availableDevices = {\\n        audio: undefined,\\n        video: undefined\\n    };\\n    this.isMutedByFocus = false;\\n\\n    // Flag indicates if the 'onCallEnded' method was ever called on this\\n    // instance. Used to log extra analytics event for debugging purpose.\\n    // We need to know if the potential issue happened before or after\\n    // the restart.\\n    this.wasStopped = false;\\n\\n    /**\\n     * The object which monitors local and remote connection statistics (e.g.\\n     * sending bitrate) and calculates a number which represents the connection\\n     * quality.\\n     */\\n    this.connectionQuality = new __WEBPACK_IMPORTED_MODULE_4__modules_connectivity_ConnectionQuality__[\\\"a\\\" /* default */](this, this.eventEmitter, options);\\n\\n    /**\\n     * Reports average RTP statistics to the analytics module.\\n     * @type {AvgRTPStatsReporter}\\n     */\\n    this.avgRtpStatsReporter = new __WEBPACK_IMPORTED_MODULE_2__modules_statistics_AvgRTPStatsReporter__[\\\"a\\\" /* default */](this, options.config.avgRtpStatsN || 15);\\n\\n    /**\\n     * Indicates whether the connection is interrupted or not.\\n     */\\n    this.isJvbConnectionInterrupted = false;\\n\\n    /**\\n     * The object which tracks active speaker times\\n     */\\n    this.speakerStatsCollector = new __WEBPACK_IMPORTED_MODULE_31__modules_statistics_SpeakerStatsCollector__[\\\"a\\\" /* default */](this);\\n\\n    /* P2P related fields below: */\\n\\n    /**\\n     * Stores reference to deferred start P2P task. It's created when 3rd\\n     * participant leaves the room in order to avoid ping pong effect (it\\n     * could be just a page reload).\\n     * @type {number|null}\\n     */\\n    this.deferredStartP2PTask = null;\\n\\n    var delay = parseInt(options.config.p2p && options.config.p2p.backToP2PDelay, 10);\\n\\n    /**\\n     * A delay given in seconds, before the conference switches back to P2P\\n     * after the 3rd participant has left.\\n     * @type {number}\\n     */\\n    this.backToP2PDelay = isNaN(delay) ? 5 : delay;\\n    logger.info('backToP2PDelay: ' + this.backToP2PDelay);\\n\\n    /**\\n     * If set to <tt>true</tt> it means the P2P ICE is no longer connected.\\n     * When <tt>false</tt> it means that P2P ICE (media) connection is up\\n     * and running.\\n     * @type {boolean}\\n     */\\n    this.isP2PConnectionInterrupted = false;\\n\\n    /**\\n     * Flag set to <tt>true</tt> when P2P session has been established\\n     * (ICE has been connected) and this conference is currently in the peer to\\n     * peer mode (P2P connection is the active one).\\n     * @type {boolean}\\n     */\\n    this.p2p = false;\\n\\n    /**\\n     * A JingleSession for the direct peer to peer connection.\\n     * @type {JingleSessionPC}\\n     */\\n    this.p2pJingleSession = null;\\n\\n    this.videoSIPGWHandler = new __WEBPACK_IMPORTED_MODULE_28__modules_videosipgw_VideoSIPGW__[\\\"a\\\" /* default */](this.room);\\n}\\n\\n// FIXME convert JitsiConference to ES6 - ASAP !\\nJitsiConference.prototype.constructor = JitsiConference;\\n\\n/**\\n * Initializes the conference object properties\\n * @param options {object}\\n * @param options.connection {JitsiConnection} overrides this.connection\\n */\\nJitsiConference.prototype._init = function () {\\n    var _this = this;\\n\\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n    // Override connection and xmpp properties (Useful if the connection\\n    // reloaded)\\n    if (options.connection) {\\n        this.connection = options.connection;\\n        this.xmpp = this.connection.xmpp;\\n\\n        // Setup XMPP events only if we have new connection object.\\n        this.eventManager.setupXMPPListeners();\\n    }\\n\\n    var config = this.options.config;\\n\\n\\n    this.room = this.xmpp.createRoom(this.options.name, config);\\n\\n    // Connection interrupted/restored listeners\\n    this._onIceConnectionInterrupted = this._onIceConnectionInterrupted.bind(this);\\n    this.room.addListener(__WEBPACK_IMPORTED_MODULE_30__service_xmpp_XMPPEvents__[\\\"CONNECTION_INTERRUPTED\\\"], this._onIceConnectionInterrupted);\\n\\n    this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this);\\n    this.room.addListener(__WEBPACK_IMPORTED_MODULE_30__service_xmpp_XMPPEvents__[\\\"CONNECTION_RESTORED\\\"], this._onIceConnectionRestored);\\n\\n    this._onIceConnectionEstablished = this._onIceConnectionEstablished.bind(this);\\n    this.room.addListener(__WEBPACK_IMPORTED_MODULE_30__service_xmpp_XMPPEvents__[\\\"CONNECTION_ESTABLISHED\\\"], this._onIceConnectionEstablished);\\n\\n    this.room.updateDeviceAvailability(__WEBPACK_IMPORTED_MODULE_21__modules_RTC_RTC__[\\\"a\\\" /* default */].getDeviceAvailability());\\n\\n    if (!this.rtc) {\\n        this.rtc = new __WEBPACK_IMPORTED_MODULE_21__modules_RTC_RTC__[\\\"a\\\" /* default */](this, options);\\n        this.eventManager.setupRTCListeners();\\n    }\\n\\n    this.participantConnectionStatus = new __WEBPACK_IMPORTED_MODULE_19__modules_connectivity_ParticipantConnectionStatus__[\\\"b\\\" /* default */](this.rtc, this, {\\n        // Both these options are not public API, leaving it here only\\n        // as an entry point through config for tuning up purposes.\\n        // Default values should be adjusted as soon as optimal values\\n        // are discovered.\\n        rtcMuteTimeout: config._peerConnStatusRtcMuteTimeout,\\n        outOfLastNTimeout: config._peerConnStatusOutOfLastNTimeout\\n    });\\n    this.participantConnectionStatus.init();\\n\\n    if (!this.statistics) {\\n        // XXX The property location on the global variable window is not\\n        // defined in all execution environments (e.g. react-native). While\\n        // jitsi-meet may polyfill it when executing on react-native, it is\\n        // better for the cross-platform support to not require window.location\\n        // especially when there is a worthy alternative (as demonstrated\\n        // bellow).\\n        var windowLocation = window.location;\\n\\n        var callStatsAliasName = this.myUserId();\\n\\n        if (config.enableDisplayNameInStats && config.displayName) {\\n            callStatsAliasName = config.displayName;\\n        }\\n\\n        this.statistics = new __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */](this.xmpp, {\\n            callStatsAliasName: callStatsAliasName,\\n            callStatsConfIDNamespace: config.callStatsConfIDNamespace || windowLocation && windowLocation.hostname || config.hosts && config.hosts.domain,\\n            callStatsCustomScriptUrl: config.callStatsCustomScriptUrl,\\n            callStatsID: config.callStatsID,\\n            callStatsSecret: config.callStatsSecret,\\n            roomName: this.options.name,\\n            swapUserNameAndAlias: config.enableStatsID,\\n            applicationName: config.applicationName,\\n            getWiFiStatsMethod: config.getWiFiStatsMethod\\n        });\\n    }\\n\\n    this.eventManager.setupChatRoomListeners();\\n\\n    // Always add listeners because on reload we are executing leave and the\\n    // listeners are removed from statistics module.\\n    this.eventManager.setupStatisticsListeners();\\n\\n    if (config.enableTalkWhileMuted) {\\n        // eslint-disable-next-line no-new\\n        new __WEBPACK_IMPORTED_MODULE_25__modules_TalkMutedDetection__[\\\"a\\\" /* default */](this, function () {\\n            return _this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"TALK_WHILE_MUTED\\\"]);\\n        });\\n    }\\n\\n    if ('channelLastN' in config) {\\n        this.setLastN(config.channelLastN);\\n    }\\n\\n    /**\\n     * Emits {@link JitsiConferenceEvents.JVB121_STATUS}.\\n     * @type {Jvb121EventGenerator}\\n     */\\n    this.jvb121Status = new __WEBPACK_IMPORTED_MODULE_17__modules_event_Jvb121EventGenerator__[\\\"a\\\" /* default */](this);\\n\\n    // creates dominant speaker detection that works only in p2p mode\\n    this.p2pDominantSpeakerDetection = new __WEBPACK_IMPORTED_MODULE_20__modules_P2PDominantSpeakerDetection__[\\\"a\\\" /* default */](this);\\n};\\n\\n/**\\n * Joins the conference.\\n * @param password {string} the password\\n */\\nJitsiConference.prototype.join = function (password) {\\n    if (this.room) {\\n        this.room.join(password);\\n    }\\n};\\n\\n/**\\n * Authenticates and upgrades the role of the local participant/user.\\n *\\n * @returns {Object} A <tt>thenable</tt> which (1) settles when the process of\\n * authenticating and upgrading the role of the local participant/user finishes\\n * and (2) has a <tt>cancel</tt> method that allows the caller to interrupt the\\n * process.\\n */\\nJitsiConference.prototype.authenticateAndUpgradeRole = function () {\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n        args[_key] = arguments[_key];\\n    }\\n\\n    return __WEBPACK_IMPORTED_MODULE_8__authenticateAndUpgradeRole__[\\\"a\\\" /* default */].apply(this, args);\\n};\\n\\n/**\\n * Check if joined to the conference.\\n */\\nJitsiConference.prototype.isJoined = function () {\\n    return this.room && this.room.joined;\\n};\\n\\n/**\\n * Tells whether or not the P2P mode is enabled in the configuration.\\n * @return {boolean}\\n */\\nJitsiConference.prototype.isP2PEnabled = function () {\\n    return Boolean(this.options.config.p2p && this.options.config.p2p.enabled)\\n\\n    // FIXME: remove once we have a default config template. -saghul\\n    || typeof this.options.config.p2p === 'undefined';\\n};\\n\\n/**\\n * When in P2P test mode, the conference will not automatically switch to P2P\\n * when there 2 participants.\\n * @return {boolean}\\n */\\nJitsiConference.prototype.isP2PTestModeEnabled = function () {\\n    return Boolean(this.options.config.testing && this.options.config.testing.p2pTestMode);\\n};\\n\\n/**\\n * Leaves the conference.\\n * @returns {Promise}\\n */\\nJitsiConference.prototype.leave = function () {\\n    var _this2 = this;\\n\\n    if (this.participantConnectionStatus) {\\n        this.participantConnectionStatus.dispose();\\n        this.participantConnectionStatus = null;\\n    }\\n    if (this.avgRtpStatsReporter) {\\n        this.avgRtpStatsReporter.dispose();\\n        this.avgRtpStatsReporter = null;\\n    }\\n\\n    this.getLocalTracks().forEach(function (track) {\\n        return _this2.onLocalTrackRemoved(track);\\n    });\\n\\n    this.rtc.closeBridgeChannel();\\n    if (this.statistics) {\\n        this.statistics.dispose();\\n    }\\n\\n    // Close both JVb and P2P JingleSessions\\n    if (this.jvbJingleSession) {\\n        this.jvbJingleSession.close();\\n        this.jvbJingleSession = null;\\n    }\\n    if (this.p2pJingleSession) {\\n        this.p2pJingleSession.close();\\n        this.p2pJingleSession = null;\\n    }\\n\\n    // leave the conference\\n    if (this.room) {\\n        var room = this.room;\\n\\n        // Unregister connection state listeners\\n        room.removeListener(__WEBPACK_IMPORTED_MODULE_30__service_xmpp_XMPPEvents__[\\\"CONNECTION_INTERRUPTED\\\"], this._onIceConnectionInterrupted);\\n        room.removeListener(__WEBPACK_IMPORTED_MODULE_30__service_xmpp_XMPPEvents__[\\\"CONNECTION_RESTORED\\\"], this._onIceConnectionRestored);\\n        room.removeListener(__WEBPACK_IMPORTED_MODULE_30__service_xmpp_XMPPEvents__[\\\"CONNECTION_ESTABLISHED\\\"], this._onIceConnectionEstablished);\\n\\n        this.room = null;\\n\\n        return room.leave().catch(function () {\\n            // remove all participants because currently the conference won't\\n            // be usable anyway. This is done on success automatically by the\\n            // ChatRoom instance.\\n            _this2.getParticipants().forEach(function (participant) {\\n                return _this2.onMemberLeft(participant.getJid());\\n            });\\n        });\\n    }\\n\\n    // If this.room == null we are calling second time leave().\\n    return Promise.reject(new Error('The conference is has been already left'));\\n};\\n\\n/**\\n * Returns name of this conference.\\n */\\nJitsiConference.prototype.getName = function () {\\n    return this.options.name;\\n};\\n\\n/**\\n * Check if authentication is enabled for this conference.\\n */\\nJitsiConference.prototype.isAuthEnabled = function () {\\n    return this.authEnabled;\\n};\\n\\n/**\\n * Check if user is logged in.\\n */\\nJitsiConference.prototype.isLoggedIn = function () {\\n    return Boolean(this.authIdentity);\\n};\\n\\n/**\\n * Get authorized login.\\n */\\nJitsiConference.prototype.getAuthLogin = function () {\\n    return this.authIdentity;\\n};\\n\\n/**\\n * Check if external authentication is enabled for this conference.\\n */\\nJitsiConference.prototype.isExternalAuthEnabled = function () {\\n    return this.room && this.room.moderator.isExternalAuthEnabled();\\n};\\n\\n/**\\n * Get url for external authentication.\\n * @param {boolean} [urlForPopup] if true then return url for login popup,\\n *                                else url of login page.\\n * @returns {Promise}\\n */\\nJitsiConference.prototype.getExternalAuthUrl = function (urlForPopup) {\\n    var _this3 = this;\\n\\n    return new Promise(function (resolve, reject) {\\n        if (!_this3.isExternalAuthEnabled()) {\\n            reject();\\n\\n            return;\\n        }\\n        if (urlForPopup) {\\n            _this3.room.moderator.getPopupLoginUrl(resolve, reject);\\n        } else {\\n            _this3.room.moderator.getLoginUrl(resolve, reject);\\n        }\\n    });\\n};\\n\\n/**\\n * Returns the local tracks of the given media type, or all local tracks if no\\n * specific type is given.\\n * @param {MediaType} [mediaType] Optional media type (audio or video).\\n */\\nJitsiConference.prototype.getLocalTracks = function (mediaType) {\\n    var tracks = [];\\n\\n    if (this.rtc) {\\n        tracks = this.rtc.getLocalTracks(mediaType);\\n    }\\n\\n    return tracks;\\n};\\n\\n/**\\n * Obtains local audio track.\\n * @return {JitsiLocalTrack|null}\\n */\\nJitsiConference.prototype.getLocalAudioTrack = function () {\\n    return this.rtc ? this.rtc.getLocalAudioTrack() : null;\\n};\\n\\n/**\\n * Obtains local video track.\\n * @return {JitsiLocalTrack|null}\\n */\\nJitsiConference.prototype.getLocalVideoTrack = function () {\\n    return this.rtc ? this.rtc.getLocalVideoTrack() : null;\\n};\\n\\n/**\\n * Attaches a handler for events(For example - \\\"participant joined\\\".) in the\\n * conference. All possible event are defined in JitsiConferenceEvents.\\n * @param eventId the event ID.\\n * @param handler handler for the event.\\n *\\n * Note: consider adding eventing functionality by extending an EventEmitter\\n * impl, instead of rolling ourselves\\n */\\nJitsiConference.prototype.on = function (eventId, handler) {\\n    if (this.eventEmitter) {\\n        this.eventEmitter.on(eventId, handler);\\n    }\\n};\\n\\n/**\\n * Removes event listener\\n * @param eventId the event ID.\\n * @param [handler] optional, the specific handler to unbind\\n *\\n * Note: consider adding eventing functionality by extending an EventEmitter\\n * impl, instead of rolling ourselves\\n */\\nJitsiConference.prototype.off = function (eventId, handler) {\\n    if (this.eventEmitter) {\\n        this.eventEmitter.removeListener(eventId, handler);\\n    }\\n};\\n\\n// Common aliases for event emitter\\nJitsiConference.prototype.addEventListener = JitsiConference.prototype.on;\\nJitsiConference.prototype.removeEventListener = JitsiConference.prototype.off;\\n\\n/**\\n * Receives notifications from other participants about commands / custom events\\n * (sent by sendCommand or sendCommandOnce methods).\\n * @param command {String} the name of the command\\n * @param handler {Function} handler for the command\\n */\\nJitsiConference.prototype.addCommandListener = function (command, handler) {\\n    if (this.room) {\\n        this.room.addPresenceListener(command, handler);\\n    }\\n};\\n\\n/**\\n  * Removes command  listener\\n  * @param command {String} the name of the command\\n  */\\nJitsiConference.prototype.removeCommandListener = function (command) {\\n    if (this.room) {\\n        this.room.removePresenceListener(command);\\n    }\\n};\\n\\n/**\\n * Sends text message to the other participants in the conference\\n * @param message the text message.\\n */\\nJitsiConference.prototype.sendTextMessage = function (message) {\\n    if (this.room) {\\n        this.room.sendMessage(message);\\n    }\\n};\\n\\n/**\\n * Send presence command.\\n * @param name {String} the name of the command.\\n * @param values {Object} with keys and values that will be sent.\\n **/\\nJitsiConference.prototype.sendCommand = function (name, values) {\\n    if (this.room) {\\n        this.room.addToPresence(name, values);\\n        this.room.sendPresence();\\n    }\\n};\\n\\n/**\\n * Send presence command one time.\\n * @param name {String} the name of the command.\\n * @param values {Object} with keys and values that will be sent.\\n **/\\nJitsiConference.prototype.sendCommandOnce = function (name, values) {\\n    this.sendCommand(name, values);\\n    this.removeCommand(name);\\n};\\n\\n/**\\n * Removes presence command.\\n * @param name {String} the name of the command.\\n **/\\nJitsiConference.prototype.removeCommand = function (name) {\\n    if (this.room) {\\n        this.room.removeFromPresence(name);\\n    }\\n};\\n\\n/**\\n * Sets the display name for this conference.\\n * @param name the display name to set\\n */\\nJitsiConference.prototype.setDisplayName = function (name) {\\n    if (this.room) {\\n        // remove previously set nickname\\n        this.room.removeFromPresence('nick');\\n\\n        this.room.addToPresence('nick', {\\n            attributes: { xmlns: 'http://jabber.org/protocol/nick' },\\n            value: name\\n        });\\n        this.room.sendPresence();\\n    }\\n};\\n\\n/**\\n * Set new subject for this conference. (available only for moderator)\\n * @param {string} subject new subject\\n */\\nJitsiConference.prototype.setSubject = function (subject) {\\n    if (this.room && this.isModerator()) {\\n        this.room.setSubject(subject);\\n    }\\n};\\n\\n/**\\n * Get a transcriber object for all current participants in this conference\\n * @return {Transcriber} the transcriber object\\n */\\nJitsiConference.prototype.getTranscriber = function () {\\n    if (this.transcriber === undefined) {\\n        this.transcriber = new __WEBPACK_IMPORTED_MODULE_26__modules_transcription_transcriber___default.a();\\n\\n        // add all existing local audio tracks to the transcriber\\n        var localAudioTracks = this.getLocalTracks(__WEBPACK_IMPORTED_MODULE_18__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]);\\n\\n        var _iteratorNormalCompletion = true;\\n        var _didIteratorError = false;\\n        var _iteratorError = undefined;\\n\\n        try {\\n            for (var _iterator = localAudioTracks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                var localAudio = _step.value;\\n\\n                this.transcriber.addTrack(localAudio);\\n            }\\n\\n            // and all remote audio tracks\\n        } catch (err) {\\n            _didIteratorError = true;\\n            _iteratorError = err;\\n        } finally {\\n            try {\\n                if (!_iteratorNormalCompletion && _iterator.return) {\\n                    _iterator.return();\\n                }\\n            } finally {\\n                if (_didIteratorError) {\\n                    throw _iteratorError;\\n                }\\n            }\\n        }\\n\\n        var remoteAudioTracks = this.rtc.getRemoteTracks(__WEBPACK_IMPORTED_MODULE_18__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]);\\n\\n        var _iteratorNormalCompletion2 = true;\\n        var _didIteratorError2 = false;\\n        var _iteratorError2 = undefined;\\n\\n        try {\\n            for (var _iterator2 = remoteAudioTracks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                var remoteTrack = _step2.value;\\n\\n                this.transcriber.addTrack(remoteTrack);\\n            }\\n        } catch (err) {\\n            _didIteratorError2 = true;\\n            _iteratorError2 = err;\\n        } finally {\\n            try {\\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                    _iterator2.return();\\n                }\\n            } finally {\\n                if (_didIteratorError2) {\\n                    throw _iteratorError2;\\n                }\\n            }\\n        }\\n    }\\n\\n    return this.transcriber;\\n};\\n\\n/**\\n * Returns the transcription status.\\n *\\n * @returns {String} \\\"on\\\" or \\\"off\\\".\\n */\\nJitsiConference.prototype.getTranscriptionStatus = function () {\\n    return this.room.transcriptionStatus;\\n};\\n\\n/**\\n * Adds JitsiLocalTrack object to the conference.\\n * @param track the JitsiLocalTrack object.\\n * @returns {Promise<JitsiLocalTrack>}\\n * @throws {Error} if the specified track is a video track and there is already\\n * another video track in the conference.\\n */\\nJitsiConference.prototype.addTrack = function (track) {\\n    if (track.isVideoTrack()) {\\n        // Ensure there's exactly 1 local video track in the conference.\\n        var localVideoTrack = this.rtc.getLocalVideoTrack();\\n\\n        if (localVideoTrack) {\\n            // Don't be excessively harsh and severe if the API client happens\\n            // to attempt to add the same local video track twice.\\n            if (track === localVideoTrack) {\\n                return Promise.resolve(track);\\n            }\\n\\n            return Promise.reject(new Error('cannot add second video track to the conference'));\\n        }\\n    }\\n\\n    return this.replaceTrack(null, track);\\n};\\n\\n/**\\n * Fires TRACK_AUDIO_LEVEL_CHANGED change conference event (for local tracks).\\n * @param {number} audioLevel the audio level\\n * @param {TraceablePeerConnection} [tpc]\\n */\\nJitsiConference.prototype._fireAudioLevelChangeEvent = function (audioLevel, tpc) {\\n    var activeTpc = this.getActivePeerConnection();\\n\\n    // There will be no TraceablePeerConnection if audio levels do not come from\\n    // a peerconnection. LocalStatsCollector.js measures audio levels using Web\\n    // Audio Analyser API and emits local audio levels events through\\n    // JitsiTrack.setAudioLevel, but does not provide TPC instance which is\\n    // optional.\\n    if (!tpc || activeTpc === tpc) {\\n        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"TRACK_AUDIO_LEVEL_CHANGED\\\"], this.myUserId(), audioLevel);\\n    }\\n};\\n\\n/**\\n * Fires TRACK_MUTE_CHANGED change conference event.\\n * @param track the JitsiTrack object related to the event.\\n */\\nJitsiConference.prototype._fireMuteChangeEvent = function (track) {\\n    // check if track was muted by focus and now is unmuted by user\\n    if (this.isMutedByFocus && track.isAudioTrack() && !track.isMuted()) {\\n        this.isMutedByFocus = false;\\n\\n        // unmute local user on server\\n        this.room.muteParticipant(this.room.myroomjid, false);\\n    }\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"TRACK_MUTE_CHANGED\\\"], track);\\n};\\n\\n/**\\n * Clear JitsiLocalTrack properties and listeners.\\n * @param track the JitsiLocalTrack object.\\n */\\nJitsiConference.prototype.onLocalTrackRemoved = function (track) {\\n    track._setConference(null);\\n    this.rtc.removeLocalTrack(track);\\n    track.removeEventListener(__WEBPACK_IMPORTED_MODULE_16__JitsiTrackEvents__[\\\"TRACK_MUTE_CHANGED\\\"], track.muteHandler);\\n    track.removeEventListener(__WEBPACK_IMPORTED_MODULE_16__JitsiTrackEvents__[\\\"TRACK_AUDIO_LEVEL_CHANGED\\\"], track.audioLevelHandler);\\n\\n    // send event for stopping screen sharing\\n    // FIXME: we assume we have only one screen sharing track\\n    // if we change this we need to fix this check\\n    if (track.isVideoTrack() && track.videoType === __WEBPACK_IMPORTED_MODULE_27__service_RTC_VideoType___default.a.DESKTOP) {\\n        this.statistics.sendScreenSharingEvent(false);\\n    }\\n\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"TRACK_REMOVED\\\"], track);\\n};\\n\\n/**\\n * Removes JitsiLocalTrack from the conference and performs\\n * a new offer/answer cycle.\\n * @param {JitsiLocalTrack} track\\n * @returns {Promise}\\n */\\nJitsiConference.prototype.removeTrack = function (track) {\\n    return this.replaceTrack(track, null);\\n};\\n\\n/**\\n * Replaces oldTrack with newTrack and performs a single offer/answer\\n *  cycle after both operations are done.  Either oldTrack or newTrack\\n *  can be null; replacing a valid 'oldTrack' with a null 'newTrack'\\n *  effectively just removes 'oldTrack'\\n * @param {JitsiLocalTrack} oldTrack the current stream in use to be replaced\\n * @param {JitsiLocalTrack} newTrack the new stream to use\\n * @returns {Promise} resolves when the replacement is finished\\n */\\nJitsiConference.prototype.replaceTrack = function (oldTrack, newTrack) {\\n    var _this4 = this;\\n\\n    // First do the removal of the oldTrack at the JitsiConference level\\n    if (oldTrack) {\\n        if (oldTrack.disposed) {\\n            return Promise.reject(new __WEBPACK_IMPORTED_MODULE_14__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_15__JitsiTrackErrors__[\\\"TRACK_IS_DISPOSED\\\"]));\\n        }\\n    }\\n    if (newTrack) {\\n        if (newTrack.disposed) {\\n            return Promise.reject(new __WEBPACK_IMPORTED_MODULE_14__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_15__JitsiTrackErrors__[\\\"TRACK_IS_DISPOSED\\\"]));\\n        }\\n    }\\n\\n    // Now replace the stream at the lower levels\\n    return this._doReplaceTrack(oldTrack, newTrack).then(function () {\\n        if (oldTrack) {\\n            _this4.onLocalTrackRemoved(oldTrack);\\n        }\\n        if (newTrack) {\\n            // Now handle the addition of the newTrack at the\\n            // JitsiConference level\\n            _this4._setupNewTrack(newTrack);\\n        }\\n\\n        return Promise.resolve();\\n    }, function (error) {\\n        return Promise.reject(new Error(error));\\n    });\\n};\\n\\n/**\\n * Replaces the tracks at the lower level by going through the Jingle session\\n * and WebRTC peer connection. The method will resolve immediately if there is\\n * currently no JingleSession started.\\n * @param {JitsiLocalTrack|null} oldTrack the track to be removed during\\n * the process or <tt>null</t> if the method should act as \\\"add track\\\"\\n * @param {JitsiLocalTrack|null} newTrack the new track to be added or\\n * <tt>null</tt> if the method should act as \\\"remove track\\\"\\n * @return {Promise} resolved when the process is done or rejected with a string\\n * which describes the error.\\n * @private\\n */\\nJitsiConference.prototype._doReplaceTrack = function (oldTrack, newTrack) {\\n    var replaceTrackPromises = [];\\n\\n    if (this.jvbJingleSession) {\\n        replaceTrackPromises.push(this.jvbJingleSession.replaceTrack(oldTrack, newTrack));\\n    } else {\\n        logger.info('_doReplaceTrack - no JVB JingleSession');\\n    }\\n\\n    if (this.p2pJingleSession) {\\n        replaceTrackPromises.push(this.p2pJingleSession.replaceTrack(oldTrack, newTrack));\\n    } else {\\n        logger.info('_doReplaceTrack - no P2P JingleSession');\\n    }\\n\\n    return Promise.all(replaceTrackPromises);\\n};\\n\\n/**\\n * Operations related to creating a new track\\n * @param {JitsiLocalTrack} newTrack the new track being created\\n */\\nJitsiConference.prototype._setupNewTrack = function (newTrack) {\\n    if (newTrack.isAudioTrack() || newTrack.isVideoTrack() && newTrack.videoType !== __WEBPACK_IMPORTED_MODULE_27__service_RTC_VideoType___default.a.DESKTOP) {\\n        // Report active device to statistics\\n        var devices = __WEBPACK_IMPORTED_MODULE_21__modules_RTC_RTC__[\\\"a\\\" /* default */].getCurrentlyAvailableMediaDevices();\\n        var device = devices.find(function (d) {\\n            return d.kind === newTrack.getTrack().kind + 'input' && d.label === newTrack.getTrack().label;\\n        });\\n\\n        if (device) {\\n            __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].sendActiveDeviceListEvent(__WEBPACK_IMPORTED_MODULE_21__modules_RTC_RTC__[\\\"a\\\" /* default */].getEventDataForActiveDevice(device));\\n        }\\n    }\\n    if (newTrack.isVideoTrack()) {\\n        this.removeCommand('videoType');\\n        this.sendCommand('videoType', {\\n            value: newTrack.videoType,\\n            attributes: {\\n                xmlns: 'http://jitsi.org/jitmeet/video'\\n            }\\n        });\\n    }\\n    this.rtc.addLocalTrack(newTrack);\\n\\n    // ensure that we're sharing proper \\\"is muted\\\" state\\n    if (newTrack.isAudioTrack()) {\\n        this.room.setAudioMute(newTrack.isMuted());\\n    } else {\\n        this.room.setVideoMute(newTrack.isMuted());\\n    }\\n\\n    newTrack.muteHandler = this._fireMuteChangeEvent.bind(this, newTrack);\\n    newTrack.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this);\\n    newTrack.addEventListener(__WEBPACK_IMPORTED_MODULE_16__JitsiTrackEvents__[\\\"TRACK_MUTE_CHANGED\\\"], newTrack.muteHandler);\\n    newTrack.addEventListener(__WEBPACK_IMPORTED_MODULE_16__JitsiTrackEvents__[\\\"TRACK_AUDIO_LEVEL_CHANGED\\\"], newTrack.audioLevelHandler);\\n\\n    newTrack._setConference(this);\\n\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"TRACK_ADDED\\\"], newTrack);\\n};\\n\\n/**\\n * Method called by the {@link JitsiLocalTrack} (a video one) in order to add\\n * back the underlying WebRTC MediaStream to the PeerConnection (which has\\n * removed on video mute).\\n * @param {JitsiLocalTrack} track the local track that will be added as part of\\n * the unmute operation.\\n * @return {Promise} resolved when the process is done or rejected with a string\\n * which describes the error.\\n */\\nJitsiConference.prototype._addLocalTrackAsUnmute = function (track) {\\n    var addAsUnmutePromises = [];\\n\\n    if (this.jvbJingleSession) {\\n        addAsUnmutePromises.push(this.jvbJingleSession.addTrackAsUnmute(track));\\n    } else {\\n        logger.info('Add local MediaStream as unmute -' + ' no JVB Jingle session started yet');\\n    }\\n\\n    if (this.p2pJingleSession) {\\n        addAsUnmutePromises.push(this.p2pJingleSession.addTrackAsUnmute(track));\\n    } else {\\n        logger.info('Add local MediaStream as unmute -' + ' no P2P Jingle session started yet');\\n    }\\n\\n    return Promise.all(addAsUnmutePromises);\\n};\\n\\n/**\\n * Method called by the {@link JitsiLocalTrack} (a video one) in order to remove\\n * the underlying WebRTC MediaStream from the PeerConnection. The purpose of\\n * that is to stop sending any data and turn off the HW camera device.\\n * @param {JitsiLocalTrack} track the local track that will be removed.\\n * @return {Promise}\\n */\\nJitsiConference.prototype._removeLocalTrackAsMute = function (track) {\\n    var removeAsMutePromises = [];\\n\\n    if (this.jvbJingleSession) {\\n        removeAsMutePromises.push(this.jvbJingleSession.removeTrackAsMute(track));\\n    } else {\\n        logger.info('Remove local MediaStream - no JVB JingleSession started yet');\\n    }\\n    if (this.p2pJingleSession) {\\n        removeAsMutePromises.push(this.p2pJingleSession.removeTrackAsMute(track));\\n    } else {\\n        logger.info('Remove local MediaStream - no P2P JingleSession started yet');\\n    }\\n\\n    return Promise.all(removeAsMutePromises);\\n};\\n\\n/**\\n * Get role of the local user.\\n * @returns {string} user role: 'moderator' or 'none'\\n */\\nJitsiConference.prototype.getRole = function () {\\n    return this.room.role;\\n};\\n\\n/**\\n * Check if local user is moderator.\\n * @returns {boolean|null} true if local user is moderator, false otherwise. If\\n * we're no longer in the conference room then <tt>null</tt> is returned.\\n */\\nJitsiConference.prototype.isModerator = function () {\\n    return this.room ? this.room.isModerator() : null;\\n};\\n\\n/**\\n * Set password for the room.\\n * @param {string} password new password for the room.\\n * @returns {Promise}\\n */\\nJitsiConference.prototype.lock = function (password) {\\n    var _this5 = this;\\n\\n    if (!this.isModerator()) {\\n        return Promise.reject();\\n    }\\n\\n    return new Promise(function (resolve, reject) {\\n        _this5.room.lockRoom(password || '', function () {\\n            return resolve();\\n        }, function (err) {\\n            return reject(err);\\n        }, function () {\\n            return reject(__WEBPACK_IMPORTED_MODULE_9__JitsiConferenceErrors__[\\\"PASSWORD_NOT_SUPPORTED\\\"]);\\n        });\\n    });\\n};\\n\\n/**\\n * Remove password from the room.\\n * @returns {Promise}\\n */\\nJitsiConference.prototype.unlock = function () {\\n    return this.lock();\\n};\\n\\n/**\\n * Elects the participant with the given id to be the selected participant in\\n * order to receive higher video quality (if simulcast is enabled).\\n * Or cache it if channel is not created and send it once channel is available.\\n * @param participantId the identifier of the participant\\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\\n */\\nJitsiConference.prototype.selectParticipant = function (participantId) {\\n    this.rtc.selectEndpoint(participantId);\\n};\\n\\n/**\\n * Elects the participant with the given id to be the pinned participant in\\n * order to always receive video for this participant (even when last n is\\n * enabled).\\n * @param participantId the identifier of the participant\\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\\n */\\nJitsiConference.prototype.pinParticipant = function (participantId) {\\n    this.rtc.pinEndpoint(participantId);\\n};\\n\\n/**\\n * Obtains the current value for \\\"lastN\\\". See {@link setLastN} for more info.\\n * @returns {number}\\n */\\nJitsiConference.prototype.getLastN = function () {\\n    return this.rtc.getLastN();\\n};\\n\\n/**\\n * Selects a new value for \\\"lastN\\\". The requested amount of videos are going\\n * to be delivered after the value is in effect. Set to -1 for unlimited or\\n * all available videos.\\n * @param lastN the new number of videos the user would like to receive.\\n * @throws Error or RangeError if the given value is not a number or is smaller\\n * than -1.\\n */\\nJitsiConference.prototype.setLastN = function (lastN) {\\n    if (!Number.isInteger(lastN) && !Number.parseInt(lastN, 10)) {\\n        throw new Error('Invalid value for lastN: ' + lastN);\\n    }\\n    var n = Number(lastN);\\n\\n    if (n < -1) {\\n        throw new RangeError('lastN cannot be smaller than -1');\\n    }\\n    this.rtc.setLastN(n);\\n\\n    // If the P2P session is not fully established yet, we wait until it gets\\n    // established.\\n    if (this.p2pJingleSession) {\\n        var isVideoActive = n !== 0;\\n\\n        this.p2pJingleSession.setMediaTransferActive(true, isVideoActive).catch(function (error) {\\n            logger.error('Failed to adjust video transfer status (' + isVideoActive + ')', error);\\n        });\\n    }\\n};\\n\\n/**\\n * Checks if the participant given by participantId is currently included in\\n * the last N.\\n * @param {string} participantId the identifier of the participant we would\\n * like to check.\\n * @return {boolean} true if the participant with id is in the last N set or\\n * if there's no last N set, false otherwise.\\n * @deprecated this method should never be used to figure out the UI, but\\n * {@link ParticipantConnectionStatus} should be used instead.\\n */\\nJitsiConference.prototype.isInLastN = function (participantId) {\\n    return this.rtc.isInLastN(participantId);\\n};\\n\\n/**\\n * @return Array<JitsiParticipant> an array of all participants in this\\n * conference.\\n */\\nJitsiConference.prototype.getParticipants = function () {\\n    return Object.keys(this.participants).map(function (key) {\\n        return this.participants[key];\\n    }, this);\\n};\\n\\n/**\\n * Returns the number of participants in the conference, including the local\\n * participant.\\n * @param countHidden {boolean} Whether or not to include hidden participants\\n * in the count. Default: false.\\n **/\\nJitsiConference.prototype.getParticipantCount = function () {\\n    var countHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n\\n    var participants = this.getParticipants();\\n\\n    if (!countHidden) {\\n        participants = participants.filter(function (p) {\\n            return !p.isHidden();\\n        });\\n    }\\n\\n    // Add one for the local participant.\\n    return participants.length + 1;\\n};\\n\\n/**\\n * @returns {JitsiParticipant} the participant in this conference with the\\n * specified id (or undefined if there isn't one).\\n * @param id the id of the participant.\\n */\\nJitsiConference.prototype.getParticipantById = function (id) {\\n    return this.participants[id];\\n};\\n\\n/**\\n * Kick participant from this conference.\\n * @param {string} id id of the participant to kick\\n */\\nJitsiConference.prototype.kickParticipant = function (id) {\\n    var participant = this.getParticipantById(id);\\n\\n    if (!participant) {\\n        return;\\n    }\\n    this.room.kick(participant.getJid());\\n};\\n\\n/**\\n * Mutes a participant.\\n * @param {string} id The id of the participant to mute.\\n */\\nJitsiConference.prototype.muteParticipant = function (id) {\\n    var participant = this.getParticipantById(id);\\n\\n    if (!participant) {\\n        return;\\n    }\\n    this.room.muteParticipant(participant.getJid(), true);\\n};\\n\\n/* eslint-disable max-params */\\n\\n/**\\n * Notifies this JitsiConference that a new member has joined its chat room.\\n *\\n * FIXME This should NOT be exposed!\\n *\\n * @param jid the jid of the participant in the MUC\\n * @param nick the display name of the participant\\n * @param role the role of the participant in the MUC\\n * @param isHidden indicates if this is a hidden participant (system\\n * participant for example a recorder).\\n * @param statsID the participant statsID (optional)\\n * @param status the initial status if any\\n */\\nJitsiConference.prototype.onMemberJoined = function (jid, nick, role, isHidden, statsID, status) {\\n    var _this6 = this;\\n\\n    var id = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(jid);\\n\\n    if (id === 'focus' || this.myUserId() === id) {\\n        return;\\n    }\\n    var participant = new __WEBPACK_IMPORTED_MODULE_13__JitsiParticipant__[\\\"a\\\" /* default */](jid, this, nick, isHidden, statsID, status);\\n\\n    participant._role = role;\\n    this.participants[id] = participant;\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"USER_JOINED\\\"], id, participant);\\n    this.xmpp.caps.getFeatures(jid).then(function (features) {\\n        participant._supportsDTMF = features.has('urn:xmpp:jingle:dtmf:0');\\n        _this6.updateDTMFSupport();\\n    }, function (error) {\\n        return logger.error('Failed to discover features of ' + jid, error);\\n    });\\n\\n    this._maybeStartOrStopP2P();\\n};\\n\\n/* eslint-enable max-params */\\n\\nJitsiConference.prototype.onMemberLeft = function (jid) {\\n    var _this7 = this;\\n\\n    var id = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(jid);\\n\\n    if (id === 'focus' || this.myUserId() === id) {\\n        return;\\n    }\\n    var participant = this.participants[id];\\n\\n    delete this.participants[id];\\n\\n    var removedTracks = this.rtc.removeRemoteTracks(id);\\n\\n    removedTracks.forEach(function (track) {\\n        return _this7.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"TRACK_REMOVED\\\"], track);\\n    });\\n\\n    // there can be no participant in case the member that left is focus\\n    if (participant) {\\n        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"USER_LEFT\\\"], id, participant);\\n    }\\n\\n    this._maybeStartOrStopP2P(true /* triggered by user left event */);\\n};\\n\\n/**\\n * Method called on local MUC role change.\\n * @param {string} role the name of new user's role as defined by XMPP MUC.\\n */\\nJitsiConference.prototype.onLocalRoleChanged = function (role) {\\n    // Emit role changed for local  JID\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"USER_ROLE_CHANGED\\\"], this.myUserId(), role);\\n\\n    // Maybe start P2P\\n    this._maybeStartOrStopP2P();\\n};\\n\\nJitsiConference.prototype.onUserRoleChanged = function (jid, role) {\\n    var id = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(jid);\\n    var participant = this.getParticipantById(id);\\n\\n    if (!participant) {\\n        return;\\n    }\\n    participant._role = role;\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"USER_ROLE_CHANGED\\\"], id, role);\\n};\\n\\nJitsiConference.prototype.onDisplayNameChanged = function (jid, displayName) {\\n    var id = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(jid);\\n    var participant = this.getParticipantById(id);\\n\\n    if (!participant) {\\n        return;\\n    }\\n\\n    if (participant._displayName === displayName) {\\n        return;\\n    }\\n\\n    participant._displayName = displayName;\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"DISPLAY_NAME_CHANGED\\\"], id, displayName);\\n};\\n\\n/**\\n * Notifies this JitsiConference that a JitsiRemoteTrack was added into\\n * the conference.\\n *\\n * @param {JitsiRemoteTrack} track the JitsiRemoteTrack which was added to this\\n * JitsiConference\\n */\\nJitsiConference.prototype.onRemoteTrackAdded = function (track) {\\n    var _this8 = this;\\n\\n    if (track.isP2P && !this.isP2PActive()) {\\n        logger.info('Trying to add remote P2P track, when not in P2P - IGNORED');\\n\\n        return;\\n    } else if (!track.isP2P && this.isP2PActive()) {\\n        logger.info('Trying to add remote JVB track, when in P2P - IGNORED');\\n\\n        return;\\n    }\\n\\n    var id = track.getParticipantId();\\n    var participant = this.getParticipantById(id);\\n\\n    if (!participant) {\\n        logger.error('No participant found for id: ' + id);\\n\\n        return;\\n    }\\n\\n    // Add track to JitsiParticipant.\\n    participant._tracks.push(track);\\n\\n    if (this.transcriber) {\\n        this.transcriber.addTrack(track);\\n    }\\n\\n    var emitter = this.eventEmitter;\\n\\n    track.addEventListener(__WEBPACK_IMPORTED_MODULE_16__JitsiTrackEvents__[\\\"TRACK_MUTE_CHANGED\\\"], function () {\\n        return emitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"TRACK_MUTE_CHANGED\\\"], track);\\n    });\\n    track.addEventListener(__WEBPACK_IMPORTED_MODULE_16__JitsiTrackEvents__[\\\"TRACK_AUDIO_LEVEL_CHANGED\\\"], function (audioLevel, tpc) {\\n        var activeTPC = _this8.getActivePeerConnection();\\n\\n        if (activeTPC === tpc) {\\n            emitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"TRACK_AUDIO_LEVEL_CHANGED\\\"], id, audioLevel);\\n        }\\n    });\\n\\n    emitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"TRACK_ADDED\\\"], track);\\n};\\n\\n/**\\n * Callback called by the Jingle plugin when 'session-answer' is received.\\n * @param {JingleSessionPC} session the Jingle session for which an answer was\\n * received.\\n * @param {jQuery} answer a jQuery selector pointing to 'jingle' IQ element\\n */\\n// eslint-disable-next-line no-unused-vars\\nJitsiConference.prototype.onCallAccepted = function (session, answer) {\\n    if (this.p2pJingleSession === session) {\\n        logger.info('P2P setAnswer');\\n        this.p2pJingleSession.setAnswer(answer);\\n    }\\n};\\n\\n/**\\n * Callback called by the Jingle plugin when 'transport-info' is received.\\n * @param {JingleSessionPC} session the Jingle session for which the IQ was\\n * received\\n * @param {jQuery} transportInfo a jQuery selector pointing to 'jingle' IQ\\n * element\\n */\\n// eslint-disable-next-line no-unused-vars\\nJitsiConference.prototype.onTransportInfo = function (session, transportInfo) {\\n    if (this.p2pJingleSession === session) {\\n        logger.info('P2P addIceCandidates');\\n        this.p2pJingleSession.addIceCandidates(transportInfo);\\n    }\\n};\\n\\n/**\\n * Notifies this JitsiConference that a JitsiRemoteTrack was removed from\\n * the conference.\\n *\\n * @param {JitsiRemoteTrack} removedTrack\\n */\\nJitsiConference.prototype.onRemoteTrackRemoved = function (removedTrack) {\\n    var _this9 = this;\\n\\n    this.getParticipants().forEach(function (participant) {\\n        var tracks = participant.getTracks();\\n\\n        for (var i = 0; i < tracks.length; i++) {\\n            if (tracks[i] === removedTrack) {\\n                // Since the tracks have been compared and are\\n                // considered equal the result of splice can be ignored.\\n                participant._tracks.splice(i, 1);\\n\\n                _this9.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"TRACK_REMOVED\\\"], removedTrack);\\n\\n                if (_this9.transcriber) {\\n                    _this9.transcriber.removeTrack(removedTrack);\\n                }\\n\\n                break;\\n            }\\n        }\\n    }, this);\\n};\\n\\n/**\\n * Handles an incoming call event for the P2P jingle session.\\n */\\nJitsiConference.prototype._onIncomingCallP2P = function (jingleSession, jingleOffer) {\\n\\n    var rejectReason = void 0;\\n    var role = this.room.getMemberRole(jingleSession.remoteJid);\\n\\n    if (role !== 'moderator') {\\n        rejectReason = {\\n            reason: 'security-error',\\n            reasonDescription: 'Only focus can start new sessions',\\n            errorMsg: 'Rejecting session-initiate from non-focus and' + ('non-moderator user: ' + jingleSession.remoteJid)\\n        };\\n    } else if (!__WEBPACK_IMPORTED_MODULE_22__modules_RTC_RTCBrowserType__[\\\"a\\\" /* default */].isP2PSupported()) {\\n        rejectReason = {\\n            reason: 'unsupported-applications',\\n            reasonDescription: 'P2P not supported',\\n            errorMsg: 'This client does not support P2P connections'\\n        };\\n    } else if (!this.isP2PEnabled() && !this.isP2PTestModeEnabled()) {\\n        rejectReason = {\\n            reason: 'decline',\\n            reasonDescription: 'P2P disabled',\\n            errorMsg: 'P2P mode disabled in the configuration'\\n        };\\n    } else if (this.p2pJingleSession) {\\n        // Reject incoming P2P call (already in progress)\\n        rejectReason = {\\n            reason: 'busy',\\n            reasonDescription: 'P2P already in progress',\\n            errorMsg: 'Duplicated P2P \\\"session-initiate\\\"'\\n        };\\n    }\\n\\n    if (rejectReason) {\\n        this._rejectIncomingCall(jingleSession, rejectReason);\\n    } else {\\n        this._acceptP2PIncomingCall(jingleSession, jingleOffer);\\n    }\\n};\\n\\n/**\\n * Handles an incoming call event.\\n */\\nJitsiConference.prototype.onIncomingCall = function (jingleSession, jingleOffer, now) {\\n    // Handle incoming P2P call\\n    if (jingleSession.isP2P) {\\n        this._onIncomingCallP2P(jingleSession, jingleOffer);\\n    } else {\\n        if (!this.room.isFocus(jingleSession.remoteJid)) {\\n            var description = 'Rejecting session-initiate from non-focus.';\\n\\n            this._rejectIncomingCall(jingleSession, {\\n                reason: 'security-error',\\n                reasonDescription: description,\\n                errorMsg: description\\n            });\\n\\n            return;\\n        }\\n        this._acceptJvbIncomingCall(jingleSession, jingleOffer, now);\\n    }\\n};\\n\\n/**\\n * Accepts an incoming call event for the JVB jingle session.\\n */\\nJitsiConference.prototype._acceptJvbIncomingCall = function (jingleSession, jingleOffer, now) {\\n    var _this10 = this;\\n\\n    // Accept incoming call\\n    this.jvbJingleSession = jingleSession;\\n    this.room.connectionTimes['session.initiate'] = now;\\n\\n    // Log \\\"session.restart\\\"\\n    if (this.wasStopped) {\\n        __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].sendEventToAll(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"y\\\" /* SESSION_RESTART */]);\\n    }\\n\\n    __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"w\\\" /* SESSION_INITIATE */], {\\n        value: now - this.room.connectionTimes['muc.joined']\\n    });\\n    try {\\n        jingleSession.initialize(false /* initiator */, this.room, this.rtc);\\n    } catch (error) {\\n        __WEBPACK_IMPORTED_MODULE_6__modules_util_GlobalOnErrorHandler___default.a.callErrorHandler(error);\\n    }\\n\\n    // Open a channel with the videobridge.\\n    this._setBridgeChannel(jingleOffer, jingleSession.peerconnection);\\n\\n    // Add local tracks to the session\\n    try {\\n        jingleSession.acceptOffer(jingleOffer, function () {\\n            // If for any reason invite for the JVB session arrived after\\n            // the P2P has been established already the media transfer needs\\n            // to be turned off here.\\n            if (_this10.isP2PActive() && _this10.jvbJingleSession) {\\n                _this10._suspendMediaTransferForJvbConnection();\\n            }\\n        }, function (error) {\\n            __WEBPACK_IMPORTED_MODULE_6__modules_util_GlobalOnErrorHandler___default.a.callErrorHandler(error);\\n            logger.error('Failed to accept incoming Jingle session', error);\\n        }, this.getLocalTracks());\\n\\n        // Start callstats as soon as peerconnection is initialized,\\n        // do not wait for XMPPEvents.PEERCONNECTION_READY, as it may never\\n        // happen in case if user doesn't have or denied permission to\\n        // both camera and microphone.\\n        logger.info('Starting CallStats for JVB connection...');\\n        this.statistics.startCallStats(this.jvbJingleSession.peerconnection, 'jitsi' /* Remote user ID for JVB is 'jitsi' */);\\n        this.statistics.startRemoteStats(this.jvbJingleSession.peerconnection);\\n    } catch (e) {\\n        __WEBPACK_IMPORTED_MODULE_6__modules_util_GlobalOnErrorHandler___default.a.callErrorHandler(e);\\n        logger.error(e);\\n    }\\n};\\n\\n/**\\n * Sets the BridgeChannel.\\n *\\n * @param {jQuery} offerIq a jQuery selector pointing to the jingle element of\\n * the offer IQ which may carry the WebSocket URL for the 'websocket'\\n * BridgeChannel mode.\\n * @param {TraceablePeerConnection} pc the peer connection which will be used\\n * to listen for new WebRTC Data Channels (in the 'datachannel' mode).\\n */\\nJitsiConference.prototype._setBridgeChannel = function (offerIq, pc) {\\n    var wsUrl = null;\\n    var webSocket = $(offerIq).find('>content>transport>web-socket').first();\\n\\n    if (webSocket.length === 1) {\\n        wsUrl = webSocket[0].getAttribute('url');\\n    }\\n\\n    var bridgeChannelType = void 0;\\n\\n    switch (this.options.config.openBridgeChannel) {\\n        case 'datachannel':\\n        case true:\\n        case undefined:\\n            bridgeChannelType = 'datachannel';\\n            break;\\n        case 'websocket':\\n            bridgeChannelType = 'websocket';\\n            break;\\n    }\\n\\n    if (bridgeChannelType === 'datachannel' && !__WEBPACK_IMPORTED_MODULE_22__modules_RTC_RTCBrowserType__[\\\"a\\\" /* default */].supportsDataChannels()) {\\n        bridgeChannelType = 'websocket';\\n    }\\n\\n    if (bridgeChannelType === 'datachannel') {\\n        this.rtc.initializeBridgeChannel(pc, null);\\n    } else if (bridgeChannelType === 'websocket' && wsUrl) {\\n        this.rtc.initializeBridgeChannel(null, wsUrl);\\n    }\\n};\\n\\n/**\\n * Rejects incoming Jingle call.\\n * @param {JingleSessionPC} jingleSession the session instance to be rejected.\\n * @param {object} [options]\\n * @param {string} options.reason the name of the reason element as defined\\n * by Jingle\\n * @param {string} options.reasonDescription the reason description which will\\n * be included in Jingle 'session-terminate' message.\\n * @param {string} options.errorMsg an error message to be logged on global\\n * error handler\\n * @private\\n */\\nJitsiConference.prototype._rejectIncomingCall = function (jingleSession, options) {\\n    if (options && options.errorMsg) {\\n        __WEBPACK_IMPORTED_MODULE_6__modules_util_GlobalOnErrorHandler___default.a.callErrorHandler(new Error(options.errorMsg));\\n    }\\n\\n    // Terminate the jingle session with a reason\\n    jingleSession.terminate(null /* success callback => we don't care */\\n    , function (error) {\\n        logger.warn('An error occurred while trying to terminate' + ' invalid Jingle session', error);\\n    }, {\\n        reason: options && options.reason,\\n        reasonDescription: options && options.reasonDescription,\\n        sendSessionTerminate: true\\n    });\\n};\\n\\n/**\\n * Handles the call ended event.\\n * @param {JingleSessionPC} jingleSession the jingle session which has been\\n * terminated.\\n * @param {String} reasonCondition the Jingle reason condition.\\n * @param {String|null} reasonText human readable reason text which may provide\\n * more details about why the call has been terminated.\\n */\\nJitsiConference.prototype.onCallEnded = function (jingleSession, reasonCondition, reasonText) {\\n    logger.info('Call ended: ' + reasonCondition + ' - ' + reasonText + ' P2P ?' + jingleSession.isP2P);\\n    if (jingleSession === this.jvbJingleSession) {\\n        this.wasStopped = true;\\n\\n        __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].sendEventToAll(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"z\\\" /* SESSION_TERMINATE */]);\\n\\n        // Stop the stats\\n        if (this.statistics) {\\n            this.statistics.stopRemoteStats(this.jvbJingleSession.peerconnection);\\n            logger.info('Stopping JVB CallStats');\\n            this.statistics.stopCallStats(this.jvbJingleSession.peerconnection);\\n        }\\n\\n        // Current JVB JingleSession is no longer valid, so set it to null\\n        this.jvbJingleSession = null;\\n\\n        // Let the RTC service do any cleanups\\n        this.rtc.onCallEnded();\\n    } else if (jingleSession === this.p2pJingleSession) {\\n        // It's the responder who decides to enforce JVB mode, so that both\\n        // initiator and responder are aware if it was intentional.\\n        if (reasonCondition === 'decline' && reasonText === 'force JVB121') {\\n            logger.info('In forced JVB 121 mode...');\\n            __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.addPermanentProperties({ forceJvb121: true });\\n        } else if (reasonCondition === 'connectivity-error' && reasonText === 'ICE FAILED') {\\n            // It can happen that the other peer detects ICE failed and\\n            // terminates the session, before we get the event on our side.\\n            // But we are able to parse the reason and mark it here.\\n            __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.addPermanentProperties({ p2pFailed: true });\\n        }\\n        this._stopP2PSession();\\n    } else {\\n        logger.error('Received onCallEnded for invalid session', jingleSession.sid, jingleSession.remoteJid, reasonCondition, reasonText);\\n    }\\n};\\n\\n/**\\n * Handles the suspend detected event. Leaves the room and fires suspended.\\n * @param {JingleSessionPC} jingleSession\\n */\\nJitsiConference.prototype.onSuspendDetected = function (jingleSession) {\\n    if (!jingleSession.isP2P) {\\n        this.leave();\\n        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"SUSPEND_DETECTED\\\"]);\\n    }\\n};\\n\\nJitsiConference.prototype.updateDTMFSupport = function () {\\n    var somebodySupportsDTMF = false;\\n    var participants = this.getParticipants();\\n\\n    // check if at least 1 participant supports DTMF\\n    for (var i = 0; i < participants.length; i += 1) {\\n        if (participants[i].supportsDTMF()) {\\n            somebodySupportsDTMF = true;\\n            break;\\n        }\\n    }\\n    if (somebodySupportsDTMF !== this.somebodySupportsDTMF) {\\n        this.somebodySupportsDTMF = somebodySupportsDTMF;\\n        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"DTMF_SUPPORT_CHANGED\\\"], somebodySupportsDTMF);\\n    }\\n};\\n\\n/**\\n * Allows to check if there is at least one user in the conference\\n * that supports DTMF.\\n * @returns {boolean} true if somebody supports DTMF, false otherwise\\n */\\nJitsiConference.prototype.isDTMFSupported = function () {\\n    return this.somebodySupportsDTMF;\\n};\\n\\n/**\\n * Returns the local user's ID\\n * @return {string} local user's ID\\n */\\nJitsiConference.prototype.myUserId = function () {\\n    return this.room && this.room.myroomjid ? __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(this.room.myroomjid) : null;\\n};\\n\\nJitsiConference.prototype.sendTones = function (tones, duration, pause) {\\n    if (!this.dtmfManager) {\\n        var peerConnection = this.getActivePeerConnection();\\n\\n        if (!peerConnection) {\\n            logger.warn('cannot sendTones: no peer connection');\\n\\n            return;\\n        }\\n\\n        var localAudio = this.getLocalAudioTrack();\\n\\n        if (!localAudio) {\\n            logger.warn('cannot sendTones: no local audio stream');\\n\\n            return;\\n        }\\n        this.dtmfManager = new __WEBPACK_IMPORTED_MODULE_12__modules_DTMF_JitsiDTMFManager___default.a(localAudio, peerConnection);\\n    }\\n\\n    this.dtmfManager.sendTones(tones, duration, pause);\\n};\\n\\n/**\\n * Returns true if recording is supported and false if not.\\n */\\nJitsiConference.prototype.isRecordingSupported = function () {\\n    if (this.room) {\\n        return this.room.isRecordingSupported();\\n    }\\n\\n    return false;\\n};\\n\\n/**\\n * Returns null if the recording is not supported, \\\"on\\\" if the recording started\\n * and \\\"off\\\" if the recording is not started.\\n */\\nJitsiConference.prototype.getRecordingState = function () {\\n    return this.room ? this.room.getRecordingState() : undefined;\\n};\\n\\n/**\\n * Returns the url of the recorded video.\\n */\\nJitsiConference.prototype.getRecordingURL = function () {\\n    return this.room ? this.room.getRecordingURL() : null;\\n};\\n\\n/**\\n * Starts/stops the recording\\n */\\nJitsiConference.prototype.toggleRecording = function (options) {\\n    var _this11 = this;\\n\\n    if (this.room) {\\n        return this.room.toggleRecording(options, function (status, error) {\\n            _this11.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"RECORDER_STATE_CHANGED\\\"], status, error);\\n        });\\n    }\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"RECORDER_STATE_CHANGED\\\"], 'error', new Error('The conference is not created yet!'));\\n};\\n\\n/**\\n * Returns true if the SIP calls are supported and false otherwise\\n */\\nJitsiConference.prototype.isSIPCallingSupported = function () {\\n    if (this.room) {\\n        return this.room.isSIPCallingSupported();\\n    }\\n\\n    return false;\\n};\\n\\n/**\\n * Dials a number.\\n * @param number the number\\n */\\nJitsiConference.prototype.dial = function (number) {\\n    if (this.room) {\\n        return this.room.dial(number);\\n    }\\n\\n    return new Promise(function (resolve, reject) {\\n        reject(new Error('The conference is not created yet!'));\\n    });\\n};\\n\\n/**\\n * Hangup an existing call\\n */\\nJitsiConference.prototype.hangup = function () {\\n    if (this.room) {\\n        return this.room.hangup();\\n    }\\n\\n    return new Promise(function (resolve, reject) {\\n        reject(new Error('The conference is not created yet!'));\\n    });\\n};\\n\\n/**\\n * Starts the transcription service.\\n */\\nJitsiConference.prototype.startTranscriber = function () {\\n    return this.dial('jitsi_meet_transcribe');\\n};\\n\\n/**\\n * Stops the transcription service.\\n */\\nJitsiConference.prototype.stopTranscriber = JitsiConference.prototype.hangup;\\n\\n/**\\n * Returns the phone number for joining the conference.\\n */\\nJitsiConference.prototype.getPhoneNumber = function () {\\n    if (this.room) {\\n        return this.room.getPhoneNumber();\\n    }\\n\\n    return null;\\n};\\n\\n/**\\n * Returns the pin for joining the conference with phone.\\n */\\nJitsiConference.prototype.getPhonePin = function () {\\n    if (this.room) {\\n        return this.room.getPhonePin();\\n    }\\n\\n    return null;\\n};\\n\\n/**\\n * Will return P2P or JVB <tt>TraceablePeerConnection</tt> depending on\\n * which connection is currently active.\\n *\\n * @return {TraceablePeerConnection|null} null if there isn't any active\\n * <tt>TraceablePeerConnection</tt> currently available.\\n * @public (FIXME how to make package local ?)\\n */\\nJitsiConference.prototype.getActivePeerConnection = function () {\\n    if (this.isP2PActive()) {\\n        return this.p2pJingleSession.peerconnection;\\n    }\\n\\n    return this.jvbJingleSession ? this.jvbJingleSession.peerconnection : null;\\n};\\n\\n/**\\n * Returns the connection state for the current room. Its ice connection state\\n * for its session.\\n * NOTE that \\\"completed\\\" ICE state which can appear on the P2P connection will\\n * be converted to \\\"connected\\\".\\n * @return {string|null} ICE state name or <tt>null</tt> if there is no active\\n * peer connection at this time.\\n */\\nJitsiConference.prototype.getConnectionState = function () {\\n    var peerConnection = this.getActivePeerConnection();\\n\\n    return peerConnection ? peerConnection.getConnectionState() : null;\\n};\\n\\n/**\\n * Make all new participants mute their audio/video on join.\\n * @param policy {Object} object with 2 boolean properties for video and audio:\\n * @param {boolean} audio if audio should be muted.\\n * @param {boolean} video if video should be muted.\\n */\\nJitsiConference.prototype.setStartMutedPolicy = function (policy) {\\n    if (!this.isModerator()) {\\n        return;\\n    }\\n    this.startMutedPolicy = policy;\\n    this.room.removeFromPresence('startmuted');\\n    this.room.addToPresence('startmuted', {\\n        attributes: {\\n            audio: policy.audio,\\n            video: policy.video,\\n            xmlns: 'http://jitsi.org/jitmeet/start-muted'\\n        }\\n    });\\n    this.room.sendPresence();\\n};\\n\\n/**\\n * Returns current start muted policy\\n * @returns {Object} with 2 properties - audio and video.\\n */\\nJitsiConference.prototype.getStartMutedPolicy = function () {\\n    return this.startMutedPolicy;\\n};\\n\\n/**\\n * Check if audio is muted on join.\\n */\\nJitsiConference.prototype.isStartAudioMuted = function () {\\n    return this.startAudioMuted;\\n};\\n\\n/**\\n * Check if video is muted on join.\\n */\\nJitsiConference.prototype.isStartVideoMuted = function () {\\n    return this.startVideoMuted;\\n};\\n\\n/**\\n * Get object with internal logs.\\n */\\nJitsiConference.prototype.getLogs = function () {\\n    var data = this.xmpp.getJingleLog();\\n\\n    var metadata = {};\\n\\n    metadata.time = new Date();\\n    metadata.url = window.location.href;\\n    metadata.ua = navigator.userAgent;\\n\\n    var log = this.xmpp.getXmppLog();\\n\\n    if (log) {\\n        metadata.xmpp = log;\\n    }\\n\\n    data.metadata = metadata;\\n\\n    return data;\\n};\\n\\n/**\\n * Returns measured connectionTimes.\\n */\\nJitsiConference.prototype.getConnectionTimes = function () {\\n    return this.room.connectionTimes;\\n};\\n\\n/**\\n * Sets a property for the local participant.\\n */\\nJitsiConference.prototype.setLocalParticipantProperty = function (name, value) {\\n    this.sendCommand('jitsi_participant_' + name, { value: value });\\n};\\n\\n/**\\n * Sends the given feedback through CallStats if enabled.\\n *\\n * @param overallFeedback an integer between 1 and 5 indicating the\\n * user feedback\\n * @param detailedFeedback detailed feedback from the user. Not yet used\\n */\\nJitsiConference.prototype.sendFeedback = function (overallFeedback, detailedFeedback) {\\n    this.statistics.sendFeedback(overallFeedback, detailedFeedback);\\n};\\n\\n/**\\n * Returns true if the callstats integration is enabled, otherwise returns\\n * false.\\n *\\n * @returns true if the callstats integration is enabled, otherwise returns\\n * false.\\n */\\nJitsiConference.prototype.isCallstatsEnabled = function () {\\n    return this.statistics.isCallstatsEnabled();\\n};\\n\\n/**\\n * Handles track attached to container (Calls associateStreamWithVideoTag method\\n * from statistics module)\\n * @param {JitsiLocalTrack|JitsiRemoteTrack} track the track\\n * @param container the container\\n */\\nJitsiConference.prototype._onTrackAttach = function (track, container) {\\n    var isLocal = track.isLocal();\\n    var ssrc = null;\\n    var isP2P = track.isP2P;\\n    var remoteUserId = isP2P ? track.getParticipantId() : 'jitsi';\\n    var peerConnection = isP2P ? this.p2pJingleSession && this.p2pJingleSession.peerconnection : this.jvbJingleSession && this.jvbJingleSession.peerconnection;\\n\\n    if (isLocal) {\\n        // Local tracks have SSRC stored on per peer connection basis\\n        if (peerConnection) {\\n            ssrc = peerConnection.getLocalSSRC(track);\\n        }\\n    } else {\\n        ssrc = track.getSSRC();\\n    }\\n    if (!container.id || !ssrc || !peerConnection) {\\n        return;\\n    }\\n\\n    this.statistics.associateStreamWithVideoTag(peerConnection, ssrc, isLocal, remoteUserId, track.getUsageLabel(), container.id);\\n};\\n\\n/**\\n * Logs an \\\"application log\\\" message.\\n * @param message {string} The message to log. Note that while this can be a\\n * generic string, the convention used by lib-jitsi-meet and jitsi-meet is to\\n * log valid JSON strings, with an \\\"id\\\" field used for distinguishing between\\n * message types. E.g.: {id: \\\"recorder_status\\\", status: \\\"off\\\"}\\n */\\nJitsiConference.prototype.sendApplicationLog = function (message) {\\n    __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].sendLog(message);\\n};\\n\\n/**\\n * Checks if the user identified by given <tt>mucJid</tt> is the conference\\n * focus.\\n * @param mucJid the full MUC address of the user to be checked.\\n * @returns {boolean|null} <tt>true</tt> if MUC user is the conference focus,\\n * <tt>false</tt> when is not. <tt>null</tt> if we're not in the MUC anymore and\\n * are unable to figure out the status or if given <tt>mucJid</tt> is invalid.\\n */\\nJitsiConference.prototype._isFocus = function (mucJid) {\\n    return this.room ? this.room.isFocus(mucJid) : null;\\n};\\n\\n/**\\n * Fires CONFERENCE_FAILED event with INCOMPATIBLE_SERVER_VERSIONS parameter\\n */\\nJitsiConference.prototype._fireIncompatibleVersionsEvent = function () {\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_9__JitsiConferenceErrors__[\\\"INCOMPATIBLE_SERVER_VERSIONS\\\"]);\\n};\\n\\n/**\\n * Sends a message via the data channel.\\n * @param to {string} the id of the endpoint that should receive the message.\\n * If \\\"\\\" the message will be sent to all participants.\\n * @param payload {object} the payload of the message.\\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\\n */\\nJitsiConference.prototype.sendEndpointMessage = function (to, payload) {\\n    this.rtc.sendChannelMessage(to, payload);\\n};\\n\\n/**\\n * Sends a broadcast message via the data channel.\\n * @param payload {object} the payload of the message.\\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\\n */\\nJitsiConference.prototype.broadcastEndpointMessage = function (payload) {\\n    this.sendEndpointMessage('', payload);\\n};\\n\\nJitsiConference.prototype.isConnectionInterrupted = function () {\\n    return this.isP2PActive() ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted;\\n};\\n\\n/**\\n * Handles {@link XMPPEvents.CONNECTION_INTERRUPTED}\\n * @param {JingleSessionPC} session\\n * @private\\n */\\nJitsiConference.prototype._onIceConnectionInterrupted = function (session) {\\n    if (session.isP2P) {\\n        this.isP2PConnectionInterrupted = true;\\n    } else {\\n        this.isJvbConnectionInterrupted = true;\\n    }\\n    if (session.isP2P === this.isP2PActive()) {\\n        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"CONNECTION_INTERRUPTED\\\"]);\\n    }\\n};\\n\\n/**\\n * Handles {@link XMPPEvents.CONNECTION_ICE_FAILED}\\n * @param {JingleSessionPC} session\\n * @private\\n */\\nJitsiConference.prototype._onIceConnectionFailed = function (session) {\\n    // We do nothing for the JVB connection, because it's up to the Jicofo to\\n    // eventually come up with the new offer (at least for the time being).\\n    if (session.isP2P) {\\n        // Add p2pFailed property to analytics to distinguish, between \\\"good\\\"\\n        // and \\\"bad\\\" connection\\n        __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.addPermanentProperties({ p2pFailed: true });\\n\\n        // Log analytics event, but only for the initiator to not count it twice\\n        if (this.p2pJingleSession && this.p2pJingleSession.isInitiator) {\\n            __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].sendEventToAll(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"t\\\" /* P2P_FAILED */]);\\n        }\\n        this._stopP2PSession('connectivity-error', 'ICE FAILED');\\n    }\\n};\\n\\n/**\\n * Handles {@link XMPPEvents.CONNECTION_RESTORED}\\n * @param {JingleSessionPC} session\\n * @private\\n */\\nJitsiConference.prototype._onIceConnectionRestored = function (session) {\\n    if (session.isP2P) {\\n        this.isP2PConnectionInterrupted = false;\\n    } else {\\n        this.isJvbConnectionInterrupted = false;\\n    }\\n\\n    if (session.isP2P === this.isP2PActive()) {\\n        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"CONNECTION_RESTORED\\\"]);\\n    }\\n};\\n\\n/**\\n * Accept incoming P2P Jingle call.\\n * @param {JingleSessionPC} jingleSession the session instance\\n * @param {jQuery} jingleOffer a jQuery selector pointing to 'jingle' IQ element\\n * @private\\n */\\nJitsiConference.prototype._acceptP2PIncomingCall = function (jingleSession, jingleOffer) {\\n    this.isP2PConnectionInterrupted = false;\\n\\n    // Accept the offer\\n    this.p2pJingleSession = jingleSession;\\n\\n    this.p2pJingleSession.initialize(false /* initiator */, this.room, this.rtc);\\n\\n    logger.info('Starting CallStats for P2P connection...');\\n\\n    var remoteID = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(this.p2pJingleSession.remoteJid);\\n\\n    if (this.options.config.enableStatsID) {\\n        var participant = this.participants[remoteID];\\n\\n        if (participant) {\\n            remoteID = participant.getStatsID() || remoteID;\\n        }\\n    }\\n\\n    this.statistics.startCallStats(this.p2pJingleSession.peerconnection, remoteID);\\n\\n    var localTracks = this.getLocalTracks();\\n\\n    this.p2pJingleSession.acceptOffer(jingleOffer, function () {\\n        logger.debug('Got RESULT for P2P \\\"session-accept\\\"');\\n    }, function (error) {\\n        logger.error('Failed to accept incoming P2P Jingle session', error);\\n    }, localTracks);\\n};\\n\\n/**\\n * Adds remote tracks to the conference associated with the JVB session.\\n * @private\\n */\\nJitsiConference.prototype._addRemoteJVBTracks = function () {\\n    this._addRemoteTracks('JVB', this.jvbJingleSession.peerconnection.getRemoteTracks());\\n};\\n\\n/**\\n * Adds remote tracks to the conference associated with the P2P session.\\n * @private\\n */\\nJitsiConference.prototype._addRemoteP2PTracks = function () {\\n    this._addRemoteTracks('P2P', this.p2pJingleSession.peerconnection.getRemoteTracks());\\n};\\n\\n/**\\n * Generates fake \\\"remote track added\\\" events for given Jingle session.\\n * @param {string} logName the session's nickname which will appear in log\\n * messages.\\n * @param {Array<JitsiRemoteTrack>} remoteTracks the tracks that will be added\\n * @private\\n */\\nJitsiConference.prototype._addRemoteTracks = function (logName, remoteTracks) {\\n    var _iteratorNormalCompletion3 = true;\\n    var _didIteratorError3 = false;\\n    var _iteratorError3 = undefined;\\n\\n    try {\\n        for (var _iterator3 = remoteTracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n            var track = _step3.value;\\n\\n            logger.info('Adding remote ' + logName + ' track: ' + track);\\n            this.rtc.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_23__service_RTC_RTCEvents__[\\\"REMOTE_TRACK_ADDED\\\"], track);\\n        }\\n    } catch (err) {\\n        _didIteratorError3 = true;\\n        _iteratorError3 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                _iterator3.return();\\n            }\\n        } finally {\\n            if (_didIteratorError3) {\\n                throw _iteratorError3;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Called when {@link XMPPEvents.CONNECTION_ESTABLISHED} event is\\n * triggered for a {@link JingleSessionPC}. Switches the conference to use\\n * the P2P connection if the event comes from the P2P session.\\n * @param {JingleSessionPC} jingleSession the session instance.\\n * @private\\n */\\nJitsiConference.prototype._onIceConnectionEstablished = function (jingleSession) {\\n    if (this.p2pJingleSession !== null) {\\n        // store the establishment time of the p2p session as a field of the\\n        // JitsiConference because the p2pJingleSession might get disposed (thus\\n        // the value is lost).\\n        this.p2pEstablishmentDuration = this.p2pJingleSession.establishmentDuration;\\n    }\\n\\n    if (this.jvbJingleSession !== null) {\\n        this.jvbEstablishmentDuration = this.jvbJingleSession.establishmentDuration;\\n    }\\n\\n    var done = false;\\n    var forceJVB121Ratio = this.options.config.forceJVB121Ratio;\\n\\n    // We don't care about the JVB case, there's nothing to be done\\n    if (!jingleSession.isP2P) {\\n        done = true;\\n    } else if (this.p2pJingleSession !== jingleSession) {\\n        logger.error('CONNECTION_ESTABLISHED - wrong P2P session instance ?!');\\n\\n        done = true;\\n    } else if (!jingleSession.isInitiator && typeof forceJVB121Ratio === 'number' && Math.random() < forceJVB121Ratio) {\\n        logger.info('Forcing JVB 121 mode (ratio=' + forceJVB121Ratio + ')...');\\n        __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.addPermanentProperties({ forceJvb121: true });\\n        this._stopP2PSession('decline', 'force JVB121');\\n\\n        done = true;\\n    }\\n\\n    if (!isNaN(this.p2pEstablishmentDuration) && !isNaN(this.jvbEstablishmentDuration)) {\\n        var establishmentDurationDiff = this.p2pEstablishmentDuration - this.jvbEstablishmentDuration;\\n\\n        __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"q\\\" /* ICE_ESTABLISHMENT_DURATION_DIFF */], { 'value': establishmentDurationDiff });\\n    }\\n\\n    if (done) {\\n\\n        return;\\n    }\\n\\n    // Update P2P status and emit events\\n    this._setP2PStatus(true);\\n\\n    // Remove remote tracks\\n    if (this.jvbJingleSession) {\\n        this._removeRemoteJVBTracks();\\n    } else {\\n        logger.info('Not removing remote JVB tracks - no session yet');\\n    }\\n\\n    // Add remote tracks\\n    this._addRemoteP2PTracks();\\n\\n    // Stop media transfer over the JVB connection\\n    if (this.jvbJingleSession) {\\n        this._suspendMediaTransferForJvbConnection();\\n    }\\n\\n    // Start remote stats\\n    logger.info('Starting remote stats with p2p connection');\\n    this.statistics.startRemoteStats(this.p2pJingleSession.peerconnection);\\n\\n    // Log the P2P established event\\n    if (this.p2pJingleSession.isInitiator) {\\n        __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].sendEventToAll(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"s\\\" /* P2P_ESTABLISHED */]);\\n    }\\n};\\n\\n/**\\n * Clears the deferred start P2P task if it has been scheduled.\\n * @private\\n */\\nJitsiConference.prototype._maybeClearDeferredStartP2P = function () {\\n    if (this.deferredStartP2PTask) {\\n        logger.info('Cleared deferred start P2P task');\\n        clearTimeout(this.deferredStartP2PTask);\\n        this.deferredStartP2PTask = null;\\n    }\\n};\\n\\n/**\\n * Removes from the conference remote tracks associated with the JVB\\n * connection.\\n * @private\\n */\\nJitsiConference.prototype._removeRemoteJVBTracks = function () {\\n    this._removeRemoteTracks('JVB', this.jvbJingleSession.peerconnection.getRemoteTracks());\\n};\\n\\n/**\\n * Removes from the conference remote tracks associated with the P2P\\n * connection.\\n * @private\\n */\\nJitsiConference.prototype._removeRemoteP2PTracks = function () {\\n    this._removeRemoteTracks('P2P', this.p2pJingleSession.peerconnection.getRemoteTracks());\\n};\\n\\n/**\\n * Generates fake \\\"remote track removed\\\" events for given Jingle session.\\n * @param {string} sessionNickname the session's nickname which will appear in\\n * log messages.\\n * @param {Array<JitsiRemoteTrack>} remoteTracks the tracks that will be removed\\n * @private\\n */\\nJitsiConference.prototype._removeRemoteTracks = function (sessionNickname, remoteTracks) {\\n    var _iteratorNormalCompletion4 = true;\\n    var _didIteratorError4 = false;\\n    var _iteratorError4 = undefined;\\n\\n    try {\\n        for (var _iterator4 = remoteTracks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n            var track = _step4.value;\\n\\n            logger.info('Removing remote ' + sessionNickname + ' track: ' + track);\\n            this.rtc.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_23__service_RTC_RTCEvents__[\\\"REMOTE_TRACK_REMOVED\\\"], track);\\n        }\\n    } catch (err) {\\n        _didIteratorError4 = true;\\n        _iteratorError4 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n                _iterator4.return();\\n            }\\n        } finally {\\n            if (_didIteratorError4) {\\n                throw _iteratorError4;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Resumes media transfer over the JVB connection.\\n * @private\\n */\\nJitsiConference.prototype._resumeMediaTransferForJvbConnection = function () {\\n    logger.info('Resuming media transfer over the JVB connection...');\\n    this.jvbJingleSession.setMediaTransferActive(true, true).then(function () {\\n        logger.info('Resumed media transfer over the JVB connection!');\\n    }, function (error) {\\n        logger.error('Failed to resume media transfer over the JVB connection:', error);\\n    });\\n};\\n\\n/**\\n * Sets new P2P status and updates some events/states hijacked from\\n * the <tt>JitsiConference</tt>.\\n * @param {boolean} newStatus the new P2P status value, <tt>true</tt> means that\\n * P2P is now in use, <tt>false</tt> means that the JVB connection is now in use\\n * @private\\n */\\nJitsiConference.prototype._setP2PStatus = function (newStatus) {\\n    if (this.p2p === newStatus) {\\n        logger.debug('Called _setP2PStatus with the same status: ' + newStatus);\\n\\n        return;\\n    }\\n    this.p2p = newStatus;\\n    if (newStatus) {\\n        logger.info('Peer to peer connection established!');\\n\\n        // When we end up in a valid P2P session need to reset the properties\\n        // in case they have persisted, after session with another peer.\\n        __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.addPermanentProperties({\\n            p2pFailed: false,\\n            forceJvb121: false\\n        });\\n\\n        // Sync up video transfer active in case p2pJingleSession not existed\\n        // when the lastN value was being adjusted.\\n        var isVideoActive = this.rtc.getLastN() !== 0;\\n\\n        this.p2pJingleSession.setMediaTransferActive(true, isVideoActive).catch(function (error) {\\n            logger.error('Failed to sync up P2P video transfer status' + ('(' + isVideoActive + ')'), error);\\n        });\\n    } else {\\n        logger.info('Peer to peer connection closed!');\\n    }\\n\\n    // Put the JVB connection on hold/resume\\n    if (this.jvbJingleSession) {\\n        this.statistics.sendConnectionResumeOrHoldEvent(this.jvbJingleSession.peerconnection, !newStatus);\\n    }\\n\\n    // Clear dtmfManager, so that it can be recreated with new connection\\n    this.dtmfManager = null;\\n\\n    // Update P2P status\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"P2P_STATUS\\\"], this, this.p2p);\\n\\n    // Refresh connection interrupted/restored\\n    this.eventEmitter.emit(this.isConnectionInterrupted() ? __WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"CONNECTION_INTERRUPTED\\\"] : __WEBPACK_IMPORTED_MODULE_11__JitsiConferenceEvents__[\\\"CONNECTION_RESTORED\\\"]);\\n};\\n\\n/**\\n * Starts new P2P session.\\n * @param {string} remoteJid the JID of the remote participant\\n * @private\\n */\\nJitsiConference.prototype._startP2PSession = function (remoteJid) {\\n    this._maybeClearDeferredStartP2P();\\n    if (this.p2pJingleSession) {\\n        logger.error('P2P session already started!');\\n\\n        return;\\n    }\\n\\n    this.isP2PConnectionInterrupted = false;\\n    this.p2pJingleSession = this.xmpp.connection.jingle.newP2PJingleSession(this.room.myroomjid, remoteJid);\\n    logger.info('Created new P2P JingleSession', this.room.myroomjid, remoteJid);\\n\\n    this.p2pJingleSession.initialize(true /* initiator */, this.room, this.rtc);\\n\\n    logger.info('Starting CallStats for P2P connection...');\\n\\n    var remoteID = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(this.p2pJingleSession.remoteJid);\\n\\n    if (this.options.config.enableStatsID) {\\n        var participant = this.participants[remoteID];\\n\\n        if (participant) {\\n            remoteID = participant.getStatsID() || remoteID;\\n        }\\n    }\\n\\n    this.statistics.startCallStats(this.p2pJingleSession.peerconnection, remoteID);\\n\\n    // NOTE one may consider to start P2P with the local tracks detached,\\n    // but no data will be sent until ICE succeeds anyway. And we switch\\n    // immediately once the P2P ICE connects.\\n    var localTracks = this.getLocalTracks();\\n\\n    this.p2pJingleSession.invite(localTracks);\\n};\\n\\n/**\\n * Suspends media transfer over the JVB connection.\\n * @private\\n */\\nJitsiConference.prototype._suspendMediaTransferForJvbConnection = function () {\\n    logger.info('Suspending media transfer over the JVB connection...');\\n    this.jvbJingleSession.setMediaTransferActive(false, false).then(function () {\\n        logger.info('Suspended media transfer over the JVB connection !');\\n    }, function (error) {\\n        logger.error('Failed to suspend media transfer over the JVB connection:', error);\\n    });\\n};\\n\\n/**\\n * Method when called will decide whether it's the time to start or stop\\n * the P2P session.\\n * @param {boolean} userLeftEvent if <tt>true</tt> it means that the call\\n * originates from the user left event.\\n * @private\\n */\\nJitsiConference.prototype._maybeStartOrStopP2P = function (userLeftEvent) {\\n    if (!__WEBPACK_IMPORTED_MODULE_22__modules_RTC_RTCBrowserType__[\\\"a\\\" /* default */].isP2PSupported() || !this.isP2PEnabled() || this.isP2PTestModeEnabled()) {\\n        logger.info('Auto P2P disabled');\\n\\n        return;\\n    }\\n    var peers = this.getParticipants();\\n    var peerCount = peers.length;\\n    var isModerator = this.isModerator();\\n\\n    // FIXME 1 peer and it must *support* P2P switching\\n    var shouldBeInP2P = peerCount === 1;\\n\\n    logger.debug('P2P? isModerator: ' + isModerator + ', peerCount: ' + peerCount + ' => ' + shouldBeInP2P);\\n\\n    // Clear deferred \\\"start P2P\\\" task\\n    if (!shouldBeInP2P && this.deferredStartP2PTask) {\\n        this._maybeClearDeferredStartP2P();\\n    }\\n\\n    // Start peer to peer session\\n    if (isModerator && !this.p2pJingleSession && shouldBeInP2P) {\\n        var peer = peerCount && peers[0];\\n\\n        // Everyone is a moderator ?\\n        if (isModerator && peer.getRole() === 'moderator') {\\n            var myId = this.myUserId();\\n            var peersId = peer.getId();\\n\\n            if (myId > peersId) {\\n                logger.debug('Everyone\\\\'s a moderator - ' + 'the other peer should start P2P', myId, peersId);\\n\\n                return;\\n            } else if (myId === peersId) {\\n                logger.error('The same IDs ? ', myId, peersId);\\n\\n                return;\\n            }\\n        }\\n        var jid = peer.getJid();\\n\\n        if (userLeftEvent) {\\n            if (this.deferredStartP2PTask) {\\n                logger.error('Deferred start P2P task\\\\'s been set already!');\\n\\n                return;\\n            }\\n            logger.info('Will start P2P with: ' + jid + ' after ' + this.backToP2PDelay + ' seconds...');\\n            this.deferredStartP2PTask = setTimeout(this._startP2PSession.bind(this, jid), this.backToP2PDelay * 1000);\\n        } else {\\n            logger.info('Will start P2P with: ' + jid);\\n            this._startP2PSession(jid);\\n        }\\n    } else if (this.p2pJingleSession && !shouldBeInP2P) {\\n        logger.info('Will stop P2P with: ' + this.p2pJingleSession.remoteJid);\\n\\n        // Log that there will be a switch back to the JVB connection\\n        if (this.p2pJingleSession.isInitiator && peerCount > 1) {\\n            __WEBPACK_IMPORTED_MODULE_24__modules_statistics_statistics__[\\\"a\\\" /* default */].sendEventToAll(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"u\\\" /* P2P_SWITCH_TO_JVB */]);\\n        }\\n        this._stopP2PSession();\\n    }\\n};\\n\\n/**\\n * Stops the current P2P session.\\n * @param {string} [reason=\\\"success\\\"] one of the Jingle \\\"reason\\\" element\\n * names as defined by https://xmpp.org/extensions/xep-0166.html#def-reason\\n * @param {string} [reasonDescription=\\\"Turing off P2P session\\\"] text\\n * description that will be included in the session terminate message\\n * @private\\n */\\nJitsiConference.prototype._stopP2PSession = function (reason, reasonDescription) {\\n    if (!this.p2pJingleSession) {\\n        logger.error('No P2P session to be stopped!');\\n\\n        return;\\n    }\\n\\n    var wasP2PEstablished = this.isP2PActive();\\n\\n    // Swap remote tracks, but only if the P2P has been fully established\\n    if (wasP2PEstablished) {\\n        if (this.jvbJingleSession) {\\n            this._resumeMediaTransferForJvbConnection();\\n        }\\n\\n        // Remove remote P2P tracks\\n        this._removeRemoteP2PTracks();\\n    }\\n\\n    // Stop P2P stats\\n    logger.info('Stopping remote stats for P2P connection');\\n    this.statistics.stopRemoteStats(this.p2pJingleSession.peerconnection);\\n    logger.info('Stopping CallStats for P2P connection');\\n    this.statistics.stopCallStats(this.p2pJingleSession.peerconnection);\\n\\n    this.p2pJingleSession.terminate(function () {\\n        logger.info('P2P session terminate RESULT');\\n    }, function (error) {\\n        // Because both initiator and responder are simultaneously\\n        // terminating their JingleSessions in case of the 'to JVB switch'\\n        // when 3rd participant joins, both will dispose their sessions and\\n        // reply with 'item-not-found' (see strophe.jingle.js). We don't\\n        // want to log this as an error since it's expected behaviour.\\n        //\\n        // We want them both to terminate, because in case of initiator's\\n        // crash the responder would stay in P2P mode until ICE fails which\\n        // could take up to 20 seconds.\\n        //\\n        // NOTE lack of 'reason' is considered as graceful session terminate\\n        // where both initiator and responder terminate their sessions\\n        // simultaneously.\\n        if (reason) {\\n            logger.error('An error occurred while trying to terminate' + ' P2P Jingle session', error);\\n        }\\n    }, {\\n        reason: reason ? reason : 'success',\\n        reasonDescription: reasonDescription ? reasonDescription : 'Turing off P2P session',\\n        sendSessionTerminate: this.room && this.getParticipantById(__WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(this.p2pJingleSession.remoteJid))\\n    });\\n\\n    this.p2pJingleSession = null;\\n\\n    // Update P2P status and other affected events/states\\n    this._setP2PStatus(false);\\n\\n    if (wasP2PEstablished) {\\n        // Add back remote JVB tracks\\n        if (this.jvbJingleSession) {\\n            this._addRemoteJVBTracks();\\n        } else {\\n            logger.info('Not adding remote JVB tracks - no session yet');\\n        }\\n    }\\n};\\n\\n/**\\n * Checks whether or not the conference is currently in the peer to peer mode.\\n * Being in peer to peer mode means that the direct connection has been\\n * established and the P2P connection is being used for media transmission.\\n * @return {boolean} <tt>true</tt> if in P2P mode or <tt>false</tt> otherwise.\\n */\\nJitsiConference.prototype.isP2PActive = function () {\\n    return this.p2p;\\n};\\n\\n/**\\n * Returns the current ICE state of the P2P connection.\\n * NOTE: method is used by the jitsi-meet-torture tests.\\n * @return {string|null} an ICE state or <tt>null</tt> if there's currently\\n * no P2P connection.\\n */\\nJitsiConference.prototype.getP2PConnectionState = function () {\\n    if (this.isP2PActive()) {\\n        return this.p2pJingleSession.peerconnection.getConnectionState();\\n    }\\n\\n    return null;\\n};\\n\\n/**\\n * Manually starts new P2P session (should be used only in the tests).\\n */\\nJitsiConference.prototype.startP2PSession = function () {\\n    var peers = this.getParticipants();\\n\\n    // Start peer to peer session\\n    if (peers.length === 1) {\\n        var peerJid = peers[0].getJid();\\n\\n        this._startP2PSession(peerJid);\\n    } else {\\n        throw new Error('There must be exactly 1 participant to start the P2P session !');\\n    }\\n};\\n\\n/**\\n * Manually stops the current P2P session (should be used only in the tests)\\n */\\nJitsiConference.prototype.stopP2PSession = function () {\\n    this._stopP2PSession();\\n};\\n\\n/**\\n * Get a summary of how long current participants have been the dominant speaker\\n * @returns {object}\\n */\\nJitsiConference.prototype.getSpeakerStats = function () {\\n    return this.speakerStatsCollector.getStats();\\n};\\n\\n/**\\n * Sets the maximum video size the local participant should receive from remote\\n * participants.\\n *\\n * @param {number} maxFrameHeightPixels the maximum frame height, in pixels,\\n * this receiver is willing to receive.\\n * @returns {void}\\n */\\nJitsiConference.prototype.setReceiverVideoConstraint = function (maxFrameHeight) {\\n    this.rtc.setReceiverVideoConstraint(maxFrameHeight);\\n};\\n\\n/**\\n * Creates a video SIP GW session and returns it if service is enabled. Before\\n * creating a session one need to check whether video SIP GW service is\\n * available in the system {@link JitsiConference.isVideoSIPGWAvailable}. Even\\n * if there are available nodes to serve this request, after creating the\\n * session those nodes can be taken and the request about using the\\n * created session can fail.\\n *\\n * @param {string} sipAddress - The sip address to be used.\\n * @param {string} displayName - The display name to be used for this session.\\n * @returns {JitsiVideoSIPGWSession|Error} Returns null if conference is not\\n * initialised and there is no room.\\n */\\nJitsiConference.prototype.createVideoSIPGWSession = function (sipAddress, displayName) {\\n    if (!this.room) {\\n        return new Error(__WEBPACK_IMPORTED_MODULE_29__modules_videosipgw_VideoSIPGWConstants__[\\\"ERROR_NO_CONNECTION\\\"]);\\n    }\\n\\n    return this.videoSIPGWHandler.createVideoSIPGWSession(sipAddress, displayName);\\n};\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"JitsiConference.js\\\"))\\n\\n/***/ }),\\n/* 65 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__service_connectivity_ConnectionQualityEvents__ = __webpack_require__(31);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__JitsiConferenceEvents__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__statistics__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType__ = __webpack_require__(13);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/* global __filename */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * This will calculate an average for one, named stat and submit it to\\n * the analytics module when requested. It automatically counts the samples.\\n */\\n\\nvar AverageStatReport = function () {\\n    /**\\n     * Creates new <tt>AverageStatReport</tt> for given name.\\n     * @param {string} name that's the name of the event that will be reported\\n     * to the analytics module.\\n     */\\n    function AverageStatReport(name) {\\n        _classCallCheck(this, AverageStatReport);\\n\\n        this.name = name;\\n        this.count = 0;\\n        this.sum = 0;\\n        this.samples = [];\\n    }\\n\\n    /**\\n     * Adds the next value that will be included in the average when\\n     * {@link calculate} is called.\\n     * @param {number} nextValue\\n     */\\n\\n\\n    _createClass(AverageStatReport, [{\\n        key: 'addNext',\\n        value: function addNext(nextValue) {\\n            if (typeof nextValue !== 'number') {\\n                logger.error(this.name + ' - invalid value for idx: ' + this.count, nextValue);\\n            } else if (!isNaN(nextValue)) {\\n                this.sum += nextValue;\\n                this.samples.push(nextValue);\\n                this.count += 1;\\n            }\\n        }\\n\\n        /**\\n         * Calculates an average for the samples collected using {@link addNext}.\\n         * @return {number|NaN} an average of all collected samples or <tt>NaN</tt>\\n         * if no samples were collected.\\n         */\\n\\n    }, {\\n        key: 'calculate',\\n        value: function calculate() {\\n            return this.sum / this.count;\\n        }\\n\\n        /**\\n         * Appends the report to the analytics \\\"data\\\" object. The object will be\\n         * set under <tt>prefix</tt> + {@link this.name} key.\\n         * @param {Object} report the analytics \\\"data\\\" object\\n         */\\n\\n    }, {\\n        key: 'appendReport',\\n        value: function appendReport(report) {\\n            report[this.name] = {\\n                value: this.calculate(),\\n                samples: this.samples\\n            };\\n        }\\n\\n        /**\\n         * Clears all memory of any samples collected, so that new average can be\\n         * calculated using this instance.\\n         */\\n\\n    }, {\\n        key: 'reset',\\n        value: function reset() {\\n            this.samples = [];\\n            this.sum = 0;\\n            this.count = 0;\\n        }\\n    }]);\\n\\n    return AverageStatReport;\\n}();\\n\\n/**\\n * Class gathers the stats that are calculated and reported for a\\n * {@link TraceablePeerConnection} even if it's not currently active. For\\n * example we want to monitor RTT for the JVB connection while in P2P mode.\\n */\\n\\n\\nvar ConnectionAvgStats = function () {\\n    /**\\n     * Creates new <tt>ConnectionAvgStats</tt>\\n     * @param {AvgRTPStatsReporter} avgRtpStatsReporter\\n     * @param {boolean} isP2P\\n     * @param {number} n the number of samples, before arithmetic mean is to be\\n     * calculated and values submitted to the analytics module.\\n     */\\n    function ConnectionAvgStats(avgRtpStatsReporter, isP2P, n) {\\n        var _this = this;\\n\\n        _classCallCheck(this, ConnectionAvgStats);\\n\\n        /**\\n         * Is this instance for JVB or P2P connection ?\\n         * @type {boolean}\\n         */\\n        this.isP2P = isP2P;\\n\\n        /**\\n         * How many samples are to be included in arithmetic mean calculation.\\n         * @type {number}\\n         * @private\\n         */\\n        this._n = n;\\n\\n        /**\\n         * The current sample index. Starts from 0 and goes up to {@link _n})\\n         * when analytics report will be submitted.\\n         * @type {number}\\n         * @private\\n         */\\n        this._sampleIdx = 0;\\n\\n        /**\\n         * Average round trip time reported by the ICE candidate pair.\\n         * @type {AverageStatReport}\\n         */\\n        this._avgRTT = new AverageStatReport('stat_avg_rtt');\\n\\n        /**\\n         * Map stores average RTT to the JVB reported by remote participants.\\n         * Mapped per participant id {@link JitsiParticipant.getId}.\\n         *\\n         * This is used only when {@link ConnectionAvgStats.isP2P} equals to\\n         * <tt>false</tt>.\\n         *\\n         * @type {Map<string,AverageStatReport>}\\n         * @private\\n         */\\n        this._avgRemoteRTTMap = new Map();\\n\\n        /**\\n         * The conference for which stats will be collected and reported.\\n         * @type {JitsiConference}\\n         * @private\\n         */\\n        this._avgRtpStatsReporter = avgRtpStatsReporter;\\n\\n        /**\\n         * The latest average E2E RTT for the JVB connection only.\\n         *\\n         * This is used only when {@link ConnectionAvgStats.isP2P} equals to\\n         * <tt>false</tt>.\\n         *\\n         * @type {number}\\n         */\\n        this._avgEnd2EndRTT = undefined;\\n\\n        this._onConnectionStats = function (tpc, stats) {\\n            if (_this.isP2P === tpc.isP2P) {\\n                _this._calculateAvgStats(stats);\\n            }\\n        };\\n\\n        var conference = avgRtpStatsReporter._conference;\\n\\n        conference.statistics.addConnectionStatsListener(this._onConnectionStats);\\n\\n        if (!this.isP2P) {\\n            this._onUserLeft = function (id) {\\n                return _this._avgRemoteRTTMap.delete(id);\\n            };\\n            conference.on(__WEBPACK_IMPORTED_MODULE_3__JitsiConferenceEvents__[\\\"USER_LEFT\\\"], this._onUserLeft);\\n\\n            this._onRemoteStatsUpdated = function (id, data) {\\n                return _this._processRemoteStats(id, data);\\n            };\\n            conference.on(__WEBPACK_IMPORTED_MODULE_2__service_connectivity_ConnectionQualityEvents__[\\\"REMOTE_STATS_UPDATED\\\"], this._onRemoteStatsUpdated);\\n        }\\n    }\\n\\n    /**\\n     * Processes next batch of stats.\\n     * @param {go figure} data\\n     * @private\\n     */\\n\\n\\n    _createClass(ConnectionAvgStats, [{\\n        key: '_calculateAvgStats',\\n        value: function _calculateAvgStats(data) {\\n            if (!data) {\\n                logger.error('No stats');\\n\\n                return;\\n            }\\n\\n            if (__WEBPACK_IMPORTED_MODULE_5__RTC_RTCBrowserType__[\\\"a\\\" /* default */].supportsRTTStatistics()) {\\n                if (data.transport && data.transport.length) {\\n                    this._avgRTT.addNext(data.transport[0].rtt);\\n                }\\n            }\\n\\n            this._sampleIdx += 1;\\n\\n            if (this._sampleIdx >= this._n) {\\n                if (__WEBPACK_IMPORTED_MODULE_5__RTC_RTCBrowserType__[\\\"a\\\" /* default */].supportsRTTStatistics()) {\\n                    var conference = this._avgRtpStatsReporter._conference;\\n\\n                    var batchReport = {\\n                        p2p: this.isP2P,\\n                        size: conference.getParticipantCount()\\n                    };\\n\\n                    if (data.transport && data.transport.length) {\\n                        Object.assign(batchReport, {\\n                            localCandidateType: data.transport[0].localCandidateType,\\n                            remoteCandidateType: data.transport[0].remoteCandidateType,\\n                            transportType: data.transport[0].type\\n                        });\\n                    }\\n\\n                    this._avgRTT.appendReport(batchReport);\\n\\n                    if (this.isP2P) {\\n                        // Report RTT diff only for P2P.\\n                        var jvbEnd2EndRTT = this._avgRtpStatsReporter.jvbStatsMonitor._avgEnd2EndRTT;\\n\\n                        if (!isNaN(jvbEnd2EndRTT)) {\\n                            var avgRTTDiff = this._avgRTT.calculate() - jvbEnd2EndRTT;\\n\\n                            // eslint-disable-next-line dot-notation\\n                            batchReport['stat_avg_rtt_diff'] = {\\n                                value: avgRTTDiff\\n                            };\\n                        }\\n                    } else {\\n                        // Report end to end RTT only for JVB.\\n                        var avgRemoteRTT = this._calculateAvgRemoteRTT();\\n                        var avgLocalRTT = this._avgRTT.calculate();\\n\\n                        this._avgEnd2EndRTT = avgLocalRTT + avgRemoteRTT;\\n\\n                        if (!isNaN(avgLocalRTT) && !isNaN(avgRemoteRTT)) {\\n                            // eslint-disable-next-line dot-notation\\n                            batchReport['stat_avg_end2endrtt'] = {\\n                                value: this._avgEnd2EndRTT\\n                            };\\n                        }\\n                    }\\n\\n                    __WEBPACK_IMPORTED_MODULE_6__statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"a\\\" /* AVG_RTP_STATS */], batchReport);\\n                }\\n\\n                this._resetAvgStats();\\n            }\\n        }\\n\\n        /**\\n         * Calculates arithmetic mean of all RTTs towards the JVB reported by\\n         * participants.\\n         * @return {number|NaN} NaN if not available (not enough data)\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_calculateAvgRemoteRTT',\\n        value: function _calculateAvgRemoteRTT() {\\n            var count = 0,\\n                sum = 0;\\n\\n            // FIXME should we ignore RTT for participant\\n            // who \\\"is having connectivity issues\\\" ?\\n            var _iteratorNormalCompletion = true;\\n            var _didIteratorError = false;\\n            var _iteratorError = undefined;\\n\\n            try {\\n                for (var _iterator = this._avgRemoteRTTMap.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                    var remoteAvg = _step.value;\\n\\n                    var avg = remoteAvg.calculate();\\n\\n                    if (!isNaN(avg)) {\\n                        sum += avg;\\n                        count += 1;\\n                        remoteAvg.reset();\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError = true;\\n                _iteratorError = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion && _iterator.return) {\\n                        _iterator.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError) {\\n                        throw _iteratorError;\\n                    }\\n                }\\n            }\\n\\n            return sum / count;\\n        }\\n\\n        /**\\n         * Processes {@link ConnectionQualityEvents.REMOTE_STATS_UPDATED} to analyse\\n         * RTT towards the JVB reported by each participant.\\n         * @param {string} id {@link JitsiParticipant.getId}\\n         * @param {go figure in ConnectionQuality.js} data\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_processRemoteStats',\\n        value: function _processRemoteStats(id, data) {\\n            var validData = typeof data.jvbRTT === 'number';\\n            var rttAvg = this._avgRemoteRTTMap.get(id);\\n\\n            if (!rttAvg && validData) {\\n                rttAvg = new AverageStatReport(id + '_stat_rtt');\\n                this._avgRemoteRTTMap.set(id, rttAvg);\\n            }\\n\\n            if (validData) {\\n                rttAvg.addNext(data.jvbRTT);\\n            } else if (rttAvg) {\\n                this._avgRemoteRTTMap.delete(id);\\n            }\\n        }\\n\\n        /**\\n         * Reset cache of all averages and {@link _sampleIdx}.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_resetAvgStats',\\n        value: function _resetAvgStats() {\\n            this._avgRTT.reset();\\n            if (this._avgRemoteRTTMap) {\\n                this._avgRemoteRTTMap.clear();\\n            }\\n            this._sampleIdx = 0;\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'dispose',\\n        value: function dispose() {\\n\\n            var conference = this._avgRtpStatsReporter._conference;\\n\\n            conference.statistics.removeConnectionStatsListener(this._onConnectionStats);\\n            if (!this.isP2P) {\\n                conference.off(__WEBPACK_IMPORTED_MODULE_2__service_connectivity_ConnectionQualityEvents__[\\\"REMOTE_STATS_UPDATED\\\"], this._onRemoteStatsUpdated);\\n                conference.off(__WEBPACK_IMPORTED_MODULE_3__JitsiConferenceEvents__[\\\"USER_LEFT\\\"], this._onUserLeft);\\n            }\\n        }\\n    }]);\\n\\n    return ConnectionAvgStats;\\n}();\\n\\n/**\\n * Reports average RTP statistics values (arithmetic mean) to the analytics\\n * module for things like bit rate, bandwidth, packet loss etc. It keeps track\\n * of the P2P vs JVB conference modes and submits the values under different\\n * namespaces (the events for P2P mode have 'p2p.' prefix). Every switch between\\n * P2P mode resets the data collected so far and averages are calculated from\\n * scratch.\\n */\\n\\n\\nvar AvgRTPStatsReporter = function () {\\n    /**\\n     * Creates new instance of <tt>AvgRTPStatsReporter</tt>\\n     * @param {JitsiConference} conference\\n     * @param {number} n the number of samples, before arithmetic mean is to be\\n     * calculated and values submitted to the analytics module.\\n     */\\n    function AvgRTPStatsReporter(conference, n) {\\n        var _this2 = this;\\n\\n        _classCallCheck(this, AvgRTPStatsReporter);\\n\\n        /**\\n         * How many {@link ConnectionQualityEvents.LOCAL_STATS_UPDATED} samples\\n         * are to be included in arithmetic mean calculation.\\n         * @type {number}\\n         * @private\\n         */\\n        this._n = n;\\n\\n        if (n > 0) {\\n            logger.info('Avg RTP stats will be calculated every ' + n + ' samples');\\n        } else {\\n            logger.info('Avg RTP stats reports are disabled.');\\n\\n            // Do not initialize\\n            return;\\n        }\\n\\n        /**\\n         * The current sample index. Starts from 0 and goes up to {@link _n})\\n         * when analytics report will be submitted.\\n         * @type {number}\\n         * @private\\n         */\\n        this._sampleIdx = 0;\\n\\n        /**\\n         * The conference for which stats will be collected and reported.\\n         * @type {JitsiConference}\\n         * @private\\n         */\\n        this._conference = conference;\\n\\n        /**\\n         * Average audio upload bitrate\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgAudioBitrateUp = new AverageStatReport('stat_avg_bitrate_audio_upload');\\n\\n        /**\\n         * Average audio download bitrate\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgAudioBitrateDown = new AverageStatReport('stat_avg_bitrate_audio_download');\\n\\n        /**\\n         * Average video upload bitrate\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgVideoBitrateUp = new AverageStatReport('stat_avg_bitrate_video_upload');\\n\\n        /**\\n         * Average video download bitrate\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgVideoBitrateDown = new AverageStatReport('stat_avg_bitrate_video_download');\\n\\n        /**\\n         * Average upload bandwidth\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgBandwidthUp = new AverageStatReport('stat_avg_bandwidth_upload');\\n\\n        /**\\n         * Average download bandwidth\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgBandwidthDown = new AverageStatReport('stat_avg_bandwidth_download');\\n\\n        /**\\n         * Average total packet loss\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgPacketLossTotal = new AverageStatReport('stat_avg_packetloss_total');\\n\\n        /**\\n         * Average upload packet loss\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgPacketLossUp = new AverageStatReport('stat_avg_packetloss_upload');\\n\\n        /**\\n         * Average download packet loss\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgPacketLossDown = new AverageStatReport('stat_avg_packetloss_download');\\n\\n        /**\\n         * Average FPS for remote videos\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgRemoteFPS = new AverageStatReport('stat_avg_framerate_remote');\\n\\n        /**\\n         * Average FPS for remote screen streaming videos (reported only if not\\n         * a <tt>NaN</tt>).\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgRemoteScreenFPS = new AverageStatReport('stat_avg_framerate_screen_remote');\\n\\n        /**\\n         * Average FPS for local video (camera)\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgLocalFPS = new AverageStatReport('stat_avg_framerate_local');\\n\\n        /**\\n         * Average FPS for local screen streaming video (reported only if not\\n         * a <tt>NaN</tt>).\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgLocalScreenFPS = new AverageStatReport('stat_avg_framerate_screen_local');\\n\\n        /**\\n         * Average pixels for remote screen streaming videos (reported only if\\n         * not a <tt>NaN</tt>).\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgRemoteCameraPixels = new AverageStatReport('stat_avg_pixels_remote');\\n\\n        /**\\n         * Average pixels for remote screen streaming videos (reported only if\\n         * not a <tt>NaN</tt>).\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgRemoteScreenPixels = new AverageStatReport('stat_avg_pixels_screen_remote');\\n\\n        /**\\n         * Average pixels for local video (camera)\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgLocalCameraPixels = new AverageStatReport('stat_avg_pixels_local');\\n\\n        /**\\n         * Average pixels for local screen streaming video (reported only if not\\n         * a <tt>NaN</tt>).\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgLocalScreenPixels = new AverageStatReport('stat_avg_pixels_screen_local');\\n\\n        /**\\n         * Average connection quality as defined by\\n         * the {@link ConnectionQuality} module.\\n         * @type {AverageStatReport}\\n         * @private\\n         */\\n        this._avgCQ = new AverageStatReport('stat_avg_cq');\\n\\n        this._onLocalStatsUpdated = function (data) {\\n            return _this2._calculateAvgStats(data);\\n        };\\n        conference.on(__WEBPACK_IMPORTED_MODULE_2__service_connectivity_ConnectionQualityEvents__[\\\"LOCAL_STATS_UPDATED\\\"], this._onLocalStatsUpdated);\\n\\n        this._onP2PStatusChanged = function () {\\n            logger.debug('Resetting average stats calculation');\\n            _this2._resetAvgStats();\\n            _this2.jvbStatsMonitor._resetAvgStats();\\n            _this2.p2pStatsMonitor._resetAvgStats();\\n        };\\n        conference.on(__WEBPACK_IMPORTED_MODULE_3__JitsiConferenceEvents__[\\\"P2P_STATUS\\\"], this._onP2PStatusChanged);\\n\\n        this._onJvb121StatusChanged = function (oldStatus, newStatus) {\\n            // We want to reset only on the transition from false => true,\\n            // because otherwise those stats are resetted on JVB <=> P2P\\n            // transition.\\n            if (newStatus === true) {\\n                logger.info('Resetting JVB avg RTP stats');\\n                _this2._resetAvgJvbStats();\\n            }\\n        };\\n        conference.on(__WEBPACK_IMPORTED_MODULE_3__JitsiConferenceEvents__[\\\"JVB121_STATUS\\\"], this._onJvb121StatusChanged);\\n\\n        this.jvbStatsMonitor = new ConnectionAvgStats(this, false /* JVB */, n);\\n\\n        this.p2pStatsMonitor = new ConnectionAvgStats(this, true /* P2P */, n);\\n    }\\n\\n    /**\\n     * Processes next batch of stats reported on\\n     * {@link ConnectionQualityEvents.LOCAL_STATS_UPDATED}.\\n     * @param {go figure} data\\n     * @private\\n     */\\n\\n\\n    _createClass(AvgRTPStatsReporter, [{\\n        key: '_calculateAvgStats',\\n        value: function _calculateAvgStats(data) {\\n\\n            if (!data) {\\n                logger.error('No stats');\\n\\n                return;\\n            }\\n\\n            var isP2P = this._conference.isP2PActive();\\n            var confSize = this._conference.getParticipantCount();\\n\\n            if (!isP2P && confSize < 2) {\\n\\n                // There's no point in collecting stats for a JVB conference of 1.\\n                // That happens for short period of time after everyone leaves\\n                // the room, until Jicofo terminates the session.\\n                return;\\n            }\\n\\n            /* Uncomment to figure out stats structure\\n            for (const key in data) {\\n                if (data.hasOwnProperty(key)) {\\n                    logger.info(`local stat ${key}: `, data[key]);\\n                }\\n            } */\\n\\n            var bitrate = data.bitrate;\\n            var bandwidth = data.bandwidth;\\n            var packetLoss = data.packetLoss;\\n            var frameRate = data.framerate;\\n            var resolution = data.resolution;\\n\\n            if (!bitrate) {\\n                logger.error('No \\\"bitrate\\\"');\\n\\n                return;\\n            } else if (!bandwidth) {\\n                logger.error('No \\\"bandwidth\\\"');\\n\\n                return;\\n            } else if (!packetLoss) {\\n                logger.error('No \\\"packetloss\\\"');\\n\\n                return;\\n            } else if (!frameRate) {\\n                logger.error('No \\\"framerate\\\"');\\n\\n                return;\\n            } else if (!resolution) {\\n                logger.error('No resolution');\\n\\n                return;\\n            }\\n\\n            this._avgAudioBitrateUp.addNext(bitrate.audio.upload);\\n            this._avgAudioBitrateDown.addNext(bitrate.audio.download);\\n\\n            this._avgVideoBitrateUp.addNext(bitrate.video.upload);\\n            this._avgVideoBitrateDown.addNext(bitrate.video.download);\\n\\n            if (__WEBPACK_IMPORTED_MODULE_5__RTC_RTCBrowserType__[\\\"a\\\" /* default */].supportsBandwidthStatistics()) {\\n                this._avgBandwidthUp.addNext(bandwidth.upload);\\n                this._avgBandwidthDown.addNext(bandwidth.download);\\n            }\\n\\n            this._avgPacketLossUp.addNext(packetLoss.upload);\\n            this._avgPacketLossDown.addNext(packetLoss.download);\\n            this._avgPacketLossTotal.addNext(packetLoss.total);\\n\\n            this._avgCQ.addNext(data.connectionQuality);\\n\\n            if (frameRate) {\\n                this._avgRemoteFPS.addNext(this._calculateAvgVideoFps(frameRate, false /* remote */, __WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType__[\\\"CAMERA\\\"]));\\n                this._avgRemoteScreenFPS.addNext(this._calculateAvgVideoFps(frameRate, false /* remote */, __WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType__[\\\"DESKTOP\\\"]));\\n\\n                this._avgLocalFPS.addNext(this._calculateAvgVideoFps(frameRate, true /* local */, __WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType__[\\\"CAMERA\\\"]));\\n                this._avgLocalScreenFPS.addNext(this._calculateAvgVideoFps(frameRate, true /* local */, __WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType__[\\\"DESKTOP\\\"]));\\n            }\\n\\n            if (resolution) {\\n                this._avgRemoteCameraPixels.addNext(this._calculateAvgVideoPixels(resolution, false /* remote */, __WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType__[\\\"CAMERA\\\"]));\\n\\n                this._avgRemoteScreenPixels.addNext(this._calculateAvgVideoPixels(resolution, false /* remote */, __WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType__[\\\"DESKTOP\\\"]));\\n\\n                this._avgLocalCameraPixels.addNext(this._calculateAvgVideoPixels(resolution, true /* local */, __WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType__[\\\"CAMERA\\\"]));\\n\\n                this._avgLocalScreenPixels.addNext(this._calculateAvgVideoPixels(resolution, true /* local */, __WEBPACK_IMPORTED_MODULE_7__service_RTC_VideoType__[\\\"DESKTOP\\\"]));\\n            }\\n\\n            this._sampleIdx += 1;\\n\\n            if (this._sampleIdx >= this._n) {\\n\\n                var batchReport = {\\n                    p2p: isP2P,\\n                    size: confSize\\n                };\\n\\n                if (data.transport && data.transport.length) {\\n                    Object.assign(batchReport, {\\n                        localCandidateType: data.transport[0].localCandidateType,\\n                        remoteCandidateType: data.transport[0].remoteCandidateType,\\n                        transportType: data.transport[0].type\\n                    });\\n                }\\n\\n                this._avgAudioBitrateUp.appendReport(batchReport);\\n                this._avgAudioBitrateDown.appendReport(batchReport);\\n\\n                this._avgVideoBitrateUp.appendReport(batchReport);\\n                this._avgVideoBitrateDown.appendReport(batchReport);\\n\\n                if (__WEBPACK_IMPORTED_MODULE_5__RTC_RTCBrowserType__[\\\"a\\\" /* default */].supportsBandwidthStatistics()) {\\n                    this._avgBandwidthUp.appendReport(batchReport);\\n                    this._avgBandwidthDown.appendReport(batchReport);\\n                }\\n                this._avgPacketLossUp.appendReport(batchReport);\\n                this._avgPacketLossDown.appendReport(batchReport);\\n                this._avgPacketLossTotal.appendReport(batchReport);\\n\\n                this._avgRemoteFPS.appendReport(batchReport);\\n                if (!isNaN(this._avgRemoteScreenFPS.calculate())) {\\n                    this._avgRemoteScreenFPS.appendReport(batchReport);\\n                }\\n                this._avgLocalFPS.appendReport(batchReport);\\n                if (!isNaN(this._avgLocalScreenFPS.calculate())) {\\n                    this._avgLocalScreenFPS.appendReport(batchReport);\\n                }\\n\\n                this._avgRemoteCameraPixels.appendReport(batchReport);\\n                if (!isNaN(this._avgRemoteScreenPixels.calculate())) {\\n                    this._avgRemoteScreenPixels.appendReport(batchReport);\\n                }\\n                this._avgLocalCameraPixels.appendReport(batchReport);\\n                if (!isNaN(this._avgLocalScreenPixels.calculate())) {\\n                    this._avgLocalScreenPixels.appendReport(batchReport);\\n                }\\n\\n                this._avgCQ.appendReport(batchReport);\\n\\n                __WEBPACK_IMPORTED_MODULE_6__statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"a\\\" /* AVG_RTP_STATS */], batchReport);\\n\\n                this._resetAvgStats();\\n            }\\n        }\\n\\n        /**\\n         * Calculates average number of pixels for the report\\n         *\\n         * @param {map} peerResolutions a map of peer resolutions\\n         * @param {boolean} isLocal if the average is to be calculated for the local\\n         * video or <tt>false</tt> if for remote videos.\\n         * @param {VideoType} videoType\\n         * @return {number|NaN} average number of pixels or <tt>NaN</tt> if there\\n         * are no samples.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_calculateAvgVideoPixels',\\n        value: function _calculateAvgVideoPixels(peerResolutions, isLocal, videoType) {\\n            var peerPixelsSum = 0;\\n            var peerCount = 0;\\n            var myID = this._conference.myUserId();\\n\\n            var _iteratorNormalCompletion2 = true;\\n            var _didIteratorError2 = false;\\n            var _iteratorError2 = undefined;\\n\\n            try {\\n                for (var _iterator2 = Object.keys(peerResolutions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                    var peerID = _step2.value;\\n\\n                    if (isLocal ? peerID === myID : peerID !== myID) {\\n                        var participant = isLocal ? null : this._conference.getParticipantById(peerID);\\n                        var videosResolution = peerResolutions[peerID];\\n\\n                        // Do not continue without participant for non local peerID\\n                        if ((isLocal || participant) && videosResolution) {\\n                            var peerAvgPixels = this._calculatePeerAvgVideoPixels(videosResolution, participant, videoType);\\n\\n                            if (!isNaN(peerAvgPixels)) {\\n                                peerPixelsSum += peerAvgPixels;\\n                                peerCount += 1;\\n                            }\\n                        }\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError2 = true;\\n                _iteratorError2 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                        _iterator2.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError2) {\\n                        throw _iteratorError2;\\n                    }\\n                }\\n            }\\n\\n            return peerPixelsSum / peerCount;\\n        }\\n\\n        /**\\n         * Calculate average pixels for either remote or local participant\\n         * @param {object} videos maps resolution per video SSRC\\n         * @param {JitsiParticipant|null} participant remote participant or\\n         * <tt>null</tt> for local video pixels calculation.\\n         * @param {VideoType} videoType the type of the video for which an average\\n         * will be calculated.\\n         * @return {number|NaN} average video pixels of all participant's videos or\\n         * <tt>NaN</tt> if currently not available\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_calculatePeerAvgVideoPixels',\\n        value: function _calculatePeerAvgVideoPixels(videos, participant, videoType) {\\n            var ssrcs = Object.keys(videos).map(function (ssrc) {\\n                return Number(ssrc);\\n            });\\n            var videoTracks = null;\\n\\n            // NOTE that this method is supposed to be called for the stats\\n            // received from the current peerconnection.\\n            var tpc = this._conference.getActivePeerConnection();\\n\\n            if (participant) {\\n                videoTracks = participant.getTracksByMediaType(__WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]);\\n                if (videoTracks) {\\n                    ssrcs = ssrcs.filter(function (ssrc) {\\n                        return videoTracks.find(function (track) {\\n                            return !track.isMuted() && track.getSSRC() === ssrc && track.videoType === videoType;\\n                        });\\n                    });\\n                }\\n            } else {\\n                videoTracks = this._conference.getLocalTracks(__WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]);\\n                ssrcs = ssrcs.filter(function (ssrc) {\\n                    return videoTracks.find(function (track) {\\n                        return !track.isMuted() && tpc.getLocalSSRC(track) === ssrc && track.videoType === videoType;\\n                    });\\n                });\\n            }\\n\\n            var peerPixelsSum = 0;\\n            var peerSsrcCount = 0;\\n\\n            var _iteratorNormalCompletion3 = true;\\n            var _didIteratorError3 = false;\\n            var _iteratorError3 = undefined;\\n\\n            try {\\n                for (var _iterator3 = ssrcs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n                    var ssrc = _step3.value;\\n\\n                    var peerSsrcPixels = Number(videos[ssrc].height) * Number(videos[ssrc].width);\\n\\n                    // FPS is reported as 0 for users with no video\\n                    if (!isNaN(peerSsrcPixels) && peerSsrcPixels > 0) {\\n                        peerPixelsSum += peerSsrcPixels;\\n                        peerSsrcCount += 1;\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError3 = true;\\n                _iteratorError3 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                        _iterator3.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError3) {\\n                        throw _iteratorError3;\\n                    }\\n                }\\n            }\\n\\n            return peerPixelsSum / peerSsrcCount;\\n        }\\n\\n        /**\\n         * Calculates average FPS for the report\\n         * @param {go figure} frameRate\\n         * @param {boolean} isLocal if the average is to be calculated for the local\\n         * video or <tt>false</tt> if for remote videos.\\n         * @param {VideoType} videoType\\n         * @return {number|NaN} average FPS or <tt>NaN</tt> if there are no samples.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_calculateAvgVideoFps',\\n        value: function _calculateAvgVideoFps(frameRate, isLocal, videoType) {\\n            var peerFpsSum = 0;\\n            var peerCount = 0;\\n            var myID = this._conference.myUserId();\\n\\n            var _iteratorNormalCompletion4 = true;\\n            var _didIteratorError4 = false;\\n            var _iteratorError4 = undefined;\\n\\n            try {\\n                for (var _iterator4 = Object.keys(frameRate)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n                    var peerID = _step4.value;\\n\\n                    if (isLocal ? peerID === myID : peerID !== myID) {\\n                        var participant = isLocal ? null : this._conference.getParticipantById(peerID);\\n                        var videosFps = frameRate[peerID];\\n\\n                        // Do not continue without participant for non local peerID\\n                        if ((isLocal || participant) && videosFps) {\\n                            var peerAvgFPS = this._calculatePeerAvgVideoFps(videosFps, participant, videoType);\\n\\n                            if (!isNaN(peerAvgFPS)) {\\n                                peerFpsSum += peerAvgFPS;\\n                                peerCount += 1;\\n                            }\\n                        }\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError4 = true;\\n                _iteratorError4 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n                        _iterator4.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError4) {\\n                        throw _iteratorError4;\\n                    }\\n                }\\n            }\\n\\n            return peerFpsSum / peerCount;\\n        }\\n\\n        /**\\n         * Calculate average FPS for either remote or local participant\\n         * @param {object} videos maps FPS per video SSRC\\n         * @param {JitsiParticipant|null} participant remote participant or\\n         * <tt>null</tt> for local FPS calculation.\\n         * @param {VideoType} videoType the type of the video for which an average\\n         * will be calculated.\\n         * @return {number|NaN} average FPS of all participant's videos or\\n         * <tt>NaN</tt> if currently not available\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_calculatePeerAvgVideoFps',\\n        value: function _calculatePeerAvgVideoFps(videos, participant, videoType) {\\n            var ssrcs = Object.keys(videos).map(function (ssrc) {\\n                return Number(ssrc);\\n            });\\n            var videoTracks = null;\\n\\n            // NOTE that this method is supposed to be called for the stats\\n            // received from the current peerconnection.\\n            var tpc = this._conference.getActivePeerConnection();\\n\\n            if (participant) {\\n                videoTracks = participant.getTracksByMediaType(__WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]);\\n                if (videoTracks) {\\n                    ssrcs = ssrcs.filter(function (ssrc) {\\n                        return videoTracks.find(function (track) {\\n                            return !track.isMuted() && track.getSSRC() === ssrc && track.videoType === videoType;\\n                        });\\n                    });\\n                }\\n            } else {\\n                videoTracks = this._conference.getLocalTracks(__WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]);\\n                ssrcs = ssrcs.filter(function (ssrc) {\\n                    return videoTracks.find(function (track) {\\n                        return !track.isMuted() && tpc.getLocalSSRC(track) === ssrc && track.videoType === videoType;\\n                    });\\n                });\\n            }\\n\\n            var peerFpsSum = 0;\\n            var peerSsrcCount = 0;\\n\\n            var _iteratorNormalCompletion5 = true;\\n            var _didIteratorError5 = false;\\n            var _iteratorError5 = undefined;\\n\\n            try {\\n                for (var _iterator5 = ssrcs[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\\n                    var ssrc = _step5.value;\\n\\n                    var peerSsrcFps = Number(videos[ssrc]);\\n\\n                    // FPS is reported as 0 for users with no video\\n                    if (!isNaN(peerSsrcFps) && peerSsrcFps > 0) {\\n                        peerFpsSum += peerSsrcFps;\\n                        peerSsrcCount += 1;\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError5 = true;\\n                _iteratorError5 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\\n                        _iterator5.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError5) {\\n                        throw _iteratorError5;\\n                    }\\n                }\\n            }\\n\\n            return peerFpsSum / peerSsrcCount;\\n        }\\n\\n        /**\\n         * Resets the stats related to JVB connection. Must not be called when in\\n         * P2P mode, because then the {@link AverageStatReport} instances are\\n         * tracking P2P stats. Note that this should never happen unless something\\n         * is wrong with the P2P and JVB121 events.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_resetAvgJvbStats',\\n        value: function _resetAvgJvbStats() {\\n            this._resetAvgStats();\\n            this.jvbStatsMonitor._resetAvgStats();\\n        }\\n\\n        /**\\n         * Reset cache of all averages and {@link _sampleIdx}.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_resetAvgStats',\\n        value: function _resetAvgStats() {\\n            this._avgAudioBitrateUp.reset();\\n            this._avgAudioBitrateDown.reset();\\n\\n            this._avgVideoBitrateUp.reset();\\n            this._avgVideoBitrateDown.reset();\\n\\n            this._avgBandwidthUp.reset();\\n            this._avgBandwidthDown.reset();\\n\\n            this._avgPacketLossUp.reset();\\n            this._avgPacketLossDown.reset();\\n            this._avgPacketLossTotal.reset();\\n\\n            this._avgRemoteFPS.reset();\\n            this._avgRemoteScreenFPS.reset();\\n            this._avgLocalFPS.reset();\\n            this._avgLocalScreenFPS.reset();\\n\\n            this._avgRemoteCameraPixels.reset();\\n            this._avgRemoteScreenPixels.reset();\\n            this._avgLocalCameraPixels.reset();\\n            this._avgLocalScreenPixels.reset();\\n\\n            this._avgCQ.reset();\\n\\n            this._sampleIdx = 0;\\n        }\\n\\n        /**\\n         * Unregisters all event listeners and stops working.\\n         */\\n\\n    }, {\\n        key: 'dispose',\\n        value: function dispose() {\\n            this._conference.off(__WEBPACK_IMPORTED_MODULE_3__JitsiConferenceEvents__[\\\"P2P_STATUS\\\"], this._onP2PStatusChanged);\\n            this._conference.off(__WEBPACK_IMPORTED_MODULE_2__service_connectivity_ConnectionQualityEvents__[\\\"LOCAL_STATS_UPDATED\\\"], this._onLocalStatsUpdated);\\n            this._conference.off(__WEBPACK_IMPORTED_MODULE_3__JitsiConferenceEvents__[\\\"JVB121_STATUS\\\"], this._onJvb121StatusChanged);\\n            this.jvbStatsMonitor.dispose();\\n            this.p2pStatsMonitor.dispose();\\n        }\\n    }]);\\n\\n    return AvgRTPStatsReporter;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (AvgRTPStatsReporter);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/statistics/AvgRTPStatsReporter.js\\\"))\\n\\n/***/ }),\\n/* 66 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* Copyright @ 2016 Atlassian Pty Ltd\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\nvar Logger = __webpack_require__(38);\\n\\n/**\\n * Creates new <tt>LogCollector</tt>. Class implements <tt>LoggerTransport</tt>\\n * and thus can be added as global transport in order to capture all the logs.\\n *\\n * It captures subsequent log lines created whenever <tt>Logger</tt> logs\\n * a message and stores them in a queue in order to batch log entries. There are\\n * time and size limit constraints which determine how often batch entries are\\n * stored. Whenever one of these limits is exceeded the <tt>LogCollector</tt>\\n * will use the <tt>logStorage</tt> object given as an argument to save\\n * the batch log entry.\\n *\\n * @param {Object} logStorage an object which allows to store the logs collected\\n * @param {function(string|object[])} logStorage.storeLogs a method called when\\n * this <tt>LogCollector</tt> requests log entry storage. The method's argument\\n * is an array which can contain <tt>string</tt>s and <tt>object</tt>s. If given\\n * item is an object it means that it's an aggregated message. That is a message\\n * which is the same as the previous one and it's representation has\\n * the following format:\\n * {\\n *   {string} text: 'the text of some duplicated message'\\n *   {number} count: 3 // how many times the message appeared in a row\\n * }\\n * If a message \\\"B\\\" after an aggregated message \\\"A\\\" is different, then it breaks\\n * the sequence of \\\"A\\\". Which means that even if the next message \\\"C\\\" is\\n * the same as \\\"A\\\" it will start a new aggregated message \\\"C\\\".\\n * @param {function()} logStorage.isReady a method which should return\\n * a <tt>boolean</tt> to tell the collector that it's ready to store. During the\\n * time storage is not ready log batches will be cached and stored on the next\\n * occasion (flush or interval timeout).\\n *\\n * @param {Object} options the <tt>LogCollector</tt> configuration options.\\n * @param {number} options.maxEntryLength the size limit for a single log entry\\n * to be stored. The <tt>LogCollector</tt> will push the entry as soon as it\\n * reaches or exceeds this limit given that <tt>logStorage.isReady</tt>\\n * returns <tt>true</tt>. Otherwise the log entry will be cached until the log\\n * storage becomes ready. Note that the \\\"is ready\\\" condition is checked every\\n * <tt>options.storeInterval</tt> milliseconds.\\n * @param {number} options.storeInterval how often the logs should be stored in\\n * case <tt>maxEntryLength</tt> was not exceeded.\\n * @param {boolean} options.stringifyObjects indicates whether or not object\\n * arguments should be \\\"stringified\\\" with <tt>JSON.stringify</tt> when a log\\n * message is composed. Note that objects logged on the error log level are\\n * always stringified.\\n *\\n * @constructor\\n */\\nfunction LogCollector(logStorage, options) {\\n    this.logStorage = logStorage;\\n    this.stringifyObjects\\n        = options && options.stringifyObjects\\n            ? options.stringifyObjects : false;\\n    this.storeInterval\\n        = options && options.storeInterval\\n            ? options.storeInterval: 30000;\\n    this.maxEntryLength\\n        = options && options.maxEntryLength\\n            ? options.maxEntryLength : 10000;\\n    // Bind the log method for each level to the corresponding method name\\n    // in order to implement \\\"global log transport\\\" object.\\n    Object.keys(Logger.levels).forEach(\\n    function (logLevel) {\\n        var methodName = Logger.levels[logLevel];\\n        this[methodName] = function (logLevel) {\\n            this._log.apply(this, arguments);\\n        }.bind(this, logLevel);\\n    }.bind(this));\\n    /**\\n     * The ID of store logs interval if one is currently scheduled or\\n     * <tt>null</tt> otherwise.\\n     * @type {number|null}\\n     */\\n    this.storeLogsIntervalID = null;\\n    /**\\n     * The log messages that are to be batched into log entry when\\n     * {@link LogCollector._flush} method is called.\\n     * @type {string[]}\\n     */\\n    this.queue = [];\\n    /**\\n     * The total length of all messages currently stored in the {@link queue}.\\n     * @type {number}\\n     */\\n    this.totalLen = 0;\\n    /**\\n     * An array used to temporarily store log batches, before the storage gets\\n     * ready.\\n     * @type {string[]}\\n     */\\n    this.outputCache = [];\\n}\\n\\n/**\\n * Method called inside of {@link formatLogMessage} in order to covert an\\n * <tt>Object</tt> argument to string. The conversion will happen when either\\n * 'stringifyObjects' option is enabled or on the {@link Logger.levels.ERROR}\\n * log level. The default implementation uses <tt>JSON.stringify</tt> and\\n * returns \\\"[object with circular refs?]\\\" instead of an object if it fails.\\n *\\n * @param {object} someObject the <tt>object</tt> to be stringified.\\n *\\n * @return {string} the result of <tt>JSON.stringify</tt> or\\n * \\\"[object with circular refs?]\\\" if any error occurs during \\\"stringification\\\".\\n *\\n * @protected\\n */\\nLogCollector.prototype.stringify = function (someObject) {\\n    try {\\n        return JSON.stringify(someObject);\\n    } catch (error) {\\n        return \\\"[object with circular refs?]\\\";\\n    }\\n};\\n\\n/**\\n * Formats log entry for the given logging level and arguments passed to the\\n * <tt>Logger</tt>'s log method. The first argument is log level and the next\\n * arguments have to be captured using JS built-in 'arguments' variable.\\n *\\n * @param {Logger.levels} logLevel provides the logging level of the message to\\n * be logged.\\n *\\n * @return {string|null} a non-empty string representation of the log entry\\n * crafted from the log arguments. If the return value is <tt>null</tt> then\\n * the message wil be discarded by this <tt>LogCollector</tt>.\\n *\\n * @protected\\n */\\nLogCollector.prototype.formatLogMessage\\n= function (logLevel/*, arg1, arg2, arg3... */) {\\n    var msg = '';\\n    for (var i = 1, len = arguments.length; i < len; i++) {\\n        var arg = arguments[i];\\n        // objects logged on error level are always converted to JSON\\n        if ((this.stringifyObjects || logLevel === Logger.levels.ERROR)\\n            && typeof arg === 'object') {\\n            arg = this.stringify(arg);\\n        }\\n        msg += arg;\\n        if (i != len - 1) {\\n            msg += ' ';\\n        }\\n    }\\n    return msg.length ? msg : null;\\n};\\n\\n/**\\n * The log method bound to each of the logging levels in order to implement\\n * \\\"global log transport\\\" object.\\n *\\n * @private\\n */\\nLogCollector.prototype._log = function() {\\n\\n    // var logLevel = arguments[0]; first argument is the log level\\n    var msg = this.formatLogMessage.apply(this, arguments);\\n    if (msg) {\\n        // The same as the previous message aggregation logic\\n        var prevMessage\\n            = this.queue.length ? this.queue[this.queue.length -1] : undefined;\\n        // NOTE that typeof undefined is 'undefined'\\n        var prevMessageText\\n            = typeof prevMessage === 'object' ? prevMessage.text : prevMessage;\\n        // Is it the same as the previous one ?\\n        if (prevMessageText == msg) {\\n            if (typeof prevMessage === 'object') {\\n                prevMessage.count += 1;\\n            } else {\\n                this.queue[this.queue.length-1] = {\\n                    text: msg,\\n                    count: 2\\n                }\\n            }\\n        } else {\\n            this.queue.push(msg);\\n            this.totalLen += msg.length;\\n        }\\n    }\\n\\n    if (this.totalLen >= this.maxEntryLength) {\\n        this._flush(true /* force */, true /* reschedule */);\\n    }\\n};\\n\\n/**\\n * Starts periodical \\\"store logs\\\" task which will be triggered at the interval\\n * specified in the constructor options.\\n */\\nLogCollector.prototype.start = function () {\\n    this._reschedulePublishInterval();\\n};\\n\\n/**\\n * Reschedules the periodical \\\"store logs\\\" task which will store the next batch\\n * log entry in the storage.\\n * @private\\n */\\nLogCollector.prototype._reschedulePublishInterval = function () {\\n    if (this.storeLogsIntervalID) {\\n        window.clearTimeout(this.storeLogsIntervalID);\\n        this.storeLogsIntervalID = null;\\n    }\\n    // It's actually a timeout, because it is rescheduled on every flush\\n    this.storeLogsIntervalID\\n        = window.setTimeout(\\n            this._flush.bind(\\n                this, false /* do not force */, true /* reschedule */),\\n            this.storeInterval);\\n};\\n\\n/**\\n * Call this method to flush the log entry buffer and store it in the log\\n * storage immediately (given that the storage is ready).\\n */\\nLogCollector.prototype.flush = function() {\\n    this._flush(\\n        false /* do not force, as it will not be stored anyway */,\\n        true /* reschedule next update */ )\\n};\\n\\n/**\\n * Stores the next batch log entry in the log storage.\\n * @param {boolean} force enforce current logs batch to be stored or cached if\\n * there is anything to be logged, but the storage is not ready yet. One of\\n * legitimate reasons to force is when the logs length exceeds size limit which\\n * could result in truncation.\\n * @param {boolean} reschedule <tt>true</tt> if the next periodic task should be\\n * scheduled after the log entry is stored. <tt>false</tt> will end the periodic\\n * task cycle.\\n * @private\\n */\\nLogCollector.prototype._flush = function(force, reschedule) {\\n    // Publish only if there's anything to be logged\\n    if (this.totalLen > 0 && (this.logStorage.isReady() || force)) {\\n        //FIXME avoid truncating\\n        // right now we don't care if the message size is \\\"slightly\\\" exceeded\\n        if (this.logStorage.isReady()) {\\n            // Sends all cached logs\\n            if (this.outputCache.length) {\\n                this.outputCache.forEach(\\n                    function (cachedQueue) {\\n                        this.logStorage.storeLogs(cachedQueue);\\n                    }.bind(this)\\n                );\\n                // Clear the cache\\n                this.outputCache = [];\\n            }\\n            // Send current batch\\n            this.logStorage.storeLogs(this.queue);\\n        } else {\\n            this.outputCache.push(this.queue);\\n        }\\n\\n        this.queue = [];\\n        this.totalLen = 0;\\n    }\\n\\n    if (reschedule) {\\n        this._reschedulePublishInterval();\\n    }\\n};\\n\\n/**\\n * Stops the periodical \\\"store logs\\\" task and immediately stores any pending\\n * log entries as a batch.\\n */\\nLogCollector.prototype.stop = function() {\\n    // Flush and stop publishing logs\\n    this._flush(false /* do not force */, false /* do not reschedule */);\\n};\\n\\nmodule.exports = LogCollector;\\n\\n\\n/***/ }),\\n/* 67 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__settings_Settings__ = __webpack_require__(19);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n\\n/**\\n * Interface for analytics handlers.\\n */\\n\\nvar AnalyticsAbstract = function () {\\n    function AnalyticsAbstract() {\\n        _classCallCheck(this, AnalyticsAbstract);\\n    }\\n\\n    _createClass(AnalyticsAbstract, [{\\n        key: 'sendEvent',\\n\\n        /**\\n         *\\n         */\\n        value: function sendEvent() {} // eslint-disable-line no-empty-function\\n\\n    }]);\\n\\n    return AnalyticsAbstract;\\n}();\\n\\n/**\\n * Handler that caches all the events.\\n * @extends AnalyticsAbstract\\n */\\n\\n\\nvar CacheAnalytics = function (_AnalyticsAbstract) {\\n    _inherits(CacheAnalytics, _AnalyticsAbstract);\\n\\n    /**\\n     *\\n     */\\n    function CacheAnalytics() {\\n        _classCallCheck(this, CacheAnalytics);\\n\\n        // some events may happen before init or implementation script download\\n        // in this case we accumulate them in this array and send them on init\\n        var _this = _possibleConstructorReturn(this, (CacheAnalytics.__proto__ || Object.getPrototypeOf(CacheAnalytics)).call(this));\\n\\n        _this.eventCache = [];\\n        return _this;\\n    }\\n\\n    /**\\n     * Cache analytics event.\\n     * @param {String} eventName the name of the event\\n     * @param {Object} data can be any JSON object\\n     */\\n\\n\\n    _createClass(CacheAnalytics, [{\\n        key: 'sendEvent',\\n        value: function sendEvent(eventName) {\\n            var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n            this.eventCache.push({\\n                eventName: eventName,\\n                data: data\\n            });\\n        }\\n\\n        /**\\n         * Clears the cached events.\\n         * @returns {Array} with the cached events.\\n         */\\n\\n    }, {\\n        key: 'drainCachedEvents',\\n        value: function drainCachedEvents() {\\n            var eventCacheCopy = this.eventCache.slice();\\n\\n            this.eventCache = [];\\n\\n            return eventCacheCopy;\\n        }\\n    }]);\\n\\n    return CacheAnalytics;\\n}(AnalyticsAbstract);\\n\\nvar cacheAnalytics = new CacheAnalytics();\\n\\n/**\\n * This class will store and manage the handlers that are going to be used.\\n */\\n\\nvar AnalyticsAdapter = function () {\\n    /**\\n     * Creates new AnalyticsAdapter instance.\\n     */\\n    function AnalyticsAdapter() {\\n        _classCallCheck(this, AnalyticsAdapter);\\n\\n        this.disposed = false;\\n        this.analyticsHandlers = new Set();\\n\\n        /**\\n         * Map of properties that will be added to every event\\n         */\\n        this.permanentProperties = {\\n            callstatsname: __WEBPACK_IMPORTED_MODULE_1__settings_Settings__[\\\"a\\\" /* default */].callStatsUserName,\\n            userAgent: navigator.userAgent,\\n            browserName: __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].getBrowserName()\\n        };\\n\\n        this.analyticsHandlers.add(cacheAnalytics);\\n    }\\n\\n    /**\\n     * Sends analytics event.\\n     * @param {String} eventName the name of the event\\n     * @param {Object} data can be any JSON object\\n     */\\n\\n\\n    _createClass(AnalyticsAdapter, [{\\n        key: 'sendEvent',\\n        value: function sendEvent(eventName) {\\n            var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n            var modifiedData = Object.assign({}, this.permanentProperties, data);\\n\\n            this.analyticsHandlers.forEach(function (analytics) {\\n                return analytics.sendEvent(eventName, analytics === cacheAnalytics ? data : modifiedData);\\n            });\\n        }\\n\\n        /**\\n         * Dispose analytics. Clears all handlers.\\n         */\\n\\n    }, {\\n        key: 'dispose',\\n        value: function dispose() {\\n            cacheAnalytics.drainCachedEvents();\\n            this.analyticsHandlers.clear();\\n            this.disposed = true;\\n        }\\n\\n        /**\\n         * Sets the handlers that are going to be used to send analytics and send\\n         * the cached events.\\n         * @param {Array} handlers the handlers\\n         */\\n\\n    }, {\\n        key: 'setAnalyticsHandlers',\\n        value: function setAnalyticsHandlers(handlers) {\\n            var _this2 = this;\\n\\n            if (this.disposed) {\\n                return;\\n            }\\n            this.analyticsHandlers = new Set(handlers);\\n            cacheAnalytics.drainCachedEvents().forEach(function (ev) {\\n                return _this2.sendEvent(ev.eventName, ev.data);\\n            });\\n        }\\n\\n        /**\\n         * Adds map of properties that will be added to every event.\\n         * @param {Object} properties the map of properties\\n         */\\n\\n    }, {\\n        key: 'addPermanentProperties',\\n        value: function addPermanentProperties(properties) {\\n            Object.assign(this.permanentProperties, properties);\\n        }\\n    }]);\\n\\n    return AnalyticsAdapter;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (new AnalyticsAdapter());\\n\\n/***/ }),\\n/* 68 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar RandomUtil = __webpack_require__(20);\\n\\n/**\\n * from faker.js - Copyright (c) 2014-2015 Matthew Bergman & Marak Squires\\n * MIT License\\n * http://github.com/marak/faker.js/\\n *\\n * @const\\n */\\nvar names = ['Aaliyah', 'Aaron', 'Abagail', 'Abbey', 'Abbie', 'Abbigail', 'Abby', 'Abdiel', 'Abdul', 'Abdullah', 'Abe', 'Abel', 'Abelardo', 'Abigail', 'Abigale', 'Abigayle', 'Abner', 'Abraham', 'Ada', 'Adah', 'Adalberto', 'Adaline', 'Adam', 'Adan', 'Addie', 'Addison', 'Adela', 'Adelbert', 'Adele', 'Adelia', 'Adeline', 'Adell', 'Adella', 'Adelle', 'Aditya', 'Adolf', 'Adolfo', 'Adolph', 'Adolphus', 'Adonis', 'Adrain', 'Adrian', 'Adriana', 'Adrianna', 'Adriel', 'Adrien', 'Adrienne', 'Afton', 'Aglae', 'Agnes', 'Agustin', 'Agustina', 'Ahmad', 'Ahmed', 'Aida', 'Aidan', 'Aiden', 'Aileen', 'Aisha', 'Aiyana', 'Akeem', 'Al', 'Alaina', 'Alan', 'Alana', 'Alanis', 'Alanna', 'Alayna', 'Alba', 'Albert', 'Alberta', 'Albertha', 'Alberto', 'Albin', 'Albina', 'Alda', 'Alden', 'Alec', 'Aleen', 'Alejandra', 'Alejandrin', 'Alek', 'Alena', 'Alene', 'Alessandra', 'Alessandro', 'Alessia', 'Aletha', 'Alex', 'Alexa', 'Alexander', 'Alexandra', 'Alexandre', 'Alexandrea', 'Alexandria', 'Alexandrine', 'Alexandro', 'Alexane', 'Alexanne', 'Alexie', 'Alexis', 'Alexys', 'Alexzander', 'Alf', 'Alfonso', 'Alfonzo', 'Alford', 'Alfred', 'Alfreda', 'Alfredo', 'Ali', 'Alia', 'Alice', 'Alicia', 'Alisa', 'Alisha', 'Alison', 'Alivia', 'Aliya', 'Aliyah', 'Aliza', 'Alize', 'Allan', 'Allen', 'Allene', 'Allie', 'Allison', 'Ally', 'Alphonso', 'Alta', 'Althea', 'Alva', 'Alvah', 'Alvena', 'Alvera', 'Alverta', 'Alvina', 'Alvis', 'Alyce', 'Alycia', 'Alysa', 'Alysha', 'Alyson', 'Alysson', 'Amalia', 'Amanda', 'Amani', 'Amara', 'Amari', 'Amaya', 'Amber', 'Ambrose', 'Amelia', 'Amelie', 'Amely', 'America', 'Americo', 'Amie', 'Amina', 'Amir', 'Amira', 'Amiya', 'Amos', 'Amparo', 'Amy', 'Amya', 'Ana', 'Anabel', 'Anabelle', 'Anahi', 'Anais', 'Anastacio', 'Anastasia', 'Anderson', 'Andre', 'Andreane', 'Andreanne', 'Andres', 'Andrew', 'Andy', 'Angel', 'Angela', 'Angelica', 'Angelina', 'Angeline', 'Angelita', 'Angelo', 'Angie', 'Angus', 'Anibal', 'Anika', 'Anissa', 'Anita', 'Aniya', 'Aniyah', 'Anjali', 'Anna', 'Annabel', 'Annabell', 'Annabelle', 'Annalise', 'Annamae', 'Annamarie', 'Anne', 'Annetta', 'Annette', 'Annie', 'Ansel', 'Ansley', 'Anthony', 'Antoinette', 'Antone', 'Antonetta', 'Antonette', 'Antonia', 'Antonietta', 'Antonina', 'Antonio', 'Antwan', 'Antwon', 'Anya', 'April', 'Ara', 'Araceli', 'Aracely', 'Arch', 'Archibald', 'Ardella', 'Arden', 'Ardith', 'Arely', 'Ari', 'Ariane', 'Arianna', 'Aric', 'Ariel', 'Arielle', 'Arjun', 'Arlene', 'Arlie', 'Arlo', 'Armand', 'Armando', 'Armani', 'Arnaldo', 'Arne', 'Arno', 'Arnold', 'Arnoldo', 'Arnulfo', 'Aron', 'Art', 'Arthur', 'Arturo', 'Arvel', 'Arvid', 'Arvilla', 'Aryanna', 'Asa', 'Asha', 'Ashlee', 'Ashleigh', 'Ashley', 'Ashly', 'Ashlynn', 'Ashton', 'Ashtyn', 'Asia', 'Assunta', 'Astrid', 'Athena', 'Aubree', 'Aubrey', 'Audie', 'Audra', 'Audreanne', 'Audrey', 'August', 'Augusta', 'Augustine', 'Augustus', 'Aurelia', 'Aurelie', 'Aurelio', 'Aurore', 'Austen', 'Austin', 'Austyn', 'Autumn', 'Ava', 'Avery', 'Avis', 'Axel', 'Ayana', 'Ayden', 'Ayla', 'Aylin', 'Baby', 'Bailee', 'Bailey', 'Barbara', 'Barney', 'Baron', 'Barrett', 'Barry', 'Bart', 'Bartholome', 'Barton', 'Baylee', 'Beatrice', 'Beau', 'Beaulah', 'Bell', 'Bella', 'Belle', 'Ben', 'Benedict', 'Benjamin', 'Bennett', 'Bennie', 'Benny', 'Benton', 'Berenice', 'Bernadette', 'Bernadine', 'Bernard', 'Bernardo', 'Berneice', 'Bernhard', 'Bernice', 'Bernie', 'Berniece', 'Bernita', 'Berry', 'Bert', 'Berta', 'Bertha', 'Bertram', 'Bertrand', 'Beryl', 'Bessie', 'Beth', 'Bethany', 'Bethel', 'Betsy', 'Bette', 'Bettie', 'Betty', 'Bettye', 'Beulah', 'Beverly', 'Bianka', 'Bill', 'Billie', 'Billy', 'Birdie', 'Blair', 'Blaise', 'Blake', 'Blanca', 'Blanche', 'Blaze', 'Bo', 'Bobbie', 'Bobby', 'Bonita', 'Bonnie', 'Boris', 'Boyd', 'Brad', 'Braden', 'Bradford', 'Bradley', 'Bradly', 'Brady', 'Braeden', 'Brain', 'Brandi', 'Brando', 'Brandon', 'Brandt', 'Brandy', 'Brandyn', 'Brannon', 'Branson', 'Brant', 'Braulio', 'Braxton', 'Brayan', 'Breana', 'Breanna', 'Breanne', 'Brenda', 'Brendan', 'Brenden', 'Brendon', 'Brenna', 'Brennan', 'Brennon', 'Brent', 'Bret', 'Brett', 'Bria', 'Brian', 'Briana', 'Brianne', 'Brice', 'Bridget', 'Bridgette', 'Bridie', 'Brielle', 'Brigitte', 'Brionna', 'Brisa', 'Britney', 'Brittany', 'Brock', 'Broderick', 'Brody', 'Brook', 'Brooke', 'Brooklyn', 'Brooks', 'Brown', 'Bruce', 'Bryana', 'Bryce', 'Brycen', 'Bryon', 'Buck', 'Bud', 'Buddy', 'Buford', 'Bulah', 'Burdette', 'Burley', 'Burnice', 'Buster', 'Cade', 'Caden', 'Caesar', 'Caitlyn', 'Cale', 'Caleb', 'Caleigh', 'Cali', 'Calista', 'Callie', 'Camden', 'Cameron', 'Camila', 'Camilla', 'Camille', 'Camren', 'Camron', 'Camryn', 'Camylle', 'Candace', 'Candelario', 'Candice', 'Candida', 'Candido', 'Cara', 'Carey', 'Carissa', 'Carlee', 'Carleton', 'Carley', 'Carli', 'Carlie', 'Carlo', 'Carlos', 'Carlotta', 'Carmel', 'Carmela', 'Carmella', 'Carmelo', 'Carmen', 'Carmine', 'Carol', 'Carolanne', 'Carole', 'Carolina', 'Caroline', 'Carolyn', 'Carolyne', 'Carrie', 'Carroll', 'Carson', 'Carter', 'Cary', 'Casandra', 'Casey', 'Casimer', 'Casimir', 'Casper', 'Cassandra', 'Cassandre', 'Cassidy', 'Cassie', 'Catalina', 'Caterina', 'Catharine', 'Catherine', 'Cathrine', 'Cathryn', 'Cathy', 'Cayla', 'Ceasar', 'Cecelia', 'Cecil', 'Cecile', 'Cecilia', 'Cedrick', 'Celestine', 'Celestino', 'Celia', 'Celine', 'Cesar', 'Chad', 'Chadd', 'Chadrick', 'Chaim', 'Chance', 'Chandler', 'Chanel', 'Chanelle', 'Charity', 'Charlene', 'Charles', 'Charley', 'Charlie', 'Charlotte', 'Chase', 'Chasity', 'Chauncey', 'Chaya', 'Chaz', 'Chelsea', 'Chelsey', 'Chelsie', 'Chesley', 'Chester', 'Chet', 'Cheyanne', 'Cheyenne', 'Chloe', 'Chris', 'Christ', 'Christa', 'Christelle', 'Christian', 'Christiana', 'Christina', 'Christine', 'Christop', 'Christophe', 'Christopher', 'Christy', 'Chyna', 'Ciara', 'Cicero', 'Cielo', 'Cierra', 'Cindy', 'Citlalli', 'Clair', 'Claire', 'Clara', 'Clarabelle', 'Clare', 'Clarissa', 'Clark', 'Claud', 'Claude', 'Claudia', 'Claudie', 'Claudine', 'Clay', 'Clemens', 'Clement', 'Clementina', 'Clementine', 'Clemmie', 'Cleo', 'Cleora', 'Cleta', 'Cletus', 'Cleve', 'Cleveland', 'Clifford', 'Clifton', 'Clint', 'Clinton', 'Clotilde', 'Clovis', 'Cloyd', 'Clyde', 'Coby', 'Cody', 'Colby', 'Cole', 'Coleman', 'Colin', 'Colleen', 'Collin', 'Colt', 'Colten', 'Colton', 'Columbus', 'Concepcion', 'Conner', 'Connie', 'Connor', 'Conor', 'Conrad', 'Constance', 'Constantin', 'Consuelo', 'Cooper', 'Cora', 'Coralie', 'Corbin', 'Cordelia', 'Cordell', 'Cordia', 'Cordie', 'Corene', 'Corine', 'Cornelius', 'Cornell', 'Corrine', 'Cortez', 'Cortney', 'Cory', 'Coty', 'Courtney', 'Coy', 'Craig', 'Crawford', 'Creola', 'Cristal', 'Cristian', 'Cristina', 'Cristobal', 'Cristopher', 'Cruz', 'Crystal', 'Crystel', 'Cullen', 'Curt', 'Curtis', 'Cydney', 'Cynthia', 'Cyril', 'Cyrus', 'Dagmar', 'Dahlia', 'Daija', 'Daisha', 'Daisy', 'Dakota', 'Dale', 'Dallas', 'Dallin', 'Dalton', 'Damaris', 'Dameon', 'Damian', 'Damien', 'Damion', 'Damon', 'Dan', 'Dana', 'Dandre', 'Dane', 'D\\\\'angelo', 'Dangelo', 'Danial', 'Daniela', 'Daniella', 'Danielle', 'Danika', 'Dannie', 'Danny', 'Dante', 'Danyka', 'Daphne', 'Daphnee', 'Daphney', 'Darby', 'Daren', 'Darian', 'Dariana', 'Darien', 'Dario', 'Darion', 'Darius', 'Darlene', 'Daron', 'Darrel', 'Darrell', 'Darren', 'Darrick', 'Darrin', 'Darrion', 'Darron', 'Darryl', 'Darwin', 'Daryl', 'Dashawn', 'Dasia', 'Dave', 'David', 'Davin', 'Davion', 'Davon', 'Davonte', 'Dawn', 'Dawson', 'Dax', 'Dayana', 'Dayna', 'Dayne', 'Dayton', 'Dean', 'Deangelo', 'Deanna', 'Deborah', 'Declan', 'Dedric', 'Dedrick', 'Dee', 'Deion', 'Deja', 'Dejah', 'Dejon', 'Dejuan', 'Delaney', 'Delbert', 'Delfina', 'Delia', 'Delilah', 'Dell', 'Della', 'Delmer', 'Delores', 'Delpha', 'Delphia', 'Delphine', 'Delta', 'Demarco', 'Demarcus', 'Demario', 'Demetris', 'Demetrius', 'Demond', 'Dena', 'Denis', 'Dennis', 'Deon', 'Deondre', 'Deontae', 'Deonte', 'Dereck', 'Derek', 'Derick', 'Deron', 'Derrick', 'Deshaun', 'Deshawn', 'Desiree', 'Desmond', 'Dessie', 'Destany', 'Destin', 'Destinee', 'Destiney', 'Destini', 'Destiny', 'Devan', 'Devante', 'Deven', 'Devin', 'Devon', 'Devonte', 'Devyn', 'Dewayne', 'Dewitt', 'Dexter', 'Diamond', 'Diana', 'Dianna', 'Diego', 'Dillan', 'Dillon', 'Dimitri', 'Dina', 'Dino', 'Dion', 'Dixie', 'Dock', 'Dolly', 'Dolores', 'Domenic', 'Domenica', 'Domenick', 'Domenico', 'Domingo', 'Dominic', 'Dominique', 'Don', 'Donald', 'Donato', 'Donavon', 'Donna', 'Donnell', 'Donnie', 'Donny', 'Dora', 'Dorcas', 'Dorian', 'Doris', 'Dorothea', 'Dorothy', 'Dorris', 'Dortha', 'Dorthy', 'Doug', 'Douglas', 'Dovie', 'Doyle', 'Drake', 'Drew', 'Duane', 'Dudley', 'Dulce', 'Duncan', 'Durward', 'Dustin', 'Dusty', 'Dwight', 'Dylan', 'Earl', 'Earlene', 'Earline', 'Earnest', 'Earnestine', 'Easter', 'Easton', 'Ebba', 'Ebony', 'Ed', 'Eda', 'Edd', 'Eddie', 'Eden', 'Edgar', 'Edgardo', 'Edison', 'Edmond', 'Edmund', 'Edna', 'Eduardo', 'Edward', 'Edwardo', 'Edwin', 'Edwina', 'Edyth', 'Edythe', 'Effie', 'Efrain', 'Efren', 'Eileen', 'Einar', 'Eino', 'Eladio', 'Elaina', 'Elbert', 'Elda', 'Eldon', 'Eldora', 'Eldred', 'Eldridge', 'Eleanora', 'Eleanore', 'Eleazar', 'Electa', 'Elena', 'Elenor', 'Elenora', 'Eleonore', 'Elfrieda', 'Eli', 'Elian', 'Eliane', 'Elias', 'Eliezer', 'Elijah', 'Elinor', 'Elinore', 'Elisa', 'Elisabeth', 'Elise', 'Eliseo', 'Elisha', 'Elissa', 'Eliza', 'Elizabeth', 'Ella', 'Ellen', 'Ellie', 'Elliot', 'Elliott', 'Ellis', 'Ellsworth', 'Elmer', 'Elmira', 'Elmo', 'Elmore', 'Elna', 'Elnora', 'Elody', 'Eloisa', 'Eloise', 'Elouise', 'Eloy', 'Elroy', 'Elsa', 'Else', 'Elsie', 'Elta', 'Elton', 'Elva', 'Elvera', 'Elvie', 'Elvis', 'Elwin', 'Elwyn', 'Elyse', 'Elyssa', 'Elza', 'Emanuel', 'Emelia', 'Emelie', 'Emely', 'Emerald', 'Emerson', 'Emery', 'Emie', 'Emil', 'Emile', 'Emilia', 'Emiliano', 'Emilie', 'Emilio', 'Emily', 'Emma', 'Emmalee', 'Emmanuel', 'Emmanuelle', 'Emmet', 'Emmett', 'Emmie', 'Emmitt', 'Emmy', 'Emory', 'Ena', 'Enid', 'Enoch', 'Enola', 'Enos', 'Enrico', 'Enrique', 'Ephraim', 'Era', 'Eriberto', 'Eric', 'Erica', 'Erich', 'Erick', 'Ericka', 'Erik', 'Erika', 'Erin', 'Erling', 'Erna', 'Ernest', 'Ernestina', 'Ernestine', 'Ernesto', 'Ernie', 'Ervin', 'Erwin', 'Eryn', 'Esmeralda', 'Esperanza', 'Esta', 'Esteban', 'Estefania', 'Estel', 'Estell', 'Estella', 'Estelle', 'Estevan', 'Esther', 'Estrella', 'Etha', 'Ethan', 'Ethel', 'Ethelyn', 'Ethyl', 'Ettie', 'Eudora', 'Eugene', 'Eugenia', 'Eula', 'Eulah', 'Eulalia', 'Euna', 'Eunice', 'Eusebio', 'Eva', 'Evalyn', 'Evan', 'Evangeline', 'Evans', 'Eve', 'Eveline', 'Evelyn', 'Everardo', 'Everett', 'Everette', 'Evert', 'Evie', 'Ewald', 'Ewell', 'Ezekiel', 'Ezequiel', 'Ezra', 'Fabian', 'Fabiola', 'Fae', 'Fannie', 'Fanny', 'Fatima', 'Faustino', 'Fausto', 'Favian', 'Fay', 'Faye', 'Federico', 'Felicia', 'Felicita', 'Felicity', 'Felipa', 'Felipe', 'Felix', 'Felton', 'Fermin', 'Fern', 'Fernando', 'Ferne', 'Fidel', 'Filiberto', 'Filomena', 'Finn', 'Fiona', 'Flavie', 'Flavio', 'Fleta', 'Fletcher', 'Flo', 'Florence', 'Florencio', 'Florian', 'Florida', 'Florine', 'Flossie', 'Floy', 'Floyd', 'Ford', 'Forest', 'Forrest', 'Foster', 'Frances', 'Francesca', 'Francesco', 'Francis', 'Francisca', 'Francisco', 'Franco', 'Frank', 'Frankie', 'Franz', 'Fred', 'Freda', 'Freddie', 'Freddy', 'Frederic', 'Frederick', 'Frederik', 'Frederique', 'Fredrick', 'Fredy', 'Freeda', 'Freeman', 'Freida', 'Frida', 'Frieda', 'Friedrich', 'Fritz', 'Furman', 'Gabe', 'Gabriel', 'Gabriella', 'Gabrielle', 'Gaetano', 'Gage', 'Gail', 'Gardner', 'Garett', 'Garfield', 'Garland', 'Garnet', 'Garnett', 'Garret', 'Garrett', 'Garrick', 'Garrison', 'Garry', 'Garth', 'Gaston', 'Gavin', 'Gay', 'Gayle', 'Gaylord', 'Gene', 'General', 'Genesis', 'Genevieve', 'Gennaro', 'Genoveva', 'Geo', 'Geoffrey', 'George', 'Georgette', 'Georgiana', 'Georgianna', 'Geovanni', 'Geovanny', 'Geovany', 'Gerald', 'Geraldine', 'Gerard', 'Gerardo', 'Gerda', 'Gerhard', 'Germaine', 'German', 'Gerry', 'Gerson', 'Gertrude', 'Gia', 'Gianni', 'Gideon', 'Gilbert', 'Gilberto', 'Gilda', 'Giles', 'Gillian', 'Gina', 'Gino', 'Giovani', 'Giovanna', 'Giovanni', 'Giovanny', 'Gisselle', 'Giuseppe', 'Gladyce', 'Gladys', 'Glen', 'Glenda', 'Glenna', 'Glennie', 'Gloria', 'Godfrey', 'Golda', 'Golden', 'Gonzalo', 'Gordon', 'Grace', 'Gracie', 'Graciela', 'Grady', 'Graham', 'Grant', 'Granville', 'Grayce', 'Grayson', 'Green', 'Greg', 'Gregg', 'Gregoria', 'Gregorio', 'Gregory', 'Greta', 'Gretchen', 'Greyson', 'Griffin', 'Grover', 'Guadalupe', 'Gudrun', 'Guido', 'Guillermo', 'Guiseppe', 'Gunnar', 'Gunner', 'Gus', 'Gussie', 'Gust', 'Gustave', 'Guy', 'Gwen', 'Gwendolyn', 'Hadley', 'Hailee', 'Hailey', 'Hailie', 'Hal', 'Haleigh', 'Haley', 'Halie', 'Halle', 'Hallie', 'Hank', 'Hanna', 'Hannah', 'Hans', 'Hardy', 'Harley', 'Harmon', 'Harmony', 'Harold', 'Harrison', 'Harry', 'Harvey', 'Haskell', 'Hassan', 'Hassie', 'Hattie', 'Haven', 'Hayden', 'Haylee', 'Hayley', 'Haylie', 'Hazel', 'Hazle', 'Heath', 'Heather', 'Heaven', 'Heber', 'Hector', 'Heidi', 'Helen', 'Helena', 'Helene', 'Helga', 'Hellen', 'Helmer', 'Heloise', 'Henderson', 'Henri', 'Henriette', 'Henry', 'Herbert', 'Herman', 'Hermann', 'Hermina', 'Herminia', 'Herminio', 'Hershel', 'Herta', 'Hertha', 'Hester', 'Hettie', 'Hilario', 'Hilbert', 'Hilda', 'Hildegard', 'Hillard', 'Hillary', 'Hilma', 'Hilton', 'Hipolito', 'Hiram', 'Hobart', 'Holden', 'Hollie', 'Hollis', 'Holly', 'Hope', 'Horace', 'Horacio', 'Hortense', 'Hosea', 'Houston', 'Howard', 'Howell', 'Hoyt', 'Hubert', 'Hudson', 'Hugh', 'Hulda', 'Humberto', 'Hunter', 'Hyman', 'Ian', 'Ibrahim', 'Icie', 'Ida', 'Idell', 'Idella', 'Ignacio', 'Ignatius', 'Ike', 'Ila', 'Ilene', 'Iliana', 'Ima', 'Imani', 'Imelda', 'Immanuel', 'Imogene', 'Ines', 'Irma', 'Irving', 'Irwin', 'Isaac', 'Isabel', 'Isabell', 'Isabella', 'Isabelle', 'Isac', 'Isadore', 'Isai', 'Isaiah', 'Isaias', 'Isidro', 'Ismael', 'Isobel', 'Isom', 'Israel', 'Issac', 'Itzel', 'Iva', 'Ivah', 'Ivory', 'Ivy', 'Izabella', 'Izaiah', 'Jabari', 'Jace', 'Jacey', 'Jacinthe', 'Jacinto', 'Jack', 'Jackeline', 'Jackie', 'Jacklyn', 'Jackson', 'Jacky', 'Jaclyn', 'Jacquelyn', 'Jacques', 'Jacynthe', 'Jada', 'Jade', 'Jaden', 'Jadon', 'Jadyn', 'Jaeden', 'Jaida', 'Jaiden', 'Jailyn', 'Jaime', 'Jairo', 'Jakayla', 'Jake', 'Jakob', 'Jaleel', 'Jalen', 'Jalon', 'Jalyn', 'Jamaal', 'Jamal', 'Jamar', 'Jamarcus', 'Jamel', 'Jameson', 'Jamey', 'Jamie', 'Jamil', 'Jamir', 'Jamison', 'Jammie', 'Jan', 'Jana', 'Janae', 'Jane', 'Janelle', 'Janessa', 'Janet', 'Janice', 'Janick', 'Janie', 'Janis', 'Janiya', 'Jannie', 'Jany', 'Jaquan', 'Jaquelin', 'Jaqueline', 'Jared', 'Jaren', 'Jarod', 'Jaron', 'Jarred', 'Jarrell', 'Jarret', 'Jarrett', 'Jarrod', 'Jarvis', 'Jasen', 'Jasmin', 'Jason', 'Jasper', 'Jaunita', 'Javier', 'Javon', 'Javonte', 'Jay', 'Jayce', 'Jaycee', 'Jayda', 'Jayde', 'Jayden', 'Jaydon', 'Jaylan', 'Jaylen', 'Jaylin', 'Jaylon', 'Jayme', 'Jayne', 'Jayson', 'Jazlyn', 'Jazmin', 'Jazmyn', 'Jazmyne', 'Jean', 'Jeanette', 'Jeanie', 'Jeanne', 'Jed', 'Jedediah', 'Jedidiah', 'Jeff', 'Jefferey', 'Jeffery', 'Jeffrey', 'Jeffry', 'Jena', 'Jenifer', 'Jennie', 'Jennifer', 'Jennings', 'Jennyfer', 'Jensen', 'Jerad', 'Jerald', 'Jeramie', 'Jeramy', 'Jerel', 'Jeremie', 'Jeremy', 'Jermain', 'Jermaine', 'Jermey', 'Jerod', 'Jerome', 'Jeromy', 'Jerrell', 'Jerrod', 'Jerrold', 'Jerry', 'Jess', 'Jesse', 'Jessica', 'Jessie', 'Jessika', 'Jessy', 'Jessyca', 'Jesus', 'Jett', 'Jettie', 'Jevon', 'Jewel', 'Jewell', 'Jillian', 'Jimmie', 'Jimmy', 'Jo', 'Joan', 'Joana', 'Joanie', 'Joanne', 'Joannie', 'Joanny', 'Joany', 'Joaquin', 'Jocelyn', 'Jodie', 'Jody', 'Joe', 'Joel', 'Joelle', 'Joesph', 'Joey', 'Johan', 'Johann', 'Johanna', 'Johathan', 'John', 'Johnathan', 'Johnathon', 'Johnnie', 'Johnny', 'Johnpaul', 'Johnson', 'Jolie', 'Jon', 'Jonas', 'Jonatan', 'Jonathan', 'Jonathon', 'Jordan', 'Jordane', 'Jordi', 'Jordon', 'Jordy', 'Jordyn', 'Jorge', 'Jose', 'Josefa', 'Josefina', 'Joseph', 'Josephine', 'Josh', 'Joshua', 'Joshuah', 'Josiah', 'Josiane', 'Josianne', 'Josie', 'Josue', 'Jovan', 'Jovani', 'Jovanny', 'Jovany', 'Joy', 'Joyce', 'Juana', 'Juanita', 'Judah', 'Judd', 'Jude', 'Judge', 'Judson', 'Judy', 'Jules', 'Julia', 'Julian', 'Juliana', 'Julianne', 'Julie', 'Julien', 'Juliet', 'Julio', 'Julius', 'June', 'Junior', 'Junius', 'Justen', 'Justice', 'Justina', 'Justine', 'Juston', 'Justus', 'Justyn', 'Juvenal', 'Juwan', 'Kacey', 'Kaci', 'Kacie', 'Kade', 'Kaden', 'Kadin', 'Kaela', 'Kaelyn', 'Kaia', 'Kailee', 'Kailey', 'Kailyn', 'Kaitlin', 'Kaitlyn', 'Kale', 'Kaleb', 'Kaleigh', 'Kaley', 'Kali', 'Kallie', 'Kameron', 'Kamille', 'Kamren', 'Kamron', 'Kamryn', 'Kane', 'Kara', 'Kareem', 'Karelle', 'Karen', 'Kari', 'Kariane', 'Karianne', 'Karina', 'Karine', 'Karl', 'Karlee', 'Karley', 'Karli', 'Karlie', 'Karolann', 'Karson', 'Kasandra', 'Kasey', 'Kassandra', 'Katarina', 'Katelin', 'Katelyn', 'Katelynn', 'Katharina', 'Katherine', 'Katheryn', 'Kathleen', 'Kathlyn', 'Kathryn', 'Kathryne', 'Katlyn', 'Katlynn', 'Katrina', 'Katrine', 'Kattie', 'Kavon', 'Kay', 'Kaya', 'Kaycee', 'Kayden', 'Kayla', 'Kaylah', 'Kaylee', 'Kayleigh', 'Kayley', 'Kayli', 'Kaylie', 'Kaylin', 'Keagan', 'Keanu', 'Keara', 'Keaton', 'Keegan', 'Keeley', 'Keely', 'Keenan', 'Keira', 'Keith', 'Kellen', 'Kelley', 'Kelli', 'Kellie', 'Kelly', 'Kelsi', 'Kelsie', 'Kelton', 'Kelvin', 'Ken', 'Kendall', 'Kendra', 'Kendrick', 'Kenna', 'Kennedi', 'Kennedy', 'Kenneth', 'Kennith', 'Kenny', 'Kenton', 'Kenya', 'Kenyatta', 'Kenyon', 'Keon', 'Keshaun', 'Keshawn', 'Keven', 'Kevin', 'Kevon', 'Keyon', 'Keyshawn', 'Khalid', 'Khalil', 'Kian', 'Kiana', 'Kianna', 'Kiara', 'Kiarra', 'Kiel', 'Kiera', 'Kieran', 'Kiley', 'Kim', 'Kimberly', 'King', 'Kip', 'Kira', 'Kirk', 'Kirsten', 'Kirstin', 'Kitty', 'Kobe', 'Koby', 'Kody', 'Kolby', 'Kole', 'Korbin', 'Korey', 'Kory', 'Kraig', 'Kris', 'Krista', 'Kristian', 'Kristin', 'Kristina', 'Kristofer', 'Kristoffer', 'Kristopher', 'Kristy', 'Krystal', 'Krystel', 'Krystina', 'Kurt', 'Kurtis', 'Kyla', 'Kyle', 'Kylee', 'Kyleigh', 'Kyler', 'Kylie', 'Kyra', 'Lacey', 'Lacy', 'Ladarius', 'Lafayette', 'Laila', 'Laisha', 'Lamar', 'Lambert', 'Lamont', 'Lance', 'Landen', 'Lane', 'Laney', 'Larissa', 'Laron', 'Larry', 'Larue', 'Laura', 'Laurel', 'Lauren', 'Laurence', 'Lauretta', 'Lauriane', 'Laurianne', 'Laurie', 'Laurine', 'Laury', 'Lauryn', 'Lavada', 'Lavern', 'Laverna', 'Laverne', 'Lavina', 'Lavinia', 'Lavon', 'Lavonne', 'Lawrence', 'Lawson', 'Layla', 'Layne', 'Lazaro', 'Lea', 'Leann', 'Leanna', 'Leanne', 'Leatha', 'Leda', 'Lee', 'Leif', 'Leila', 'Leilani', 'Lela', 'Lelah', 'Leland', 'Lelia', 'Lempi', 'Lemuel', 'Lenna', 'Lennie', 'Lenny', 'Lenora', 'Lenore', 'Leo', 'Leola', 'Leon', 'Leonard', 'Leonardo', 'Leone', 'Leonel', 'Leonie', 'Leonor', 'Leonora', 'Leopold', 'Leopoldo', 'Leora', 'Lera', 'Lesley', 'Leslie', 'Lesly', 'Lessie', 'Lester', 'Leta', 'Letha', 'Letitia', 'Levi', 'Lew', 'Lewis', 'Lexi', 'Lexie', 'Lexus', 'Lia', 'Liam', 'Liana', 'Libbie', 'Libby', 'Lila', 'Lilian', 'Liliana', 'Liliane', 'Lilla', 'Lillian', 'Lilliana', 'Lillie', 'Lilly', 'Lily', 'Lilyan', 'Lina', 'Lincoln', 'Linda', 'Lindsay', 'Lindsey', 'Linnea', 'Linnie', 'Linwood', 'Lionel', 'Lisa', 'Lisandro', 'Lisette', 'Litzy', 'Liza', 'Lizeth', 'Lizzie', 'Llewellyn', 'Lloyd', 'Logan', 'Lois', 'Lola', 'Lolita', 'Loma', 'Lon', 'London', 'Lonie', 'Lonnie', 'Lonny', 'Lonzo', 'Lora', 'Loraine', 'Loren', 'Lorena', 'Lorenz', 'Lorenza', 'Lorenzo', 'Lori', 'Lorine', 'Lorna', 'Lottie', 'Lou', 'Louie', 'Louisa', 'Lourdes', 'Louvenia', 'Lowell', 'Loy', 'Loyal', 'Loyce', 'Lucas', 'Luciano', 'Lucie', 'Lucienne', 'Lucile', 'Lucinda', 'Lucio', 'Lucious', 'Lucius', 'Lucy', 'Ludie', 'Ludwig', 'Lue', 'Luella', 'Luigi', 'Luis', 'Luisa', 'Lukas', 'Lula', 'Lulu', 'Luna', 'Lupe', 'Lura', 'Lurline', 'Luther', 'Luz', 'Lyda', 'Lydia', 'Lyla', 'Lynn', 'Lyric', 'Lysanne', 'Mabel', 'Mabelle', 'Mable', 'Mac', 'Macey', 'Maci', 'Macie', 'Mack', 'Mackenzie', 'Macy', 'Madaline', 'Madalyn', 'Maddison', 'Madeline', 'Madelyn', 'Madelynn', 'Madge', 'Madie', 'Madilyn', 'Madisen', 'Madison', 'Madisyn', 'Madonna', 'Madyson', 'Mae', 'Maegan', 'Maeve', 'Mafalda', 'Magali', 'Magdalen', 'Magdalena', 'Maggie', 'Magnolia', 'Magnus', 'Maia', 'Maida', 'Maiya', 'Major', 'Makayla', 'Makenna', 'Makenzie', 'Malachi', 'Malcolm', 'Malika', 'Malinda', 'Mallie', 'Mallory', 'Malvina', 'Mandy', 'Manley', 'Manuel', 'Manuela', 'Mara', 'Marc', 'Marcel', 'Marcelina', 'Marcelino', 'Marcella', 'Marcelle', 'Marcellus', 'Marcelo', 'Marcia', 'Marco', 'Marcos', 'Marcus', 'Margaret', 'Margarete', 'Margarett', 'Margaretta', 'Margarette', 'Margarita', 'Marge', 'Margie', 'Margot', 'Margret', 'Marguerite', 'Maria', 'Mariah', 'Mariam', 'Marian', 'Mariana', 'Mariane', 'Marianna', 'Marianne', 'Mariano', 'Maribel', 'Marie', 'Mariela', 'Marielle', 'Marietta', 'Marilie', 'Marilou', 'Marilyne', 'Marina', 'Mario', 'Marion', 'Marisa', 'Marisol', 'Maritza', 'Marjolaine', 'Marjorie', 'Marjory', 'Mark', 'Markus', 'Marlee', 'Marlen', 'Marlene', 'Marley', 'Marlin', 'Marlon', 'Marques', 'Marquis', 'Marquise', 'Marshall', 'Marta', 'Martin', 'Martina', 'Martine', 'Marty', 'Marvin', 'Mary', 'Maryam', 'Maryjane', 'Maryse', 'Mason', 'Mateo', 'Mathew', 'Mathias', 'Mathilde', 'Matilda', 'Matilde', 'Matt', 'Matteo', 'Mattie', 'Maud', 'Maude', 'Maudie', 'Maureen', 'Maurice', 'Mauricio', 'Maurine', 'Maverick', 'Mavis', 'Max', 'Maxie', 'Maxime', 'Maximilian', 'Maximillia', 'Maximillian', 'Maximo', 'Maximus', 'Maxine', 'Maxwell', 'May', 'Maya', 'Maybell', 'Maybelle', 'Maye', 'Maymie', 'Maynard', 'Mayra', 'Mazie', 'Mckayla', 'Mckenna', 'Mckenzie', 'Meagan', 'Meaghan', 'Meda', 'Megane', 'Meggie', 'Meghan', 'Mekhi', 'Melany', 'Melba', 'Melisa', 'Melissa', 'Mellie', 'Melody', 'Melvin', 'Melvina', 'Melyna', 'Melyssa', 'Mercedes', 'Meredith', 'Merl', 'Merle', 'Merlin', 'Merritt', 'Mertie', 'Mervin', 'Meta', 'Mia', 'Micaela', 'Micah', 'Michael', 'Michaela', 'Michale', 'Micheal', 'Michel', 'Michele', 'Michelle', 'Miguel', 'Mikayla', 'Mike', 'Mikel', 'Milan', 'Miles', 'Milford', 'Miller', 'Millie', 'Milo', 'Milton', 'Mina', 'Minerva', 'Minnie', 'Miracle', 'Mireille', 'Mireya', 'Misael', 'Missouri', 'Misty', 'Mitchel', 'Mitchell', 'Mittie', 'Modesta', 'Modesto', 'Mohamed', 'Mohammad', 'Mohammed', 'Moises', 'Mollie', 'Molly', 'Mona', 'Monica', 'Monique', 'Monroe', 'Monserrat', 'Monserrate', 'Montana', 'Monte', 'Monty', 'Morgan', 'Moriah', 'Morris', 'Mortimer', 'Morton', 'Mose', 'Moses', 'Moshe', 'Mossie', 'Mozell', 'Mozelle', 'Muhammad', 'Muriel', 'Murl', 'Murphy', 'Murray', 'Mustafa', 'Mya', 'Myah', 'Mylene', 'Myles', 'Myra', 'Myriam', 'Myrl', 'Myrna', 'Myron', 'Myrtice', 'Myrtie', 'Myrtis', 'Myrtle', 'Nadia', 'Nakia', 'Name', 'Nannie', 'Naomi', 'Naomie', 'Napoleon', 'Narciso', 'Nash', 'Nasir', 'Nat', 'Natalia', 'Natalie', 'Natasha', 'Nathan', 'Nathanael', 'Nathanial', 'Nathaniel', 'Nathen', 'Nayeli', 'Neal', 'Ned', 'Nedra', 'Neha', 'Neil', 'Nelda', 'Nella', 'Nelle', 'Nellie', 'Nels', 'Nelson', 'Neoma', 'Nestor', 'Nettie', 'Neva', 'Newell', 'Newton', 'Nia', 'Nicholas', 'Nicholaus', 'Nichole', 'Nick', 'Nicklaus', 'Nickolas', 'Nico', 'Nicola', 'Nicolas', 'Nicole', 'Nicolette', 'Nigel', 'Nikita', 'Nikki', 'Nikko', 'Niko', 'Nikolas', 'Nils', 'Nina', 'Noah', 'Noble', 'Noe', 'Noel', 'Noelia', 'Noemi', 'Noemie', 'Noemy', 'Nola', 'Nolan', 'Nona', 'Nora', 'Norbert', 'Norberto', 'Norene', 'Norma', 'Norris', 'Norval', 'Norwood', 'Nova', 'Novella', 'Nya', 'Nyah', 'Nyasia', 'Obie', 'Oceane', 'Ocie', 'Octavia', 'Oda', 'Odell', 'Odessa', 'Odie', 'Ofelia', 'Okey', 'Ola', 'Olaf', 'Ole', 'Olen', 'Oleta', 'Olga', 'Olin', 'Oliver', 'Ollie', 'Oma', 'Omari', 'Omer', 'Ona', 'Onie', 'Opal', 'Ophelia', 'Ora', 'Oral', 'Oran', 'Oren', 'Orie', 'Orin', 'Orion', 'Orland', 'Orlando', 'Orlo', 'Orpha', 'Orrin', 'Orval', 'Orville', 'Osbaldo', 'Osborne', 'Oscar', 'Osvaldo', 'Oswald', 'Oswaldo', 'Otha', 'Otho', 'Otilia', 'Otis', 'Ottilie', 'Ottis', 'Otto', 'Ova', 'Owen', 'Ozella', 'Pablo', 'Paige', 'Palma', 'Pamela', 'Pansy', 'Paolo', 'Paris', 'Parker', 'Pascale', 'Pasquale', 'Pat', 'Patience', 'Patricia', 'Patrick', 'Patsy', 'Pattie', 'Paul', 'Paula', 'Pauline', 'Paxton', 'Payton', 'Pearl', 'Pearlie', 'Pearline', 'Pedro', 'Peggie', 'Penelope', 'Percival', 'Percy', 'Perry', 'Pete', 'Peter', 'Petra', 'Peyton', 'Philip', 'Phoebe', 'Phyllis', 'Pierce', 'Pierre', 'Pietro', 'Pink', 'Pinkie', 'Piper', 'Polly', 'Porter', 'Precious', 'Presley', 'Preston', 'Price', 'Prince', 'Princess', 'Priscilla', 'Providenci', 'Prudence', 'Queen', 'Queenie', 'Quentin', 'Quincy', 'Quinn', 'Quinten', 'Quinton', 'Rachael', 'Rachel', 'Rachelle', 'Rae', 'Raegan', 'Rafael', 'Rafaela', 'Raheem', 'Rahsaan', 'Rahul', 'Raina', 'Raleigh', 'Ralph', 'Ramiro', 'Ramon', 'Ramona', 'Randal', 'Randall', 'Randi', 'Randy', 'Ransom', 'Raoul', 'Raphael', 'Raphaelle', 'Raquel', 'Rashad', 'Rashawn', 'Rasheed', 'Raul', 'Raven', 'Ray', 'Raymond', 'Raymundo', 'Reagan', 'Reanna', 'Reba', 'Rebeca', 'Rebecca', 'Rebeka', 'Rebekah', 'Reece', 'Reed', 'Reese', 'Regan', 'Reggie', 'Reginald', 'Reid', 'Reilly', 'Reina', 'Reinhold', 'Remington', 'Rene', 'Renee', 'Ressie', 'Reta', 'Retha', 'Retta', 'Reuben', 'Reva', 'Rex', 'Rey', 'Reyes', 'Reymundo', 'Reyna', 'Reynold', 'Rhea', 'Rhett', 'Rhianna', 'Rhiannon', 'Rhoda', 'Ricardo', 'Richard', 'Richie', 'Richmond', 'Rick', 'Rickey', 'Rickie', 'Ricky', 'Rico', 'Rigoberto', 'Riley', 'Rita', 'River', 'Robb', 'Robbie', 'Robert', 'Roberta', 'Roberto', 'Robin', 'Robyn', 'Rocio', 'Rocky', 'Rod', 'Roderick', 'Rodger', 'Rodolfo', 'Rodrick', 'Rodrigo', 'Roel', 'Rogelio', 'Roger', 'Rogers', 'Rolando', 'Rollin', 'Roma', 'Romaine', 'Roman', 'Ron', 'Ronaldo', 'Ronny', 'Roosevelt', 'Rory', 'Rosa', 'Rosalee', 'Rosalia', 'Rosalind', 'Rosalinda', 'Rosalyn', 'Rosamond', 'Rosanna', 'Rosario', 'Roscoe', 'Rose', 'Rosella', 'Roselyn', 'Rosemarie', 'Rosemary', 'Rosendo', 'Rosetta', 'Rosie', 'Rosina', 'Roslyn', 'Ross', 'Rossie', 'Rowan', 'Rowena', 'Rowland', 'Roxane', 'Roxanne', 'Roy', 'Royal', 'Royce', 'Rozella', 'Ruben', 'Rubie', 'Ruby', 'Rubye', 'Rudolph', 'Rudy', 'Rupert', 'Russ', 'Russel', 'Russell', 'Rusty', 'Ruth', 'Ruthe', 'Ruthie', 'Ryan', 'Ryann', 'Ryder', 'Rylan', 'Rylee', 'Ryleigh', 'Ryley', 'Sabina', 'Sabrina', 'Sabryna', 'Sadie', 'Sadye', 'Sage', 'Saige', 'Sallie', 'Sally', 'Salma', 'Salvador', 'Salvatore', 'Sam', 'Samanta', 'Samantha', 'Samara', 'Samir', 'Sammie', 'Sammy', 'Samson', 'Sandra', 'Sandrine', 'Sandy', 'Sanford', 'Santa', 'Santiago', 'Santina', 'Santino', 'Santos', 'Sarah', 'Sarai', 'Sarina', 'Sasha', 'Saul', 'Savanah', 'Savanna', 'Savannah', 'Savion', 'Scarlett', 'Schuyler', 'Scot', 'Scottie', 'Scotty', 'Seamus', 'Sean', 'Sebastian', 'Sedrick', 'Selena', 'Selina', 'Selmer', 'Serena', 'Serenity', 'Seth', 'Shad', 'Shaina', 'Shakira', 'Shana', 'Shane', 'Shanel', 'Shanelle', 'Shania', 'Shanie', 'Shaniya', 'Shanna', 'Shannon', 'Shanny', 'Shanon', 'Shany', 'Sharon', 'Shaun', 'Shawn', 'Shawna', 'Shaylee', 'Shayna', 'Shayne', 'Shea', 'Sheila', 'Sheldon', 'Shemar', 'Sheridan', 'Sherman', 'Sherwood', 'Shirley', 'Shyann', 'Shyanne', 'Sibyl', 'Sid', 'Sidney', 'Sienna', 'Sierra', 'Sigmund', 'Sigrid', 'Sigurd', 'Silas', 'Sim', 'Simeon', 'Simone', 'Sincere', 'Sister', 'Skye', 'Skyla', 'Skylar', 'Sofia', 'Soledad', 'Solon', 'Sonia', 'Sonny', 'Sonya', 'Sophia', 'Sophie', 'Spencer', 'Stacey', 'Stacy', 'Stan', 'Stanford', 'Stanley', 'Stanton', 'Stefan', 'Stefanie', 'Stella', 'Stephan', 'Stephania', 'Stephanie', 'Stephany', 'Stephen', 'Stephon', 'Sterling', 'Steve', 'Stevie', 'Stewart', 'Stone', 'Stuart', 'Summer', 'Sunny', 'Susan', 'Susana', 'Susanna', 'Susie', 'Suzanne', 'Sven', 'Syble', 'Sydnee', 'Sydney', 'Sydni', 'Sydnie', 'Sylvan', 'Sylvester', 'Sylvia', 'Tabitha', 'Tad', 'Talia', 'Talon', 'Tamara', 'Tamia', 'Tania', 'Tanner', 'Tanya', 'Tara', 'Taryn', 'Tate', 'Tatum', 'Tatyana', 'Taurean', 'Tavares', 'Taya', 'Taylor', 'Teagan', 'Ted', 'Telly', 'Terence', 'Teresa', 'Terrance', 'Terrell', 'Terrence', 'Terrill', 'Terry', 'Tess', 'Tessie', 'Tevin', 'Thad', 'Thaddeus', 'Thalia', 'Thea', 'Thelma', 'Theo', 'Theodora', 'Theodore', 'Theresa', 'Therese', 'Theresia', 'Theron', 'Thomas', 'Thora', 'Thurman', 'Tia', 'Tiana', 'Tianna', 'Tiara', 'Tierra', 'Tiffany', 'Tillman', 'Timmothy', 'Timmy', 'Timothy', 'Tina', 'Tito', 'Titus', 'Tobin', 'Toby', 'Tod', 'Tom', 'Tomas', 'Tomasa', 'Tommie', 'Toney', 'Toni', 'Tony', 'Torey', 'Torrance', 'Torrey', 'Toy', 'Trace', 'Tracey', 'Tracy', 'Travis', 'Travon', 'Tre', 'Tremaine', 'Tremayne', 'Trent', 'Trenton', 'Tressa', 'Tressie', 'Treva', 'Trever', 'Trevion', 'Trevor', 'Trey', 'Trinity', 'Trisha', 'Tristian', 'Tristin', 'Triston', 'Troy', 'Trudie', 'Trycia', 'Trystan', 'Turner', 'Twila', 'Tyler', 'Tyra', 'Tyree', 'Tyreek', 'Tyrel', 'Tyrell', 'Tyrese', 'Tyrique', 'Tyshawn', 'Tyson', 'Ubaldo', 'Ulices', 'Ulises', 'Una', 'Unique', 'Urban', 'Uriah', 'Uriel', 'Ursula', 'Vada', 'Valentin', 'Valentina', 'Valentine', 'Valerie', 'Vallie', 'Van', 'Vance', 'Vanessa', 'Vaughn', 'Veda', 'Velda', 'Vella', 'Velma', 'Velva', 'Vena', 'Verda', 'Verdie', 'Vergie', 'Verla', 'Verlie', 'Vern', 'Verna', 'Verner', 'Vernice', 'Vernie', 'Vernon', 'Verona', 'Veronica', 'Vesta', 'Vicenta', 'Vicente', 'Vickie', 'Vicky', 'Victor', 'Victoria', 'Vida', 'Vidal', 'Vilma', 'Vince', 'Vincent', 'Vincenza', 'Vincenzo', 'Vinnie', 'Viola', 'Violet', 'Violette', 'Virgie', 'Virgil', 'Virginia', 'Virginie', 'Vita', 'Vito', 'Viva', 'Vivian', 'Viviane', 'Vivianne', 'Vivien', 'Vivienne', 'Vladimir', 'Wade', 'Waino', 'Waldo', 'Walker', 'Wallace', 'Walter', 'Walton', 'Wanda', 'Ward', 'Warren', 'Watson', 'Wava', 'Waylon', 'Wayne', 'Webster', 'Weldon', 'Wellington', 'Wendell', 'Wendy', 'Werner', 'Westley', 'Weston', 'Whitney', 'Wilber', 'Wilbert', 'Wilburn', 'Wiley', 'Wilford', 'Wilfred', 'Wilfredo', 'Wilfrid', 'Wilhelm', 'Wilhelmine', 'Will', 'Willa', 'Willard', 'William', 'Willie', 'Willis', 'Willow', 'Willy', 'Wilma', 'Wilmer', 'Wilson', 'Wilton', 'Winfield', 'Winifred', 'Winnifred', 'Winona', 'Winston', 'Woodrow', 'Wyatt', 'Wyman', 'Xander', 'Xavier', 'Xzavier', 'Yadira', 'Yasmeen', 'Yasmin', 'Yasmine', 'Yazmin', 'Yesenia', 'Yessenia', 'Yolanda', 'Yoshiko', 'Yvette', 'Yvonne', 'Zachariah', 'Zachary', 'Zachery', 'Zack', 'Zackary', 'Zackery', 'Zakary', 'Zander', 'Zane', 'Zaria', 'Zechariah', 'Zelda', 'Zella', 'Zelma', 'Zena', 'Zetta', 'Zion', 'Zita', 'Zoe', 'Zoey', 'Zoie', 'Zoila', 'Zola', 'Zora', 'Zula'];\\n\\n/**\\n * Generate random username.\\n * @returns {string} random username\\n */\\nfunction generateUsername() {\\n    var name = RandomUtil.randomElement(names);\\n    var suffix = RandomUtil.randomAlphanumStr(3);\\n\\n    return name + '-' + suffix;\\n}\\n\\nmodule.exports = {\\n    generateUsername: generateUsername\\n};\\n\\n/***/ }),\\n/* 69 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__util_GlobalOnErrorHandler__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/* global callstats */\\n\\n\\n\\n\\nvar logger = __webpack_require__(0).getLogger(__filename);\\n\\n/**\\n * We define enumeration of wrtcFuncNames as we need them before\\n * callstats is initialized to queue events.\\n * @const\\n * @see http://www.callstats.io/api/#enumeration-of-wrtcfuncnames\\n */\\nvar wrtcFuncNames = {\\n    createOffer: 'createOffer',\\n    createAnswer: 'createAnswer',\\n    setLocalDescription: 'setLocalDescription',\\n    setRemoteDescription: 'setRemoteDescription',\\n    addIceCandidate: 'addIceCandidate',\\n    getUserMedia: 'getUserMedia',\\n    iceConnectionFailure: 'iceConnectionFailure',\\n    signalingError: 'signalingError',\\n    applicationLog: 'applicationLog'\\n};\\n\\n/**\\n * We define enumeration of fabricEvent as we need them before\\n * callstats is initialized to queue events.\\n * @const\\n * @see http://www.callstats.io/api/#enumeration-of-fabricevent\\n */\\nvar fabricEvent = {\\n    fabricHold: 'fabricHold',\\n    fabricResume: 'fabricResume',\\n    audioMute: 'audioMute',\\n    audioUnmute: 'audioUnmute',\\n    videoPause: 'videoPause',\\n    videoResume: 'videoResume',\\n    fabricUsageEvent: 'fabricUsageEvent',\\n    fabricStats: 'fabricStats',\\n    fabricTerminated: 'fabricTerminated',\\n    screenShareStart: 'screenShareStart',\\n    screenShareStop: 'screenShareStop',\\n    dominantSpeaker: 'dominantSpeaker',\\n    activeDeviceList: 'activeDeviceList'\\n};\\n\\n/**\\n * The user id to report to callstats as destination.\\n * @type {string}\\n */\\nvar DEFAULT_REMOTE_USER = 'jitsi';\\n\\n/**\\n * Type of pending reports, can be event or an error.\\n * @type {{ERROR: string, EVENT: string}}\\n */\\nvar reportType = {\\n    ERROR: 'error',\\n    EVENT: 'event',\\n    MST_WITH_USERID: 'mstWithUserID'\\n};\\n\\n/**\\n * Set of currently existing {@link CallStats} instances.\\n * @type {Set<CallStats>}\\n */\\nvar _fabrics = void 0;\\n\\n/**\\n * An instance of this class is a wrapper for the CallStats API fabric. A fabric\\n * reports one peer connection the the CallStats backend and is allocated with\\n * {@link callstats.addNewFabric}. It has a bunch of instance methods for\\n * reporting various events. A fabric is considered disposed when\\n * {@link CallStats.sendTerminateEvent} is executed.\\n *\\n * Currently only one backend instance can be created ever and it's done using\\n * {@link CallStats.initBackend}. At the time of this writing there is no way to\\n * explicitly shutdown the backend, but it's supposed to close it's connection\\n * automatically, after all fabrics have been terminated.\\n */\\n\\nvar CallStats = function () {\\n    _createClass(CallStats, null, [{\\n        key: '_addNewFabricCallback',\\n\\n        /**\\n         * A callback passed to {@link callstats.addNewFabric}.\\n         * @param {string} error 'success' means ok\\n         * @param {string} msg some more details\\n         * @private\\n         */\\n        value: function _addNewFabricCallback(error, msg) {\\n            if (CallStats.backend && error !== 'success') {\\n                logger.error('Monitoring status: ' + error + ' msg: ' + msg);\\n            }\\n        }\\n\\n        /**\\n         * Callback passed to {@link callstats.initialize} (backend initialization)\\n         * @param {string} error 'success' means ok\\n         * @param {String} msg\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_initCallback',\\n        value: function _initCallback(error, msg) {\\n            logger.log('CallStats Status: err=' + error + ' msg=' + msg);\\n\\n            // there is no lib, nothing to report to\\n            if (error !== 'success') {\\n                return;\\n            }\\n\\n            CallStats.backendInitialized = true;\\n\\n            // I hate that\\n            var atLeastOneFabric = false;\\n            var defaultInstance = null;\\n\\n            var _iteratorNormalCompletion = true;\\n            var _didIteratorError = false;\\n            var _iteratorError = undefined;\\n\\n            try {\\n                for (var _iterator = CallStats.fabrics.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                    var callStatsInstance = _step.value;\\n\\n                    if (!callStatsInstance.hasFabric) {\\n                        logger.debug('addNewFabric - initCallback');\\n                        if (callStatsInstance._addNewFabric()) {\\n                            atLeastOneFabric = true;\\n                            if (!defaultInstance) {\\n                                defaultInstance = callStatsInstance;\\n                            }\\n                        }\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError = true;\\n                _iteratorError = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion && _iterator.return) {\\n                        _iterator.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError) {\\n                        throw _iteratorError;\\n                    }\\n                }\\n            }\\n\\n            if (!atLeastOneFabric) {\\n                return;\\n            }\\n\\n            CallStats._emptyReportQueue(defaultInstance);\\n        }\\n\\n        /**\\n         * Empties report queue.\\n         *\\n         * @param {CallStats} csInstance - The callstats instance.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_emptyReportQueue',\\n        value: function _emptyReportQueue(csInstance) {\\n            // There is no conference ID nor a PeerConnection available when some of\\n            // the events are scheduled on the reportsQueue, so those will be\\n            // reported on the first initialized fabric.\\n            var defaultConfID = csInstance.confID;\\n            var defaultPC = csInstance.peerconnection;\\n\\n            // notify callstats about failures if there were any\\n            var _iteratorNormalCompletion2 = true;\\n            var _didIteratorError2 = false;\\n            var _iteratorError2 = undefined;\\n\\n            try {\\n                for (var _iterator2 = CallStats.reportsQueue[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                    var report = _step2.value;\\n\\n                    if (report.type === reportType.ERROR) {\\n                        var errorData = report.data;\\n\\n                        CallStats._reportError(csInstance, errorData.type, errorData.error, errorData.pc || defaultPC);\\n                    } else if (report.type === reportType.EVENT) {\\n                        // if we have and event to report and we failed to add\\n                        // fabric this event will not be reported anyway, returning\\n                        // an error\\n                        var eventData = report.data;\\n\\n                        CallStats.backend.sendFabricEvent(report.pc || defaultPC, eventData.event, defaultConfID, eventData.eventData);\\n                    } else if (report.type === reportType.MST_WITH_USERID) {\\n                        var data = report.data;\\n\\n                        CallStats.backend.associateMstWithUserID(report.pc || defaultPC, data.callStatsId, defaultConfID, data.ssrc, data.usageLabel, data.containerId);\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError2 = true;\\n                _iteratorError2 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                        _iterator2.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError2) {\\n                        throw _iteratorError2;\\n                    }\\n                }\\n            }\\n\\n            CallStats.reportsQueue.length = 0;\\n        }\\n\\n        /* eslint-disable max-params */\\n        /**\\n         * Reports an error to callstats.\\n         *\\n         * @param {CallStats} [cs]\\n         * @param type the type of the error, which will be one of the wrtcFuncNames\\n         * @param error the error\\n         * @param pc the peerconnection\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_reportError',\\n        value: function _reportError(cs, type, error, pc) {\\n            var _error = error;\\n\\n            if (!_error) {\\n                logger.warn('No error is passed!');\\n                _error = new Error('Unknown error');\\n            }\\n            if (CallStats.backendInitialized && cs) {\\n                CallStats.backend.reportError(pc, cs.confID, type, _error);\\n            } else {\\n                CallStats.reportsQueue.push({\\n                    type: reportType.ERROR,\\n                    data: {\\n                        error: _error,\\n                        pc: pc,\\n                        type: type\\n                    }\\n                });\\n            }\\n\\n            // else just ignore it\\n        }\\n\\n        /* eslint-enable max-params */\\n\\n        /**\\n         * Reports an error to callstats.\\n         *\\n         * @param {CallStats} cs\\n         * @param event the type of the event, which will be one of the fabricEvent\\n         * @param eventData additional data to pass to event\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_reportEvent',\\n        value: function _reportEvent(cs, event, eventData) {\\n            var pc = cs && cs.peerconnection;\\n            var confID = cs && cs.confID;\\n\\n            if (CallStats.backendInitialized && cs) {\\n                CallStats.backend.sendFabricEvent(pc, event, confID, eventData);\\n            } else {\\n                CallStats.reportsQueue.push({\\n                    confID: confID,\\n                    pc: pc,\\n                    type: reportType.EVENT,\\n                    data: { event: event,\\n                        eventData: eventData }\\n                });\\n            }\\n        }\\n\\n        /**\\n         * Wraps some of the CallStats API method and logs their calls with\\n         * arguments on the debug logging level. Also wraps some of the backend\\n         * methods execution into try catch blocks to not crash the app in case\\n         * there is a problem with the backend itself.\\n         * @param {callstats} theBackend\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_traceAndCatchBackendCalls',\\n        value: function _traceAndCatchBackendCalls(theBackend) {\\n            var tryCatchMethods = ['associateMstWithUserID', 'sendFabricEvent', 'sendUserFeedback'\\n\\n            // 'reportError', - this one needs special handling - see code below\\n            ];\\n\\n            var _loop = function _loop(methodName) {\\n                var originalMethod = theBackend[methodName];\\n\\n                theBackend[methodName] = function () {\\n                    try {\\n                        for (var _len2 = arguments.length, theArguments = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n                            theArguments[_key2] = arguments[_key2];\\n                        }\\n\\n                        return originalMethod.apply(theBackend, theArguments);\\n                    } catch (e) {\\n                        __WEBPACK_IMPORTED_MODULE_1__util_GlobalOnErrorHandler___default.a.callErrorHandler(e);\\n                    }\\n                };\\n            };\\n\\n            var _iteratorNormalCompletion3 = true;\\n            var _didIteratorError3 = false;\\n            var _iteratorError3 = undefined;\\n\\n            try {\\n                for (var _iterator3 = tryCatchMethods[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n                    var methodName = _step3.value;\\n\\n                    _loop(methodName);\\n                }\\n            } catch (err) {\\n                _didIteratorError3 = true;\\n                _iteratorError3 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                        _iterator3.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError3) {\\n                        throw _iteratorError3;\\n                    }\\n                }\\n            }\\n\\n            var debugMethods = ['associateMstWithUserID', 'sendFabricEvent', 'sendUserFeedback'\\n\\n            // 'reportError', - this one needs special handling - see code below\\n            ];\\n\\n            var _loop2 = function _loop2(methodName) {\\n                var originalMethod = theBackend[methodName];\\n\\n                theBackend[methodName] = function () {\\n                    for (var _len3 = arguments.length, theArguments = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n                        theArguments[_key3] = arguments[_key3];\\n                    }\\n\\n                    logger.debug(methodName, theArguments);\\n                    originalMethod.apply(theBackend, theArguments);\\n                };\\n            };\\n\\n            var _iteratorNormalCompletion4 = true;\\n            var _didIteratorError4 = false;\\n            var _iteratorError4 = undefined;\\n\\n            try {\\n                for (var _iterator4 = debugMethods[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n                    var methodName = _step4.value;\\n\\n                    _loop2(methodName);\\n                }\\n            } catch (err) {\\n                _didIteratorError4 = true;\\n                _iteratorError4 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n                        _iterator4.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError4) {\\n                        throw _iteratorError4;\\n                    }\\n                }\\n            }\\n\\n            var originalReportError = theBackend.reportError;\\n\\n            /* eslint-disable max-params */\\n            theBackend.reportError = function (pc, cs, type) {\\n                for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\\n                    args[_key - 3] = arguments[_key];\\n                }\\n\\n                // Logs from the logger are submitted on the applicationLog event\\n                // \\\"type\\\". Logging the arguments on the logger will create endless\\n                // loop, because it will put all the logs to the logger queue again.\\n                if (type === wrtcFuncNames.applicationLog) {\\n                    // NOTE otherArguments are not logged to the console on purpose\\n                    // to not log the whole log batch\\n                    // FIXME check the current logging level (currently not exposed\\n                    // by the logger implementation)\\n                    // NOTE it is not safe to log whole objects on react-native as\\n                    // those contain too many circular references and may crash\\n                    // the app.\\n                    if (!__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isReactNative()) {\\n                        console && console.debug('reportError', pc, cs, type);\\n                    }\\n                } else {\\n                    logger.debug.apply(logger, ['reportError', pc, cs, type].concat(args));\\n                }\\n                try {\\n                    originalReportError.call.apply(originalReportError, [theBackend, pc, cs, type].concat(args));\\n                } catch (exception) {\\n                    if (type === wrtcFuncNames.applicationLog) {\\n                        console && console.error('reportError', exception);\\n                    } else {\\n                        __WEBPACK_IMPORTED_MODULE_1__util_GlobalOnErrorHandler___default.a.callErrorHandler(exception);\\n                    }\\n                }\\n            };\\n\\n            /* eslint-enable max-params */\\n        }\\n\\n        /**\\n         * Returns the Set with the currently existing {@link CallStats} instances.\\n         * Lazily initializes the Set to allow any Set polyfills to be applied.\\n         * @type {Set<CallStats>}\\n         */\\n\\n    }, {\\n        key: 'initBackend',\\n\\n\\n        /**\\n         * Initializes the CallStats backend. Should be called only if\\n         * {@link CallStats.isBackendInitialized} returns <tt>false</tt>.\\n         * @param {object} options\\n         * @param {String} options.callStatsID CallStats credentials - ID\\n         * @param {String} options.callStatsSecret CallStats credentials - secret\\n         * @param {string} options.aliasName the <tt>aliasName</tt> part of\\n         * the <tt>userID</tt> aka endpoint ID, see CallStats docs for more info.\\n         * @param {string} options.userName the <tt>userName</tt> part of\\n         * the <tt>userID</tt> aka display name, see CallStats docs for more info.\\n         *\\n         */\\n        value: function initBackend(options) {\\n            if (CallStats.backend) {\\n                throw new Error('CallStats backend has been initialized already!');\\n            }\\n            try {\\n                // In react-native we need to import the callstats module, but\\n                // imports are only allowed at top-level, so we must use require\\n                // here. Sigh.\\n                var CallStatsBackend = __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isReactNative() ? __webpack_require__(70) : callstats;\\n\\n                CallStats.backend = new CallStatsBackend();\\n\\n                CallStats._traceAndCatchBackendCalls(CallStats.backend);\\n\\n                CallStats.userID = {\\n                    aliasName: options.aliasName,\\n                    userName: options.userName\\n                };\\n                CallStats.callStatsID = options.callStatsID;\\n                CallStats.callStatsSecret = options.callStatsSecret;\\n\\n                var configParams = void 0;\\n\\n                if (options.applicationName) {\\n                    configParams = {\\n                        applicationVersion: options.applicationName + ' (' + __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].getBrowserName() + ')'\\n                    };\\n                }\\n\\n                // userID is generated or given by the origin server\\n                CallStats.backend.initialize(CallStats.callStatsID, CallStats.callStatsSecret, CallStats.userID, CallStats._initCallback, undefined, configParams);\\n\\n                var getWiFiStatsMethod = options.getWiFiStatsMethod;\\n\\n                if (getWiFiStatsMethod) {\\n                    CallStats.backend.attachWifiStatsHandler(getWiFiStatsMethod);\\n\\n                    getWiFiStatsMethod().then(function (result) {\\n                        if (result) {\\n                            logger.info('Reported wifi addresses:', JSON.parse(result).addresses);\\n                        }\\n                    }).catch(function () {}); // eslint-disable-line no-empty-function\\n                }\\n\\n                return true;\\n            } catch (e) {\\n                // The callstats.io API failed to initialize (e.g. because its\\n                // download did not succeed in general or on time). Further attempts\\n                // to utilize it cannot possibly succeed.\\n                __WEBPACK_IMPORTED_MODULE_1__util_GlobalOnErrorHandler___default.a.callErrorHandler(e);\\n                CallStats.backend = null;\\n                logger.error(e);\\n\\n                return false;\\n            }\\n        }\\n\\n        /**\\n         * Checks if the CallStats backend has been created. It does not mean that\\n         * it has been initialized, but only that the API instance has been\\n         * allocated successfully.\\n         * @return {boolean} <tt>true</tt> if backend exists or <tt>false</tt>\\n         * otherwise\\n         */\\n\\n    }, {\\n        key: 'isBackendInitialized',\\n        value: function isBackendInitialized() {\\n            return Boolean(CallStats.backend);\\n        }\\n\\n        /**\\n         * Notifies CallStats about active device.\\n         * @param {{deviceList: {String:String}}} devicesData list of devices with\\n         * their data\\n         * @param {CallStats} cs callstats instance related to the event\\n         */\\n\\n    }, {\\n        key: 'sendActiveDeviceListEvent',\\n        value: function sendActiveDeviceListEvent(devicesData, cs) {\\n            CallStats._reportEvent(cs, fabricEvent.activeDeviceList, devicesData);\\n        }\\n\\n        /**\\n         * Notifies CallStats that there is a log we want to report.\\n         *\\n         * @param {Error} e error to send or {String} message\\n         * @param {CallStats} cs callstats instance related to the error (optional)\\n         */\\n\\n    }, {\\n        key: 'sendApplicationLog',\\n        value: function sendApplicationLog(e, cs) {\\n            try {\\n                CallStats._reportError(cs, wrtcFuncNames.applicationLog, e, cs && cs.peerconnection);\\n            } catch (error) {\\n                // If sendApplicationLog fails it should not be printed to\\n                // the logger, because it will try to push the logs again\\n                // (through sendApplicationLog) and an endless loop is created.\\n                if (console && typeof console.error === 'function') {\\n                    // FIXME send analytics event as well\\n                    console.error('sendApplicationLog failed', error);\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Sends the given feedback through CallStats.\\n         *\\n         * @param {string} conferenceID the conference ID for which the feedback\\n         * will be reported.\\n         * @param overallFeedback an integer between 1 and 5 indicating the\\n         * user feedback\\n         * @param detailedFeedback detailed feedback from the user. Not yet used\\n         */\\n\\n    }, {\\n        key: 'sendFeedback',\\n        value: function sendFeedback(conferenceID, overallFeedback, detailedFeedback) {\\n            if (CallStats.backend) {\\n                CallStats.backend.sendUserFeedback(conferenceID, {\\n                    userID: CallStats.userID,\\n                    overall: overallFeedback,\\n                    comment: detailedFeedback\\n                });\\n            } else {\\n                logger.error('Failed to submit feedback to CallStats - no backend');\\n            }\\n        }\\n\\n        /**\\n         * Notifies CallStats that getUserMedia failed.\\n         *\\n         * @param {Error} e error to send\\n         * @param {CallStats} cs callstats instance related to the error (optional)\\n         */\\n\\n    }, {\\n        key: 'sendGetUserMediaFailed',\\n        value: function sendGetUserMediaFailed(e, cs) {\\n            CallStats._reportError(cs, wrtcFuncNames.getUserMedia, e, null);\\n        }\\n\\n        /**\\n         * Notifies CallStats for mute events\\n         * @param mute {boolean} true for muted and false for not muted\\n         * @param type {String} \\\"audio\\\"/\\\"video\\\"\\n         * @param {CallStats} cs callstats instance related to the event\\n         */\\n\\n    }, {\\n        key: 'sendMuteEvent',\\n        value: function sendMuteEvent(mute, type, cs) {\\n            var event = void 0;\\n\\n            if (type === 'video') {\\n                event = mute ? fabricEvent.videoPause : fabricEvent.videoResume;\\n            } else {\\n                event = mute ? fabricEvent.audioMute : fabricEvent.audioUnmute;\\n            }\\n\\n            CallStats._reportEvent(cs, event);\\n        }\\n\\n        /**\\n         * Creates new CallStats instance that handles all callstats API calls for\\n         * given {@link TraceablePeerConnection}. Each instance is meant to handle\\n         * one CallStats fabric added with 'addFabric' API method for the\\n         * {@link TraceablePeerConnection} instance passed in the constructor.\\n         * @param {TraceablePeerConnection} tpc\\n         * @param {Object} options\\n         * @param {string} options.confID the conference ID that wil be used to\\n         * report the session.\\n         * @param {string} [options.remoteUserID='jitsi'] the remote user ID to\\n         * which given <tt>tpc</tt> is connected.\\n         */\\n\\n    }, {\\n        key: 'fabrics',\\n        get: function get() {\\n            if (!_fabrics) {\\n                _fabrics = new Set();\\n            }\\n\\n            return _fabrics;\\n        }\\n    }]);\\n\\n    function CallStats(tpc, options) {\\n        _classCallCheck(this, CallStats);\\n\\n        this.confID = options.confID;\\n        this.tpc = tpc;\\n        this.peerconnection = tpc.peerconnection;\\n        this.remoteUserID = options.remoteUserID || DEFAULT_REMOTE_USER;\\n        this.hasFabric = false;\\n\\n        CallStats.fabrics.add(this);\\n\\n        if (CallStats.backendInitialized) {\\n            this._addNewFabric();\\n\\n            // if this is the first fabric let's try to empty the\\n            // report queue. Reports all events that we recorded between\\n            // backend initialization and receiving the first fabric\\n            if (CallStats.fabrics.size === 1) {\\n                CallStats._emptyReportQueue(this);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Initializes CallStats fabric by calling \\\"addNewFabric\\\" for\\n     * the peer connection associated with this instance.\\n     * @return {boolean} true if the call was successful or false otherwise.\\n     */\\n\\n\\n    _createClass(CallStats, [{\\n        key: '_addNewFabric',\\n        value: function _addNewFabric() {\\n            logger.info('addNewFabric', this.remoteUserID);\\n            try {\\n                var fabricAttributes = {\\n                    remoteEndpointType: this.tpc.isP2P ? CallStats.backend.endpointType.peer : CallStats.backend.endpointType.server\\n                };\\n                var ret = CallStats.backend.addNewFabric(this.peerconnection, this.remoteUserID, CallStats.backend.fabricUsage.multiplex, this.confID, fabricAttributes, CallStats._addNewFabricCallback);\\n\\n                this.hasFabric = true;\\n\\n                var success = ret.status === 'success';\\n\\n                if (!success) {\\n                    logger.error('callstats fabric not initilized', ret.message);\\n                }\\n\\n                return success;\\n            } catch (error) {\\n                __WEBPACK_IMPORTED_MODULE_1__util_GlobalOnErrorHandler___default.a.callErrorHandler(error);\\n\\n                return false;\\n            }\\n        }\\n\\n        /* eslint-disable max-params */\\n\\n        /**\\n         * Lets CallStats module know where is given SSRC rendered by providing\\n         * renderer tag ID.\\n         * If the lib is not initialized yet queue the call for later, when it's\\n         * ready.\\n         * @param {number} ssrc the SSRC of the stream\\n         * @param {boolean} isLocal indicates whether this the stream is local\\n         * @param {string|null} streamEndpointId if the stream is not local the it\\n         * needs to contain the stream owner's ID\\n         * @param {string} usageLabel meaningful usage label of this stream like\\n         *        'microphone', 'camera' or 'screen'.\\n         * @param {string} containerId  the id of media 'audio' or 'video' tag which\\n         *        renders the stream.\\n         */\\n\\n    }, {\\n        key: 'associateStreamWithVideoTag',\\n        value: function associateStreamWithVideoTag(ssrc, isLocal, streamEndpointId, usageLabel, containerId) {\\n            if (!CallStats.backend) {\\n                return;\\n            }\\n\\n            var callStatsId = isLocal ? CallStats.userID : streamEndpointId;\\n\\n            if (CallStats.backendInitialized) {\\n                CallStats.backend.associateMstWithUserID(this.peerconnection, callStatsId, this.confID, ssrc, usageLabel, containerId);\\n            } else {\\n                CallStats.reportsQueue.push({\\n                    type: reportType.MST_WITH_USERID,\\n                    pc: this.peerconnection,\\n                    data: {\\n                        callStatsId: callStatsId,\\n                        containerId: containerId,\\n                        ssrc: ssrc,\\n                        usageLabel: usageLabel\\n                    }\\n                });\\n            }\\n        }\\n\\n        /* eslint-enable max-params */\\n\\n        /**\\n         * Notifies CallStats that we are the new dominant speaker in the\\n         * conference.\\n         */\\n\\n    }, {\\n        key: 'sendDominantSpeakerEvent',\\n        value: function sendDominantSpeakerEvent() {\\n            CallStats._reportEvent(this, fabricEvent.dominantSpeaker);\\n        }\\n\\n        /**\\n         * Notifies CallStats that the fabric for the underlying peerconnection was\\n         * closed and no evens should be reported, after this call.\\n         */\\n\\n    }, {\\n        key: 'sendTerminateEvent',\\n        value: function sendTerminateEvent() {\\n            if (CallStats.backendInitialized) {\\n                CallStats.backend.sendFabricEvent(this.peerconnection, CallStats.backend.fabricEvent.fabricTerminated, this.confID);\\n            }\\n            CallStats.fabrics.delete(this);\\n        }\\n\\n        /**\\n         * Notifies CallStats for ice connection failed\\n         */\\n\\n    }, {\\n        key: 'sendIceConnectionFailedEvent',\\n        value: function sendIceConnectionFailedEvent() {\\n            CallStats._reportError(this, wrtcFuncNames.iceConnectionFailure, null, this.peerconnection);\\n        }\\n\\n        /**\\n         * Notifies CallStats that peer connection failed to create offer.\\n         *\\n         * @param {Error} e error to send\\n         */\\n\\n    }, {\\n        key: 'sendCreateOfferFailed',\\n        value: function sendCreateOfferFailed(e) {\\n            CallStats._reportError(this, wrtcFuncNames.createOffer, e, this.peerconnection);\\n        }\\n\\n        /**\\n         * Notifies CallStats that peer connection failed to create answer.\\n         *\\n         * @param {Error} e error to send\\n         */\\n\\n    }, {\\n        key: 'sendCreateAnswerFailed',\\n        value: function sendCreateAnswerFailed(e) {\\n            CallStats._reportError(this, wrtcFuncNames.createAnswer, e, this.peerconnection);\\n        }\\n\\n        /**\\n         * Sends either resume or hold event for the fabric associated with\\n         * the underlying peerconnection.\\n         * @param {boolean} isResume true to resume or false to hold\\n         */\\n\\n    }, {\\n        key: 'sendResumeOrHoldEvent',\\n        value: function sendResumeOrHoldEvent(isResume) {\\n            CallStats._reportEvent(this, isResume ? fabricEvent.fabricResume : fabricEvent.fabricHold);\\n        }\\n\\n        /**\\n         * Notifies CallStats for screen sharing events\\n         * @param {boolean} start true for starting screen sharing and\\n         * false for not stopping\\n         * @param {string|null} ssrc - optional ssrc value, used only when\\n         * starting screen sharing.\\n         */\\n\\n    }, {\\n        key: 'sendScreenSharingEvent',\\n        value: function sendScreenSharingEvent(start, ssrc) {\\n            var eventData = void 0;\\n\\n            if (ssrc) {\\n                eventData = { ssrc: ssrc };\\n            }\\n\\n            CallStats._reportEvent(this, start ? fabricEvent.screenShareStart : fabricEvent.screenShareStop, eventData);\\n        }\\n\\n        /**\\n         * Notifies CallStats that peer connection failed to set local description.\\n         *\\n         * @param {Error} e error to send\\n         */\\n\\n    }, {\\n        key: 'sendSetLocalDescFailed',\\n        value: function sendSetLocalDescFailed(e) {\\n            CallStats._reportError(this, wrtcFuncNames.setLocalDescription, e, this.peerconnection);\\n        }\\n\\n        /**\\n         * Notifies CallStats that peer connection failed to set remote description.\\n         *\\n         * @param {Error} e error to send\\n         */\\n\\n    }, {\\n        key: 'sendSetRemoteDescFailed',\\n        value: function sendSetRemoteDescFailed(e) {\\n            CallStats._reportError(this, wrtcFuncNames.setRemoteDescription, e, this.peerconnection);\\n        }\\n\\n        /**\\n         * Notifies CallStats that peer connection failed to add ICE candidate.\\n         *\\n         * @param {Error} e error to send\\n         */\\n\\n    }, {\\n        key: 'sendAddIceCandidateFailed',\\n        value: function sendAddIceCandidateFailed(e) {\\n            CallStats._reportError(this, wrtcFuncNames.addIceCandidate, e, this.peerconnection);\\n        }\\n    }]);\\n\\n    return CallStats;\\n}();\\n\\n/**\\n * The CallStats API backend instance\\n * @type {callstats}\\n */\\n\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (CallStats);\\nCallStats.backend = null;\\n\\n// some errors/events may happen before CallStats init\\n// in this case we accumulate them in this array\\n// and send them to callstats on init\\nCallStats.reportsQueue = [];\\n\\n/**\\n * Whether the library was successfully initialized(the backend) using its\\n * initialize method.\\n * @type {boolean}\\n */\\nCallStats.backendInitialized = false;\\n\\n/**\\n * Part of the CallStats credentials - application ID\\n * @type {string}\\n */\\nCallStats.callStatsID = null;\\n\\n/**\\n * Part of the CallStats credentials - application secret\\n * @type {string}\\n */\\nCallStats.callStatsSecret = null;\\n\\n/**\\n * Local CallStats user ID structure. Can be set only once when\\n * {@link backend} is initialized, so it's static for the time being.\\n * See CallStats API for more info:\\n * https://www.callstats.io/api/#userid\\n * @type {object}\\n */\\nCallStats.userID = null;\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/statistics/CallStats.js\\\"))\\n\\n/***/ }),\\n/* 70 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! callstats.js  version = 3.27.0 2017-12-14 */\\n!function(){function a(){function a(){var a=(Math.random()+1).toString(36);return a.substring(2,a.length)}function b(){return window.performance.now?window.performance.now()+window.performance.timing.navigationStart:Date.now()}function c(){var a=b();return a+bb.currentOffset}function d(a){if(!$a||!$a.rtc_rtp_parameters||!$a.rtc_rtp_parameters.encodings)return void a.streams.forEach(function(a){var b=a.data;\\\"video\\\"===b.mediaType&&a.streamType===ub.outbound&&(b.csioSCSValidationSampleCount=null,b.csioAvgMaxBitrateDiff=null,b.csioAvgDeltaThroughput=null,b.csioMaxBitrateAboveRatio=null,b.csioCCDrivenRatio=null)});var b=function(a){return Sb[a]?Sb[a]:(Sb[a]={total:0,above:0,ccDriven:0,sumMaxBitrateDiff:0,sumThroughputDiff:0,prevCsioAvgBRKbps:0},Sb[a])},c=function(a,c,d,e,f){var g=b(a.ssrc);a.csioSCSValidationSampleCount=++g.total,g.sumMaxBitrateDiff+=c,a.csioAvgMaxBitrateDiff=g.sumMaxBitrateDiff/g.total,g.sumThroughputDiff+=d,a.csioAvgDeltaThroughput=g.sumThroughputDiff/g.total,e&&(g.above+=1),a.csioMaxBitrateAboveRatio=g.above/g.total,f&&(g.ccDriven+=1),a.csioCCDrivenRatio=g.ccDriven/g.total},d=0;$a.rtc_rtp_parameters.encodings.forEach(function(a){a&&(d=Math.max(d,a.maxBitrate))});var e=0;if(_a){_a.encodings.forEach(function(a){e=Math.max(e,a.maxBitrate)});var f=0,g=0,h=null,i=null;a.streams.forEach(function(a){var j=a.data,k=b(j.ssrc);\\\"video\\\"===j.mediaType&&a.streamType===ub.outbound&&(0<e&&.9*e<1e3*j.csioAvgBRKbps?(f=d-e,i=!1):(f=d-1e3*j.csioAvgBRKbps,i=!0),h=0<f,g=j.csioAvgBRKbps-k.prevCsioAvgBRKbps,k.prevCsioAvgBRKbps=j.csioAvgBRKbps,c(j,f,g,h,i))})}}function e(){return window.performance.now?window.performance.now():null}function f(){navigator&&\\\"function\\\"==typeof navigator.getBattery&&navigator.getBattery().then(function(a){Xa=a})}function g(){if(Xa)return Xa.level}function h(){if(Xa)return Xa.charging}function i(a,b){return a.sort().toString()===b.sort().toString()}function j(a,b,c){navigator&&navigator.mediaDevices&&navigator.mediaDevices.enumerateDevices&&navigator.mediaDevices.enumerateDevices().then(function(d){la?i(la,d)||(la=d,_b(a,b,c)):(la=d,_b(a,b,c)),setTimeout(function(){j(a,b,c)},sa)}).catch(function(){setTimeout(function(){j(a,b,c)},sa)})}function k(){Z&&Z().then(function(a){ka=JSON.parse(a),setTimeout(function(){k()},ta)}).catch(function(){setTimeout(function(){k()},ta)})}function l(){qa||window&&window.addEventListener&&window.addEventListener(\\\"beforeunload\\\",function(a){var b;for(b in ab)ab.hasOwnProperty(b)&&Xb(jb.userLeft,null,b,ab[b].ucID,null,null,null);return cb&&(bb.offsetResults=[],bb.syncHandler=null,cb=!1),\\\"Are you sure you want to close the call?\\\"})}function m(a,b,c,d,f){var g=kc(c,d),h=null;g&&(h=e(),Xb(jb.mediaPlaybackStartEvent,b,c,a,{ssrc:f,highResTs:h},g,null))}function n(a,b,c,d,f){var g=kc(c,d),h=null;g&&(h=e(),Xb(jb.mediaSuspendedEvent,b,c,a,{ssrc:f,highResTs:h},g,null))}function o(a,b,c,d){var e,f=document.getElementById(b);f&&(f.oncanplay=function(){e=ab[a].ucID;var b=jc(a,c);b&&m(e,b.remoteUserID,a,c,d)},f.onsuspend=function(){e=ab[a].ucID;var b=jc(a,c);b&&n(e,b.remoteUserID,a,c,d)})}function p(a){var b=Aa.codebase,c=!1;if(null===a)c=!1;else if(b===Fb.firefox){var d=typeof mozRTCPeerConnection,e=typeof RTCPeerConnection;\\\"undefined\\\"!==d&&a instanceof mozRTCPeerConnection?c=!0:\\\"undefined\\\"!==e&&a instanceof RTCPeerConnection&&(c=!0)}else null!==hb&&a instanceof hb&&(c=!0),\\\"function\\\"!=typeof a&&b!==Fb.edge||(c=!0),void 0!==typeof a.createOffer&&(c=!0);return c}function q(a,b){var c;return a&&(b===Fb.chrome?a.googLocalAddress?(c=a.googLocalAddress,c.concat(\\\":\\\",a.googRemoteAddress)):a.selectedCandidatePairId&&(c=a.selectedCandidatePairId):b===Fb.firefox&&(a.localAddr?(c=a.localAddr,c.concat(\\\":\\\",a.remoteAddr)):a.selectedCandidatePairId&&(c=a.selectedCandidatePairId))),cc(c)}function r(){var a;return a=navigator.onLine===!0?\\\"online\\\":\\\"offline\\\"}function s(a,b,c){var d=null;c.ssrcMap.hasOwnProperty(a.data.ssrc)&&(c.ssrcMap[a.data.ssrc].mediaType=a.data.mediaType,a.data.googCodecName?d=a.data.googCodecName:a.data.codec&&(d=a.data.codec),c.ssrcMap[a.data.ssrc].codec=d,a.data.codecImplementationName&&(c.ssrcMap[a.data.ssrc].codecImplementationName=a.data.codecImplementationName))}function t(a,b,c){var d,e,f,g,h,i,j,k,l=[];if(void 0!==a.lastStatsSent&&void 0!==a.lastStatsSent.statistics.Transport)for(f=a.lastStatsSent.statistics.Transport,g=a.latestEventSent,h=void 0,d=0;d<b.length;d++){for(h=void 0,e=0;e<f.length;e++)if(b[d].hash===f[e].hash){h=f[e];break}void 0!==h&&(i=parseInt(h.bytesReceived,10),j=parseInt(h.bytesSent,10),k=c-g,k>0&&(b[d].csioReceivedBwKbps=8*(parseInt(b[d].bytesReceived,10)-i)/k,b[d].csioSentBwKbps=8*(parseInt(b[d].bytesSent,10)-j)/k,b[d].csioIntBytesReceived=parseInt(b[d].bytesReceived,10)-i,b[d].csioIntBytesSent=parseInt(b[d].bytesSent,10)-j,void 0!==h.packetsSent&&void 0!==b[d].packetsSent&&(b[d].csioSentPacketRate=(parseInt(b[d].packetsSent,10)-parseInt(h.packetsSent,10))/(k/1e3),b[d].csioIntPacketsSent=parseInt(b[d].packetsSent,10)-parseInt(h.packetsSent,10)),void 0!==h.packetsReceived&&void 0!==b[d].packetsReceived&&(b[d].csioReceivedPacketRate=(parseInt(b[d].packetsReceived,10)-parseInt(h.packetsReceived,10))/(k/1e3),b[d].csioIntPacketsReceived=parseInt(b[d].packetsReceived,10)-parseInt(h.packetsReceived,10))),l.push(b[d]))}return l}function u(a,b,c,d){var e=[];return c===Fb.firefox?e=b:b&&(e=t(a,b,d)),e}function v(a){var b,c,d;for(b in a.streams)if(a.streams.hasOwnProperty(b)){if(a.streams[b].inbound)for(d in a.streams[b].inbound)a.streams[b].inbound.hasOwnProperty(d)&&(c=a.streams[b].inbound[d].mark,c===wb.bad?a.streams[b].inbound[d].mark=2:c===wb.fair?a.streams[b].inbound[d].mark=1:a.streams[b].inbound[d].mark=0);if(a.streams[b].outbound)for(d in a.streams[b].outbound)a.streams[b].outbound.hasOwnProperty(d)&&(c=a.streams[b].outbound[d].mark,c===wb.bad?a.streams[b].outbound[d].mark=2:c===wb.fair?a.streams[b].outbound[d].mark=1:a.streams[b].outbound[d].mark=0)}return a}function w(a){var b={},c=od.getConferenceURL();return a.connectionState&&(b.connectionState=a.connectionState),a.fabricState&&(b.fabricState=a.fabricState),c&&(b.conferenceURL=c),b.streams={},null===a.streams?b:(a.streams.forEach(function(a){var c={cname:a.cname,ssrc:a.ssrc,msid:a.msid,remoteUserID:a.userID,usageLabel:a.usage,associatedVideoTag:a.associatedVideoTag};a.data.hasOwnProperty(\\\"csioIntFL\\\")&&(c.fractionLoss=a.data.csioIntFL),a.data.hasOwnProperty(\\\"csioIntBRKbps\\\")&&(c.bitrate=a.data.csioIntBRKbps),a.data.hasOwnProperty(\\\"csioMark\\\")&&(c.quality=a.data.csioMark),a.data.hasOwnProperty(\\\"csioMediaType\\\")&&(c.mediaType=a.data.csioMediaType),a.data.hasOwnProperty(\\\"googRtt\\\")&&(c.rtt=a.data.googRtt),a.data.hasOwnProperty(\\\"mozRtt\\\")&&(c.rtt=a.data.mozRtt),a.data.hasOwnProperty(\\\"roundTripTime\\\")&&(c.rtt=a.data.roundTripTime),a.data.hasOwnProperty(\\\"jitter\\\")&&(c.jitter=a.data.jitter),a.data.hasOwnProperty(\\\"googJitterReceived\\\")&&(c.jitter=a.data.googJitterReceived),a.data.hasOwnProperty(\\\"audioOutputLevel\\\")&&(c.audioOutputLevel=a.data.audioOutputLevel),a.data.hasOwnProperty(\\\"audioInputLevel\\\")&&(c.audioInputLevel=a.data.audioInputLevel),a.data.hasOwnProperty(\\\"audioLevel\\\")&&(c.audioLevel=a.data.audioLevel),a.data.hasOwnProperty(\\\"csioAvgRtt\\\")&&(c.averageRTT=a.data.csioAvgRtt),a.data.hasOwnProperty(\\\"csioAvgJitter\\\")&&(c.averageJitter=a.data.csioAvgJitter),a.data.hasOwnProperty(\\\"csioPktLossPercentage\\\")&&(c.packetLossPercentage=a.data.csioPktLossPercentage),a.reportType&&\\\"local\\\"===a.reportType?a.streamType&&(c.statsType=a.streamType+\\\"-rtp\\\"):a.reportType&&\\\"remote\\\"===a.reportType&&a.streamType&&(c.statsType=\\\"remote-\\\"+a.streamType+\\\"-rtp\\\"),b.streams[a.ssrc]=c}),b)}function x(a,b,d,e,f,g){var h=c();a.hasOwnProperty(\\\"token\\\")&&a.hasOwnProperty(\\\"ucID\\\")&&!cb?(S(kb.processedStats,a,g),b.latestEventSent=h,b.lastFabricState=b.pcState):(a.clockUnsynced=cb,Oa.cacheEvent({channel:kb.processedStats,data:a}))}function y(a,b){for(var c in b)b.hasOwnProperty(c)&&\\\"id\\\"!==c&&\\\"type\\\"!==c&&\\\"timestamp\\\"!==c&&(a[c]=b[c]);return a}function z(a,e,f,i,j){function k(k){if(k){var l=c(),m=b();void 0===i.lastRawStatsSentInterval||null===i.lastRawStatsSentInterval?i.lastRawStatsSentInterval=m-i.statsPollingStart:i.lastRawStatsSentInterval=m-i.rawstatsTS+i.lastRawStatsSentInterval,void 0===i.lastProcessedStatsSentInterval||null===i.lastProcessedStatsSentInterval?i.lastProcessedStatsSentInterval=Fa+1:i.lastProcessedStatsSentInterval=m-i.rawstatsTS+i.lastProcessedStatsSentInterval,i.rawstatsTS=m;var n={},o=Aa.codebase,p=i.conferenceID,t=i.remoteUserID;n.version=da,n.appID=ma,n.conferenceID=encodeURIComponent(p),n.apiTS=l,n.timeShift=0,n.fabricState=i.pcState,n.pcID=i.pcHash,void 0!==f&&(n.ucID=f),Ua.authToken&&(n.token=Ua.authToken),n.localID=encodeURIComponent(e),n.remoteID=t?encodeURIComponent(t):null,n.deviceID=pa;var y,z,A,C,G,H,J,K={streams:[]},L=null,M=!1,N=!1,O={},P={};for(L=nc(k),y=0;y<L.length;++y)if(z=E(L[y]),A=B(z),!F(A))if(A.hasOwnProperty(\\\"Transport\\\"))C=\\\"Transport\\\",K.hasOwnProperty(C)||(K[C]=[]),o!==Fb.firefox?(parseInt(A[C].bytesReceived,10)>0||parseInt(A[C].bytesSent,10)>0)&&(K[C].push(A[C]),\\\"true\\\"!==A[C].googActiveConnection&&A[C].googActiveConnection!==!0||(n.activeConnectionIndex=K[C].length)):(K[C].push(A[C]),\\\"true\\\"!==A[C].selected&&A[C].selected!==!0||(n.activeConnectionIndex=K[C].length));else if(A.localCandidate)O[A.localCandidate.id]=A.localCandidate;else if(A.remoteCandidate)P[A.remoteCandidate.id]=A.remoteCandidate;else if(A.bwe)K.bwe=A.bwe;else if(A.trackStats)K.trackStats||(K.trackStats=[]),K.trackStats.push(A.trackStats);else if(A.codec)K.codec||(K.codec=[]),K.codec.push(A.codec);else if(A.candidatePair)K.candidatePair||(K.candidatePair=[]),K.candidatePair.push(A.candidatePair);else{H=Ub(i,A.ssrc),void 0!==H&&H.localStartTime||(J=Wb(t,p,f,i,j,null),J&&(N=!0),H=Ub(i,A.ssrc)),H&&(G=H.remoteUserID),void 0===G&&(G=t);var Q={userID:G,data:A.data,reportType:A.reportType,streamType:A.streamType,ssrc:A.ssrc};void 0!==H&&(Q.cname=H.cname,Q.msid=H.msid,Q.associatedVideoTag=H.associatedVideoTag,Q.usage=H.usageLabel),K.streams.push(Q)}if(n.statistics=K,K.Transport&&(M=D(K.Transport,i)),M&&cd(j,jb.fabricTransportSwitch,p),K.Transport||o!==Fb.firefox||(K.Transport=K.candidatePair.filter(function(a){return!(!a.selected&&\\\"true\\\"!==a.selected)})),K.Transport)for(var R=0;R<K.Transport.length;R++)K.Transport[R].hash=q(K.Transport[R],o);i.pcState===xb.disrupted&&I(n),K.trackStats&&(K=hd(K)),K.Transport&&K.candidatePair&&(K=gd(K)),N&&Xb(jb.ssrcMap,t,p,f,Vb(i),i.pcHash),Za&&(Xb(kb.senderConfiguration,t,p,f,$a,i.pcHash),Za=!1);var S={},T={response:null},V={response:null},W={response:null},X=null;if(ja.fire(ja.events.OnPolling,{streams:K.streams,codeBase:o}),ja.fire(ja.events.OnOneWayAudioDisruptionsRequest,V),null!==V.response&&V.response.forEach(function(a){X={mediaType:a.mediaType,ssrc:a.ssrc,disruptionType:a.type},Xb(jb.oneWayMedia,t,p,f,X,i.pcHash)}),ja.fire(ja.events.OnSendingThroughputObservationsRequest,W),null!==W.response&&(X=W.response,Xb(kb.sendingThroughputObservations,t,p,f,X,i.pcHash)),ja.fire(ja.events.OnStatsRequest,T),null!==T.response){if(T.response.streams)for(y=0;y<T.response.streams.length;y++)s(T.response.streams[y],o,i);S.streams=T.response.streams;for(var Y=0<Ma.length,Z=0,$=function(a){a.data.ssrc===Z&&(Y|=\\\"audio\\\"===a.mediaType&&a.streamType===ub.inbound)};0<Ma.length;)Z=Ma.shift(),S.streams.forEach($);if(Y){var _={mediaType:\\\"audio\\\",ssrc:null,disruptionType:vb.noInboundAudioOnlyFabric};Xb(jb.oneWayMedia,t,p,f,_,i.pcHash)}if(S.fabricState=i.pcState,S.connectionState=r(),K.Transport&&(S.Transport=u(i,K.Transport,o,l)),K.bwe&&(S.bwe=K.bwe),void 0===i.processedStatsTupleArray&&(i.processedStatsTupleArray=[]),Da.stats){var aa=w(S);Da.stats(aa)}S.apiTS=l,S.batteryStatus={},S.batteryStatus.batteryLevel=g(),S.batteryStatus.isBatteryCharging=h(),S.wifiStats=ka,S=v(S),d(S),i.processedStatsTupleArray.push(S),n.processedStatistics=i.processedStatsTupleArray,i.lastStatsSent=n;var ba=U(n);delete ba.statistics,i.lastProcessedStatsSentInterval>=Fa&&(i.processedStatsTupleArray=[],Ra.add(ba,ba.processedStatistics.length),ba.msgStat=Ra.getStat(),x(ba,i,p,t,e,a),i.lastProcessedStatsSentInterval=0)}}}return k}function A(a){var b;return yb.hasOwnProperty(a)?a===yb.createOffer||a===yb.createAnswer||a===yb.setRemoteDescription?b=zb.negotiationFailure:a===yb.setLocalDescription?b=zb.sdpError:a===yb.addIceCandidate?b=zb.sdpError:a===yb.getUserMedia?b=zb.mediaConfigError:a===yb.iceConnectionFailure?b=zb.iceFailure:a===yb.signalingError?b=zb.signalingError:(a===yb.applicationLog||yb.applicationError)&&(b=zb.applicationLog):b=Pb.invalidWebRTCFunctionName,b}function B(a){var b={};if(\\\"inboundrtp\\\"===a.type||\\\"outboundrtp\\\"===a.type||\\\"inbound-rtp\\\"===a.type||\\\"outbound-rtp\\\"===a.type){if(b.ssrc=a.ssrc,b.streamType=\\\"inboundrtp\\\"===a.type||\\\"inbound-rtp\\\"===a.type?\\\"inbound\\\":\\\"outbound\\\",\\\"Safari\\\"===Aa.name&&!a.mediaType){a.id.includes(\\\"Audio\\\")?a.mediaType=\\\"audio\\\":a.id.includes(\\\"Video\\\")&&(a.mediaType=\\\"video\\\");var c=a.id.split(\\\"_\\\");if(c[1])try{a.ssrc=parseInt(c[1]),b.ssrc=a.ssrc}catch(a){}}b.data=a,void 0!==a.isRemote?b.reportType=\\\"true\\\"===a.isRemote||a.isRemote===!0?\\\"remote\\\":\\\"local\\\":b.reportType=\\\"local\\\",a.trackId&&(b.trackId=a.trackId),a.mediaType&&(b.mediaType=a.mediaType)}else\\\"candidatepair\\\"===a.type&&a.selected?b.Transport=a:\\\"localcandidate\\\"===a.type||\\\"local-candidate\\\"===a.type?b.localCandidate=a:\\\"remotecandidate\\\"===a.type||\\\"remote-candidate\\\"===a.type?b.remoteCandidate=a:\\\"transport\\\"===a.type||\\\"googCandidatePair\\\"===a.type?b.Transport=a:\\\"VideoBwe\\\"===a.type?b.bwe=a:\\\"track\\\"===a.type?b.trackStats=a:\\\"candidate-pair\\\"===a.type?b.candidatePair=a:\\\"codec\\\"===a.type?b.codec=a:\\\"ssrc\\\"===a.type&&(b.reportType=\\\"local\\\",a.bytesSent?b.streamType=\\\"outbound\\\":b.streamType=\\\"inbound\\\",b.ssrc=a.ssrc,b.data=a);return b}function C(a){var b=\\\"None\\\";switch(a){case 0:b=\\\"TURN/TLS\\\";break;case 1:b=\\\"TURN/TCP\\\";break;case 2:b=\\\"TURN/UDP\\\"}return b}function D(a,b){var c,d,e,f,g,h,i,j,k,l=!1,m=\\\"None\\\",n=!1,o=Aa.codebase,p=function(a){if(a.typePreference){var b=a.typePreference>>24;return\\\"rtp\\\"===a.protocol&&a.address===c&&(b>=0&&b<=2&&(m=C(b)),!0)}return!1};for(i=0;i<a.length;i++)if(j=a[i],o!==Fb.firefox||\\\"candidatepair\\\"!==j.type||\\\"true\\\"!==j.selected&&j.selected!==!0?\\\"googCandidatePair\\\"!==j.type||\\\"true\\\"!==j.googActiveConnection&&j.googActiveConnection!==!0?\\\"transport\\\"===j.type&&(n=!0,j.selectedCandidatePairId&&(k=j.selectedCandidatePairId)):(n=!0,c=j.googLocalAddress,d=j.googRemoteAddress,e=j.googLocalCandidateType,f=j.googRemoteCandidateType,g=j.googTransportType):(n=!0,c=j.localAddr,d=j.remoteAddr,e=j.localAddrType,f=j.remoteAddrType,g=j.transportType),n){c&&(h=0===c.indexOf(\\\"[\\\")),b.iceCandidates.some(p);break}if(!n)return l;var q=b.transportData;return void 0!==q&&q.localAddr===c&&q.remoteAddr===d&&q.transportType===g&&q.selectedCandidatePairId===k||(b.transportData={localAddr:c,remoteAddr:d,localAddrType:e,remoteAddrType:f,transportType:g,ipv6:h,relayType:m,selectedCandidatePairId:k},l=!0),l}function E(a){var b,c={};a.timestamp instanceof Date&&(c.timestamp=a.timestamp.getTime().toString()),a.type&&(c.type=a.type);var d=0;if(a.names){var e=a.names();for(d=0;d<e.length;++d)c[e[d]]=a.stat(e[d])}else for(b in a)a.hasOwnProperty(b)&&(c[b]=a[b]);if(c.values){for(d=0;d<c.values.length;++d){a=c.values[d];for(b in a)a.hasOwnProperty(b)&&(c[b]=a[b])}delete c.values}return c}function F(a){if(null===a)return!0;if(a.length>0)return!1;if(0===a.length)return!0;var b;for(b in a)if(a.hasOwnProperty(b))return!1;return!0}function G(a){return{magicKey:a,statsSubmissionInterval:Fa,endpoint:Ya,localUserIDObject:oa}}function H(a,b,c){var d=ab[a];void 0===d&&(ab[a]={},ab[a].participants=null,c&&(ab[a].userJoinedSent=!0),b&&(ab[a].refreshPresence=b))}function I(a){var b,c=a.statistics.outbound;if(void 0!==c)for(b in c)c.hasOwnProperty(b)&&(c[b].data.mozRtt?c[b].data.mozRtt=0:c[b].data.googRtt?c[b].data.googRtt=0:c[b].data.rtt?c[b].data.rtt=0:c[b].data.roundTripTime&&(c[b].data.roundTripTime=0))}function J(a){return clearInterval(a),null}function K(){var a;for(a in ab)ab.hasOwnProperty(a)&&(ab[a].refreshPresence=J(ab[a].refreshPresence),delete ab[a].refreshPresence);W()}function L(a){var b=!1;if(!a)return b;var c=ab[a];return void 0!==c&&c.participants&&c.participants.length>0&&(b=!0),b}function M(a,b){var c=ab[a],d=[];if(void 0===c)d.push(b),ab[a]={},ab[a].participants=d;else{var e=c.participants;null===e?(d.push(b),c.participants=d):e.push(b)}}function N(a){var b=!1;if(!ab[a])return{conferenceFinished:b,ucID:null};var c=ab[a].ucID;return 0===ab[a].participants.length&&(J(ab[a].refreshPresence),W(),Oa.sendCachedEvents(Ua,cb),delete ab[a],b=!0),{conferenceFinished:b,ucID:c}}function O(a,b){Xb(jb.userLeft,null,a,b,null,null,null),W(),db=Rb,Rb=null}function P(){var a,b=function(a){return setInterval(function(){ac(a)},Ha)};for(a in ab)if(ab.hasOwnProperty(a)){if(a===ia)return;ac(a),ab[a].refreshPresence=b(a)}X()}function Q(){bb.syncHandler||(Ob(ma,na,\\\"log\\\",{msg:\\\"start clockSync\\\"}),bb.offsetResults=[],ld(),bb.syncHandler=!0)}function R(a){try{if(window&&window.sessionStorage){var b=JSON.parse(window.sessionStorage.getItem(\\\"csio_ucid_data\\\"));if(b&&b[a])return b[a].ucID}}catch(a){return null}return null}function S(a,b,c){var d=b.action,e=b.remoteID,f=b.ucID;b.channel=a,Ua._isTokenValid(Ua.authToken,ma,na)?(f&&!cb&&e||Hb.indexOf(d)!==-1)&&b.conferenceID!==ia?(b.token=Ua.authToken,pd(a,b,c),c&&d&&c(nb.success,d+\\\" sent to the backend.\\\")):(b.clockUnsynced=cb,Oa.cacheEvent({channel:a,data:b,callback:c})):Ua.sendAuthenticationRequest(ma,na,function(g,h){g!==nb.success?(g===ob.authOngoing&&(b.clockUnsynced=cb,Oa.cacheEvent({channel:a,data:b,callback:c})),c&&g!==ob.authOngoing&&c(g,h)):g===nb.success&&\\\"SDK authentication successful.\\\"===h&&((f&&!cb&&e||Hb.indexOf(d)!==-1)&&b.conferenceID!==ia?(b.token=Ua.authToken,pd(a,b,c),c&&d&&c(nb.success,d+\\\" sent to the backend.\\\")):(b.clockUnsynced=cb,Oa.cacheEvent({channel:a,data:b,callback:c})))})}function T(a){a&&a(ob.authOngoing,\\\"Authentication Ongoing\\\")}function U(a){var b;if(null===a||\\\"object\\\"!=typeof a)return a;if(a instanceof Array){b=[];for(var c=0,d=a.length;c<d;c++)b[c]=U(a[c]);return b}if(a instanceof Object){b={};for(var e in a)a.hasOwnProperty(e)&&(b[e]=U(a[e]));return b}}function V(){var a={};Object.keys(ab).forEach(function(b){var c=ab[b];if(!c)return!0;var d,e,f={ucID:c.ucID,userJoinedSent:c.userJoinedSent},g=[];if(c.participants){var h,i=c.participants;for(d=0;d<i.length;d++)e={},h=i[d],e={pcID:h.pcHash,pcState:h.pcState,iceConnectionState:h.iceConnectionState,iceGatheringState:h.iceGatheringState,iceCandidatesNumber:h.iceCandidates.length,remoteUserID:h.remoteUserID},g.push(e)}f.participants=g,a[b]=f});var b={authStatus:!!Ua.tokenData,clockSync:!cb,stateMachine:a,pageURL:window.location.href,eventType:\\\"warn\\\",version:da};b.wsStatus=od.getWSConnectionState(),Ob(ma,na,\\\"stateMachine\\\",b)}function W(){eb||(eb=setInterval(function(){V()},fb))}function X(){J(eb),eb=null}function Y(){Array.prototype.find||Object.defineProperty(Array.prototype,\\\"find\\\",{value:function(a){if(null===this)throw new TypeError(\\\"Array.prototype.find called on null or undefined\\\");if(\\\"function\\\"!=typeof a)throw new TypeError(\\\"predicate must be a function\\\");for(var b,c=Object(this),d=c.length>>>0,e=arguments[1],f=0;f<d;f++)if(b=c[f],a.call(e,b,f,c))return b}})}var Z,$=__webpack_require__(71),_=__webpack_require__(72),aa=__webpack_require__(79),ba=\\\"https://collector.callstats.io:443/\\\",ca=\\\"https://auth.callstats.io/\\\",da=\\\"3.27.0\\\",ea=\\\"wss://collector.callstats.io:443/csiows/collectCallStats\\\",fa=\\\"https://dashboard.callstats.io/apps/\\\",ga=\\\"https://dashboard.callstats.io/api-internal/v1/qmodelthresholds\\\",ha=\\\"https://appsettings.callstats.io/v1/apps/\\\",ia=\\\"csio-conf-id-tmp\\\",ja=new _.Reporter,ka=null;window&&(window.csioChromeLegacyGetStats=!0);var la,ma=null,na=null,oa=null,pa=null,qa=!1,ra=!1,sa=1e4,ta=1e4,ua=1e3,va=\\\"\\\",wa=function(a,b){var c=\\\"precalltest error (\\\"+a+\\\"): \\\"+b;console.warn(c),Ob&&Ob(ma,na,\\\"log\\\",{msg:c}),va+=\\\"(error)\\\"},xa=__webpack_require__(80),ya=null;try{ya=new xa.PreCallTest}catch(a){wa(\\\"initializing\\\",a)}var za,Aa,Ba=[],Ca={create:Date.now()},Da={stats:null,defaultConfig:null,recommendedConfig:null,preCallTest:null},Ea=2e4,Fa=15e3,Ga=!1,Ha=1e4,Ia=5e3,Ja=2e3,Ka=!0,La=!0,Ma=[],Na=function(){function a(a,b){setTimeout(function(){var b=c(),d=b-a.data.apiTS;a.data.timeShift=d,S(a.channel,a.data,a.callback)},b)}this.eventCache=[],this.updateRemoteUserID=function(a,b){for(var c,d=this,e=0;e<d.eventCache.length;e++)c=d.eventCache[e],c.data.pcID===b&&(c.data.remoteID=a)},this.sendCachedEvents=function(b,d,e,f,g,h){var i=this;if(0!==i.eventCache.length){if(!b.authToken)return void b.sendAuthenticationRequest(ma,na);if(!d){var j,k,l,m,n=c(),o=[],p=Math.max(Fa/i.eventCache.length,gb);for(j=0;j<i.eventCache.length;j++)if(l=i.eventCache[j],!l.data.remoteID&&l.data.pcID||l.data.conferenceID===ia)o.push(i.eventCache[j]);else if(l.data.action!==jb.userJoined){if(l.data.token=b.authToken,e&&l.data.apiTS>=n-f||!l.data.ucID)if(m=decodeURIComponent(l.data.conferenceID),ab[m]&&ab[m].ucID)l.data.ucID=ab[m].ucID;else{if(m!==g){o.push(i.eventCache[j]);continue}l.data.ucID=h}if(l.data.clockUnsynced&&(l.data.apiTS+=bb.currentOffset),l.channel===kb.processedStats&&l.data.clockUnsynced&&l.data.processedStatistics&&l.data.processedStatistics.length>0)for(k=0;k<l.data.processedStatistics.length;k++)l.data.processedStatistics[k].apiTS+=bb.currentOffset;delete l.data.clockUnsynced,a(l,p*(j+1))}else o.push(i.eventCache[j]);i.eventCache=o}}},this.sendCachedUserJoinedEvents=function(b){var c=this;if(0!==c.eventCache.length){if(!b.authToken)return void b.sendAuthenticationRequest(ma,na);var d,e,f=[],g=Math.max(Fa/c.eventCache.length,gb);for(d=0;d<c.eventCache.length;d++)e=c.eventCache[d],!e.data.remoteID&&e.data.pcID||e.data.conferenceID===ia?f.push(c.eventCache[d]):e.data.action===jb.userJoined||e.data.action===ib.fabricSetupFailed?(e.data.token=b.authToken,e.data.clockUnsynced&&(e.data.apiTS=e.data.apiTS+bb.currentOffset),e.data.value&&(e.data.value.statsSubmissionInterval=Fa),a(e,g*(d+1))):f.push(c.eventCache[d]);c.eventCache=f}},this.updateConferenceId=function(a){for(var b,c=this,d=0;d<c.eventCache.length;d++)b=c.eventCache[d],b.data.conferenceID===ia&&(b.data.conferenceID=a)},this.cacheEvent=function(a){this.eventCache.push(a)},this.sendCachedFeedback=function(){var a=Jb(\\\"feedback\\\"),b=JSON.parse(Jb(\\\"csio_auth_data\\\"));if(a&&b){var c=JSON.parse(a),d=b===c.token;d||na!==c.userID||(c.token=b,d=!0),d?S(kb.userFeedback,c):Kb(\\\"feedback\\\")}}},Oa=new Na,Pa=function(){this.size_max=0,this.size_ewma=0,this.statNum_max=0,this.statNum_ewma=0,this.msg_num=0,this.maxInterval=0,this.minInterval=0,this.avgInterval=0,this.stdInterval=0},Qa=function(){this.stat=new Pa,this.lastTime=null,this.samplesCount=0,this.add=function(a,c){var d=this.memorySizeOf(a);if(this.stat.size_ewma=.5*this.stat.size_ewma+.5*d,this.stat.size_max<d&&(this.stat.size_max=d),this.stat.statNum_ewma=.5*this.stat.statNum_ewma+.5*c,this.stat.statNum_max<c&&(this.stat.statNum_max=c),this.stat.msg_num+=1,null===this.lastTime)return void(this.lastTime=b());var e=b()-this.lastTime;this.lastTime=b(),(0===this.stat.maxInterval||this.stat.maxInterval<e)&&(this.maxInterval=e),(0===this.stat.minInterval||e<this.stat.minInterval)&&(this.minInterval=e),this.stat.avgInterval=(this.stat.avgInterval*this.samplesCount+e)/(this.samplesCount+c),this.samplesCount+=c,this.stat.stdInterval=(31*this.stat.stdInterval+Math.abs(this.stat.avgInterval-e))/32},this.getStat=function(){return this.stat},this.memorySizeOf=function(a){function b(a){if(null!==a&&void 0!==a)switch(typeof a){case\\\"number\\\":c+=8;break;case\\\"string\\\":c+=2*a.length;break;case\\\"boolean\\\":c+=4;break;case\\\"object\\\":var d=Object.prototype.toString.call(a).slice(8,-1);if(\\\"Object\\\"===d||\\\"Array\\\"===d)for(var e in a)a.hasOwnProperty(e)&&b(a[e]);else c+=2*a.toString().length}return c}var c=0;return b(a)}},Ra=new Qa,Sa={appSecret:\\\"appSecret\\\",jwt:\\\"jwt\\\"},Ta=function(){var a=this,b=\\\"urn:x-callstats:auth:errorActions\\\",d=.9;this.authInProgress=!1,this.tokenData=null,this.authToken=null,this.type=Sa.appSecret,this.tokenGenerator=function(a,b){b(\\\"Token generator not set\\\")};var e=null,f=null,g=!1,h=window.atob,i=window.btoa,j=[\\\"Authentication Internal Error\\\",\\\"Invalid Credentials\\\",\\\"Invalid Credentials\\\",\\\"Invalid Credentials\\\",\\\"Invalid Credentials\\\",\\\"Origin URL missmatch\\\",\\\"Invalid Credentials\\\",\\\"Authentication Protocol Error\\\"],k=function(a){return i(encodeURIComponent(a).replace(/%([0-9A-F]{2})/g,function(a,b){return String.fromCharCode(\\\"0x\\\"+b)}))},l=function(a){return i(a).replace(/\\\\+/g,\\\"-\\\").replace(/\\\\//g,\\\"_\\\").replace(/\\\\=+$/,\\\"\\\")},m=function(a){return k(a).replace(/\\\\+/g,\\\"-\\\").replace(/\\\\//g,\\\"_\\\").replace(/\\\\=+$/,\\\"\\\")},n=function(a){for(var b=h(a.replace(/[ \\\\r\\\\n]+$/,\\\"\\\")),c=[],d=0;d<b.length;++d){var e=b.charCodeAt(d).toString(16);1===e.length&&(e=\\\"0\\\"+e),c.push(e)}return c.join(\\\"\\\")},o={};o.cryptotype=null,window.crypto&&window.crypto.subtle?(o.cryptotype=\\\"standard\\\",o.subtlecrypto=window.crypto.subtle):window.crypto&&!window.crypto.subtle&&window.crypto.webkitSubtle?(o.cryptotype=\\\"webkit\\\",o.subtlecrypto=window.crypto.webkitSubtle):window.msCrypto&&window.msCrypto.subtle?(o.cryptotype=\\\"ie\\\",o.subtlecrypto=window.msCrypto.subtle):(o.subtlecrypto=null,console.info(\\\"WebCryptography API not supported in this browser.\\\")),o.sign=function(a,b,c,d){if(\\\"HS256\\\"!==a.alg)return d(\\\"Use header.alg=HS256\\\");a=JSON.stringify(a),\\\"string\\\"!=typeof b&&(b=JSON.stringify(b));var e=m(a)+\\\".\\\"+m(b);if(window.csioReactNative)return void window.csiosign(e,c,function(a,b){return a?(console.log(\\\"Token sign error\\\",a),d(a)):d(null,b)});for(var f=new ArrayBuffer(e.length),g=new Uint8Array(f),h=e.length-1;h>=0;h--)g[h]=e.charCodeAt(h);var i=function(a){for(var b=\\\"\\\",c=new Uint8Array(a),f=c.byteLength,g=0;g<f;g++)b+=String.fromCharCode(c[g]);return e+=\\\".\\\"+l(b),d(null,e)},j=function(a){return d(a)},k={name:\\\"HMAC\\\"};\\\"ie\\\"!==o.cryptotype&&\\\"webkit\\\"!==o.cryptotype||(k.hash={name:\\\"sha-256\\\"});var n=o.subtlecrypto.sign(k,c,g);\\\"ie\\\"===o.cryptotype?(n.onerror=j,n.oncomplete=function(a){i(a.target.result)}):n.then(i).catch(j)},o.decode=function(a){try{return JSON.parse(h(a.split(\\\".\\\")[1]))}catch(a){return console.error(\\\"Couldn't decode token. \\\",a),null}},o.importKey=function(a,b,c){if(window.csioReactNative)return void b(a);if(\\\"webkit\\\"===o.cryptotype)for(;a.length<32;)a+=\\\"\\\\0\\\";var d={kty:\\\"oct\\\",k:l(a),alg:\\\"HS256\\\"},e={name:\\\"HMAC\\\",hash:{name:\\\"SHA-256\\\"}};if(\\\"ie\\\"===o.cryptotype?d.extractable=!1:d.ext=!1,\\\"webkit\\\"===o.cryptotype&&(e=null,d.use=\\\"sig\\\"),\\\"ie\\\"===o.cryptotype||\\\"webkit\\\"===o.cryptotype){var f=JSON.stringify(d);d=new Uint8Array(f.length);for(var g=0;g<f.length;g++)d[g]=f.charCodeAt(g)}var h=o.subtlecrypto.importKey(\\\"jwk\\\",d,e,!1,[\\\"sign\\\"]);\\\"ie\\\"===o.cryptotype?(h.onerror=c,h.oncomplete=function(a){b(a.target.result)}):h.then(b).catch(c)},this.setAuthType=function(a){this.type=a},this._isTokenValid=function(a,b,d){var e=!1,f=Aa.codebase;if(null===a)return!1;try{var g=o.decode(a);if(null!==g&&g.appID===b&&g.userID===encodeURIComponent(d)){var h=null;if(f===Fb.firefox){var i=g.expiry.split(\\\" \\\").join(\\\"T\\\");h=Date.parse(i)}else h=new Date(g.expiry);var j=new Date(c());j<h&&(e=!0)}return e}catch(a){}return!1},this.setupAuthToken=function(a){Ib(\\\"csio_auth_data\\\",JSON.stringify(a)),this.authToken=a,this.tokenData=o.decode(a),Fa=parseInt(this.tokenData.submissionInterval,10),ja.setSubmissionInterval(Fa),ja.setReportingMode(this.tokenData.adaptiveInterval),Ga=this.tokenData.collectSDP},this.sendAuthenticationRequest=function(c,f,h){if(c&&f){if(a.authInProgress)return void T(h);null!==e&&(clearTimeout(e),e=null),p(),a.authInProgress=!0,a.tokenGenerator(g,function(i,j){if(null!==i)return a.authInProgress=!1,void(h&&h(nb.tokenGenerationError,i.toString()));var k=ca+\\\"authenticate\\\",l={client_id:f+\\\"@\\\"+ma,code:j,grant_type:\\\"authorization_code\\\"};jd(k,l,function(i,j){var k=null;a.authInProgress=!1,Ca.auth=j;try{k=JSON.parse(i.response)}catch(a){console.error(\\\"Authentication response parse error\\\")}if(!k)return void(e=setTimeout(a.sendAuthenticationRequest,Ia,c,f,h));if(200===i.status){if(\\\"bearer\\\"!==k.token_type)return console.error(\\\"Authentication was successful, but token type was not bearer. Scheduling retry.\\\"),void(e=setTimeout(a.sendAuthenticationRequest,Ia,c,f,h));a.setupAuthToken(k.access_token);var l=parseInt(1e3*parseInt(k.expires_in)*d);if(q(l,c,f,h),g=!1,h&&h(nb.success,\\\"SDK authentication successful.\\\"),k.iceServers&&!ra&&ya)try{va=k.iceServers[0].username+\\\" \\\",ya.start(k.iceServers,gc.bind(this)),Ob(ma,na,\\\"log\\\",{msg:\\\"precalltest started \\\"+va}),va+=\\\"(started)\\\"}catch(a){wa(\\\"start\\\",a),ya.crashDisconnect()}ra&&(Ob(ma,na,\\\"log\\\",{msg:\\\"precalltest disabled \\\"+va}),va+=\\\"(disabled)\\\"),hc(),od._isChannelReady()?(Oa.sendCachedUserJoinedEvents(Ua),h&&h(nb.success,\\\"WebSocket establishment successful.\\\")):od._setupWebSocketConnection(function(a,b){h&&h(a,b)})}else{if(k[b]&&k[b].length>0)return r(c,f,h,k[b],a.type);console.error(\\\"Authentication failed, but no error actions were defined in response.\\\"),e=setTimeout(a.sendAuthenticationRequest,Ia,c,f,h)}})})}};var p=function(){null!==f&&(clearTimeout(f),f=null)},q=function(b,c,d,e){p(),f=setTimeout(function(){a.sendAuthenticationRequest(c,d,e)},b)},r=function(a,b,c,d,e){if(0!==d.length){var f=d.shift();if(f.action===Qb.RETRY)return e===Sa.jwt&&q(f.params.timeout,a,b,c),r(a,b,c,d);if(f.action===Qb.GET_NEW_TOKEN)return g=!0,r(a,b,c,d);if(f.action===Qb.REPORT_ERROR){var h=\\\"Authentication Error\\\";return f.params&&f.params.errorCode>=0&&(h=j[f.params.errorCode]),c&&c(nb.authError,h),r(a,b,c,d)}}};this.appSecretTokenGenerator=function(b){var c=null,d=null,e=!1,f=null;b.indexOf(\\\":\\\")>-1&&(f=n(b.split(\\\":\\\")[0]),b=b.split(\\\":\\\")[1]);var g=function(a){b=null,c=a},h=function(a){e=!0,b=null,console.error(\\\"Couldn't import key\\\",a)};return o.importKey(b,g,h),function(b,g){if(e)return g(\\\"appsecret based token generation failed\\\");if(!b&&null!==d)return g(null,d);if(null===c)return setTimeout(function(){a.tokenGenerator(b,g)},100);var h={userID:na,appID:ma};f&&(h.keyID=f),o.sign({alg:\\\"HS256\\\"},h,c,function(a,b){return a?g(a):(d=b,g(null,b))})}}},Ua=new Ta,Va=new $;try{Aa=Va.detectBrowserInfo()}catch(a){console.log(\\\"detectBrowserInfo: Error\\\",a)}var Wa;window.csioReactNative||(Wa=Va.measureAppLoadingPerformance(Aa),Ca.loading=Wa);var Xa,Ya={type:\\\"browser\\\",name:Aa.name,ver:Aa.ver,os:Aa.os,osVersion:Aa.osVersion,userAgent:Aa.userAgent},Za=!1,$a=null,_a=null,ab={},bb={currentOffset:0,offsetResults:[],syncStartTime:null,syncAttempts:5,syncHandler:null,maxAllowedLatency:6e4},cb=!0,db=null,eb=null,fb=2e4,gb=100,hb=null;\\\"Firefox\\\"===Aa.name?hb=mozRTCPeerConnection:\\\"Chrome\\\"===Aa.name||\\\"Opera\\\"===Aa.name?hb=webkitRTCPeerConnection:\\\"Safari\\\"===Aa.name?console.log(\\\"Browser type Safari\\\"):\\\"Edge\\\"===Aa.name&&(hb=window.RTCPeerConnection);var ib={fabricSetupFailed:\\\"fabricSetupFailed\\\",fabricHold:\\\"fabricHold\\\",fabricResume:\\\"fabricResume\\\",audioMute:\\\"audioMute\\\",audioUnmute:\\\"audioUnmute\\\",videoPause:\\\"videoPause\\\",videoResume:\\\"videoResume\\\",fabricUsageEvent:\\\"fabricUsageEvent\\\",fabricTerminated:\\\"fabricTerminated\\\",screenShareStart:\\\"screenShareStart\\\",screenShareStop:\\\"screenShareStop\\\",dominantSpeaker:\\\"dominantSpeaker\\\",userIDChangedEvent:\\\"userIDChangedEvent\\\",activeDeviceList:\\\"activeDeviceList\\\",applicationErrorLog:\\\"applicationErrorLog\\\"},jb={autoFabricSetup:\\\"autoFabricSetup\\\",userJoined:\\\"userJoined\\\",userLeft:\\\"userLeft\\\",refreshPresence:\\\"userAlive\\\",ssrcMap:\\\"ssrcMap\\\",mediaPlaybackStartEvent:\\\"mediaPlaybackStartEvent\\\",mediaSuspendedEvent:\\\"mediaSuspendedEvent\\\",oneWayMedia:\\\"oneWayMedia\\\",fabricStateChange:\\\"fabricStateChange\\\",iceDisruptionStart:\\\"iceDisruptionStart\\\",iceDisruptionEnd:\\\"iceDisruptionEnd\\\",fabricTransportSwitch:\\\"fabricTransportSwitch\\\",iceConnectionDisruptionStart:\\\"iceConnectionDisruptionStart\\\",iceConnectionDisruptionEnd:\\\"iceConnectionDisruptionEnd\\\",iceAborted:\\\"iceAborted\\\",iceTerminated:\\\"iceTerminated\\\",iceFailed:\\\"iceFailed\\\",iceRestarted:\\\"iceRestarted\\\",fabricDropped:\\\"fabricDropped\\\",connectedDevices:\\\"connectedDevices\\\",iceCompleted:\\\"iceCompleted\\\",iceCandidateFound:\\\"iceCandidateFound\\\"},kb={sdpSubmission:\\\"sdpSubmissionEvent\\\",rtpStats:\\\"rtpStats\\\",processedStats:\\\"processedStats\\\",callStatsEvent:\\\"callStatsEvent\\\",userFeedback:\\\"userFeedbackEvent\\\",clockSync:\\\"clockSync\\\",preCallTest:\\\"preCallTest\\\",senderConfiguration:\\\"senderConfiguration\\\",\\nsendingThroughputObservations:\\\"sendingThroughputObservations\\\"},lb={results:\\\"preCallTestResults\\\",associate:\\\"preCallTestAssociate\\\"},mb={success:\\\"success\\\",failure:\\\"failure\\\"},nb={httpError:\\\"httpError\\\",authError:\\\"authError\\\",wsChannelFailure:\\\"wsChannelFailure\\\",success:\\\"success\\\",csProtoError:\\\"csProtoError\\\",appConnectivityError:\\\"appConnectivityError\\\",tokenGenerationError:\\\"tokenGenerationError\\\",ok:\\\"OK\\\"},ob={authOngoing:\\\"authOngoing\\\"},pb={peer:\\\"peer\\\",server:\\\"server\\\"},qb={sendonly:\\\"sendonly\\\",receiveonly:\\\"receiveonly\\\",sendrecv:\\\"sendrecv\\\",inactive:\\\"inactive\\\"},rb={audio:\\\"audio\\\",video:\\\"video\\\",data:\\\"data\\\",screen:\\\"screen\\\",multiplex:\\\"multiplex\\\",unbundled:\\\"unbundled\\\"},sb={local:\\\"local\\\",remote:\\\"remote\\\"},tb={excellent:5,good:4,fair:3,poor:2,bad:1},ub={local:\\\"local\\\",remote:\\\"remote\\\",inbound:\\\"inbound\\\",outbound:\\\"outbound\\\"},vb={noAudioInMultiplexFabric:\\\"noAudioInMultiplexFabric\\\",noOutboundAudioOnlyFabric:\\\"noOutboundAudioOnlyFabric\\\",noInboundAudioOnlyFabric:\\\"noInboundAudioOnlyFabric\\\"},wb={excellent:\\\"excellent\\\",fair:\\\"fair\\\",bad:\\\"bad\\\"},xb={established:\\\"established\\\",initializing:\\\"initializing\\\",failed:\\\"failed\\\",disrupted:\\\"disrupted\\\",checkingDisrupted:\\\"checkingDisrupted\\\"},yb={createOffer:\\\"createOffer\\\",createAnswer:\\\"createAnswer\\\",setLocalDescription:\\\"setLocalDescription\\\",setRemoteDescription:\\\"setRemoteDescription\\\",addIceCandidate:\\\"addIceCandidate\\\",getUserMedia:\\\"getUserMedia\\\",iceConnectionFailure:\\\"iceConnectionFailure\\\",signalingError:\\\"signalingError\\\",applicationError:\\\"applicationError\\\",applicationLog:\\\"applicationLog\\\"},zb={mediaConfigError:\\\"MediaConfigError\\\",negotiationFailure:\\\"NegotiationFailure\\\",sdpError:\\\"SDPGenerationError\\\",iceFailure:\\\"IceConnectionFailure\\\",transportFailure:\\\"TransportFailure\\\",signalingError:\\\"SignalingError\\\",applicationError:\\\"ApplicationError\\\",applicationLog:\\\"ApplicationLog\\\"},Ab={video:{gThreshold:1024,rThreshold:256},audio:{gThreshold:30,rThreshold:8}},Bb={video:{gThreshold:.8,rThreshold:.3}},Cb={video:{gThreshold:400,rThreshold:1e3}},Db={video:{gThreshold:10,rThreshold:50},audio:{gThreshold:15,rThreshold:30}},Eb={audio:{gThreshold:240,rThreshold:400}},Fb={chrome:\\\"Chrome\\\",firefox:\\\"Firefox\\\",edge:\\\"Edge\\\"},Gb={signalingState:\\\"signalingState\\\",iceConnectionState:\\\"iceConnectionState\\\",iceGatheringState:\\\"iceGatheringState\\\"},Hb=[jb.userJoined,jb.refreshPresence,ib.fabricSetupFailed],Ib=function(a,b){try{window&&window.localStorage&&window.localStorage.setItem(a,b)}catch(a){return}},Jb=function(a){try{if(window&&window.localStorage)return window.localStorage.getItem(a)}catch(a){return null}return null},Kb=function(a){try{window&&window.localStorage&&window.localStorage.removeItem(a)}catch(a){return}},Lb=function(){if(pa=Jb(\\\"endpointID\\\"),null===pa){var a=b(),c=Math.random()*a;Ac(c.toString(),function(a){pa=a,Ib(\\\"endpointID\\\",pa)})}},Mb=function(a,c,d,e,f){var g=null,h=null,i=null,j=new XMLHttpRequest;if(\\\"Microsoft Internet Explorer\\\"!==Aa.name&&(j.timeout=d),j){j.open(\\\"GET\\\",encodeURI(a));for(var k in c)j.setRequestHeader(k,c[k]);g=b(),j.onload=function(){h=b(),i=h-g,e(j,i)},j.ontimeout=f,j.send()}},Nb=function(a,b,c,d){var e=new XMLHttpRequest;if(e){if(e.open(\\\"POST\\\",encodeURI(a)),e.setRequestHeader(\\\"Content-Type\\\",\\\"application/json\\\"),d)for(var f in d)e.setRequestHeader(f,d[f]);e.onload=function(){c(e)},e.send(b)}},Ob=function(a,c,d,e){if(Ka&&a){var f=ba+\\\"generics\\\",g={appID:a,timestamp:b(),userID:encodeURIComponent(c),version:da,eventType:d,data:e},h=JSON.stringify(g);za!==h&&(za=h,Nb(f,h,function(a){200===a.status?console.log(\\\"Got generic response: %o\\\",a.response):200!==a.status&&console.log(\\\"Got error for generic request %o, %s\\\",a,a.status)}))}};window&&window.addEventListener&&window.addEventListener(\\\"error\\\",function(a){if(a&&a.filename&&a.filename.indexOf(\\\"callstats\\\")>-1){var b,c=!1,d={fileName:a.filename,line:a.lineno,col:a.colno,jsVersion:da,eventType:\\\"error\\\",message:a.message,pageURL:window.location.href};for(b in ab)ab.hasOwnProperty(b)&&(d.conferenceID=b,Ob(ma,na,\\\"onErrorLog\\\",d),c=!0);c||Ob(ma,na,\\\"onErrorLog\\\",d)}});var Pb={invalidWebRTCFunctionName:\\\"Invalid WebRTC function name\\\"},Qb={RETRY:0,GET_NEW_TOKEN:1,REPORT_ERROR:2},Rb=a(),Sb=Object.create(null),Tb=function(a,d,e){var f=RegExp.prototype.test.bind(/^([a-z])=(.*)/),g=/^ssrc:(\\\\d*) ([\\\\w_]*):(.*)/,h=/^ssrc-group:SIM (\\\\d*)/;d.split(/(\\\\r\\\\n|\\\\r|\\\\n)/).filter(f).forEach(function(d){var f=d[0],i=d.slice(2);if(\\\"a\\\"===f){if(g.test(i)){var j=i.match(g),k=j[1];void 0===a.ssrcMap[k]&&(a.ssrcMap[k]={}),a.ssrcMap[k][j[2]]=j[3],a.ssrcMap[k].localStartTime=b(),a.ssrcMap[k].syncedStartTime=c(),a.ssrcMap[k].streamType=e}h.test(i)&&(void 0===a.ssrcMap.ssrcGroup&&(a.ssrcMap.ssrcGroup={},a.ssrcMap.ssrcGroup[e]={}),a.ssrcMap.ssrcGroup[e].simulcastGroup=i.match(/\\\\d+/g))}})},Ub=function(a,b){return a.ssrcMap[b]},Vb=function(a){return a.ssrcMap},Wb=function(a,b,c,d,e,f){if(!e.localDescription||!e.remoteDescription)return!1;var g=e.localDescription.sdp,h=e.remoteDescription.sdp;if(!g||!h||g===d.localSDP&&h===d.remoteSDP)return!1;if(Tb(d,g,ub.outbound),Tb(d,h,ub.inbound),Ga){var i={sdp:{}};i.sdp.localSDP=g!==d.localSDP?g:-1,i.sdp.remoteSDP=h!==d.remoteSDP?h:-1,Zb(a,b,c,i,d.pcHash,f)}return d.localSDP=g,d.remoteSDP=h,!0},Xb=function(a,b,d,e,f,g,h){if(!a)return void console.error(\\\"sendEvent: Invalid eventType \\\");var i=c(),j={version:da,apiTS:i,action:a,localID:encodeURIComponent(na),remoteID:b?encodeURIComponent(b):null,conferenceID:encodeURIComponent(d),timeShift:0,appID:ma,ucID:e,pcID:g,deviceID:pa,value:f};return null===d?void Ob(ma,na,\\\"log\\\",{msg:\\\"conferenceID is null in sendEvent for \\\"+a}):void S(kb.callStatsEvent,j,h)},Yb=function(a,b,d,e){if(!a)return void console.error(\\\"sendEvent: Invalid eventType \\\");var f=c(),g={version:da,channel:kb.preCallTest,timestamp:f,apiTS:f,action:a,eventType:a,localID:encodeURIComponent(na),remoteID:encodeURIComponent(na),conferenceID:encodeURIComponent(b),timeShift:0,appID:ma,ucID:d,deviceID:pa,token:Ua.authToken};return a===lb.results&&(g.results=e,null==b)?void pd(kb.preCallTest,g):(a===lb.associate&&(g.ids=e),void(d&&!cb?S(kb.preCallTest,g):(g.clockUnsynced=cb,Oa.cacheEvent({channel:kb.preCallTest,data:g,callback:null}))))},Zb=function(a,b,d,e,f,g){var h=c(),i={version:da,appID:ma,conferenceID:encodeURIComponent(b),ucID:d,apiTS:h,localID:encodeURIComponent(na),remoteID:encodeURIComponent(a),pcID:f,deviceID:pa,sdpPayload:e,action:kb.sdpSubmission};Ua.authToken&&d&&!cb?(i.token=Ua.authToken,S(kb.sdpSubmission,i,g)):(i.clockUnsynced=cb,Oa.cacheEvent({channel:kb.sdpSubmission,data:i,callback:g}),Ua.authToken||Ua.sendAuthenticationRequest(ma,na))},$b=function(a,b,c,d,e,f,g){sc(a,function(a){b.localCandidates=a.localCandidates,b.remoteCandidates=a.remoteCandidates,b.iceCandidatePairs=a.iceCandidatePairs,b.activeIceCandidatePair=Nc(b.iceCandidatePairs),g.currPair=b.activeIceCandidatePair,Xb(jb.fabricStateChange,e,c,d,g,f)})},_b=function(a,b,c){var d={connectedDevices:la},e=ab[a]?ab[a].ucID:null;Xb(jb.connectedDevices,b,a,e,d,c)},ac=function(a){var b={ucID:ab[a].ucID,endpoint:Ya,magicKey:Rb};Xb(jb.refreshPresence,null,a,ab[a].ucID,b,null)},bc=function(a,b){var c={};return c.status=a,b&&(c.message=b),c},cc=function(a,b){var c,d,e,f=0;if(!a)return f;for(c=0,e=a.length;c<e;c++)d=a.charCodeAt(c),f=(f<<5)-f+d,f|=0;return b&&b(f),f},dc=function(a,c,d,e,f,g){if(!a||!d||!c)return console.error(\\\"initialize: Argument missing/invalid\\\"),bc(mb.failure,\\\"initialize: Argument missing/invalid\\\");if(e&&\\\"function\\\"!=typeof e)return console.error(\\\"initialize: Argument missing/invalid\\\"),bc(mb.failure,\\\"initialize: Argument missing/invalid\\\");if(f&&\\\"function\\\"!=typeof f)return console.error(\\\"initialize: Argument missing/invalid\\\"),bc(mb.failure,\\\"initialize: Argument missing/invalid\\\");if(Ua.setAuthType(Sa.jwt),\\\"function\\\"!=typeof c){if(Ua.setAuthType(Sa.appSecret),!(window.crypto&&(window.crypto.subtle||window.crypto.webkitSubtle)||window.msCrypto&&window.msCrypto.subtle||window.csioReactNative))return console.error(\\\"Browser does not support Web Cryptography API. App secret based authentication requires Web Cryptography API\\\"),e&&e(nb.tokenGenerationError,\\\"Browser does not support Web Cryptography API. App secret based authentication requires Web Cryptography API\\\"),bc(mb.failure,\\\"Browser does not support Web Cryptography API. App secret based authentication requires Web Cryptography API\\\");c=Ua.appSecretTokenGenerator(c)}if(\\\"string\\\"==typeof a&&(a=parseInt(a,10)),ma=a,isNaN(ma))return bc(mb.failure,\\\"Invalid Credentials\\\");if(\\\"object\\\"==typeof d?(na=d.aliasName,oa=d):na=d,Ca.initializeSinceCreate=b()-Ca.create,Ob(ma,na,\\\"log\\\",{msg:\\\"callstats initialize in progress\\\"}),g&&(g.disableBeforeUnloadHandler===!0&&(qa=!0),null!==g.applicationVersion&&void 0!==g.applicationVersion&&(Ya.appVer=uc(g.applicationVersion,30)),g.disablePrecalltest===!0&&(ra=!0)),Ua.tokenGenerator=c,Jb(\\\"csio_auth_data\\\"))try{var h=JSON.parse(Jb(\\\"csio_auth_data\\\"));Ua._isTokenValid(h,ma,na)&&(e&&e(nb.success,\\\"SDK authentication successful.\\\"),Ua.setupAuthToken(h),hc(),od._isChannelReady()||od._setupWebSocketConnection(e))}catch(a){console.log(\\\"initialize: Error\\\",a)}l(),f&&(Da.stats=f);try{Ua.sendAuthenticationRequest(ma,na,e)}catch(a){console.log(\\\"initialize: Error\\\",a)}return bc(mb.success)},ec=function(){Ca.sent||(Ca.remoteofferSinceCreate&&Ca.config&&Ca.senderConfig||Ca.errorSinceCreate)&&(console.log(\\\"Send generic event for timing\\\"),Ob(ma,na,\\\"timing\\\",Ca),Ca.sent=!0)},fc=function(a,b){\\\"function\\\"==typeof b&&Da.hasOwnProperty(a)&&(Da[a]=b)},gc=function(a){Ob(ma,na,\\\"log\\\",{msg:\\\"precalltest finished \\\"+va}),va+=\\\"(finished)\\\",Da.preCallTest&&Da.preCallTest(a);try{Ba.push(a.id);var b=null,c=null;for(var d in ab)if(ab.hasOwnProperty(d)){b=d,ab[d].ucID&&(c=ab[d].ucID);break}Yb(lb.results,b,c,a)}catch(a){wa(\\\"send results\\\",a)}},hc=function(){var a=ha+ma,b={Authorization:\\\"Bearer \\\"+Ua.authToken},c=Ja,d=function(a,b){200!==a.status&&setTimeout(function(){f()},100),Ca.config=b,ec();var c=JSON.parse(a.response);if(console.log(\\\"internal config:\\\",c),c.submissionInterval&&(Fa=parseInt(c.submissionInterval,10),ja.setSubmissionInterval(Fa)),c.adaptiveStats&&ja.setReportingMode(c.adaptiveStats),c.collectSDP&&(Ga=c.collectSDP),c.qmodelThresholdsAPI){var d=c.qmodelThresholdsAPI;id(\\\"eModelThreshold\\\",d,Eb),id(\\\"throughputThreshold\\\",d,Ab),id(\\\"fractionalLossThreshold\\\",d,Db),id(\\\"rttThreshold\\\",d,Cb),id(\\\"currOverPrevFrameRateThreshold\\\",d,Bb)}},e=function(a){200!==a.status&&setTimeout(function(){g()},100);var b=JSON.parse(a.response),c=function(a,b){var c={};return b&&(c={peerConnection:null,media:null}),a.peerConnection&&(c.peerConnection=a.peerConnection),a.media&&(c.media=a.media),a.sender&&(c.sender=a.sender),a.confidence&&(c.confidence=a.confidence),c};if(Da.defaultConfig&&b.default){var d=c(b.default,!0);d!=={}&&Da.defaultConfig(d)}if(Da.recommendedConfig&&b.recommended){var e=c(b.recommended,!1);e!=={}&&Da.recommendedConfig(e)}},f=function(){Mb(a+\\\"/configurations/internal\\\",b,c,d,f)},g=function(){Mb(a+\\\"/configurations\\\",b,c,e,g)};f(),g()},ic=function(a){return function(b){return b.pc===a||(!(!a.callstatsID||b.pcHash!==a.callstatsID)||void 0)}},jc=function(a,b){var c=null,d=null;return ab[a]&&ab[a].participants&&(d=ab[a].participants.filter(ic(b))),c=d&&d.length>0?d[0]:null},kc=function(a,b){var c=null,d=null;return c=jc(a,b),c&&(d=c.pcHash),d},lc=function(a){var b=null,c=null,d=null;for(b in ab)if(ab.hasOwnProperty(b)&&(d=jc(b,a))){c={fabric:d,conferenceID:b};break}return c},mc=function(a,b){var c=0;if(a&&ab[b].participants)for(c=0;c<ab[b].participants.length;c++)if(ab[b].participants[c].pcHash===a.pcHash){ab[b].participants.splice(c,1);break}},nc=function(a){if(a){var b=[],c=0;if(a&&a.result)b=a.result();else if(a&&a.forEach)a.forEach(function(a){b.push(a)});else for(c in a)a.hasOwnProperty(c)&&b.push(a[c]);return b}},oc=function(a){var b,c=null,d=null,e=null,f=[],g=[],h=[],i=0;if(c=nc(a),!c)return{localCandidates:f,remoteCandidates:g};for(i=0;i<c.length;++i)if(d=E(c[i]),e=B(d),e.localCandidate)f.push(e.localCandidate);else if(e.remoteCandidate)g.push(e.remoteCandidate);else if(e.Transport){if(\\\"transport\\\"===e.Transport.type){b=e.Transport.selectedCandidatePairId;continue}h.push(e.Transport)}else e.candidatePair&&h.push(e.candidatePair);if(b)for(i=0;i<h.length;i++)h[i].id===b&&(h[i].googActiveConnection=\\\"true\\\");return{localCandidates:f,remoteCandidates:g,iceCandidatePairs:h}},pc=function(a){function b(b){var c={};c=oc(b),a(c)}return b},qc=function(a){var b=null;return a&&(b=a.message+\\\" : \\\"+a.stack),b},rc=function(a,b,c,d,e,f){var g=Aa.codebase,h=Aa.name;if(g===Fb.firefox)if(La)try{a.getStats().then(c(b,d,e,f,a)).catch(function(h){La=!1,Ob(ma,d,\\\"log\\\",{msg:\\\"### \\\"+g+\\\" getStats reports error \\\"+qc(h)}),a.getStats(null,c(b,d,e,f,a))})}catch(h){La=!1,Ob(ma,d,\\\"log\\\",{msg:\\\"### \\\"+g+\\\" getStats reports error \\\"+qc(h)}),a.getStats(null,c(b,d,e,f,a))}else a.getStats(null,c(b,d,e,f,a),function(a){console.log(\\\"getstats error \\\",a)});else if(\\\"Safari\\\"===h)a.getStats().then(c(b,d,e,f,a)).catch(function(a){Ob(ma,d,\\\"log\\\",{msg:\\\"### \\\"+g+\\\" getStats reports error \\\"+qc(a)})});else if(g===Fb.chrome)if(window&&window.csioReactNative)a.getStats(null,c(b,d,e,f,a),function(a){Ob(ma,d,\\\"log\\\",{msg:\\\"### \\\"+g+\\\" getStats reports error \\\"+qc(a)})});else if(La)try{a.getStats().then(c(b,d,e,f,a)).catch(function(h){La=!1,Ob(ma,d,\\\"log\\\",{msg:\\\"### \\\"+g+\\\" getStats reports error \\\"+qc(h)}),a.getStats(c(b,d,e,f,a))})}catch(h){La=!1,Ob(ma,d,\\\"log\\\",{msg:\\\"### \\\"+g+\\\" getStats reports error \\\"+qc(h)}),a.getStats(c(b,d,e,f,a))}else a.getStats(c(b,d,e,f,a));else g===Fb.edge&&a.getStats().then(c(b,d,e,f,a)).catch(function(a){Ob(ma,d,\\\"log\\\",{msg:\\\"### \\\"+g+\\\" getStats reports error \\\"+qc(a)})})},sc=function(a,b){try{rc(a,b,pc)}catch(a){console.log(\\\"csioGetStats: Error\\\",a)}},tc=function(a,b,c,d){if(c||(c=ia),!a||!b)return console.error(\\\"sendFabricEvent: Arguments missing/Invalid\\\"),bc(mb.failure,\\\"sendFabricEvent: Arguments missing/Invalid\\\");if(!ma||!na||!ab[c])return console.error(\\\"sendFabricEvent: SDK is not initialized or no Fabrics added.\\\"),bc(mb.failure,\\\"sendFabricEvent: SDK is not initialized or no Fabrics added.\\\");if(b===ib.fabricSetupFailed)return console.error(\\\"sendFabricEvent: Unsupported fabricEvent fabricSetupFailed\\\"),bc(mb.failure,\\\"sendFabricEvent: Unsupported fabricEvent fabricSetupFailed\\\");if(!p(a))return console.error(\\\"sendFabricEvent: Invalid PeerConnection object passed\\\"),bc(mb.failure,\\\"sendFabricEvent: Invalid PeerConnection object passed\\\");if(!ib.hasOwnProperty(b)&&!jb.hasOwnProperty(b))return console.error(\\\"sendFabricEvent: Invalid fabricEvents value: \\\",b),bc(mb.failure,\\\"sendFabricEvent: Invalid fabricEvents value: \\\"+b);var e={},f=null,g=ab[c],h=null;if(void 0===g)return console.error(\\\"sendFabricEvent: Conference ID not found!\\\"),bc(mb.failure,\\\"sendFabricEvent: Conference ID not found!\\\");if(h=jc(c,a),null===h)return console.error(\\\"sendFabricEvent: fabricData is null\\\"),bc(mb.failure,\\\"sendFabricEvent: fabricData is null\\\");if(f=h.remoteUserID,b===ib.activeDeviceList){if(!d||!d.deviceList)return console.error(\\\"sendFabricEvent: Arguments missing/Invalid\\\"),bc(mb.failure,\\\"sendFabricEvent: Arguments missing/Invalid\\\");if(!(d.deviceList instanceof Array))return console.error(\\\"sendFabricEvent: DeviceList Invalid\\\"),bc(mb.failure,\\\"sendFabricEvent: DeviceList Invalid\\\");e={magicKey:Rb,endpoint:Ya,activeDevicelist:d.deviceList}}if(b!==ib.screenShareStart&&b!==ib.screenShareStop||(e={magicKey:Rb,endpoint:Ya},d&&(e.ssrc=d.ssrc)),Xb(b,f,c,g.ucID,e,h.pcHash,h.pcCallback),b===ib.fabricTerminated){if(ab[c].participants){h&&(h.statsInterval=J(h.statsInterval),mc(h,c));var i=N(c);i.conferenceFinished&&O(c,i.ucID)}}else b===ib.fabricHold?(h.statsInterval=J(h.statsInterval),h.onHold=!0):b===ib.fabricResume&&(h.onHold=!1,Qc(h,a,c,f));return bc(mb.success)},uc=function(a,b){return a&&\\\"string\\\"==typeof a?(a.length>b&&(a=a.substring(0,b)),a):null},vc=function(a){return a&&\\\"string\\\"==typeof a?a=uc(a,Ea):a&&\\\"object\\\"==typeof a&&a.message&&(a.message=uc(a.message,Ea)),a},wc=function(a,b,c){return b?b:a&&a[c]?a[c].sdp:-1},xc=function(c,d,e,f,g,h){if(d||(d=ia),void 0===c||!e)return console.error(\\\"reportError: Arguments missing/invalid\\\"),bc(mb.error,\\\"reportError: Arguments missing/invalid\\\");if(!ma||!na)return console.error(\\\"reportError: SDK is not initialized\\\"),bc(mb.error,\\\"reportError: SDK is not initialized\\\");if(!yb.hasOwnProperty(e))return console.error(\\\"reportError: Invalid webRTC functionName value: %o\\\",e),bc(mb.error,\\\"reportError: Invalid webRTC functionName value: \\\"+e);void 0===f&&console.warn(\\\"reportError: Missing dom error parameter\\\");var i,j,k,l=null,m=b(),n=ab[d],o=null,q=m,r=null,s=null,t=null,u=null;if(t=R(d),j=A(e),e!==yb.getUserMedia&&(u=a()),f)if(window.DOMException&&f instanceof window.DOMException)f={message:f.message,name:f.name};else if(\\\"object\\\"==typeof f){var v={};f.message&&(v.message=f.message),f.name&&(v.name=f.name),f.constraintName&&(v.constraintName=f.constraintName),f.stack&&(v.stack=f.stack),f=v}if(f=vc(f),p(c)){n&&(t=n.ucID),o=jc(d,c),o?(i=o.remoteUserID,q=o.startTime,r=o.pcState,s=o.pc.iceConnectionState,u=o.pcHash,k=o.pcCallback):i=na;var w=m-q;if(l={failureDelay:w,reason:j,domError:f,fabricState:r,iceConnectionState:s,function:e,magicKey:Rb,endpoint:Ya},e===yb.applicationLog||e===yb.applicationError?Xb(ib.applicationErrorLog,i,d,t,l,u,k):(Xb(ib.fabricSetupFailed,i,d,t,l,u,k),Ca.errorSinceCreate=b()-Ca.create,ec()),g||h||c&&c.localDescription||c&&c.remoteDescription){var x={sdp:{}};x.sdp.localSDP=wc(c,g,\\\"localDescription\\\"),x.sdp.remoteSDP=wc(c,h,\\\"remoteDescription\\\"),Zb(i,d,t,x,u)}}else null===Rb&&(Rb=a()),i=na,l={failureDelay:0,reason:j,domError:f,function:e,magicKey:Rb,endpoint:Ya},e===yb.applicationLog||e===yb.applicationError?Xb(ib.applicationErrorLog,i,d,t,l,null,null):Xb(ib.fabricSetupFailed,i,d,t,l,u,null);return bc(mb.success)},yc=function(a){for(var b=[],c=0;c<a.length;c++){var d=a.charCodeAt(c);d<128?b[b.length]=d:d>127&&d<2048?(b[b.length]=d>>6|192,b[b.length]=63&d|128):(b[b.length]=d>>12|224,b[b.length]=d>>6&63|128,b[b.length]=63&d|128)}return new Uint8Array(b).buffer},zc=function(a){for(var b,c=new DataView(a),d=\\\"\\\",e=0;e<c.byteLength;e++)b=c.getUint8(e).toString(16),b.length<2&&(b=\\\"0\\\"+b),d+=b;return d},Ac=function(a,b){var c={name:\\\"SHA-256\\\"};if(window.crypto){var d=window.crypto.subtle||window.crypto.webkitSubtle;if(!d)return void cc(a,b);d.digest(c,yc(a)).then(function(a){b(zc(a))}).catch(function(){cc(a,b)})}else if(window.msCrypto){if(!window.msCrypto.subtle)return void cc(a,b);var e=window.msCrypto.subtle.digest(c,yc(a));e.oncomplete=function(a){a.target&&b(zc(a.target.result))},e.onerror=function(){cc(a,b)}}else cc(a,b)},Bc=function(a,b,c){var d;if(!b||!a)return console.error(\\\"sendUserFeedback: Arguments missing/Invalid\\\"),bc(mb.error,\\\"sendUserFeedback: Arguments missing/Invalid\\\");if(\\\"object\\\"!=typeof b)return console.error(\\\"sendUserFeedback: Invalid feedback object.\\\"),bc(mb.error,\\\"sendUserFeedback: Invalid feedback object.\\\");if(0===Object.keys(b).length)return console.error(\\\"sendUserFeedback: Feedback data object must not be empty.\\\"),bc(mb.error,\\\"sendUserFeedback: Feedback data object must not be empty.\\\");var e=ab[a],f=null;void 0!==e&&void 0!==e.ucID&&(f=e.ucID);var g=null;if(g=null===Rb?db:Rb,null===f&&(f=R(a)),null===f)return console.error(\\\"sendUserFeedback: ucID unavailable\\\"),bc(mb.error,\\\"sendUserFeedback: ucID unavailable\\\");d=\\\"object\\\"==typeof b.userID?b.userID.aliasName:b.userID,b&&b.overall<=0&&(b.overall=null);var h={conferenceID:encodeURIComponent(a),magicKey:g,appID:ma,version:da,ucID:f,remoteID:encodeURIComponent(d),userID:encodeURIComponent(d),userQoe:{overall:b.overall}};return b.video&&(h.userQoe.video=b.video),b.audio&&(h.userQoe.audio=b.audio),b.screen&&(h.userQoe.screen=b.screen),b.comment&&(h.userQoe.comment=b.comment),Ua.authToken&&!cb?(h.token=Ua.authToken,Ib(\\\"feedback\\\",JSON.stringify(h)),S(kb.userFeedback,h,c)):(h.clockUnsynced=cb,Oa.cacheEvent({channel:kb.userFeedback,data:h,callback:c}),Ua.sendAuthenticationRequest(ma,d)),bc(mb.success)},Cc=function(a){return a?\\\"function\\\"!=typeof a?(console.error(\\\"attachWifiStatsHandler: Arguments Invalid\\\"),bc(mb.error,\\\"attachWifiStatsHandler: Arguments Invalid\\\")):(Z=a,void k()):(console.error(\\\"attachWifiStatsHandler: Arguments missing\\\"),bc(mb.error,\\\"attachWifiStatsHandler: Arguments missing\\\"))},Dc=function(a,b,c,d,e,f){var g=null;if(g=\\\"object\\\"==typeof b?b.aliasName:b,c||(c=ia),!(a&&d&&e&&g))return console.error(\\\"associateMstWithUserID: Arguments missing\\\"),bc(mb.error,\\\"associateMstWithUserID: Arguments missing\\\");if(!p(a))return console.error(\\\"associateMstWithUserID: Invalid PeerConnection object passed\\\"),bc(mb.error,\\\"associateMstWithUserID: Invalid PeerConnection object passed\\\");var h=ab[c];if(void 0===h)return console.error(\\\"associateMstWithUserID: conferenceID doesn't exist\\\"),bc(mb.error,\\\"associateMstWithUserID: conferenceID doesn't exist\\\");var i=null;if(i=jc(c,a),null===i)return console.error(\\\"associateMstWithUserID: Unknown pcObject passed\\\"),bc(mb.error,\\\"associateMstWithUserID: Unknown pcObject passed\\\");var j=Ub(i,d);return void 0===j&&(i.ssrcMap[d]={},j=Ub(i,d)),j.remoteUserID=g,j.ssrc=d,j.associatedVideoTag=f,j.usageLabel=e,f&&g!==na&&o(c,f,a,d),bc(mb.success)},Ec=function(a){var b=ab[ia];if(b){var c=ab[ia].participants;if(c)for(var d=0;d<c.length;d++)c[d].conferenceID=a}},Fc=function(a){Oa.updateConferenceId(encodeURIComponent(a))},Gc=function(a,b){var c=lc(b);c&&Oa.updateRemoteUserID(a,c.fabric.pcHash)},Hc=function(a,b){var c=null;c=lc(b),c&&(c.fabric.remoteUserID=a)},Ic=function(){Oa.sendCachedUserJoinedEvents(Ua),Oa.sendCachedEvents(Ua,cb)},Jc=function(a,b){return a?(a.conferenceID&&(Ec(a.conferenceID),ab[a.conferenceID]=ab[ia],Fc(a.conferenceID),Ic()),a.remoteUserID&&b&&(Gc(a.remoteUserID,b),Hc(a.remoteUserID,b),Ic()),bc(mb.success)):(console.error(\\\"setIdentifiers: Arguments missing/Invalid\\\"),bc(mb.error,\\\"_setIdentifiers: Arguments missing/Invalid\\\"))},Kc=function(a){return window&&!window.csioproxy?(console.error(\\\"setCallstatsURLs: cannot be called if window.csioproxy is false\\\"),bc(mb.error,\\\"setCallstatsURLs: cannot be called if window.csioproxy is false\\\")):a?(a.collectorURL&&(ba=a.collectorURL),a.authServiceURL&&(ca=a.authServiceURL),a.csioInternalAPIURL&&(ga=a.csioInternalAPIURL),a.wsURL&&(ea=a.wsURL),kd(),Q(),W(),bc(mb.success)):(console.error(\\\"setCallstatsURLs: Arguments missing/Invalid\\\"),bc(mb.error,\\\"setCallstatsURLs: Arguments missing/Invalid\\\"))},Lc=function(c,d,e,f,g,h){var i,k,l=null,m=pb.peer,n=qb.sendrecv,o={authStatus:!!Ua.tokenData,clockSync:!cb,msg:\\\"addNewFabric called\\\",eventType:\\\"warn\\\",pageURL:window.location.href,conferenceID:f,version:da};if(W(),Ob(ma,na,\\\"stateMachine\\\",o),l=d&&\\\"object\\\"==typeof d?d.aliasName:d,f||(f=ia),!c||!e)return console.error(\\\"addNewFabric: Arguments missing/Invalid\\\"),bc(mb.error,\\\"addNewFabric: Arguments missing/Invalid\\\");if(!ma||!na)return console.error(\\\"addNewFabric: SDK not initialized.\\\"),bc(mb.error,\\\"addNewFabric: SDK not initialized\\\");if(!p(c))return console.error(\\\"addNewFabric: Invalid PeerConnection object passed\\\"),bc(mb.error,\\\"addNewFabric: Invalid PeerConnection object passed\\\");if(!rb.hasOwnProperty(e)||e instanceof Function)return console.error(\\\"addNewFabric: Invalid fabricUsage value\\\"),bc(mb.error,\\\"addNewFabric: Invalid fabricUsage value\\\");if(h&&\\\"function\\\"==typeof h&&(i=h),g&&\\\"function\\\"==typeof g&&(i=g),g&&\\\"function\\\"!=typeof g){if(g.remoteEndpointType){if(!pb.hasOwnProperty(g.remoteEndpointType))return console.error(\\\"addNewFabric: Invalid remoteEndpointType value\\\"),bc(mb.error,\\\"addNewFabric: Invalid remoteEndpointType value\\\");m=g.remoteEndpointType}if(g.fabricTransmissionDirection){if(!qb.hasOwnProperty(g.fabricTransmissionDirection))return console.error(\\\"addNewFabric: Invalid fabricTransmissionDirection value\\\"),bc(mb.error,\\\"addNewFabric: Invalid fabricTransmissionDirection value\\\");n=g.fabricTransmissionDirection}}var q=b();Ca.addnewfabricSinceCreate=q-Ca.create,ec(),null===Rb&&(Rb=a());var r=null,s=!1;if(!L(f)){var t=G(Rb);Xb(jb.userJoined,null,f,null,t,null,null),s=!0,o={authStatus:!!Ua.tokenData,clockSync:!cb,msg:\\\"userJoined sent\\\",pageURL:window.location.href,eventType:\\\"warn\\\",conferenceID:f,version:da},Ob(ma,na,\\\"stateMachine\\\",o)}if(H(f,r,s),!jc(f,c)){if(c){new aa(c,_c,Zc,Pc,Yc)}k=a();var u={pc:c,remoteUserID:l,fabricUsage:e,magicKey:Rb,startTime:q,pcCallback:h,pcState:xb.initializing,fabricSetupSent:!1,iceCandidates:[],iceConnectionState:c.iceConnectionState,latestEventSent:q,pcHash:k,localSDP:-1,remoteSDP:-1,statsInterval:null,intervalAdaptionPhase:!0,gatheringIceCandidatesDelay:0,connectivityIceStatusDelay:0,numNegotiationNeededCalls:0,currentActivePhaseIndex:0,onHold:!1,ssrcMap:{},conferenceID:f,remoteEndpointType:m,fabricTransmissionDirection:n};Za&&(Xb(kb.senderConfiguration,d,f,null,$a,u.pcHash),Za=!1),\\\"function\\\"!=typeof c||c.callstatsID||(c.callstatsID=k),\\\"connected\\\"!==c.iceConnectionState&&\\\"completed\\\"!==c.iceConnectionState||(u.pcState=xb.established),M(f,u),u.pcState===xb.established&&(bd(c,jb.autoFabricSetup,f),Qc(u,c,f));var v=function(a){var b=0;return Object.keys(a).forEach(function(a){a&&a.mediaType&&(b+=\\\"audio\\\"===a.mediaType?1:0)}),0<b},w=function(){return!!u.ssrcMap&&v(u.ssrcMap)},x=function(){return!(!u.ssrcMap||n!==qb.sendonly)&&v(u.ssrcMap)},y=function(){return!!u.ssrcMap&&void Object.keys(u.ssrcMap).forEach(function(a){Ma.push(a)})},z=null;if(e===rb.multiplex&&w()?z={mediaType:\\\"audio\\\",ssrc:null,disruptionType:vb.noAudioInMultiplexFabric}:e===rb.audio&&x()?z={mediaType:\\\"audio\\\",ssrc:null,disruptionType:vb.noOutboundAudioOnlyFabric}:e===rb.audio&&n===qb.receiveonly&&y(),z){var A=ab[f]?ab[f].ucID:null;Xb(jb.oneWayMedia,l,f,A,z,u.pcHash)}}if(!k){var B=jc(f,c);k=B.pcHash}if(j(f,l,k),ya)try{var C=Ba;Ba=[];var D=null;if(D=ya.getId(),D&&C.push(D),C.length>0){var E=ab[f].ucID;Yb(lb.associate,f,E,C)}}catch(a){wa(\\\"send associate\\\",a)}return bc(mb.success)},Mc=function(a,b,c,d){if(!(a&&c&&d&&b))return console.error(\\\"reportUserIDChange: Arguments missing/Invalid\\\"),bc(mb.error,\\\"reportUserIDChange: Arguments missing/Invalid\\\");if(!ma||!na)return console.error(\\\"reportUserIDChange: SDK not initialized.\\\"),bc(mb.error,\\\"reportUserIDChange: SDK not initialized\\\");if(\\\"\\\"===c||\\\"\\\"===b)return console.error(\\\"reportUserIDChange: id or  conferenceID MUST not be empty\\\"),bc(mb.error,\\\"reportUserIDChange: id or  conferenceID MUST not be empty\\\");if(!p(a))return console.error(\\\"reportUserIDChange: Invalid PeerConnection object passed\\\"),bc(mb.error,\\\"reportUserIDChange: Invalid PeerConnection object passed\\\");var e,f=null,g=ab[b];if(void 0===g)return console.error(\\\"reportUserIDChange: Conference ID not found!\\\"),bc(mb.error,\\\"reportUserIDChange: Conference ID not found!\\\");var h=null;if(void 0===g.ucID)return console.error(\\\"reportUserIDChange: addNewFabric was not called\\\"),Ob(ma,na,\\\"log\\\",{msg:\\\"### reportUserIDChange: addNewFabric was not called\\\"}),bc(mb.error,\\\"reportUserIDChange: addNewFabric was not called\\\");if(h=g.ucID,f=jc(b,a),null===f)return console.error(\\\"reportUserIDChange: Invalid pcObject passed as argument\\\"),bc(mb.error,\\\"reportUserIDChange: Invalid pcObject passed as argument\\\");var i={id:c,idType:d};return Xb(ib.userIDChangedEvent,e,b,h,i,null,f.pcCallback),bc(mb.success)},Nc=function(a){var b=null;if(a&&a.length>0){var c=a.filter(function(a){return\\\"true\\\"===a.selected||\\\"true\\\"===a.googActiveConnection||a.selected===!0||a.googActiveConnection===!0});c.length>0&&(b=c[0])}return b},Oc=function(a){var c=b(),d=function(){Ca.senderConfig=-1,Ca.senderExists=!1,ec()},e=function(a){var d=JSON.parse(a.response);console.log(\\\"Sender config response:\\\",a.status,d);var e;d.recommended&&d.recommended.sender&&(e=d.recommended.sender,console.log(\\\"ConfigService, recommended SENDER info:\\\",e)),e&&($a=e,Za=!0),Ca.senderConfig=b()-c,Ca.senderExists=!!e,ec()},f=function(a){_a=a;var b=ha+ma+\\\"/configurations\\\",c={Authorization:\\\"Bearer \\\"+Ua.authToken},d={app_id:ma,local_id:na,rtc_rtp_parameters:a},f=JSON.stringify(d);Nb(b,f,e,c)},g=function(){var a={encodings:[{maxBitrate:0}]};f(a)};if(Object.keys(ab).length>1)return console.warn(\\\"Multiple PCs found, skipping\\\"),void d();if(!a.getSenders||\\\"function\\\"!=typeof a.getSenders)return console.warn(\\\"Get senders error\\\"),void g();var h,i=a.getSenders();for(var j in i){var k=i[j];if(\\\"object\\\"!=typeof k||!k.track||\\\"object\\\"!=typeof k.track||!k.track.kind)return console.warn(\\\"Access senders error\\\"),void d();if(\\\"video\\\"===k.track.kind){if(h)return console.warn(\\\"Multiple video sender, skipping\\\"),void d();h=k}}if(!h)return console.warn(\\\"No video sender found\\\"),void d();if(!h.getParameters||\\\"function\\\"!=typeof h.getParameters)return console.warn(\\\"Sender getParameters error\\\"),void g();var l=h.getParameters();return\\\"object\\\"!=typeof l?void d():(\\\"encodings\\\"in l||(l.encodings=[]),0===l.encodings.length&&l.encodings.push({maxBitrate:0}),void f(l))},Pc=function(a,c){if(a){var d,e=null;if(void 0!==c){var f=c.signalingState;if(e=lc(c),e&&e.fabric){d=e.fabric.signalingState,e.fabric.signalingState=f;var g=e.conferenceID,h=e.fabric,i=h.remoteUserID,j=ab[g].ucID,k={changedState:Gb.signalingState,prevState:d,newState:f};$b(c,h,g,j,i,h.pcHash,k),\\\"closed\\\"===f&&tc(c,ib.fabricTerminated,e.conferenceID),\\\"have-local-offer\\\"!==f&&\\\"have-local-pranswer\\\"!==f&&\\\"stable\\\"!==f||e.sentSenderConfigRequest||(console.log(f,\\\".. requesting sender config.\\\",e.sentSenderConfigRequest),e.sentSenderConfigRequest=!0,Oc(c))}if(\\\"closed\\\"===f&&ya)try{ya.callFinished()}catch(a){wa(\\\"callFinished\\\",a),ya.crashDisconnect()}if(\\\"have-remote-offer\\\"===f||\\\"stable\\\"===f){if(Ca.remoteofferSinceCreate=b()-Ca.create,ec(),ya)try{ya.callStarts()}catch(a){wa(\\\"callStarts\\\",a),ya.crashDisconnect()}Ob(ma,na,\\\"log\\\",{msg:\\\"precalltest told to stop \\\"+va}),va+=\\\"(stopped)\\\"}}}},Qc=function(a,c,d){if(!a.onHold){var e=c,f=d;null===a.statsInterval&&(a.statsPollingStart=b(),ad(e,f),a.statsInterval=setInterval(function(){ad(e,f)},ua))}},Rc=function(a,b,c,d,e,f){f.localCandidates=b.localCandidates,f.remoteCandidates=b.remoteCandidates,f.iceCandidatePairs=b.iceCandidatePairs,Xb(jb.iceFailed,c,d,e,f,b.pcHash,b.pcCallback)},Sc=function(a,b,c,d){var e=b.iceConnectionState,f=b.remoteUserID,g=ab[c],h={prevIceConnectionState:e,currIceConnectionState:a.iceConnectionState,currPair:b.activeIceCandidatePair,failureDelay:d};b.pcState=xb.failed,\\\"checking\\\"===e?Rc(a,b,f,c,g.ucID,h):\\\"completed\\\"===e||\\\"connected\\\"===e?Xb(jb.fabricDropped,f,c,g.ucID,h,b.pcHash,b.pcCallback):\\\"disconnected\\\"===e&&b.established?Xb(jb.fabricDropped,f,c,g.ucID,h,b.pcHash,b.pcCallback):\\\"disconnected\\\"===e&&Rc(a,b,f,c,g.ucID,h)},Tc=function(a,c,d,e){var f=c.iceConnectionState,g=c.remoteUserID,h=ab[d],i=b(),j={prevIceConnectionState:f,currIceConnectionState:a.iceConnectionState,prevPair:c.activeIceCandidatePair},k=c.pcState===xb.disrupted,l=\\\"completed\\\"===a.iceConnectionState;c.connectivityIceStatusDelay=e,c.established=!0,sc(a,function(a){if(c.localCandidates=a.localCandidates,c.remoteCandidates=a.remoteCandidates,c.iceCandidatePairs=a.iceCandidatePairs,c.activeIceCandidatePair=Nc(c.iceCandidatePairs),j.currPair=c.activeIceCandidatePair,j.disruptionDelay=i-c.disruptedTS,k)Xb(jb.iceDisruptionEnd,g,d,h.ucID,j,c.pcHash);else if(l){var b={};b.iceCandidatePairs=a.iceCandidatePairs,Xb(jb.iceCompleted,g,d,h.ucID,b,c.pcHash)}}),bd(c.pc,jb.autoFabricSetup,d),c.pcState=xb.established,Qc(c,a,d,g)},Uc=function(a,c,d){var e=c.iceConnectionState,f=c.remoteUserID,g=ab[d],h=b(),i={prevIceConnectionState:e,currIceConnectionState:a.iceConnectionState,prevIceConnectionStateTs:c.iceConnectionStateTS,currPair:c.activeIceCandidatePair};c.startTime=h,\\\"connected\\\"===e||\\\"completed\\\"===e?(c.pcState=xb.disrupted,c.disruptedTS=h,Xb(jb.iceDisruptionStart,f,d,g.ucID,i,c.pcHash,c.pcCallback),c.pcCallback&&c.pcCallback(nb.appConnectivityError,\\\"Connectivity check for PC object to \\\"+f+\\\" failed.\\\")):\\\"checking\\\"===e&&(c.pcState=xb.checkingDisrupted,c.disruptedTS=h,Xb(jb.iceConnectionDisruptionStart,f,d,g.ucID,i,c.pcHash,c.pcCallback),c.pcCallback&&c.pcCallback(nb.appConnectivityError,\\\"Connectivity check for PC object to \\\"+f+\\\" failed.\\\"))},Vc=function(a,b,c,d){var e=b.iceConnectionState,f=b.remoteUserID,g=ab[c],h={prevIceConnectionState:e,currIceConnectionState:a.iceConnectionState};\\\"new\\\"===e||\\\"checking\\\"===e?(h.failureDelay=d,Xb(jb.iceAborted,f,c,g.ucID,h,b.pcHash,b.pcCallback)):(h.currPair=b.activeIceCandidatePair,\\nXb(jb.iceTerminated,f,c,g.ucID,h,b.pcHash,b.pcCallback))},Wc=function(a,b,c){var d=b.iceConnectionState,e=b.remoteUserID,f=ab[c],g={prevIceConnectionState:d,currIceConnectionState:a.iceConnectionState,prevPair:b.activeIceCandidatePair};\\\"new\\\"!==d&&(b.established=!1,Xb(jb.iceRestarted,e,c,f.ucID,g,b.pcHash,b.pcCallback))},Xc=function(a,c,d,e){var f=c.iceConnectionState,g=c.remoteUserID,h=ab[d],i=b(),j={prevIceConnectionState:f,currIceConnectionState:a.iceConnectionState};c.gatheringIceCandidatesDelay=e,\\\"disconnected\\\"===f&&c.pcState===xb.checkingDisrupted&&(j.disruptionDelay=i-c.disruptedTS,Xb(jb.iceConnectionDisruptionEnd,g,d,h.ucID,j,c.pcHash,c.pcCallback))},Yc=function(a,b){if(a&&void 0!==b){var c=null;c=lc(b),c&&c.fabric&&c.fabric.numNegotiationNeededCalls++}},Zc=function(a,c){if(a&&void 0!==c){var d,e,f,g,h,i=null,j=null;if(j=lc(c),j&&j.fabric){i=j.fabric,d=j.conferenceID,e=b(),f=e-i.startTime,g=i.iceConnectionState,h=i.iceGatheringState;var k=i.remoteUserID,l=ab[d].ucID,m={changedState:Gb.iceConnectionState,prevState:g,newState:c.iceConnectionState};if($b(c,i,d,l,k,i.pcHash,m),h!==c.iceGatheringState){var n={changedState:Gb.iceGatheringState,prevState:h,newState:c.iceGatheringState};$b(c,i,d,l,k,i.pcHash,n)}\\\"complete\\\"===c.iceGatheringState&&\\\"checking\\\"===c.iceConnectionState&&Xc(c,i,d,f),\\\"connected\\\"===c.iceConnectionState||\\\"completed\\\"===c.iceConnectionState?Tc(c,i,d,f):\\\"failed\\\"===c.iceConnectionState?Sc(c,i,d,f):\\\"disconnected\\\"===c.iceConnectionState?Uc(c,i,d):\\\"closed\\\"===c.iceConnectionState?Vc(c,i,d,f):\\\"new\\\"===c.iceConnectionState&&Wc(),i.iceConnectionState=c.iceConnectionState,i.iceGatheringState=c.iceGatheringState,i.iceConnectionStateTS=b()}}},$c=function(a,b){var c=lc(a);if(c&&c.fabric){var d=c.fabric,e=d.remoteUserID,f=c.conferenceID,g=ab[f].ucID;Xb(jb.iceCandidateFound,e,f,g,b,d.pcHash)}},_c=function(a,b){var c,d,e;if(void 0!==b){if(null!==a.candidate){var f=a.candidate.candidate;d=f.split(\\\" \\\");var g=\\\"1\\\"===d[1]?\\\"rtp\\\":\\\"rtcp\\\";\\\"0\\\"!==d[5]&&(e=d[4].indexOf(\\\":\\\")!==-1,c={transport:d[2],protocol:g,typePreference:d[3],address:e?\\\"[\\\"+d[4]+\\\"]:\\\"+d[5]:d[4]+\\\":\\\"+d[5],type:d[7],media:a.candidate.sdpMid})}var h=null;h=lc(b),sc(b,function(a){h.localCandidates=a.localCandidates,h.remoteCandidates=a.remoteCandidates,h.iceCandidatePairs=a.iceCandidatePairs,h.activeIceCandidatePair=Nc(h.iceCandidatePairs)}),h&&h.fabric&&(void 0!==c&&h.fabric.iceCandidates.indexOf(c)===-1&&h.fabric.iceCandidates.push(c),c&&h.fabric.fabricSetupSent&&$c(b,c))}},ad=function(a,b){if(!ab.hasOwnProperty(b))return void console.error(\\\"ConferenceID %o doesn't exist. Can't call getStats for it.\\\",b);if(\\\"closed\\\"===a.signalingState)return tc(a,ib.fabricTerminated,b),!0;var c=jc(b,a);if(c.pcState!==xb.established&&c.lastFabricState===c.pcState&&\\\"connected\\\"!==a.iceConnectionState&&\\\"completed\\\"!==a.iceConnectionState)return!0;var d=ab[b].ucID;try{rc(a,c.pcCallback,z,na,d,c)}catch(a){console.log(\\\"csioGetStats: Error\\\",a)}},bd=function(a,c,d){var e,f=null,g=ab[d],h=null,i=b();if(void 0===g&&console.error(\\\"sendAutoFabricSetupEvent: Conference ID not found!\\\"),h=jc(d,a),null===h&&console.error(\\\"sendAutoFabricSetupEvent: fabricData is null\\\"),!h.fabricSetupSent){f=h.remoteUserID,e=i-h.startTime;var j={setupDelay:e,iceGatheringDelay:h.gatheringIceCandidatesDelay,iceConnectivityDelay:h.connectivityIceStatusDelay,remoteEndpointType:h.remoteEndpointType,fabricTransmissionDirection:h.fabricTransmissionDirection};cb||(j.clockSyncOffset=bb.currentOffset),sc(a,function(a){j.localCandidates=a.localCandidates,j.remoteCandidates=a.remoteCandidates,j.iceCandidatePairs=a.iceCandidatePairs,h.localCandidates=a.localCandidates,h.remoteCandidates=a.remoteCandidates,h.iceCandidatePairs=a.iceCandidatePairs,h.pcState=xb.established,h.activeIceCandidatePair=Nc(h.iceCandidatePairs),h.fabricSetupSent||(Xb(c,f,d,g.ucID,j,h.pcHash,h.pcCallback),h.fabricSetupSent=!0)})}},cd=function(a,b,c){var d={},e=null,f=ab[c],g=null;void 0===f&&console.error(\\\"sendFabricTransportSwitchEvent: Conference ID not found!\\\"),g=jc(c,a),null===g&&console.error(\\\"sendFabricTransportSwitchEvent: fabricData is null\\\"),e=g.remoteUserID,d.prevPair=g.activeIceCandidatePair,sc(a,function(a){d.currPair=Nc(a.iceCandidatePairs),g.activeIceCandidatePair=d.currPair,d.switchDelay=null,d.relayType=g.transportData.relayType,Xb(b,e,c,f.ucID,d,g.pcHash,g.pcCallback)})},dd=function(a,b){if(a.trackStats){var c=a.trackStats.filter(function(a){return a.id===b});if(c.length>0)return c[0]}},ed=function(a,b){if(a.codec){var c=a.codec.filter(function(a){return a.id===b});if(c.length>0)return c[0]}},fd=function(a,b){if(a.candidatePair){var c=a.candidatePair.filter(function(a){return a.id===b});if(c.length>0)return c[0]}},gd=function(a){for(var b,c,d=a.Transport.length,e=0;e<d;e++)c=a.Transport[e],c.selectedCandidatePairId&&(b=fd(a,c.selectedCandidatePairId),b&&(a.Transport[e]=y(a.Transport[e],b)));return a},hd=function(a){for(var b,c,d,e=a.streams.length,f=0;f<e;f++)b=a.streams[f],b.data.trackId&&(c=dd(a,b.data.trackId),c&&(a.streams[f].data=y(a.streams[f].data,c))),b.data.codecId&&(d=ed(a,b.data.codecId),d&&(a.streams[f].data=y(a.streams[f].data,d)));return a},id=function(a,b,c){b.hasOwnProperty(a)&&(b[a].hasOwnProperty(\\\"video\\\")&&(b[a].video.isGreaterBetter?(c.video.gThreshold=b[a].video.upperThreshold,c.video.rThreshold=b[a].video.lowerThreshold):(c.video.gThreshold=b[a].video.lowerThreshold,c.video.rThreshold=b[a].video.upperThreshold)),b[a].hasOwnProperty(\\\"audio\\\")&&(b[a].audio.isGreaterBetter?(c.audio.gThreshold=b[a].audio.upperThreshold,c.audio.rThreshold=b[a].audio.lowerThreshold):(c.audio.gThreshold=b[a].audio.lowerThreshold,c.audio.rThreshold=b[a].audio.upperThreshold)))},jd=function(a,c,d){var e=[],f=null,g=null;for(var h in c)c.hasOwnProperty(h)&&e.push(encodeURIComponent(h)+\\\"=\\\"+encodeURIComponent(c[h]));var i=e.join(\\\"&\\\"),j=new XMLHttpRequest;j.open(\\\"POST\\\",a),j.setRequestHeader(\\\"Content-Type\\\",\\\"application/x-www-form-urlencoded\\\"),f=b(),j.onload=function(){g=b();var a=g-f;d(j,a)},j.send(i)},kd=function(){Mb(ga,null,5e3,function(a){if(200===a.status)try{var b=JSON.parse(a.responseText);id(\\\"eModelThreshold\\\",b,Eb),id(\\\"throughputThreshold\\\",b,Ab),id(\\\"fractionalLossThreshold\\\",b,Db),id(\\\"rttThreshold\\\",b,Cb),id(\\\"currOverPrevFrameRateThreshold\\\",b,Bb)}catch(a){return a}},function(){cb&&kd()})},ld=function(){var a=ba+\\\"clockSync\\\",c=null,d=null;Mb(a,null,5e3,function(a,e){200===a.status?(c=JSON.parse(a.response),d=b(),md(c,e,d)):cb&&setTimeout(function(){ld()},100)},function(){cb&&ld()})},md=function(a,b,c){if(cb){var d=b/2;if(d>bb.maxAllowedLatency)bb.offsetResults=[],Ob(ma,na,\\\"log\\\",{msg:\\\"clockSync restarting\\\"});else{var e=a.now+d,f=e-c;bb.offsetResults.push(f),Ob(ma,na,\\\"log\\\",{msg:\\\"clockSync Info serverTime \\\"+e+\\\" responseRecvTs \\\"+c+\\\" requestExecutionTime \\\"+b})}if(bb.offsetResults.length>=bb.syncAttempts){var g=bb.offsetResults.reduce(function(a,b){return a+b});bb.currentOffset=g/bb.offsetResults.length,Ob(ma,na,\\\"log\\\",{msg:\\\"clockSync Done \\\"+bb.currentOffset+\\\"Length \\\"+bb.offsetResults.length}),bb.offsetResults=[],cb=!1,Oa.sendCachedUserJoinedEvents(Ua),Oa.sendCachedEvents(Ua,cb)}else cb&&setTimeout(function(){ld()},100)}},nd=function(){var a=this,c=null,d=!1,e=!1,f={},g={initiated:\\\"initiated\\\",connected:\\\"connected\\\",closed:\\\"closed\\\"};this._wsConnectionState=g.closed;var h=function(a,b){try{if(window&&window.sessionStorage){var c=JSON.parse(window.sessionStorage.getItem(\\\"csio_ucid_data\\\"));c||(c={}),c[a]||(c[a]={}),c[a].ucID=b,window.sessionStorage.setItem(\\\"csio_ucid_data\\\",JSON.stringify(c))}}catch(a){return}f[a]=fa+ma+\\\"/conferences/\\\"+encodeURIComponent(a)+\\\"/\\\"+b+\\\"/general\\\"};this.getConferenceURL=function(){return f},this._setupWebSocketConnection=function(f){return a._wsConnectionState===g.initiated||a._wsConnectionState===g.connected?(Ob(ma,na,\\\"log\\\",{msg:\\\"### _setupWebSocketConnection is called when already connected!\\\"}),console.log(\\\"### _setupWebSocketConnection is called when already connected!\\\"),void(f&&f(nb.success,\\\"WebSocket establishment successful.\\\"))):(a._wsConnectionState=g.initiated,c=new WebSocket(ea,\\\"echo-protocol\\\"),c.onopen=function(){console.log(\\\"**** Successfully connected to the backend \\\",e,na),Ob(ma,na,\\\"log\\\",{msg:\\\"Successfully connected to the backend\\\"}),a._wsConnectionState=g.connected,d?e=!0:d=!0,Oa.sendCachedUserJoinedEvents(Ua),e&&(P(),Oa.sendCachedEvents(Ua,cb)),e=!1},c.onclose=function(){a._wsConnectionState=g.closed,console.log(\\\"**** Connection to the server closed.\\\"),Ob(ma,na,\\\"log\\\",{msg:\\\"Connection to the server closed.\\\"}),K(),c&&(c=null),f&&f(nb.httpError,\\\"Connection to the server closed.\\\")},c.onerror=function(b){a._wsConnectionState=g.closed,Ob(ma,na,\\\"log\\\",{msg:\\\"WebSocket establishment failed.\\\"}),console.log(\\\"WebSocket establishment failed.\\\",b),f&&f(nb.wsChannelFailure,\\\"WebSocket establishment failed.\\\",b)},void(c.onmessage=function(a){var c,d=a.data,e=b(),g=JSON.parse(d);if(\\\"Error\\\"===g.status)\\\"Invalid client token.\\\"===g.reason&&(Ua.tokenData=null,Ua.authToken=null,Ua.sendAuthenticationRequest(ma,na)),f&&f(nb.csProtoError,d.reason);else if(\\\"200 OK\\\"===g.status)if(\\\"feedback\\\"===g.event)Kb(\\\"feedback\\\");else if(g.event===jb.userJoined||g.event===jb.refreshPresence){var i=!1,j=null;c=decodeURIComponent(g.conferenceID);var k=function(a){return setInterval(function(){ac(a)},Ha)};ab.hasOwnProperty(c)&&(ab[c].ucID!==g.ucID&&(i=!0,h(c,g.ucID),j=g.conferenceCreationTS?g.conferenceCreationTS:g.conferenceDuration),g.event!==jb.userJoined||ab[c].refreshPresence||(ab[c].refreshPresence=k(c),X()),ab[c].ucID=g.ucID),Oa.sendCachedFeedback(),Oa.sendCachedEvents(Ua,cb,i,j,c,g.ucID)}else g.event===kb.clockSync?md(g,e):g.event===ib.fabricSetupFailed&&(c=decodeURIComponent(g.conferenceID),g.ucID&&(h(c,g.ucID),Oa.sendCachedFeedback(),Oa.sendCachedEvents(Ua,cb,!0,0,c,g.ucID)))}))},this._isChannelReady=function(){return!(!c||1!==c.readyState)},this.getWSConnectionState=function(){return c?c.readyState:-1},this.send=function(a){c.send(JSON.stringify(a))}},od=new nd,pd=function(a,b,c){if(od._isChannelReady())try{od.send(b)}catch(d){d&&\\\"InvalidStateError\\\"===d.name&&Oa.cacheEvent({channel:a,data:b,callback:c})}else Oa.cacheEvent({channel:a,data:b,callback:c}),od._setupWebSocketConnection()};return f(),Lb(),Y(),window&&!window.csioproxy&&(kd(),Q()),window&&window.csioChromeLegacyGetStats&&(La=!1),{version:da,initialize:dc,on:fc,fabricEvent:ib,addNewFabric:Lc,sendFabricEvent:tc,sendUserFeedback:Bc,associateMstWithUserID:Dc,attachWifiStatsHandler:Cc,csError:nb,fabricUsage:rb,qualityRating:tb,webRTCFunctions:yb,reportError:xc,reportUserIDChange:Mc,userIDType:sb,setProxyConfig:Kc,callStatsAPIReturnStatus:mb,setIdentifiers:Jc,transmissionDirection:qb,endpointType:pb}} true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (a),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):global.callstats=a,module.exports=a}(\\\"undefined\\\"!=typeof window?window:\\\"undefined\\\"!=typeof global?global:this);\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\\n\\n/***/ }),\\n/* 71 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! callstats.js  version = 3.27.0 2017-12-14 */\\nfunction callstatsUtils(){}callstatsUtils.prototype.measureAppLoadingPerformance=function(a){var b=0,c=Number.MAX_VALUE,d=0,e=\\\"\\\",f=\\\"\\\",g=window.performance;if(!(\\\"performance\\\"in window&&\\\"timing\\\"in window.performance&&\\\"navigation\\\"in window.performance))return{support:\\\"none\\\",total:void 0};var h=g.timing.loadEventEnd-g.timing.navigationStart;if(\\\"Chrome\\\"===a.name||\\\"Opera\\\"===a.name){var i,j=g.getEntriesByType(\\\"resource\\\");for(i=0;i<j.length;i++)j[i].duration>d&&(f=j[i].name.substr(j[i].name.lastIndexOf(\\\"/\\\")+1),d=j[i].duration),j[i].duration<c&&(e=j[i].name.substr(j[i].name.lastIndexOf(\\\"/\\\")+1),c=j[i].duration),j[i].name.indexOf(\\\"CALLSTATS_SRC_URLstatic/callstats\\\")>-1&&(b=j[i].duration);return{support:\\\"full\\\",callstats:b,min:{name:e,time:c},max:{name:f,time:d},total:h}}return\\\"Firefox\\\"===a.name?{support:\\\"limited\\\",total:h}:void 0},callstatsUtils.prototype.detectBrowserInfo=function(){var a=\\\"Chrome\\\",b=null,c=null,d=null,e={goog:\\\"Chrome\\\",moz:\\\"Firefox\\\",plugin:\\\"Plugin\\\",edge:\\\"Edge\\\"},f=e.goog;if(!window.navigator.userAgent||window.csioReactNative)return console.log(\\\"Invalid userAgent\\\"),window&&window.csioGetOsName&&(b=window.csioGetOsName()),window&&window.csioGetOsVer&&(c=window.csioGetOsVer()),window&&window.csioReactNative&&(d=\\\"react-native\\\"),{name:a,codebase:f,os:b,osVersion:c,userAgent:d};d=navigator.userAgent;var g,h=d.toLowerCase(),i=navigator.appVersion,j=\\\"\\\"+parseFloat(navigator.appVersion);(g=h.indexOf(\\\"opera\\\"))!==-1?(a=\\\"Opera\\\",j=h.substring(g+6),(g=h.indexOf(\\\"Version\\\"))!==-1&&(j=h.substring(g+8)),f=e.goog):(g=h.indexOf(\\\"opr\\\"))!==-1?(a=\\\"Opera\\\",j=h.substring(g+4),(g=h.indexOf(\\\"Version\\\"))!==-1&&(j=h.substring(g+8)),f=e.goog):(g=h.indexOf(\\\"msie\\\"))!==-1?(a=\\\"Microsoft Internet Explorer\\\",j=h.substring(g+5),f=e.goog):(g=h.indexOf(\\\"edge\\\"))!==-1?(a=e.edge,j=h.substring(g+5),f=e.edge):(g=h.indexOf(\\\"chrome\\\"))!==-1?(a=e.goog,j=h.substring(g+7),f=e.goog):(g=h.indexOf(\\\"safari\\\"))!==-1?(a=\\\"Safari\\\",j=h.substring(g+7),(g=h.indexOf(\\\"version\\\"))!==-1&&(j=h.substring(g+8)),f=e.goog):(g=h.indexOf(\\\"firefox\\\"))!==-1?(a=\\\"Firefox\\\",j=h.substring(g+8),f=e.moz):(g=h.indexOf(\\\"trident\\\"))!==-1&&(a=\\\"Microsoft Internet Explorer\\\",g=h.indexOf(\\\"rv\\\"),j=h.substring(g+3,g+7),f=e.goog);var k,l,m=[{s:\\\"Windows 3.11\\\",r:/win16/},{s:\\\"Windows 95\\\",r:/(windows 95|win95|windows_95)/},{s:\\\"Windows ME\\\",r:/(win 9x 4.90|windows me)/},{s:\\\"Windows 98\\\",r:/(windows 98|win98)/},{s:\\\"Windows CE\\\",r:/windows ce/},{s:\\\"Windows 2000\\\",r:/(windows nt 5.0|windows 2000)/},{s:\\\"Windows XP\\\",r:/(windows nt 5.1|windows xp)/},{s:\\\"Windows Server 2003\\\",r:/windows nt 5.2/},{s:\\\"Windows Vista\\\",r:/windows nt 6.0/},{s:\\\"Windows 7\\\",r:/(windows 7|windows nt 6.1)/},{s:\\\"Windows 8.1\\\",r:/(windows 8.1|windows nt 6.3)/},{s:\\\"Windows 8\\\",r:/(windows 8|windows nt 6.2)/},{s:\\\"Windows 10\\\",r:/(windows 10|windows nt 10.0)/},{s:\\\"Windows NT 4.0\\\",r:/(windows nt 4.0|winnt4.0|winnt|windows nt)/},{s:\\\"Windows ME\\\",r:/windows me/},{s:\\\"Android\\\",r:/android/},{s:\\\"Open BSD\\\",r:/openbsd/},{s:\\\"Sun OS\\\",r:/sunos/},{s:\\\"Linux\\\",r:/(linux|x11)/},{s:\\\"iOS\\\",r:/(iphone|ipad|ipod)/},{s:\\\"Mac OS X\\\",r:/mac os x/},{s:\\\"Mac OS\\\",r:/(macppc|macintel|mac_powerpc|macintosh)/},{s:\\\"QNX\\\",r:/qnx/},{s:\\\"UNIX\\\",r:/unix/},{s:\\\"BeOS\\\",r:/beos/},{s:\\\"OS/2\\\",r:/os\\\\/2/},{s:\\\"Search Bot\\\",r:/(nuhk|googlebot|yammybot|openbot|slurp|msnbot|ask jeeves\\\\/teoma|ia_archiver)/}];for(k in m)if(l=m[k],l.r.test(h)){b=l.s;break}switch(b&&/Windows/.test(b)&&(c=/Windows (.*)/.exec(b)[1],b=\\\"Windows\\\"),b){case\\\"Mac OS X\\\":c=/mac os x (10[\\\\.\\\\_\\\\d]+)/.exec(h)[1];break;case\\\"Android\\\":c=/android ([\\\\.\\\\_\\\\d]+)/.exec(h)[1];break;case\\\"iOS\\\":c=/os (\\\\d+)_(\\\\d+)_?(\\\\d+)?/.exec(i),c=c[1]+\\\".\\\"+c[2]+\\\".\\\"+(0|c[3])}return{name:a,ver:j.toString(),os:b,osVersion:c,codebase:f,userAgent:d}},module.exports=callstatsUtils;\\n\\n/***/ }),\\n/* 72 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/*! callstats.js  version = 3.27.0 2017-12-14 */\\nfunction PusherPlug(){this.invoker=null,this.receiver=null}function Notifier(){this.listeners=[]}function SenderGate(a){this.stats=null,this.lastResponsed=(new Date).getTime(),this.onDataSent=a}function Measurement(a){this.ssrc=null,this.direction=void 0,this.mediaType=null,this.resolution=null,this.frameRateReceived=null,this.frameWidth=null,this.rtt=null,this.droppedFramesNum=null,this.packetLosts=null,this.jitter=null,this.bytesReceived=-1,this.packetsReceived=-1,this.packetsDiscarded=-1,this.bytesSent=-1,this.packetsSent=-1,this.stream=a}function NumberComparator(a,b){var c=\\\"number\\\"==typeof a?a:parseInt(a),d=\\\"number\\\"==typeof b?b:parseInt(b);return c===d?0:c<d?-1:1}function MeasurementRTTComparator(a,b){return NumberComparator(a.rtt,b.rtt)}function MeasurementFrameHeightComparator(a,b){return NumberComparator(a.frameHeight,b.frameHeight)}function MeasurementFrameWidthComparator(a,b){return NumberComparator(a.frameWidth,b.frameWidth)}function MeasurementJitterComparator(a,b){return NumberComparator(a.jitter,b.jitter)}function MeasurementFrameRateReceivedComparator(a,b){var c=parseInt(a.frameRateReceived),d=parseInt(b.frameRateReceived);return c===d?0:c<d?-1:1}function MeasurementMerger(a,b){return a}function Assembler(){this.codeBase=null,this.mediaType={unknown:\\\"unknown\\\",audio:\\\"audio\\\",video:\\\"video\\\"},this.codeBaseType={chrome:\\\"Chrome\\\",firefox:\\\"Firefox\\\",edge:\\\"Edge\\\"}}function SWValueTracker(a){SWPlugin.call(this),this.extractorFnc=a,this.prev=0,this.delta=0,this.first=0,this.actual=0,this.addSignalListener(Reporter.Signals.onDataSent,this.onDataSent,this)}function SWValueHolder(a){SWPlugin.call(this),this.extractorFnc=a,this.prev=null}function FractionLost(a,b){this.intervalPacketsRecv=b,this.intervalLoss=a}function FractionLostComparator(a,b){var c=a.getValue(),d=b.getValue();return c===d?0:c<d?-1:1}function FractionLostMerger(a,b){var c=(a.getIntervalLoss()+b.getIntervalLoss())/2,d=(a.getIntervalPacketsRecv()+b.getIntervalPacketsRecv())/2;return new FractionLost(c,d)}function Monitor(){this.measurements=new SlidingWindow(Reporter.maxItemsNum,Reporter.timeoutInMs),this.packetLostTracker=new SWValueTracker(function(a){return a.packetLosts}),this.measurements.addPlugin(this.packetLostTracker),this.packetsDiscardedTracker=new SWValueTracker(function(a){return a.packetsDiscarded}),this.measurements.addPlugin(this.packetsDiscardedTracker),this.resolutionTracker=new SWValueHolder(function(a){return a.resolution}),this.measurements.addPlugin(this.resolutionTracker),this.jitter95PercentileTracker=new SWPercentileTracker(MeasurementJitterComparator,95,MeasurementMerger),this.measurements.addPlugin(this.jitter95PercentileTracker),this.jitter95PercentileTracker.addFilter(function(a){return void 0!==a.jitter&&null!==a.jitter}),this.rtt95PercentileTracker=new SWPercentileTracker(MeasurementRTTComparator,95,MeasurementMerger),this.measurements.addPlugin(this.rtt95PercentileTracker),this.rtt95PercentileTracker.addFilter(function(a){return void 0!==a.rtt&&null!==a.rtt&&0<a.rtt}),this.frameHeight50PercentileTracker=new SWPercentileTracker(MeasurementFrameHeightComparator,50,MeasurementMerger),this.measurements.addPlugin(this.frameHeight50PercentileTracker),this.frameHeight50PercentileTracker.addFilter(function(a){return void 0!==a.frameHeight&&null!==a.frameHeight&&0<a.frameHeight}),this.frameHeight95PercentileTracker=new SWPercentileTracker(MeasurementFrameHeightComparator,95,MeasurementMerger),this.measurements.addPlugin(this.frameHeight95PercentileTracker),this.frameHeight95PercentileTracker.addFilter(function(a){return void 0!==a.frameHeight&&null!==a.frameHeight&&0<a.frameHeight}),this.frameRate50PercentileTracker=new SWPercentileTracker(MeasurementFrameRateReceivedComparator,50,MeasurementMerger),this.measurements.addPlugin(this.frameRate50PercentileTracker),this.frameRate50PercentileTracker.addFilter(function(a){return void 0!==a.frameRateReceived&&null!==a.frameRateReceived}),this.frameRate95PercentileTracker=new SWPercentileTracker(MeasurementFrameRateReceivedComparator,95,MeasurementMerger),this.measurements.addPlugin(this.frameRate95PercentileTracker),this.frameRate95PercentileTracker.addFilter(function(a){return void 0!==a.frameRateReceived&&null!==a.frameRateReceived}),this.frameWidth50PercentileTracker=new SWPercentileTracker(MeasurementFrameWidthComparator,50,MeasurementMerger),this.measurements.addPlugin(this.frameWidth50PercentileTracker),this.frameWidth50PercentileTracker.addFilter(function(a){return void 0!==a.frameWidth&&null!==a.frameWidth&&0<a.frameWidth}),this.frameWidth95PercentileTracker=new SWPercentileTracker(MeasurementFrameWidthComparator,95,MeasurementMerger),this.measurements.addPlugin(this.frameWidth95PercentileTracker),this.frameWidth95PercentileTracker.addFilter(function(a){return void 0!==a.frameWidth&&null!==a.frameWidth&&0<a.frameWidth}),this.rttAvgRTTracker=new SWAvg(function(a){return a.rtt}),this.measurements.addPlugin(this.rttAvgRTTracker),this.rttAvgRTTracker.addFilter(function(a){return void 0!==a.rtt&&null!==a.rtt&&0<a.rtt}),this.frameRateMeanTracker=new SWAvg(function(a){return a.frameRateReceived}),this.measurements.addPlugin(this.frameRateMeanTracker),this.frameRateMeanTracker.addFilter(function(a){return void 0!==a.frameRateReceived&&null!==a.frameRateReceived&&0<a.frameRateReceived}),this.frameHeightMeanTracker=new SWAvg(function(a){return a.frameHeight}),this.measurements.addPlugin(this.frameHeightMeanTracker),this.frameHeightMeanTracker.addFilter(function(a){return void 0!==a.frameHeight&&null!==a.frameHeight&&0<a.frameHeight}),this.frameWidthMeanTracker=new SWAvg(function(a){return a.frameWidth}),this.measurements.addPlugin(this.frameWidthMeanTracker),this.frameWidthMeanTracker.addFilter(function(a){return void 0!==a.frameHeight&&null!==a.frameWidth&&0<a.frameWidth}),this.jitterAvgTracker=new SWAvg(function(a){return a.jitter}),this.measurements.addPlugin(this.jitterAvgTracker),this.jitterAvgTracker.addFilter(function(a){return void 0!==a.jitter&&null!==a.jitter&&0<a.jitter}),this.intervalFractionLosts=new SlidingWindow(Reporter.maxItemsNum,Reporter.timeoutInMs),this.FLPercentileTracker=new SWPercentileTracker(FractionLostComparator,95,FractionLostMerger),this.intervalFractionLosts.addPlugin(this.FLPercentileTracker),this.lastSent=0,this.firstAdded=0,this.lastAdded=0,this.doSending=!1,this.mediaType=null,this.direction=null,this.lastTraffic=0,this.ssrc=0}function InboundMonitor(){Monitor.call(this),this.bytesReceivedTracker=new SWValueTracker(function(a){return a.bytesReceived}),this.packetsReceivedTracker=new SWValueTracker(function(a){return a.packetsReceived}),this.addPlugin(this.bytesReceivedTracker),this.addPlugin(this.packetsReceivedTracker),this.csioIntBRKbpsCount=0,this.csioIntPRCount=0}function InbAudioMonitor(){InboundMonitor.call(this),this.quality={eModel:0,bandwidth:0},this.direction=Measurement.Direction.inbound,this.mediaType=Measurement.MediaTypes.audio}function InbVideoMonitor(){InboundMonitor.call(this),this.frameRateReceivedTracker=new SWValueTracker(function(a){return a.frameRateReceived}),this.frameRatePercTracker=new SWPercentileTracker(MeasurementFrameRateReceivedComparator,10,MeasurementMerger),this.frameRatePercTracker.addFilter(function(a){return void 0!==a.frameRateReceived&&null!==a.frameRateReceived}),this.frameRatePercTracker.attach(this.setFrameRateReceived10,this),this.frameRateReceived10=null,this.addPlugin(this.frameRatePercTracker),this.addPlugin(this.frameRateReceivedTracker),this.quality={eModel:0,bandwidth:0,frameRate:0},this.direction=Measurement.Direction.inbound,this.mediaType=Measurement.MediaTypes.video}function OutboundMonitor(){Monitor.call(this),this.bytesSentTracker=new SWValueTracker(function(a){return a.bytesSent}),this.packetsSentTracker=new SWValueTracker(function(a){return a.packetsSent}),this.addPlugin(this.bytesSentTracker),this.addPlugin(this.packetsSentTracker),this.csioIntBRKbpsCount=0,this.csioIntPRCount=0}function OutbVideoMonitor(){OutboundMonitor.call(this),this.frameRateReceivedTracker=new SWValueTracker(function(a){return a.frameRateReceived}),this.frameRatePercTracker=new SWPercentileTracker(MeasurementFrameRateReceivedComparator,10,MeasurementMerger),this.frameRatePercTracker.addFilter(function(a){return void 0!==a.frameRateReceived&&null!==a.frameRateReceived}),this.frameRatePercTracker.attach(this.setFrameRateReceived10,this),this.frameRateReceived10=null,this.addPlugin(this.frameRatePercTracker),this.addPlugin(this.frameRateReceivedTracker),this.quality={eModel:0,bandwidth:0,frameRate:0},this.sendingThroughputObservations={ssrc:0,started:0,max:0,maxTs:0,stable:0,stableTs:0,ready:!1,maxVerified:!1,stableVerified:!1},this.direction=Measurement.Direction.outbound,this.mediaType=Measurement.MediaTypes.video}function OutbAudioMonitor(){OutboundMonitor.call(this),this.quality={eModel:0,bandwidth:0},this.direction=Measurement.Direction.outbound,this.mediaType=Measurement.MediaTypes.audio}function Monitors(){this.monitors={},this.assembler=new Assembler,this.sendable=!1,this.inbOneWayAudioDisruption={sent:!1,started:0,hasTrafficTs:0},this.outbOneWayAudioDisruption={sent:!1,started:0,hasTrafficTs:0}}function Analyzer(a){this.monitors=new Monitors,this.output=new PusherPlug,this.lastForwarded=(new Date).getTime(),this.lastInterval=0,this.sentCounter=0,this.nextInterval=0,a.addListener(this.monitors.onDataSent,this.monitors),a.addListener(this.onDataSent,this)}function Reporter(){this.states={Idle:\\\"Idle\\\",Run:\\\"Run\\\"},this.events={OnPolling:\\\"OnPolling\\\",OnStatsRequest:\\\"OnStatsRequest\\\",OnStop:\\\"OnStop\\\",OnStart:\\\"OnStart\\\",OnOneWayAudioDisruptionsRequest:\\\"OnOneWayAudioDisruptionsRequest\\\",OnSendingThroughputObservationsRequest:\\\"OnSendingThroughputObservationsRequest\\\"},this.onDataSent=new Notifier,this.analyzer=new Analyzer(this.onDataSent),this.senderGate=new SenderGate(this.onDataSent),this.sendingThroughputObservationsSent=!1,this.analyzer.output.connect(this.senderGate.receiver,this.senderGate),this.currentState=this.states.Run}var SlidingWindow=__webpack_require__(73),SWPlugin=__webpack_require__(33),SWPercentileTracker=__webpack_require__(75),SWAvg=__webpack_require__(78);Reporter.disruptions=[],Reporter.adaptiveSending=!0,Reporter.minMeasurementsNum=20,Reporter.SendingTimeTresholds={max:3e4,min:1e3,regular:5e3},Reporter.minDeltaTimeInMs=1e3,Reporter.maxItemsNum=1e3,Reporter.timeoutInMs=3e5,Reporter.Signals={onDataSent:\\\"onDataSent\\\"},PusherPlug.prototype={constructor:PusherPlug,connect:function(a,b){this.invoker=void 0===b?null:b,this.receiver=a},send:function(a){return null===this.receiver?void console.warn(\\\"There is no receiver to call\\\"):null===this.invoker?void this.receiver(a):void this.receiver.call(this.invoker,a)}},Notifier.prototype={constructor:Notifier,addListener:function(a,b){this.listeners.push({callback:a,that:b})},notify:function(){for(var a=0;a<this.listeners.length;++a){var b=this.listeners[a];void 0!==b.callback&&null!==b.callback&&(null===b.that?b.callback():b.callback.call(b.that))}}},SenderGate.prototype={constructor:SenderGate,receiver:function(a){this.stats=a,this.initiate=!1},requestStats:function(){var a=null,b=(new Date).getTime();if(null===this.stats)return null;if(this.initiate&&b-Reporter.SendingTimeTresholds.min<this.lastResponsed)return console.warn(\\\"Reporter : Too small interval between two sampling to response\\\"),null;var c=b-this.lastResponsed;return console.log(\\\"Elapsed time since last report: \\\"+c),a={streams:this.stats},this.stats=null,this.lastResponsed=b,this.onDataSent.notify(),this.initiate=!0,a}},Measurement.MediaTypes={audio:\\\"audio\\\",video:\\\"video\\\"},Measurement.Direction={inbound:\\\"inbound\\\",outbound:\\\"outbound\\\"},Measurement.prototype={constructor:Measurement,toString:function(){return\\\"Measurement {RTT: \\\"+this.RTT+\\\"; }\\\"}},Assembler.prototype={constructor:Assembler,do:function(a,b){var c=new Measurement(a);if(c.ssrc=a.ssrc,c.mediaType=this.getMediaType(a),c.resolution=this.getResolution(a),c.frameRateReceived=this.getFrameRate(a),c.frameWidth=this.getFrameWidth(a),c.frameHeight=this.getFrameHeight(a),c.rtt=this.getLatencyData(a),c.droppedFramesNum=this.getDroppedFramesNum(a),c.packetLosts=this.getPacketLosts(a),c.jitter=this.getJitter(a),a.streamType===Measurement.Direction.inbound?(c.direction=Measurement.Direction.inbound,c.bytesReceived=this.getBytesReceived(a),c.packetsReceived=this.getPacketsReceived(a),c.packetsDiscarded=this.getPacketsDiscarded(a)):a.streamType===Measurement.Direction.outbound&&(c.direction=Measurement.Direction.outbound,c.bytesSent=this.getBytesSent(a),c.packetsSent=this.getPacketsSent(a)),void 0!==b&&b===!0){c.rawdats={};for(var d in a.data)a.data.hasOwnProperty(d)&&(c.rawdats[d]=a.data[d])}return c},setupCodeBase:function(a){this.codeBase=a},getBytesSent:function(a){if(void 0===a.data.bytesSent)return 0;var b=this.checkForNan(parseInt(a.data.bytesSent,10));return null!==b?b:0},getBytesReceived:function(a){if(void 0===a.data.bytesReceived)return 0;var b=this.checkForNan(parseInt(a.data.bytesReceived,10));return null!==b?b:0},getPacketsReceived:function(a){if(void 0===a.data.packetsReceived)return 0;var b=this.checkForNegativeValue(parseInt(a.data.packetsReceived,10));return null!==b?b:0},getPacketsSent:function(a){if(void 0===a.data.packetsSent)return 0;var b=this.checkForNegativeValue(parseInt(a.data.packetsSent,10));return null!==b?b:0},getPacketsDiscarded:function(a){if(void 0===a.data.discardedPackets)return 0;var b=this.checkForNan(parseInt(a.data.discardedPackets,10));return null!==b?b:0},getPacketLosts:function(a){if(void 0===a.data.packetsLost)return 0;var b=this.checkForNegativeValue(parseInt(a.data.packetsLost,10));return null!==b?b:0},getDroppedFramesNum:function(a){if(void 0===a.data.droppedFrames)return 0;var b=this.checkForNegativeValue(parseInt(a.data.droppedFrames,10));return null!==b?b:0},getFrameRate:function(a){var b;return void 0!==a.data.googFrameRateOutput?b=parseInt(a.data.googFrameRateOutput,10):void 0!==a.data.googFrameRateDecoded?b=parseInt(a.data.googFrameRateDecoded,10):void 0!==a.data.googFrameRateReceived?b=parseInt(a.data.googFrameRateReceived,10):void 0!==a.data.googFrameRateSent?b=parseInt(a.data.googFrameRateSent,10):void 0!==a.data.framerateMean&&(b=parseInt(a.data.framerateMean,10)),void 0!==b&&(b=isNaN(b)||b<0?null:b),b},getFrameHeight:function(a){var b;return void 0!==a.data.googFrameHeightReceived?b=a.data.googFrameHeightReceived:void 0!==a.data.googFrameHeightSent?b=a.data.googFrameHeightSent:void 0!==a.data.frameHeight&&(b=a.data.frameHeight),b},getJitter:function(a){if(void 0!==a){var b;return void 0!==a.data.googJitterReceived?(b=this.checkForNan(parseInt(a.data.googJitterReceived,10)),b?b/1e3:b):this.codeBase===this.codeBaseType.chrome&&void 0!==a.data.jitter?(b=this.checkForNan(parseInt(a.data.jitter,10)),b?b/1e3:b):this.codeBase===this.codeBaseType.firefox&&void 0!==a.data.jitter?this.checkForNan(parseInt(a.data.jitter,10)):void 0}},getResolution:function(a){var b,c,d,e=\\\"unavailable\\\";return b=this.getFrameRate(a),d=this.getFrameWidth(a),c=this.getFrameHeight(a),void 0!==b&&void 0!==d&&void 0!==c&&d>0&&c>0&&(e=d.concat(\\\"x\\\",c,\\\"@\\\",b)),e},getFrameWidth:function(a){var b;return void 0!==a.data.googFrameWidthReceived?b=a.data.googFrameWidthReceived:void 0!==a.data.googFrameWidthSent?b=a.data.googFrameWidthSent:void 0!==a.data.frameWidth&&(b=a.data.frameWidth),b},validateRTT:function(a){var b;return b=isNaN(a)||a<0?null:a},getLatencyData:function(a){return void 0===a?null:void 0!==a.data.googRtt?this.validateRTT(parseInt(a.data.googRtt,10)):void 0!==a.data.roundTripTime?this.validateRTT(parseInt(a.data.roundTripTime,10)):void 0!==a.data.mozRtt?this.validateRTT(parseInt(a.data.mozRtt,10)):null},getMediaType:function(a){var b=this.mediaType.unknown;if(void 0!==a)return a.data&&void 0!==a.data.mediaType?a.data.mediaType:(a.data.mediaType?b=a.data.mediaType:void 0!==a.data.googFrameRateReceived||void 0!==a.data.googFrameRateSent?b=this.mediaType.video:void 0!==a.data.audioInputLevel||void 0!==a.data.audioOutputLevel||void 0!==a.data.audioLevel?b=this.mediaType.audio:void 0!==a.data.framerateMean&&(b=this.mediaType.video),b)},checkForNan:function(a){var b=isNaN(a)?null:a;return b},checkForNegativeValue:function(a){if(a=this.checkForNan(a),null!==a){var b=a<0?null:a;return b}},toString:function(){return\\\"ToString function is not defined. for this object\\\"}},SWValueTracker.prototype=Object.create(SWPlugin.prototype),SWValueTracker.prototype.constructor=SWValueTracker,SWValueTracker.prototype.onDataSent=function(){this.prev=this.actual},SWValueTracker.prototype.getActual=function(){return this.actual},SWValueTracker.prototype.getFirst=function(){return this.first},SWValueTracker.prototype.getDelta=function(){return this.delta=this.actual-this.prev,this.delta},SWValueTracker.prototype.getPrevious=function(){return this.prev},SWValueTracker.prototype.add=function(a){var b=this.extractorFnc(a);if(void 0!==b&&null!==b){if(0===this.first)return this.first=b,void(this.actual=b);this.actual=b,this.notify({last:this.prev,delta:this.delta})}},SWValueTracker.prototype.remove=function(){},SWValueHolder.prototype=Object.create(SWPlugin.prototype),SWValueHolder.prototype.constructor=SWValueHolder,SWValueHolder.prototype.add=function(a){void 0!==a&&null!==a&&(this.prev=this.extractorFnc(a))},SWValueHolder.prototype.remove=function(){},SWValueHolder.prototype.getPrevious=function(){return this.prev},FractionLost.prototype={constructor:FractionLost,getIntervalLoss:function(){return this.intervalLoss},getIntervalPacketsRecv:function(){return this.intervalPacketsRecv},getValue:function(){return void 0===this.intervalPacketsRecv||void 0===this.intervalLoss?null:null===this.intervalPacketsRecv||null===this.intervalLoss?null:0===this.intervalLoss&&0===this.intervalPacketsRecv?0:this.intervalLoss/(this.intervalPacketsRecv+this.intervalLoss)}},Monitor.VideoThroughputThresholds={green:1024,red:256},Monitor.AudioThroughputThresholds={green:30,red:8},Monitor.FrameRateRatioTresholds={green:.8,red:.3},Monitor.VideoRTTThresholds={green:400,red:1e3},Monitor.VideoFractionLostTreshdolds={green:10,red:50},Monitor.AudioFractionLostTresholds={green:15,red:30},Monitor.AudioEModelTresholds={green:240,red:400},Monitor.avQualityRating={excellent:3,fair:2,bad:1},Monitor.avQualityRatingString={excellent:\\\"excellent\\\",fair:\\\"fair\\\",bad:\\\"bad\\\"},Monitor.prototype={constructor:Monitor,doStart:function(){return!0},getStartTime:function(){return this.firstAdded},hasTraffic:function(){var a=this.getLastMeasurement();return this.direction===Measurement.Direction.inbound?0<a.bytesReceived:this.direction===Measurement.Direction.outbound&&0<a.bytesSent},getTotalTimeInMs:function(){return 0===this.firstAdded?0:this.lastAdded-this.firstAdded},getDeltaTimeInMs:function(){return 0===this.lastSent?this.lastAdded-this.firstAdded:this.lastAdded-this.lastSent},getLastMeasurement:function(){return this.measurements.getLast()},setSSRC:function(a){this.ssrc=a},getSSRC:function(){return this.ssrc},add:function(a){var b=(new Date).getTime();if(0===this.firstAdded){if(!this.doStart(a))return;this.firstAdded=b}this.lastAdded=b,this.measurements.add(a)},requestSending:function(){this.doSending=!0},setIntBRAndPR:function(a,b,c){var d=this.getDeltaTimeInMs(),e=Math.max(Reporter.minDeltaTimeInMs,d),f=8*a.getDelta()/e,g=b.getDelta()/(e/1e3);c.data.csioIntBRKbps=f,c.data.csioIntPR=g,0<f?this.csioIntBRKbpsCount=10:0<this.csioIntBRKbpsCount&&(--this.csioIntBRKbpsCount,this.requestSendingIf(1e3<d&&this.csioIntPRCount<5,\\\"OutboundMonitor csioIntBRKbps is 0 and this is the reason for sending\\\")),0<g?this.csioIntPRCount=10:0<this.csioIntPRCount&&(--this.csioIntPRCount,this.requestSendingIf(1e3<d&&this.csioIntPRCount<5,\\\"OutboundMonitor csioIntPR is 0 and this is the reason for sending: \\\"))},requestSendingIf:function(a,b){this.doSending=this.doSending||a},getAvgRTT:function(){return this.rttAvgRTTracker.getResult()},getResolution:function(){return this.resolutionTracker.getPrevious()},percentileTrackerExtractor:function(a,b,c){var d=null,e=a.getResult();return null===e?c:(d=b(e.actual),null===d?c:d)},getRTT95:function(){var a=this.percentileTrackerExtractor(this.rtt95PercentileTracker,function(a){return a.rtt},null),b=this.getLastMeasurement();if(null!==b&&null!==a){var c=Math.max(.1*a,50);this.requestSendingIf(a+c<b.rtt,\\\"RTT95 the reason of sending \\\"+a+\\\" < \\\"+b.rtt)}return a},getJitter95:function(){var a=this.percentileTrackerExtractor(this.jitter95PercentileTracker,function(a){return a.jitter},null),b=this.getLastMeasurement();if(null!==b){var c=Math.max(.1*a,10);this.requestSendingIf(a+c<b.jitter,\\\"Jitter95 the reason of sending \\\"+a+\\\" < \\\"+b.jitter)}return this.result},getFrameRateMean:function(){return this.frameRateMeanTracker.getResult()},getFrameWidth50Percentile:function(){return this.percentileTrackerExtractor(this.frameWidth50PercentileTracker,function(a){return a.frameWidth},null)},getFrameWidth95Percentile:function(){return this.percentileTrackerExtractor(this.frameWidth95PercentileTracker,function(a){return a.frameWidth},null)},getFrameHeight50Percentile:function(){return this.percentileTrackerExtractor(this.frameHeight50PercentileTracker,function(a){return a.frameHeight},null)},getFrameHeight95Percentile:function(){return this.percentileTrackerExtractor(this.frameHeight95PercentileTracker,function(a){return a.frameHeight},null)},getFrameRate50Percentile:function(){return this.percentileTrackerExtractor(this.frameRate50PercentileTracker,function(a){return a.frameRateReceived},null)},getFrameRate95Percentile:function(){return this.percentileTrackerExtractor(this.frameRate95PercentileTracker,function(a){return a.frameRateReceived},null)},getFrameHeightMean:function(){return this.frameHeightMeanTracker.getResult()},getFrameWidthMean:function(){return this.frameWidthMeanTracker.getResult()},getAvgJitter:function(){return this.jitterAvgTracker.getResult()},getQualityEvaluation:function(a,b){if(void 0!==a&&void 0!==b){if(null===a||null===a)return null;var c;return c=b.green<=a?Monitor.avQualityRating.excellent:b.red<a&&a<b.green?Monitor.avQualityRating.fair:Monitor.avQualityRating.bad}},getQualityReverseEvaluation:function(a,b){if(void 0!==a&&void 0!==b){if(null===a||null===a)return null;var c;return c=b.red<a?Monitor.avQualityRating.bad:b.green<=a&&a<=b.red?Monitor.avQualityRating.fair:Monitor.avQualityRating.excellent}},hasData:function(){return this.measurements.refresh(),1<this.measurements.getItemsNum()},addPlugin:function(a){this.measurements.addPlugin(a)},setup:function(a){a.data.csioIntBRKbps=0,a.data.csioAvgBRKbps=0,a.data.csioIntFL=void 0,a.data.csioIntMs=Math.max(Reporter.SendingTimeTresholds.regular,this.getDeltaTimeInMs()),a.data.csioIntPR=void 0,a.data.csioPercentileFl=void 0,a.data.csioIntPktLoss=void 0,a.data.csioAvgJitter=this.getAvgJitter(),a.data.csioAvgRtt=this.getAvgRTT(),a.data.csioPercentileJitter=this.getJitter95(),a.data.csioSig2Latency=this.getRTT95(),a.data.csioTimeElapseMs=this.getTotalTimeInMs(),a.data.csioeM=(null!==this.getRTT95()?this.getRTT95():0)+40,a.data.csiores=this.getResolution(),a.data.csioFrameWidth95Percentile=this.getFrameWidth95Percentile(),a.data.csioFrameWidth50Percentile=this.getFrameWidth50Percentile(),a.data.csioFrameHeight95Percentile=this.getFrameHeight95Percentile(),a.data.csioFrameHeight50Percentile=this.getFrameHeight50Percentile(),a.data.csioFrameRate95Percentile=this.getFrameRate95Percentile(),a.data.csioFrameRate50Percentile=this.getFrameRate50Percentile(),a.data.csioFrameWidthMean=this.getFrameWidthMean(),a.data.csioFrameHeightMean=this.getFrameHeightMean(),a.data.csioFrameRateMean=this.getFrameRateMean()},addIntervalFractionLost:function(a){this.intervalFractionLosts.add(a)},getLastFractionLost:function(){return this.intervalFractionLosts.getLast()},getIntervalFractionLost95:function(){var a,b=this.FLPercentileTracker.getResult();if(null===b)return 0;a=b.actual.getValue();var c=this.getLastFractionLost();if(null!==c&&null!==a){var d=Math.max(.05,c.getValue());this.requestSendingIf(c.getValue()+d<a,\\\"Fraction lost is the reason for sending \\\"+c.getValue()+\\\" \\\"+a)}return a},onDataSent:function(){var a=(new Date).getTime();this.measurements.signalize(Reporter.Signals.onDataSent,null),this.lastSent=a},isValid:function(){for(var a=0;a<arguments.length;a++)if(null===arguments[a]||void 0===arguments[a])return!1;return!0},doSend:function(){if(this.hasData()===!1)return!0;var a=this.doSending;return this.doSending=!1,a},getMediaType:function(){return this.mediaType},getDirection:function(){return this.direction}},InboundMonitor.prototype=Object.create(Monitor.prototype),InboundMonitor.prototype.constructor=InboundMonitor,InboundMonitor.prototype.setRTT95=function(a){Monitor.prototype.setRTT95(a)},InboundMonitor.prototype.setup=function(a){Monitor.prototype.setup.call(this,a);var b=new FractionLost(this.packetLostTracker.getDelta(),this.packetsReceivedTracker.getDelta());this.addIntervalFractionLost(b),a.data.csioIntPktRcv=this.packetsReceivedTracker.getDelta(),this.setIntBRAndPR(this.bytesReceivedTracker,this.packetsReceivedTracker,a),this.getTotalTimeInMs()>0&&(a.data.csioAvgBRKbps=8*this.bytesReceivedTracker.getActual()/this.getTotalTimeInMs()),a.data.csioIntFL=b.getValue(),a.data.csioPercentileFl=this.getIntervalFractionLost95(),a.data.csioeM=(null!==this.getRTT95()?this.getRTT95():0)+40,a.data.csioIntPktLoss=this.packetLostTracker.getDelta(),void 0!==a.data.csioAvgBRKbps&&null!==a.data.csioAvgBRKbps?a.data.csioAvgPacketSize=this.bytesReceivedTracker.getDelta()/this.packetsReceivedTracker.getDelta():a.data.csioAvgPacketSize=null,a.data.csioPktLossPercentage=this.packetLostTracker.getDelta()/this.packetsReceivedTracker.getDelta()*100},InbAudioMonitor.prototype=Object.create(InboundMonitor.prototype),InbAudioMonitor.prototype.constructor=InbAudioMonitor,InbAudioMonitor.prototype.setup=function(a){InboundMonitor.prototype.setup.call(this,a),a.data.csioMediaType=Measurement.MediaTypes.audio,this.quality.eModel=this.getQualityReverseEvaluation(a.data.csioeM,Monitor.AudioEModelTresholds),this.quality.bandwidth=this.getQualityEvaluation(a.data.csioIntBRKbps,Monitor.AudioThroughputThresholds),a.data.csioMark=this.getQuality()},InbAudioMonitor.prototype.getQuality=function(){var a=0,b=.5*this.quality.bandwidth+.5*this.quality.eModel;return b=Math.floor(b),b===Monitor.avQualityRating.excellent?a=Monitor.avQualityRatingString.excellent:b===Monitor.avQualityRating.fair?a=Monitor.avQualityRatingString.fair:b===Monitor.avQualityRating.bad&&(a=Monitor.avQualityRatingString.bad),a},InbVideoMonitor.prototype=Object.create(InboundMonitor.prototype),InbVideoMonitor.prototype.constructor=InbVideoMonitor,InbVideoMonitor.prototype.setFrameRatioQuality=function(){var a=this.frameRateReceivedTracker.getActual(),b=this.frameRateReceivedTracker.getPrevious(),c=0;this.quality.frameRate=0,void 0!==a&&void 0!==b&&null!==a&&null!==b&&0!==b&&(c=a/b,this.quality.frameRate=this.getQualityEvaluation(c,Monitor.FrameRateRatioTresholds))},InbVideoMonitor.prototype.setFrameRateReceived10=function(a){return null===a?void(this.frameRateReceived10=null):void(this.frameRateReceived10=a.actual)},InbVideoMonitor.prototype.setup=function(a){InboundMonitor.prototype.setup.call(this,a),a.data.csioMediaType=Measurement.MediaTypes.video,this.setFrameRatioQuality(),this.quality.eModel=this.getQualityReverseEvaluation(a.data.csioeM,Monitor.AudioEModelTresholds),this.quality.bandwidth=this.getQualityEvaluation(a.data.csioIntBRKbps,Monitor.VideoThroughputThresholds),a.data.csioMark=this.getQuality()},InbVideoMonitor.prototype.getQuality=function(){var a=0,b=.33*this.quality.bandwidth+.33*this.quality.eModel+.33*this.quality.frameRate;return b=Math.floor(b),b===Monitor.avQualityRating.excellent?a=Monitor.avQualityRatingString.excellent:b===Monitor.avQualityRating.fair?a=Monitor.avQualityRatingString.fair:b===Monitor.avQualityRating.bad&&(a=Monitor.avQualityRatingString.bad),a},OutboundMonitor.prototype=Object.create(Monitor.prototype),OutboundMonitor.prototype.constructor=OutboundMonitor,OutboundMonitor.prototype.setup=function(a){Monitor.prototype.setup.call(this,a);var b=new FractionLost(this.packetLostTracker.getDelta(),this.packetsSentTracker.getDelta());this.addIntervalFractionLost(b),this.setIntBRAndPR(this.bytesSentTracker,this.packetsSentTracker,a),this.getTotalTimeInMs()>0&&(a.data.csioAvgBRKbps=8*this.bytesSentTracker.getActual()/this.getTotalTimeInMs()),a.data.csioIntFL=b.getValue(),a.data.csioIntPktRcv=this.packetsSentTracker.getDelta(),a.data.csioPercentileFl=this.getIntervalFractionLost95(),a.data.csioeM=(null!==this.getRTT95()?this.getRTT95():0)+40,a.data.csioIntPktLoss=this.packetLostTracker.getDelta(),void 0!==a.data.csioAvgBRKbps&&null!==a.data.csioAvgBRKbps?a.data.csioAvgPacketSize=this.bytesSentTracker.getDelta()/this.packetsSentTracker.getDelta():a.data.csioAvgPacketSize=null,a.data.csioPktLossPercentage=this.packetLostTracker.getDelta()/this.packetsSentTracker.getDelta()*100},OutbVideoMonitor.verificationElapsedThreshold=1e4,OutbVideoMonitor.initialElapsedThreshold=15e3,OutbVideoMonitor.minStableKBpsSlack=50,OutbVideoMonitor.prototype=Object.create(OutboundMonitor.prototype),OutbVideoMonitor.prototype.constructor=OutbVideoMonitor,OutbVideoMonitor.prototype.setFrameRatioQuality=function(){var a=this.frameRateReceivedTracker.getActual(),b=this.frameRateReceivedTracker.getPrevious(),c=0;this.quality.frameRate=0,void 0!==a&&void 0!==b&&null!==a&&null!==b&&0!==b&&(c=a/b,this.quality.frameRate=this.getQualityEvaluation(c,Monitor.FrameRateRatioTresholds))},OutbVideoMonitor.prototype.setFrameRateReceived10=function(a){return null===a?void(this.frameRateReceived10=null):void(this.frameRateReceived10=a.actual)},OutbVideoMonitor.prototype.getSendingKBitrateObservations=function(){var a=this.sendingThroughputObservations;return a.ready?{ssrc:a.ssrc,maxsendingKBitrate:a.max,timeToMaxSendingKBitrate:a.maxTs-a.started,stablesendingKBitrate:a.stable,timeToStableSendingKBitrate:a.stableTs-a.started}:null},OutbVideoMonitor.prototype.checkSendingKBitrateObservations=function(a){var b=this.sendingThroughputObservations,c=(new Date).getTime();if(b.ready!==!0){if(0===b.started)return b.ssrc=this.getSSRC(),void(b.started=c);var d=a.data.csioIntBRKbps,e=Math.min(OutbVideoMonitor.minStableKBpsSlack,.05*d);b.max<d?(b.max=d,b.maxTs=c):OutbVideoMonitor.verificationElapsedThreshold<c-b.maxTs&&(b.maxVerified=!0),c-b.started<OutbVideoMonitor.initialElapsedThreshold||(d-e<a.data.csioAvgBRKbps&&a.data.csioAvgBRKbps<d+e&&(b.stableTs=c,b.stable=d,b.stableVerified=!0),b.stableVerified&&b.maxVerified&&(b.ready=!0))}},OutbVideoMonitor.prototype.setup=function(a){OutboundMonitor.prototype.setup.call(this,a),a.data.csioMediaType=Measurement.MediaTypes.video,this.setFrameRatioQuality(),this.quality.eModel=this.getQualityReverseEvaluation(a.data.csioeM,Monitor.AudioEModelTresholds),this.quality.bandwidth=this.getQualityEvaluation(a.data.csioIntBRKbps,Monitor.VideoThroughputThresholds),a.data.csioMark=this.getQuality(),this.checkSendingKBitrateObservations(a)},OutbVideoMonitor.prototype.getQuality=function(){var a=0,b=.33*this.quality.bandwidth+.33*this.quality.eModel+.33*this.quality.frameRate;return b=Math.floor(b),b===Monitor.avQualityRating.excellent?a=Monitor.avQualityRatingString.excellent:b===Monitor.avQualityRating.fair?a=Monitor.avQualityRatingString.fair:b===Monitor.avQualityRating.bad&&(a=Monitor.avQualityRatingString.bad),a},OutbAudioMonitor.prototype=Object.create(OutboundMonitor.prototype),OutbAudioMonitor.prototype.constructor=OutbAudioMonitor,OutbAudioMonitor.prototype.setEModelQuality=function(a){a<Monitor.AudioEModelTresholds.green?this.quality.eModel=Monitor.avQualityRating.excellent:a>Monitor.AudioEModelTresholds.green&&a<Monitor.AudioEModelTresholds.red?this.quality.eModel=Monitor.avQualityRating.fair:a>Monitor.AudioEModelTresholds.red&&(this.quality.eModel=Monitor.avQualityRating.bad)},OutbAudioMonitor.prototype.setThroughputQuality=function(a){null!==a&&void 0!==a&&(a>Monitor.AudioThroughputThresholds.green?this.quality.bandwidth=Monitor.avQualityRating.excellent:a>Monitor.AudioThroughputThresholds.red&&a<Monitor.AudioThroughputThresholds.green?this.quality.bandwidth=Monitor.avQualityRating.fair:a<Monitor.AudioThroughputThresholds.red&&(this.quality.bandwidth=Monitor.avQualityRating.bad));\\n},OutbAudioMonitor.prototype.setup=function(a){OutboundMonitor.prototype.setup.call(this,a),this.setThroughputQuality(a.data.csioIntBRKbps),this.setEModelQuality(a.data.csioeM),a.data.csioMediaType=Measurement.MediaTypes.audio,a.data.csioMark=this.getQuality()},OutbAudioMonitor.prototype.doSend=function(){return this.hasData()===!1,!1},OutbAudioMonitor.prototype.getQuality=function(){var a=0,b=.5*this.quality.bandwidth+.5*this.quality.eModel;return b=Math.floor(b),b===Monitor.avQualityRating.excellent?a=Monitor.avQualityRatingString.excellent:b===Monitor.avQualityRating.fair?a=Monitor.avQualityRatingString.fair:b===Monitor.avQualityRating.bad&&(a=Monitor.avQualityRatingString.bad),a},Monitors.OneWayAudioDisruptionTimeout=5e3,Monitors.DisruptionsMediaType={audio:\\\"audio\\\",video:\\\"video\\\",screen:\\\"screen\\\"},Monitors.DisruptionsType={inbOneWayAudioDisruption:\\\"inbOneWayAudioDisruption\\\",outbOneWayAudioDisruption:\\\"outbOneWayAudioDisruption\\\"},Monitors.prototype={constructor:Monitors,getMonitor:function(a){var b;if(this.monitors[a.direction]&&(b=this.monitors[a.direction][a.ssrc]),void 0!==b)return this.monitors[a.direction][a.ssrc];var c=a.direction===Measurement.Direction.inbound,d=a.direction===Measurement.Direction.outbound,e=a.mediaType===Measurement.MediaTypes.audio,f=a.mediaType===Measurement.MediaTypes.video;return b=c&&e?new InbAudioMonitor:d&&e?new OutbAudioMonitor:c&&f?new InbVideoMonitor:d&&f?new OutbVideoMonitor:null,b.setSSRC(a.ssrc),this.monitors[a.direction]||(this.monitors[a.direction]={}),this.monitors[a.direction][a.ssrc]=b,b},setupCodeBase:function(a){this.assembler.setupCodeBase(a)},isSendable:function(){var a=this.sendable;return this.sendable=!1,a},process:function(a){var b=this.assembler.do(a),c=this.getMonitor(b);return null===c||void 0===c?void console.warn(\\\"For ssrc \\\"+b.ssrc+\\\"we do not have monitor\\\"):(c.doSend(b)&&(this.sendable=!0),c.add(b),void c.setup(a))},checkDistortions:function(){var a,b=[],c=[],d=this.monitors[Measurement.Direction.inbound];d&&Object.keys(d).forEach(function(c){a=d[c],a.getMediaType()===Measurement.MediaTypes.audio&&b.push(a)}),d=this.monitors[Measurement.Direction.outbound],d&&Object.keys(d).forEach(function(b){a=d[b],a.getMediaType()===Measurement.MediaTypes.audio&&c.push(a)}),[this.getInbOneWayAudioDisruption(b,c),this.getOutbOneWayAudioDisruption(b,c)].forEach(function(a){a&&Reporter.disruptions.push(a)})},getSendingThroughputObservations:function(){var a=[],b=null,c=this.monitors[Measurement.Direction.outbound];return c?(Object.keys(c).forEach(function(d){b=c[d],b.getMediaType()===Measurement.MediaTypes.video&&a.push(b.getSendingKBitrateObservations())}),a):null},getInbOneWayAudioDisruption:function(a,b){var c=this.inbOneWayAudioDisruption,d=(new Date).getTime();if(c.sent)return null;var e=b.filter(function(a){return 0===a.getStartTime()}).length<1,f=b.filter(function(a){return!a.hasTraffic()}).length<1;if(!e||f)return null;if(!a.length)return null;var g=a.filter(function(a){return!a.hasTraffic()});if(g.length<1)return c.started=0,null;if(0===c.started)return c.started=d,null;if(d-Monitors.OneWayAudioDisruptionTimeout<c.started)return null;var h=g[0].getSSRC();return c.sent=!0,{mediaType:Monitors.DisruptionsMediaType.audio,type:Monitors.DisruptionsType.inbOneWayAudioDisruption,ssrc:h}},getOutbOneWayAudioDisruption:function(a,b){var c=this.outbOneWayAudioDisruption,d=(new Date).getTime();if(c.sent)return null;var e=a.filter(function(a){return 0===a.getStartTime()}).length<1,f=a.filter(function(a){return!a.hasTraffic()}).length<1;if(!e||!f)return null;if(!b.length)return null;var g=b.filter(function(a){return!a.hasTraffic()});if(g.length<1)return c.started=0,null;if(0===c.started)return c.started=d,null;if(d-Monitors.OneWayAudioDisruptionTimeout<c.started)return null;var h=g[0].getSSRC();return c.sent=!0,{mediaType:Monitors.DisruptionsMediaType.audio,type:Monitors.DisruptionsType.outbOneWayAudioDisruption,ssrc:h}},toString:function(){return\\\"ToString function is not defined. for this object\\\"},onDataSent:function(){for(var a in this.monitors)if(this.monitors.hasOwnProperty(a))for(var b in this.monitors[a])if(this.monitors[a].hasOwnProperty(b)){var c=this.monitors[a][b];null!==c?c.onDataSent():console.warn(\\\"A Monitor with ssrc: \\\"+b+\\\" should not be null but it is!\\\")}}},Analyzer.prototype={constructor:Analyzer,onDataSent:function(){++this.sentCounter},getSendingThroughputObservations:function(){var a=this.monitors.getSendingThroughputObservations();if(!a)return null;var b=a.filter(function(a){return null===a}).length<1;return b?a:null},receive:function(a){var b=(new Date).getTime(),c=a.streams,d=a.codeBase;this.monitors.setupCodeBase(d);for(var e=0;e<c.length;++e){var f=c[e];this.monitors.process(f)}this.monitors.checkDistortions();var g=!1;if(Reporter.adaptiveSending===!1)g=this.lastForwarded+Reporter.SendingTimeTresholds.regular<b,g&&(this.output.send(c),this.lastInterval=b-this.lastForwarded,this.lastForwarded=b);else{var h=this.monitors.isSendable();if(0===this.sentCounter?g=!0:this.sentCounter<5?(g=this.lastForwarded+Reporter.SendingTimeTresholds.regular<b,h=!1):g=this.lastForwarded+Math.min(Reporter.SendingTimeTresholds.max,this.nextInterval)<b,g||h)if(this.output.send(c),this.lastInterval=b-this.lastForwarded,this.lastForwarded=b,h)this.lastInterval=Math.max(Reporter.SendingTimeTresholds.min,this.lastInterval/2);else if(g){var i=Math.random()+1;this.nextInterval=Math.min(Reporter.SendingTimeTresholds.max,this.lastInterval*i)}}}},Reporter.prototype={constructor:Reporter,fire:function(a){var b;switch(this.currentState){case this.states.Idle:switch(a){case this.events.OnStart:this.currentState=this.states.Run;break;default:console.warn(\\\"Unhandled event \\\"+a+\\\" in \\\"+this.currentState+\\\" mode\\\")}break;case this.states.Run:switch(a){case this.events.OnStop:this.currentState=this.states.Idle;break;case this.events.OnPolling:var c=arguments[1];this.analyzer.receive(c);break;case this.events.OnOneWayAudioDisruptionsRequest:if(b=arguments[1],void 0===b){console.warn(\\\"OnStatsRequest event required a parameter to store the response\\\");break}0<Reporter.disruptions.length&&(b.response=Reporter.disruptions,Reporter.disruptions=[]);break;case this.events.OnSendingThroughputObservationsRequest:if(b=arguments[1],void 0===b){console.warn(\\\"OnSendingThroughputObservationsRequest event required a parameter to store the response\\\");break}this.sendingThroughputObservationsSent===!1&&(b.response=this.analyzer.getSendingThroughputObservations(),this.sendingThroughputObservationsSent=null!==b.response);break;case this.events.OnStatsRequest:if(b=arguments[1],void 0===b){console.warn(\\\"OnStatsRequest event required a parameter to store the response\\\");break}b.response=this.senderGate.requestStats();break;default:console.warn(\\\"Unhandled event \\\"+a+\\\" in \\\"+this.currentState+\\\" mode\\\")}break;default:console.error(\\\"The Reporter machine is in an unkown state: \\\"+this.currentState)}},toString:function(){return\\\"Reporter is in \\\"+this.currentState},setReportingMode:function(a){Reporter.adaptiveSending=a===!0},setSubmissionInterval:function(a){Reporter.SendingTimeTresholds.regular=a,Reporter.adaptiveSending?(Reporter.SendingTimeTresholds.min=1e3,Reporter.SendingTimeTresholds.max=3e4):(Reporter.SendingTimeTresholds.min=a,Reporter.SendingTimeTresholds.max=a)}},module.exports.Reporter=Reporter;\\n\\n/***/ }),\\n/* 73 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/*! callstats.js  version = 3.27.0 2017-12-14 */\\nfunction SlidingWindow(a,b){this.items=[],this.plugins=[],this.timeoutInMs=b,this.maxItemsNum=a,this.minItemsNum=0,this.last=null}var SWItem=__webpack_require__(74);SlidingWindow.prototype={constructor:SlidingWindow,signalize:function(a,b){for(var c=0;c<this.plugins.length;++c){var d=this.plugins[c];null!==d.signalize&&void 0!==d.signalize?d.signalize.call(d,a,b):console.warn(d)}},toString:function(){return\\\"\\\"}},SlidingWindow.prototype.getLast=function(){return this.last},SlidingWindow.prototype.setMaxItemsNum=function(a){this.maxItemsNum=a},SlidingWindow.prototype.setTimeoutInMs=function(a){this.timeoutInMs=a},SlidingWindow.prototype.setMinItemsNum=function(a){this.minItemsNum=a},SlidingWindow.prototype.refresh=function(){if(!(this.items.length<=this.minItemsNum)){for(;0<this.maxItemsNum&&this.maxItemsNum<=this.items.length;)this.remove();0<this.timeoutInMs&&this.timeoutInMs<this.items[0].getElapsed()&&(this.remove(),this.refresh())}},SlidingWindow.prototype.getItemsNum=function(){return this.items.length},SlidingWindow.prototype.add=function(a){this.refresh(),this.items.push(new SWItem(a));for(var b=0;b<this.plugins.length;b++){var c=this.plugins[b];c.add(a)}this.last=a},SlidingWindow.prototype.map=function(a){for(var b=0;b<this.plugins.length;b++){var c=this.plugins[b];c.map(a)}},SlidingWindow.prototype.remove=function(){for(var a=this.items.shift(),b=0;b<this.plugins.length;b++){var c=this.plugins[b];c.remove(a.value)}},SlidingWindow.prototype.foreach=function(a,b){var c=this.items;void 0!==b&&(c=b(c));for(var d=0;d<c.length;d++){var e=c[d];a(e.value)}},SlidingWindow.prototype.addPlugin=function(a){this.plugins.push(a)},module.exports=SlidingWindow;\\n\\n/***/ }),\\n/* 74 */\\n/***/ (function(module, exports) {\\n\\n/*! callstats.js  version = 3.27.0 2017-12-14 */\\nfunction SWItem(a){this.value=a,this.created=(new Date).getTime()}SWItem.prototype={constructor:SWItem,getElapsed:function(){return(new Date).getTime()-this.created},toString:function(){return\\\"\\\"}},module.exports=SWItem;\\n\\n/***/ }),\\n/* 75 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/*! callstats.js  version = 3.27.0 2017-12-14 */\\nfunction SWPercentileTracker(a,b,c){if(SWPlugin.call(this),99<b||b<1)throw new RangeError(\\\"Percentile parameter must be between 1 and 99\\\");this.comparator=a,this.percentile=b,this.meanCalcer=\\\"undefined\\\"==typeof c?function(a,b){return(a+b)/2}:c,this.ratio=b/(100-b),this.maxtree=new BinaryTree(a),this.mintree=new BinaryTree(a),this.ratio<1?this.required=1/this.ratio+1:1<this.ratio?this.required=this.ratio+1:this.required=2,this.maxcounter=this.mincounter=0,this.result=null,this.filter=null}var SWPercentileNotification=__webpack_require__(76),BinaryTree=__webpack_require__(77),SWPlugin=__webpack_require__(33);SWPercentileTracker.prototype=Object.create(SWPlugin.prototype),SWPercentileTracker.prototype.constructor=SWPercentileTracker,SWPercentileTracker.prototype.addFilter=function(a,b){this.filter={callback:a,that:b}},SWPercentileTracker.prototype.doFilter=function(a){return null===this.filter||(void 0===this.filter.that||null===this.filter.that?this.filter.callback(a):this.filter.callback.call(this.filter.that,a))},SWPercentileTracker.prototype.getResult=function(){return this.result},SWPercentileTracker.prototype.add=function(a){if(this.doFilter(a)){if(this.maxcounter<1)return this.maxtree.insert(a),void++this.maxcounter;this.comparator(a,this.maxtree.getTopValue())<=0?(this.maxtree.insert(a),++this.maxcounter):(this.mintree.insert(a),++this.mincounter),this.balancing(),this.calculate()}},SWPercentileTracker.prototype.remove=function(a){if(this.doFilter(a)){if(this.maxtree.delete(a))--this.maxcounter;else{if(!this.mintree.delete(a))throw new ReferenceError(\\\"The requested value \\\"+a+\\\" is not found in trees\\\");--this.mincounter}this.balancing(),this.calculate()}},SWPercentileTracker.prototype.balancing=function(){var a=function(){for(var a=(this.maxcounter+1)/(this.mincounter-1);;a=(this.maxcounter+1)/(this.mincounter-1)){if(this.ratio<a||this.mincounter<1)return;this.maxtree.insertByTop(this.mintree.deleteBottomValue()),++this.maxcounter,--this.mincounter}},b=function(){for(var a=(this.maxcounter-1)/(this.mincounter+1);;a=(this.maxcounter-1)/(this.mincounter+1)){if(a<this.ratio||this.maxcounter<1)return;this.mintree.insertByBottom(this.maxtree.deleteTopValue()),++this.mincounter,--this.maxcounter}};if(!(this.maxcounter+this.mincounter<this.required)){if(this.mincounter<1)return void b.call(this);if(this.maxcounter<1)return void a.call(this);var c=this.maxcounter/this.mincounter;this.ratio<c?b.call(this):a.call(this)}},SWPercentileTracker.prototype.calculate=function(){var a,b,c=new SWPercentileNotification,d=null,e=this.mincounter+this.maxcounter;if(!(e<1)){if(this.mincounter<1?(b=this.maxtree.getTopValue(),a=this.maxtree.getBottomValue()):this.maxcounter<1?(b=this.mintree.getTopValue(),a=this.mintree.getBottomValue()):(b=this.mintree.getTopValue(),a=this.maxtree.getBottomValue()),c.min=a,c.max=b,c.tracked=e,e<this.required||this.mincounter<1)return d=this.ratio<1?a:1<this.ratio?b:this.meanCalcer(a,b),c.actual=d,c.estimated=!0,this.result=c,void this.notify(this.result);var f=this.maxcounter/this.mincounter;d=this.ratio<f?this.maxtree.getTopValue():f<this.ratio?this.mintree.getBottomValue():this.meanCalcer(this.mintree.getBottomValue(),this.maxtree.getTopValue()),c.actual=d,this.result=c,this.notify(this.result)}},SWPercentileTracker.prototype.map=function(a){this.mapping(this.result.actual,a)},module.exports=SWPercentileTracker;\\n\\n/***/ }),\\n/* 76 */\\n/***/ (function(module, exports) {\\n\\n/*! callstats.js  version = 3.27.0 2017-12-14 */\\nfunction SWPercentileNotification(){this.estimated=!1,this.tracked=0,this.max=this.min=this.actual=null}SWPercentileNotification.prototype={constructor:SWPercentileNotification,toString:function(){return\\\"Tracked: \\\"+this.tracked+\\\" Estimated: \\\"+this.estimated+\\\" Min: \\\"+this.min+\\\" Max: \\\"+this.max+\\\" Actual: \\\"+this.actual}},module.exports=SWPercentileNotification;\\n\\n/***/ }),\\n/* 77 */\\n/***/ (function(module, exports) {\\n\\n/*! callstats.js  version = 3.27.0 2017-12-14 */\\nfunction BinaryTreeNode(a){this.value=[],this.value.push(a),this.left=null,this.right=null}function BinaryTree(a){this.root=null,this.top=null,this.bottom=null,this.comparator=a,this.node_counter=0,this.duplicate_counter=0}BinaryTreeNode.prototype={constructor:BinaryTreeNode,toString:function(){return this.value.toString()}},BinaryTree.prototype={constructor:BinaryTree},BinaryTree.prototype.getTop=function(){return this.top},BinaryTree.prototype.getTopValue=function(){return null===this.top?null:this.top.value[0]},BinaryTree.prototype.getBottomValue=function(){return null===this.bottom?null:this.bottom.value[0]},BinaryTree.prototype.getBottom=function(){return this.bottom},BinaryTree.prototype.getDuplicatedCounter=function(){return this.duplicate_counter},BinaryTree.prototype.getNodeCounter=function(){return this.node_counter},BinaryTree.prototype.getSize=function(){return this.duplicate_counter+this.node_counter},BinaryTree.prototype.logTree=function(){function a(b,c,d){if(null!==b){for(var e=\\\"-\\\",f=0;f<c;++f)e+=\\\"--\\\";console.log(e+\\\"> (\\\"+d+\\\") values: [\\\"+b.value.toString()+\\\"]\\\"),null!==b.left&&a(b.left,c+1,\\\"Left\\\"),null!==b.right&&a(b.right,c+1,\\\"Right\\\")}}return null===this.root?void console.log(\\\"This tree is empty\\\"):(console.log(\\\"Size of the tree: \\\"+this.getSize()+\\\" Node: \\\"+this.getNodeCounter()+\\\" Duplicates: \\\"+this.getDuplicatedCounter()+\\\" Top: \\\"+this.getTop().toString()+\\\" Bottom: \\\"+this.getBottom().toString()),void a(this.root,0,\\\"Root\\\"))},BinaryTree.prototype.insertByTop=function(a){this.inserting(a,this.top)},BinaryTree.prototype.insertByBottom=function(a){this.inserting(a,this.bottom)},BinaryTree.prototype.insert=function(a){this.inserting(a,this.root)},BinaryTree.prototype.inserting=function(a,b){var c=function(){var b=new BinaryTreeNode(a);return(null===this.top||this.comparator(this.top.value[0],b.value[0])<0)&&(this.top=b),(null===this.bottom||this.comparator(b.value[0],this.bottom.value[0])<0)&&(this.bottom=b),b};if(null===this.root)return this.root=c.call(this),void(this.node_counter=1);for(var d=null,e=b,f=0,g=function(b){return b===a};null!==e;){if(f=this.comparator(a,e.value[0]),0===f)return void(e.value.find(g)||(e.value.push(a),++this.duplicate_counter));d=e,e=f<0?e.left:e.right}++this.node_counter,f<0?d.left=c.call(this):d.right=c.call(this)},BinaryTree.prototype.search=function(a){for(var b,c=this.root,d=null,e=function(b){return b===a};null!==c;){if(b=this.comparator(a,c.value[0]),0===b)return c.value.find(e)?(c.parent=d,c):null;d=c,c=b<0?c.left:c.right}return null},BinaryTree.prototype.getRightist=function(a){for(var b=null;null!==a.right;)b=a,a=a.right;return a.parent=b,a},BinaryTree.prototype.getLeftist=function(a){for(var b=null;null!==a.left;)b=a,a=a.left;return a.parent=b,a},BinaryTree.prototype.deleteBottomValue=function(){for(;null===this.bottom;)return null;var a=this.bottom.value[0];return this.delete(a),a},BinaryTree.prototype.deleteTopValue=function(){for(;null===this.top;)return null;var a=this.top.value[0];return this.delete(a),a},BinaryTree.prototype.delete=function(a){var b=null,c=function(a,b,c){null!==b?b.left===a?b.left=c:b.right=c:this.root=c},d=function(a){return null===this.root?void(this.bottom=this.top=null):(0===this.comparator(this.top.value[0],a.value[0])&&(this.top=this.getRightist(this.root)),void(0===this.comparator(this.bottom.value[0],a.value[0])&&(this.bottom=this.getLeftist(this.root))))};if(b=this.search(a),null===b)return!1;if(1<b.value.length)return b.value.splice(b.value.indexOf(a),1),--this.duplicate_counter,!0;if(--this.node_counter,null===b.left&&null===b.right)c.call(this,b,b.parent,null);else if(null===b.left)c.call(this,b,b.parent,b.right);else if(null===b.right)c.call(this,b,b.parent,b.left);else{for(var e=b.left,f=b;null!==e.right;f=e,e=e.right);f===b?f.left=e.left:f.right=e.left,b.value.shift(),b.value=b.value.concat(e.value)}return d.call(this,b),!0},module.exports=BinaryTree;\\n\\n/***/ }),\\n/* 78 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/*! callstats.js  version = 3.27.0 2017-12-14 */\\nfunction SWAvg(a){SWPlugin.call(this),this.avg=0,this.sum=0,this.count=0,this.filter=null,void 0===a?this.extractor=function(a){return a}:this.extractor=a}var SWPlugin=__webpack_require__(33);SWAvg.prototype=Object.create(SWPlugin.prototype),SWAvg.prototype.constructor=SWAvg,SWAvg.prototype.add=function(a){(null===this.filter||void 0===this.filter||this.filter(a))&&(this.sum+=parseInt(this.extractor(a)),++this.count,this.calc(this))},SWAvg.prototype.addFilter=function(a){this.filter=a},SWAvg.prototype.remove=function(a){(null===this.filter||void 0===this.filter||this.filter(a))&&(this.sum-=parseInt(this.extractor(a)),--this.count,this.calc(this))},SWAvg.prototype.calc=function(){this.count<1||(this.avg=this.sum/this.count,this.notify(this.avg))},SWAvg.prototype.getResult=function(){return this.avg},module.exports=SWAvg;\\n\\n/***/ }),\\n/* 79 */\\n/***/ (function(module, exports) {\\n\\n/*! callstats.js  version = 3.27.0 2017-12-14 */\\nfunction pcCallbackHandler(a,b,c,d,e){this.pc=a,this.onIceCandidateCallback=b,this.onIceConnectionStateChangeCallback=c,this.onPcSignalingStateChangeCallback=d,this.onPcNegotiationNeededCallback=e,a.addEventListener?(this.pc.addEventListener(\\\"icecandidate\\\",this.iceCandidateCallback.bind(this),!1),this.pc.addEventListener(\\\"iceconnectionstatechange\\\",this.iceConnectionStateChangeCallback.bind(this),!1),this.pc.addEventListener(\\\"signalingstatechange\\\",this.pcSignalingStateChangeCallback.bind(this),!1),this.pc.addEventListener(\\\"negotiationneeded\\\",this.pcNegotiationNeededCallback.bind(this),!1)):a.attachEvent&&(this.pc.attachEvent(\\\"onicecandidate\\\",this.iceCandidateCallback.bind(this)),this.pc.attachEvent(\\\"oniceconnectionstatechange\\\",this.iceConnectionStateChangeCallback.bind(this)),this.pc.attachEvent(\\\"onsignalingstatechange\\\",this.pcSignalingStateChangeCallback.bind(this)),this.pc.attachEvent(\\\"onnegotiationneeded\\\",this.pcNegotiationNeededCallback.bind(this)))}pcCallbackHandler.prototype.iceCandidateCallback=function(a){try{this.onIceCandidateCallback(a,this.pc)}catch(a){console.log(\\\"onIceCandidateCallback: Error\\\",a)}},pcCallbackHandler.prototype.iceConnectionStateChangeCallback=function(a){try{this.onIceConnectionStateChangeCallback(a,this.pc)}catch(a){console.log(\\\"onIceConnectionStateChangeCallback: Error\\\",a)}},pcCallbackHandler.prototype.pcSignalingStateChangeCallback=function(a){try{this.onPcSignalingStateChangeCallback(a,this.pc)}catch(a){console.log(\\\"onPcSignalingStateChangeCallback: Error\\\",a)}},pcCallbackHandler.prototype.pcNegotiationNeededCallback=function(a){try{this.onPcNegotiationNeededCallback(a,this.pc)}catch(a){console.log(\\\"onPcNegotiationNeededCallback: Error\\\",a)}},module.exports=pcCallbackHandler;\\n\\n/***/ }),\\n/* 80 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.PreCallTest=void 0;var _createClass=function(){function t(t,e){for(var s=0;s<e.length;s++){var n=e[s];n.enumerable=n.enumerable||!1,n.configurable=!0,\\\"value\\\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,s,n){return s&&t(e.prototype,s),n&&t(e,n),e}}(),_turnConnection=__webpack_require__(81),_rttTest=__webpack_require__(86),_throughputTest=__webpack_require__(87),_resultsHandler=__webpack_require__(88),_onlineCheck=__webpack_require__(89),_detectbrowser=__webpack_require__(24),Promise=__webpack_require__(25),TEST_NAMES={RTT:\\\"rtt\\\",THROUGHPUT:\\\"throughput\\\"},FAILURE_RETRIES=10,PreCallTest=function(){function t(){_classCallCheck(this,t),this.browserInfo=(0,_detectbrowser.detect)(),this.turnConnection=new _turnConnection.TurnConnection(this.browserInfo),this.onlineCheck=new _onlineCheck.OnlineCheck,this.callsInProgress=0,this.turnTests=[TEST_NAMES.RTT,TEST_NAMES.THROUGHPUT],this.active=!1,this.rtt=null,this.resultsHandler=null}return _createClass(t,[{key:\\\"start\\\",value:function(t,e){if(this.browserInfo.browserName!==_detectbrowser.Constants.browserName.msie&&(!window||!window.csioReactNative)&&(this.iceServers=t,this.callback=e,!this.active&&!(this.callsInProgress>0)&&t)){this.turnTestCounter=0,this.resultsHandler=new _resultsHandler.ResultsHandler;var s={type:\\\"browser\\\",os:this.browserInfo.os,osVersion:this.browserInfo.osVersion,buildName:this.browserInfo.browserName,buildVersion:this.browserInfo.browserVersion};this.resultsHandler.add(\\\"endpointInfo\\\",s),this.onlineCheck.start(),this.active=!0,this._start()}}},{key:\\\"_start\\\",value:function(){var t=this;this.active&&this.turnConnection.connect(this.iceServers).then(function(){t.active&&t.startTurnTests().then(function(){t.stop()},function(e){t.stop()})},function(e){t.resultsHandler.failure(e),t.resultsHandler.getFailureNumber()>=FAILURE_RETRIES?t.stop():(t.turnConnection.disconnect(),setTimeout(function(){t._start()},0))})}},{key:\\\"stop\\\",value:function(){var t=this;if(this.browserInfo.browserName!==_detectbrowser.Constants.browserName.msie&&this.active){this.active=!1,this.activeTurnTest&&this.activeTurnTest.forceStop();var e=this.onlineCheck.stop();this.resultsHandler.add(\\\"onlineStatus\\\",e),this.turnConnection.getIceResults().then(function(e){t.resultsHandler.add(\\\"ice\\\",e),t.turnConnection.disconnect(),t.sendResults()},function(e){t.resultsHandler.failure(e),t.turnConnection.disconnect(),t.sendResults()})}}},{key:\\\"sendResults\\\",value:function(){var t=this.resultsHandler.getResults();this.callback&&this.callback(t),this.resultsHandler=null}},{key:\\\"callStarts\\\",value:function(){this.callsInProgress+=1,this.stop()}},{key:\\\"callFinished\\\",value:function(){this.callsInProgress-=1}},{key:\\\"getId\\\",value:function(){return this.resultsHandler?this.resultsHandler.getId():null}},{key:\\\"crashDisconnect\\\",value:function(){try{this.turnConnection.disconnect()}catch(t){}}},{key:\\\"startTurnTests\\\",value:function(){var t=this;if(this.turnTestCounter>=this.turnTests.length)return new Promise(function(t,e){t()});var e=this.turnTests[this.turnTestCounter],s=null;switch(e){case TEST_NAMES.RTT:s=new _rttTest.RttTest(this.turnConnection);break;case TEST_NAMES.THROUGHPUT:s=new _throughputTest.ThroughputTest(this.turnConnection,this.rtt);break;default:return new Promise(function(t,s){s(new Error(\\\"Unknown test: \\\"+e))})}return this.activeTurnTest=s,this.active?s.start().then(function(){return t.handleTestResults(e,s.getResults()),t.turnTestCounter+=1,t.activeTurnTest=null,t.startTurnTests()},function(n){return t.handleTestResults(e,s.getResults(),n),t.turnTestCounter+=1,t.activeTurnTest=null,t.startTurnTests()}):new Promise(function(t,e){e(new Error(\\\"Test trying to start while testing is not active\\\"))})}},{key:\\\"handleTestResults\\\",value:function(t,e){null==(arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)&&t==TEST_NAMES.RTT&&(this.rtt=e.median),this.resultsHandler&&this.resultsHandler.add(t,e)}}]),t}();exports.PreCallTest=PreCallTest;\\n\\n/***/ }),\\n/* 81 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\\\"Cannot call a class as a function\\\")}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.TurnConnection=void 0;var _createClass=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\\\"value\\\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),_parsedIceCandidate=__webpack_require__(82),_getstatshandler=__webpack_require__(83),_detectbrowser=__webpack_require__(24),Promise=__webpack_require__(25),ICE_CHECKING_TIMEOUT=1e4,CONNECTION_TIMEOUT=3e4,TurnConnection=function(){function e(t){_classCallCheck(this,e),this.reset(),this.statshandler=new _getstatshandler.GetStatsHandler(t)}return _createClass(e,[{key:\\\"reset\\\",value:function(){this.iceServers=null,this.pctpc1=null,this.pctpc2=null,this.sendChannel=null,this.messageCallback=null,this.errorCallback=null,this.parsedIceResults={}}},{key:\\\"setMessageCallback\\\",value:function(e){this.messageCallback=e}},{key:\\\"setErrorCallback\\\",value:function(e){this.errorCallback=e}},{key:\\\"send\\\",value:function(e){if(this.sendChannel)try{this.sendChannel.send(e)}catch(e){this.raiseSendError(e)}else this.raiseSendError(new Error(\\\"No send channel\\\"))}},{key:\\\"raiseSendError\\\",value:function(e){this.errorCallback&&this.errorCallback(e)}},{key:\\\"assignEvent\\\",value:function(e,t,n){e.addEventListener?e.addEventListener(t,n.bind(this),!1):e.attachEvent&&(t=\\\"on\\\"+t,e.attachEvent(t,n.bind(this)))}},{key:\\\"connect\\\",value:function(e){var t=this;this.reset();var n=new Promise(function(e,n){t.resolveCb=e,t.rejectCb=n});this.iceServers=e;var r=null;try{if(RTCPeerConnection?r=RTCPeerConnection:webkitRTCPeerConnection?r=webkitRTCPeerConnection:mozRTCPeerConnection?r=mozRTCPeerConnection:window&&window.RTCPeerConnection&&(r=window.RTCPeerConnection),!r)return this.rejectCb(new Error(\\\"RTCPeerConnection not found\\\")),n}catch(e){return this.rejectCb(e),n}var c={ordered:!1,maxRetransmits:0},a={iceTransportPolicy:\\\"all\\\",iceServers:this.iceServers};try{this.pctpc1=new r(a),this.pctpc2=new r(a)}catch(e){return this.rejectDisconnect(e),n}return this.connectionTimer=setTimeout(function(){delete t.connectionTimer,t.rejectDisconnect(new Error(\\\"Connection timeout\\\"))},CONNECTION_TIMEOUT),this.sendChannel=this.pctpc1.createDataChannel(\\\"precalltest\\\",c),this.sendChannel.binaryType=\\\"arraybuffer\\\",this.assignEvent(this.sendChannel,\\\"error\\\",function(e){t.raiseSendError(e),t.rejectDisconnect(e)}),this.assignEvent(this.pctpc2,\\\"datachannel\\\",function(e){var n=e.channel;t.assignEvent(n,\\\"open\\\",function(e){t.resolveCb&&t.resolveCb()}),t.assignEvent(n,\\\"close\\\",function(e){t&&t.disconnect&&t.disconnect()}),t.assignEvent(n,\\\"message\\\",function(e){t.messageCallback&&t.messageCallback(e.data)}),t.assignEvent(n,\\\"error\\\",function(e){t.errorCallback&&t.errorCallback(e),t.rejectDisconnect(e)})}),this.assignEvent(this.pctpc1,\\\"icecandidate\\\",function(e){t.onIceCandidate(t.pctpc1,e)}),this.assignEvent(this.pctpc1,\\\"iceconnectionstatechange\\\",function(e){t.onIceStateChange(t.pctpc1,e)}),this.assignEvent(this.pctpc2,\\\"icecandidate\\\",function(e){t.onIceCandidate(t.pctpc2,e)}),this.assignEvent(this.pctpc2,\\\"iceconnectionstatechange\\\",function(e){t.onIceStateChange(t.pctpc2,e)}),this.pctpc1.createOffer().then(function(e,n){t.onCreateOfferSuccess(e)},function(e){t.onCreateOfferError(t.pctpc1,e)}),n}},{key:\\\"rejectDisconnect\\\",value:function(e){this.rejectCb&&(this.rejectCb(e),this.disconnect())}},{key:\\\"disconnect\\\",value:function(){if(clearTimeout(this.connectionTimer),this.pctpc1)try{this.pctpc1.close()}catch(e){}if(this.pctpc1=null,this.pctpc2)try{this.pctpc2.close()}catch(e){}this.pctpc2=null,this.resolveCb=null,this.rejectCb=null}},{key:\\\"getName\\\",value:function(e){return e===this.pctpc1?\\\"pctpc1\\\":\\\"pctpc2\\\"}},{key:\\\"getOtherPc\\\",value:function(e){return e===this.pctpc1?this.pctpc2:this.pctpc1}},{key:\\\"onCreateOfferError\\\",value:function(e,t){this.rejectDisconnect(t)}},{key:\\\"onCreateAnswerError\\\",value:function(e,t){this.rejectDisconnect(t)}},{key:\\\"onCreateOfferSuccess\\\",value:function(e){var t=this;this.pctpc1.setLocalDescription(e).then(function(){t.onSetLocalSuccess(t.pctpc1)},function(e){t.onSetSessionDescriptionError(t.pctpc1,e)}),this.pctpc2.setRemoteDescription(e).then(function(){t.onSetRemoteSuccess(t.pctpc2)},function(e){t.onSetRemoteSessionDescriptionError(t.pctpc2,e)}),this.pctpc2.createAnswer().then(function(e){t.onCreateAnswerSuccess(e)},function(e){t.onCreateAnswerError(t.pctpc2,e)})}},{key:\\\"onSetLocalSuccess\\\",value:function(e){}},{key:\\\"onSetRemoteSuccess\\\",value:function(e){}},{key:\\\"onSetSessionDescriptionError\\\",value:function(e,t){this.rejectDisconnect(t)}},{key:\\\"onSetRemoteSessionDescriptionError\\\",value:function(e,t){this.rejectDisconnect(t)}},{key:\\\"onCreateAnswerSuccess\\\",value:function(e){var t=this;this.pctpc2.setLocalDescription(e).then(function(){t.onSetLocalSuccess(t.pctpc2)},function(e){t.onSetSessionDescriptionError(t.pctpc2,e)}),this.pctpc1.setRemoteDescription(e).then(function(){t.onSetRemoteSuccess(t.pctpc1)},function(e){t.onSetRemoteSessionDescriptionError(t.pctpc1,e)})}},{key:\\\"onIceCandidate\\\",value:function(e,t){var n=this;if(t.candidate){var r=new _parsedIceCandidate.ParsedIceCandidate(t.candidate);e==this.pctpc1&&this.statshandler.codeBase==_detectbrowser.Constants.codeBaseType.chrome&&(r.isRelay()&&(r.isTypeTransportUdp()&&(this.parsedIceResults.relayUdpGathered=!0),r.isTypeTransportTcp()&&(this.parsedIceResults.relayTcpGathered=!0),r.isTypeTransportTls()&&(this.parsedIceResults.relayTlsGathered=!0)),r.isServerReflexive()&&(this.parsedIceResults.srflxGathered=!0)),r.isRelay()&&this.getOtherPc(e).addIceCandidate(t.candidate).then(function(){n.onAddIceCandidateSuccess(e)},function(t){n.onAddIceCandidateError(e,t,r.isRelay())})}}},{key:\\\"onAddIceCandidateSuccess\\\",value:function(e){}},{key:\\\"onAddIceCandidateError\\\",value:function(e,t,n){n&&this.rejectDisconnect(t)}},{key:\\\"onIceStateChange\\\",value:function(e,t){var n=this,r=\\\"(?)\\\";e&&(r=e.iceConnectionState),\\\"failed\\\"===r&&this.rejectDisconnect(new Error(\\\"ICE failure\\\")),\\\"checking\\\"!==r||this.iceTimer||(this.iceTimer=setTimeout(function(){delete n.iceTimer,n.rejectDisconnect(new Error(\\\"ICE timeout\\\"))},ICE_CHECKING_TIMEOUT)),\\\"completed\\\"!==r&&\\\"connected\\\"!==r||delete this.iceTimer}},{key:\\\"getIceResults\\\",value:function(){var e=this;return new Promise(function(t,n){var r=e.iceServers,c=!0,a=!1,i=void 0;try{for(var s,o=r[Symbol.iterator]();!(c=(s=o.next()).done);c=!0){var l=s.value;r.hasOwnProperty(l)||delete l.credential}}catch(e){a=!0,i=e}finally{try{!c&&o.return&&o.return()}finally{if(a)throw i}}var d={turnIpAddress:\\\"\\\",turnIpVersion:\\\"\\\",turnTransport:\\\"\\\",iceServers:r,ipv6Supported:!1,ipv4Supported:!1,relayTlsGathered:!1,relayTcpGathered:!1,relayUdpGathered:!1,srflxGathered:!1,relayTlsSuccess:!1,relayTcpSuccess:!1,relayUdpSuccess:!1,srflxSuccess:!1};for(var u in e.parsedIceResults)e.parsedIceResults.hasOwnProperty(u)&&(d[u]=e.parsedIceResults[u]);e.pctpc1?e.statshandler.getIceCandidates(e.pctpc1).then(function(e){var n=!0,r=!1,c=void 0;try{for(var a,i=e.iceCandidatePairs[Symbol.iterator]();!(n=(a=i.next()).done);n=!0){var s=a.value;if(s.googActiveConnection||s.selected){var o=!0,l=!1,u=void 0;try{for(var p,h=e.localCandidates[Symbol.iterator]();!(o=(p=h.next()).done);o=!0){var f=p.value,y=null;if(y=f.ip?f.ip:f.ipAddress,f.id==s.localCandidateId){d.turnIpAddress=y;var v=-1!==y.indexOf(\\\":\\\");d.turnIpVersion=v?\\\"ipv6\\\":\\\"ipv4\\\",d.turnTransport=f.mozLocalTransport,!0}\\\"relay\\\"!==f.candidateType&&\\\"relayed\\\"!==f.candidateType||(\\\"udp\\\"===f.mozLocalTransport&&(d.relayUdpSuccess=!0),\\\"tcp\\\"===f.mozLocalTransport&&(d.relayTcpSuccess=!0),\\\"tls\\\"===f.mozLocalTransport&&(d.relayTlsSuccess=!0)),-1!==y.indexOf(\\\":\\\")?d.ipv6Supported=!0:d.ipv4Supported=!0}}catch(e){l=!0,u=e}finally{try{!o&&h.return&&h.return()}finally{if(l)throw u}}}}}catch(e){r=!0,c=e}finally{try{!n&&i.return&&i.return()}finally{if(r)throw c}}var C=!0,T=!1,S=void 0;try{for(var m,E=e.localCandidates[Symbol.iterator]();!(C=(m=E.next()).done);C=!0){var b=m.value;\\\"relay\\\"!==b.candidateType&&\\\"relayed\\\"!==b.candidateType||(\\\"udp\\\"===b.mozLocalTransport&&(d.relayUdpGathered=!0),\\\"tcp\\\"===b.mozLocalTransport&&(d.relayTcpGathered=!0),\\\"tls\\\"===b.mozLocalTransport&&(d.relayTlsGathered=!0)),\\\"srflx\\\"!==b.candidateType&&\\\"serverreflexive\\\"!==b.candidateType||(d.srflxGathered=!0)}}catch(e){T=!0,S=e}finally{try{!C&&E.return&&E.return()}finally{if(T)throw S}}var I=!0,k=!1,w=void 0;try{for(var g,R=e.iceCandidatePairs[Symbol.iterator]();!(I=(g=R.next()).done);I=!0){var D=g.value;if(\\\"succeeded\\\"===D.state){var P=!0,x=!1,j=void 0;try{for(var O,_=e.localCandidates[Symbol.iterator]();!(P=(O=_.next()).done);P=!0){var L=O.value;L.id==D.localCandidateId&&(\\\"relay\\\"!==L.candidateType&&\\\"relayed\\\"!==L.candidateType||(\\\"udp\\\"===L.mozLocalTransport&&(d.relayUdpSuccess=!0),\\\"tcp\\\"===L.mozLocalTransport&&(d.relayTcpSuccess=!0),\\\"tls\\\"===L.mozLocalTransport&&(d.relayTlsSuccess=!0)),\\\"srflx\\\"!==L.candidateType&&\\\"serverreflexive\\\"!==L.candidateType||(d.srflxSuccess=!0))}}catch(e){x=!0,j=e}finally{try{!P&&_.return&&_.return()}finally{if(x)throw j}}}}}catch(e){k=!0,w=e}finally{try{!I&&R.return&&R.return()}finally{if(k)throw w}}t(d)},function(e){n(e)}):n(new Error(\\\"PC not available for stats\\\"))},function(e){reject(e)})}}]),e}();exports.TurnConnection=TurnConnection;\\n\\n/***/ }),\\n/* 82 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\\\"Cannot call a class as a function\\\")}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0});var _createClass=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\\\"value\\\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),ParsedIceCandidate=function(){function e(t){_classCallCheck(this,e),this.iceCandidateStr=t.candidate,this.parse()}return _createClass(e,[{key:\\\"parse\\\",value:function(){var e=this.iceCandidateStr.split(\\\" \\\");e.length<8||(this.protocol=\\\"1\\\"===e[1]?\\\"rtp\\\":\\\"rtcp\\\",this.transport=e[2],this.typeTransport=this.extractTypeTransport(e[3]),this.ipv6=-1!==e[4].indexOf(\\\":\\\"),this.ipAddress=e[4],this.port=e[5],this.type=e[7])}},{key:\\\"extractTypeTransport\\\",value:function(e){var t=\\\"None\\\",r=e>>24;if(\\\"rtp\\\"===this.protocol&&r>=0&&r<=2)switch(r){case 0:t=\\\"TLS\\\";break;case 1:t=\\\"TCP\\\";break;case 2:t=\\\"UDP\\\"}return t}},{key:\\\"getString\\\",value:function(){return this.iceCandidateStr}},{key:\\\"getType\\\",value:function(){return this.type}},{key:\\\"isHost\\\",value:function(){return\\\"host\\\"===this.type.toLowerCase()}},{key:\\\"isServerReflexive\\\",value:function(){return\\\"srflx\\\"===this.type.toLowerCase()}},{key:\\\"isPeerReflexive\\\",value:function(){return\\\"prflx\\\"===this.type.toLowerCase()}},{key:\\\"isRelay\\\",value:function(){return\\\"relay\\\"===this.type.toLowerCase()||\\\"relayed\\\"===this.type.toLowerCase()}},{key:\\\"getTypeTransport\\\",value:function(){return this.typeTransport}},{key:\\\"isTypeTransportUdp\\\",value:function(){return\\\"UDP\\\"===this.typeTransport}},{key:\\\"isTypeTransportTcp\\\",value:function(){return\\\"TCP\\\"===this.typeTransport}},{key:\\\"isTypeTransportTls\\\",value:function(){return\\\"TLS\\\"===this.typeTransport}},{key:\\\"getTransport\\\",value:function(){return this.transport}},{key:\\\"isUdp\\\",value:function(){return\\\"udp\\\"===this.transport.toLowerCase()}},{key:\\\"isTcp\\\",value:function(){return\\\"tcp\\\"===this.transport.toLowerCase()}},{key:\\\"getProtocol\\\",value:function(){return this.protocol}},{key:\\\"isRtp\\\",value:function(){return\\\"rtp\\\"===this.protocol}},{key:\\\"isRtcp\\\",value:function(){return\\\"rtcp\\\"===this.protocol}},{key:\\\"isIpv6\\\",value:function(){return this.ipv6}},{key:\\\"getIpAddress\\\",value:function(){return this.ipAddress}},{key:\\\"getPort\\\",value:function(){return this.port}}]),e}();exports.ParsedIceCandidate=ParsedIceCandidate;\\n\\n/***/ }),\\n/* 83 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.GetStatsHandler=void 0;var _createClass=function(){function t(t,e){for(var s=0;s<e.length;s++){var a=e[s];a.enumerable=a.enumerable||!1,a.configurable=!0,\\\"value\\\"in a&&(a.writable=!0),Object.defineProperty(t,a.key,a)}}return function(e,s,a){return s&&t(e.prototype,s),a&&t(e,a),e}}(),_detectbrowser=__webpack_require__(24),_statsadapter=__webpack_require__(84),Promise=__webpack_require__(25),GetStatsHandler=function(){function t(e){_classCallCheck(this,t),this.codeBase=e.codeBase,this.browserName=e.browserName,this.adapter=new _statsadapter.StatsAdapter(this.codeBase,this.browserName),this.isPromiseBased=!0}return _createClass(t,[{key:\\\"getIceCandidates\\\",value:function(t){var e=this;return new Promise(function(s,a){e.csioGetStats(e.iceCandidatesHandler.bind(e),t,function(t){s(t)})})}},{key:\\\"iceCandidatesHandler\\\",value:function(t,e){e(this.adapter.getIceCandidates(t))}},{key:\\\"csioGetStats\\\",value:function(t,e,s){var a=_detectbrowser.Constants.codeBaseType.firefox,n=_detectbrowser.Constants.codeBaseType.chrome,i=_detectbrowser.Constants.codeBaseType.edge,r=_detectbrowser.Constants.browserName.safari;e&&(this.codeBase===a?this.getStatsFirefox(t,e,s):this.browserName===r?this.getStatsSafari(t,e,s):this.codeBase===n?this.getStatsChrome(t,e,s):this.codeBase===i&&this.getStatsEdge(t,e,s))}},{key:\\\"getStatsFirefox\\\",value:function(t,e,s){var a=this;if(a.isPromiseBased)try{e.getStats().then(function(e){t(e,s)}).catch(function(n){a.isPromiseBased=!1,e.getStats(null,function(e){t(e,s)},function(){})})}catch(n){a.isPromiseBased=!1,e.getStats(null,function(e){t(e,s)},function(){})}else e.getStats(null,function(e){t(e,s)},function(){})}},{key:\\\"getStatsChrome\\\",value:function(t,e,s){var a=this;if(window&&window.csioReactNative)e.getStats(null,function(e){t(e,s)},function(t){});else if(a.isPromiseBased)try{e.getStats().then(function(e){t(e,s)}).catch(function(n){a.isPromiseBased=!1,e.getStats(function(e){t(e,s)})})}catch(a){isPromiseBased=!1,e.getStats(function(e){t(e,s)})}else e.getStats(function(e){t(e,s)})}},{key:\\\"getStatsEdge\\\",value:function(t,e,s){e.getStats().then(function(e){t(e,s)}).catch(function(t){})}},{key:\\\"getStatsSafari\\\",value:function(t,e,s){e.getStats().then(function(e){t(e,s)}).catch(function(t){})}}]),t}();exports.GetStatsHandler=GetStatsHandler;\\n\\n/***/ }),\\n/* 84 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.StatsAdapter=void 0;var _createClass=function(){function t(t,e){for(var a=0;a<e.length;a++){var r=e[a];r.enumerable=r.enumerable||!1,r.configurable=!0,\\\"value\\\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,a,r){return a&&t(e.prototype,a),r&&t(e,r),e}}(),_detectbrowser=__webpack_require__(24),StatsAdapter=function(){function t(e,a){_classCallCheck(this,t),this.codeBase=e,this.browser=a}return _createClass(t,[{key:\\\"getIceCandidates\\\",value:function(t){if(!t)return null;var e=this.extractRawStats(t);return this.processRawStatsForIceInfo(e)}},{key:\\\"extractRawStats\\\",value:function(t){var e=[],a=void 0,r=_detectbrowser.Constants.codeBaseType.firefox,s=_detectbrowser.Constants.codeBaseType.chrome,o=_detectbrowser.Constants.browserName.safari;if(this.codeBase===r&&this.browser!==o)t.forEach(function(t){e.push(t)});else if(this.codeBase===s&&this.browser!==o)t&&t.result?e=t.result():t&&t.forEach&&(e=[],t.forEach(function(t){e.push(t)}));else for(a in t)t.hasOwnProperty(a)&&e.push(t[a]);return e}},{key:\\\"processRawStatsForIceInfo\\\",value:function(t){var e=[],a=[],r=[],s=void 0;if(!t)return null;for(var o=0;o<t.length;++o){var n=this.getParsedStats(t[o]),i=this.statsClassifier(n);if(i.candidatePair)r.push(i.candidatePair);else if(i.transportStats){if(\\\"transport\\\"===i.transportStats.type){s=i.transportStats.selectedCandidatePairId;continue}r.push(i.transportStats)}else if(i.localCandidate){var c=i.localCandidate;if(\\\"relay\\\"==c.candidateType||\\\"relayed\\\"==c.candidateType){if(!c.mozLocalTransport){var d=c.priority>>24;c.mozLocalTransport=this.formatRelayType(d)}c.mozLocalTransport=c.mozLocalTransport.toLowerCase()}e.push(c)}else i.remoteCandidate&&a.push(i.remoteCandidate)}if(s)for(var l=0;l<r.length;++l)r[l].id===s&&(r[l].googActiveConnection=\\\"true\\\");return{localCandidates:e,remoteCandidates:a,iceCandidatePairs:r}}},{key:\\\"getParsedStats\\\",value:function(t){var e={};if(t.timestamp instanceof Date&&(e.timestamp=t.timestamp.getTime().toString()),t.type&&(e.type=t.type),t.names)for(var a=t.names(),r=0;r<a.length;++r)e[a[r]]=t.stat(a[r]);else Object.assign(e,t);if(e.values){var s=!0,o=!1,n=void 0;try{for(var i,c=e.values[Symbol.iterator]();!(s=(i=c.next()).done);s=!0){var d=i.value;Object.assign(e,d)}}catch(t){o=!0,n=t}finally{try{!s&&c.return&&c.return()}finally{if(o)throw n}}delete e.values}return e}},{key:\\\"statsClassifier\\\",value:function(t){var e={},a=function(){for(var e=arguments.length,a=Array(e),r=0;r<e;r++)a[r]=arguments[r];var s=!0,o=!1,n=void 0;try{for(var i,c=a[Symbol.iterator]();!(s=(i=c.next()).done);s=!0){var d=i.value;if(t.type===d)return!0}}catch(t){o=!0,n=t}finally{try{!s&&c.return&&c.return()}finally{if(o)throw n}}return!1},r=a(\\\"inbound-rtp\\\",\\\"inboundrtp\\\"),s=\\\"true\\\"===t.isRemote||!0===t.isRemote;return r||a(\\\"outbound-rtp\\\",\\\"outboundrtp\\\")?(e.tracks={},e.tracks.data=t,e.tracks.ssrc=t.ssrc,e.tracks.streamType=r?\\\"inbound\\\":\\\"outbound\\\",e.tracks.reportType=\\\"local\\\",void 0!==t.isRemote&&(e.tracks.reportType=s?\\\"remote\\\":\\\"local\\\")):a(\\\"candidatepair\\\")&&t.selected?e.transportStats=t:a(\\\"localcandidate\\\",\\\"local-candidate\\\")?e.localCandidate=t:a(\\\"remotecandidate\\\",\\\"remote-candidate\\\")?e.remoteCandidate=t:a(\\\"transport\\\",\\\"googCandidatePair\\\")?e.transportStats=t:a(\\\"VideoBwe\\\")?e.bwe=t:a(\\\"track\\\")?e.trackStats=t:a(\\\"candidate-pair\\\")?e.candidatePair=t:a(\\\"codec\\\")?e.codec=t:a(\\\"ssrc\\\")&&(e.tracks={},e.tracks.data=t,e.tracks.ssrc=t.ssrc,e.tracks.reportType=\\\"local\\\",e.tracks.streamType=t.bytesSent?\\\"outbound\\\":\\\"inbound\\\"),e}},{key:\\\"formatRelayType\\\",value:function(t){var e=\\\"none\\\";switch(t){case 0:e=\\\"tls\\\";break;case 1:e=\\\"tcp\\\";break;case 2:e=\\\"udp\\\"}return e}}]),t}();exports.StatsAdapter=StatsAdapter;\\n\\n/***/ }),\\n/* 85 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\\n    \\\"use strict\\\";\\n\\n    if (global.setImmediate) {\\n        return;\\n    }\\n\\n    var nextHandle = 1; // Spec says greater than zero\\n    var tasksByHandle = {};\\n    var currentlyRunningATask = false;\\n    var doc = global.document;\\n    var registerImmediate;\\n\\n    function setImmediate(callback) {\\n      // Callback can either be a function or a string\\n      if (typeof callback !== \\\"function\\\") {\\n        callback = new Function(\\\"\\\" + callback);\\n      }\\n      // Copy function arguments\\n      var args = new Array(arguments.length - 1);\\n      for (var i = 0; i < args.length; i++) {\\n          args[i] = arguments[i + 1];\\n      }\\n      // Store and register the task\\n      var task = { callback: callback, args: args };\\n      tasksByHandle[nextHandle] = task;\\n      registerImmediate(nextHandle);\\n      return nextHandle++;\\n    }\\n\\n    function clearImmediate(handle) {\\n        delete tasksByHandle[handle];\\n    }\\n\\n    function run(task) {\\n        var callback = task.callback;\\n        var args = task.args;\\n        switch (args.length) {\\n        case 0:\\n            callback();\\n            break;\\n        case 1:\\n            callback(args[0]);\\n            break;\\n        case 2:\\n            callback(args[0], args[1]);\\n            break;\\n        case 3:\\n            callback(args[0], args[1], args[2]);\\n            break;\\n        default:\\n            callback.apply(undefined, args);\\n            break;\\n        }\\n    }\\n\\n    function runIfPresent(handle) {\\n        // From the spec: \\\"Wait until any invocations of this algorithm started before this one have completed.\\\"\\n        // So if we're currently running a task, we'll need to delay this invocation.\\n        if (currentlyRunningATask) {\\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\\n            // \\\"too much recursion\\\" error.\\n            setTimeout(runIfPresent, 0, handle);\\n        } else {\\n            var task = tasksByHandle[handle];\\n            if (task) {\\n                currentlyRunningATask = true;\\n                try {\\n                    run(task);\\n                } finally {\\n                    clearImmediate(handle);\\n                    currentlyRunningATask = false;\\n                }\\n            }\\n        }\\n    }\\n\\n    function installNextTickImplementation() {\\n        registerImmediate = function(handle) {\\n            process.nextTick(function () { runIfPresent(handle); });\\n        };\\n    }\\n\\n    function canUsePostMessage() {\\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\\n        if (global.postMessage && !global.importScripts) {\\n            var postMessageIsAsynchronous = true;\\n            var oldOnMessage = global.onmessage;\\n            global.onmessage = function() {\\n                postMessageIsAsynchronous = false;\\n            };\\n            global.postMessage(\\\"\\\", \\\"*\\\");\\n            global.onmessage = oldOnMessage;\\n            return postMessageIsAsynchronous;\\n        }\\n    }\\n\\n    function installPostMessageImplementation() {\\n        // Installs an event handler on `global` for the `message` event: see\\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\\n\\n        var messagePrefix = \\\"setImmediate$\\\" + Math.random() + \\\"$\\\";\\n        var onGlobalMessage = function(event) {\\n            if (event.source === global &&\\n                typeof event.data === \\\"string\\\" &&\\n                event.data.indexOf(messagePrefix) === 0) {\\n                runIfPresent(+event.data.slice(messagePrefix.length));\\n            }\\n        };\\n\\n        if (global.addEventListener) {\\n            global.addEventListener(\\\"message\\\", onGlobalMessage, false);\\n        } else {\\n            global.attachEvent(\\\"onmessage\\\", onGlobalMessage);\\n        }\\n\\n        registerImmediate = function(handle) {\\n            global.postMessage(messagePrefix + handle, \\\"*\\\");\\n        };\\n    }\\n\\n    function installMessageChannelImplementation() {\\n        var channel = new MessageChannel();\\n        channel.port1.onmessage = function(event) {\\n            var handle = event.data;\\n            runIfPresent(handle);\\n        };\\n\\n        registerImmediate = function(handle) {\\n            channel.port2.postMessage(handle);\\n        };\\n    }\\n\\n    function installReadyStateChangeImplementation() {\\n        var html = doc.documentElement;\\n        registerImmediate = function(handle) {\\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\\n            var script = doc.createElement(\\\"script\\\");\\n            script.onreadystatechange = function () {\\n                runIfPresent(handle);\\n                script.onreadystatechange = null;\\n                html.removeChild(script);\\n                script = null;\\n            };\\n            html.appendChild(script);\\n        };\\n    }\\n\\n    function installSetTimeoutImplementation() {\\n        registerImmediate = function(handle) {\\n            setTimeout(runIfPresent, 0, handle);\\n        };\\n    }\\n\\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\\n\\n    // Don't get fooled by e.g. browserify environments.\\n    if ({}.toString.call(global.process) === \\\"[object process]\\\") {\\n        // For Node.js before 0.9\\n        installNextTickImplementation();\\n\\n    } else if (canUsePostMessage()) {\\n        // For non-IE10 modern browsers\\n        installPostMessageImplementation();\\n\\n    } else if (global.MessageChannel) {\\n        // For web workers, where supported\\n        installMessageChannelImplementation();\\n\\n    } else if (doc && \\\"onreadystatechange\\\" in doc.createElement(\\\"script\\\")) {\\n        // For IE 6–8\\n        installReadyStateChangeImplementation();\\n\\n    } else {\\n        // For older browsers\\n        installSetTimeoutImplementation();\\n    }\\n\\n    attachTo.setImmediate = setImmediate;\\n    attachTo.clearImmediate = clearImmediate;\\n}(typeof self === \\\"undefined\\\" ? typeof global === \\\"undefined\\\" ? this : global : self));\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21), __webpack_require__(34)))\\n\\n/***/ }),\\n/* 86 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _interopRequireWildcard(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e.default=t,e}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}function _possibleConstructorReturn(t,e){if(!t)throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");return!e||\\\"object\\\"!=typeof e&&\\\"function\\\"!=typeof e?t:e}function _inherits(t,e){if(\\\"function\\\"!=typeof e&&null!==e)throw new TypeError(\\\"Super expression must either be null or a function, not \\\"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.RttTest=void 0;var _createClass=function(){function t(t,e){for(var s=0;s<e.length;s++){var i=e[s];i.enumerable=i.enumerable||!1,i.configurable=!0,\\\"value\\\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,s,i){return s&&t(e.prototype,s),i&&t(e,i),e}}(),_get=function t(e,s,i){null===e&&(e=Function.prototype);var r=Object.getOwnPropertyDescriptor(e,s);if(void 0===r){var n=Object.getPrototypeOf(e);return null===n?void 0:t(n,s,i)}if(\\\"value\\\"in r)return r.value;var u=r.get;if(void 0!==u)return u.call(i)},_timestamps=__webpack_require__(22),Timestamps=_interopRequireWildcard(_timestamps),_turnTest=__webpack_require__(40),RTTSAMPLES=10,TIMEOUT=100,LAST_TIMEOUT=500,RttTest=function(t){function e(t){_classCallCheck(this,e);var s=_possibleConstructorReturn(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return s.sendTimer=null,s.countSent=0,s.rtts=[],s}return _inherits(e,_turnTest.TurnTest),_createClass(e,[{key:\\\"initiate\\\",value:function(){this.results.startTimestamp=Timestamps.getCurrent(),this.sendPing()}},{key:\\\"handleMessage\\\",value:function(t){if(this.isActive()){var e=parseInt(t,10),s=this.calculateRtt(e);this.rtts.push(s),this.countSent<RTTSAMPLES?this.sendPing():this.calculateMetrics()}}},{key:\\\"handleError\\\",value:function(t){this.fillResults(),this.failed(t)}},{key:\\\"sendPing\\\",value:function(){if(this.isActive()){var t=Timestamps.getCurrent();this.send(t.toString()),this.countSent+=1,this.sendTimer&&(clearTimeout(this.sendTimer),this.sendTimer=null),this.countSent<RTTSAMPLES?this.sendTimer=setTimeout(this.sendPing.bind(this),TIMEOUT):this.sendTimer=setTimeout(this.calculateMetrics.bind(this),LAST_TIMEOUT)}}},{key:\\\"calculateRtt\\\",value:function(t){return Timestamps.getCurrent()-t}},{key:\\\"calculateMetrics\\\",value:function(){this.sendTimer&&(clearTimeout(this.sendTimer),this.sendTimer=null),this.fillResults(),this.finished()}},{key:\\\"fillResults\\\",value:function(){this.results.sentMessages=this.countSent,this.results.unAckedMessages=this.countSent-this.rtts.length,this.results.maxMessages=RTTSAMPLES,this.results.forceStopped=this.forceStopped,this.results.median=this.median(),this.results.variance=this.variance(),this.results.endTimestamp=Timestamps.getCurrent()}},{key:\\\"median\\\",value:function(){if(0==this.rtts.length)return null;this.rtts.sort();var t=Math.floor(this.rtts.length/2);return this.rtts[t]}},{key:\\\"variance\\\",value:function(){if(0==this.rtts.length)return null;var t=0,e=this.median(),s=!0,i=!1,r=void 0;try{for(var n,u=this.rtts[Symbol.iterator]();!(s=(n=u.next()).done);s=!0){var o=n.value;t+=Math.abs(o-e)}}catch(t){i=!0,r=t}finally{try{!s&&u.return&&u.return()}finally{if(i)throw r}}return t/=this.rtts.length}},{key:\\\"stop\\\",value:function(){this.isActive()&&(_get(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\\\"stop\\\",this).call(this),this.fillResults())}}]),e}();exports.RttTest=RttTest;\\n\\n/***/ }),\\n/* 87 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _interopRequireWildcard(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t.default=e,t}function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\\\"Cannot call a class as a function\\\")}function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");return!t||\\\"object\\\"!=typeof t&&\\\"function\\\"!=typeof t?e:t}function _inherits(e,t){if(\\\"function\\\"!=typeof t&&null!==t)throw new TypeError(\\\"Super expression must either be null or a function, not \\\"+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.ThroughputTest=void 0;var _createClass=function(){function e(e,t){for(var s=0;s<t.length;s++){var i=t[s];i.enumerable=i.enumerable||!1,i.configurable=!0,\\\"value\\\"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,s,i){return s&&e(t.prototype,s),i&&e(t,i),t}}(),_get=function e(t,s,i){null===t&&(t=Function.prototype);var r=Object.getOwnPropertyDescriptor(t,s);if(void 0===r){var n=Object.getPrototypeOf(t);return null===n?void 0:e(n,s,i)}if(\\\"value\\\"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(i)},_timestamps=__webpack_require__(22),Timestamps=_interopRequireWildcard(_timestamps),_messageMaker=__webpack_require__(41),_turnTest=__webpack_require__(40),ThroughputTest=function(e){function t(e,s){_classCallCheck(this,t);var i=_possibleConstructorReturn(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));if(i.sentBytes=0,i.receivedBytes=0,i.secondHalfBytes=0,i.secondHalfStart=null,i.bufferEmpty=0,i.chunkSize=1200,i.messageMaker=new _messageMaker.MessageMaker(i.chunkSize),i.duration=5e3,null!=s){var r=50*s;i.duration=Math.max(Math.min(r,1e4),1e3)}return i.sendTimer=null,i.lastMessage=null,i.intervals=[],i.intervalStart=0,i.intervalLength=100,i.intervalBytes=0,i}return _inherits(t,_turnTest.TurnTest),_createClass(t,[{key:\\\"initiate\\\",value:function(){this.startSend()}},{key:\\\"handleMessage\\\",value:function(e){var t=this;if(this.isActive()){this.lastMessage=e,this.receivedBytes+=e.length;var s=Timestamps.getCurrent();if(this.sendTimer||(this.results.startTimestamp=s,this.sendTimer=setTimeout(function(){t.stop(),t.finished()},this.duration)),0==this.intervalStart&&(this.intervalStart=s),this.intervalBytes+=e.length,s-this.intervalStart>=this.intervalLength){var i=s-this.intervalStart,r=this.averageThroughput(this.intervalBytes,i),n=null;try{n=s-JSON.parse(this.lastMessage).timestamp}catch(e){}this.intervals.push({startTimestamp:this.intervalStart,endTimestamp:s,bytesReceived:this.intervalBytes,average:r,rtt:n}),this.intervalStart=s,this.intervalBytes=0}this.results.startTimestamp&&s-this.results.startTimestamp>this.duration/2&&(this.secondHalfStart||(this.secondHalfStart=s),this.secondHalfBytes+=e.length)}}},{key:\\\"handleError\\\",value:function(e){this.stop(),this.failed(e)}},{key:\\\"averageThroughput\\\",value:function(e,t){return e/(t/1e3)*8/1024}},{key:\\\"bufferListener\\\",value:function(){this.sendChannel.removeEventListener(\\\"bufferedamountlow\\\",this.bufferListener.bind(this)),this.fillBuffer()}},{key:\\\"fillBuffer\\\",value:function(){for(0==this.sendChannel.bufferedAmount&&(this.bufferEmpty+=1);this.isActive();){if(this.sendChannel.bufferedAmount>this.bufferFullThreshold)return void(this.usePolling?setTimeout(this.fillBuffer.bind(this),250):this.sendChannel.addEventListener(\\\"bufferedamountlow\\\",this.bufferListener.bind(this)));var e=this.messageMaker.make(this.sentBytes);this.sentBytes+=e.length,this.send(e)}this.sendChannel.removeEventListener(\\\"bufferedamountlow\\\",this.bufferListener.bind(this))}},{key:\\\"startSend\\\",value:function(){this.isActive()&&(this.bufferFullThreshold=1e3*this.chunkSize,this.sendChannel=this.connection.sendChannel,this.usePolling=!0,\\\"number\\\"==typeof this.sendChannel.bufferedAmountLowThreshold&&(this.usePolling=!1,this.sendChannel.bufferedAmountLowThreshold=this.bufferFullThreshold/10),setTimeout(this.fillBuffer.bind(this),0))}},{key:\\\"fillResults\\\",value:function(){this.results.endTimestamp=Timestamps.getCurrent(),this.results.maxDuration=this.duration,this.results.forceStopped=this.forceStopped,this.results.bufferEmpty=this.bufferEmpty,this.results.intervals=this.intervals,this.results.bytesPrepared=this.sentBytes,this.results.bytesReceived=this.receivedBytes;var e=0,t=0;this.secondHalfStart&&(e=this.results.endTimestamp-this.secondHalfStart,t=this.averageThroughput(this.secondHalfBytes,e));var s=this.results.endTimestamp-this.results.startTimestamp,i=this.averageThroughput(this.receivedBytes,s);i>t&&(t=i),this.results.average=t;var r=null;try{r=JSON.parse(this.lastMessage)}catch(e){return}if(r){var n=r.sentBytes+this.lastMessage.length;this.results.bytesSent=n,this.results.fractionLostBytes=1-this.receivedBytes/n}else this.results.bytesSent=-1,this.results.fractionLostBytes=-1}},{key:\\\"stop\\\",value:function(){this.isActive()&&(clearTimeout(this.sendTimer),this.sendTimer=null,_get(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),\\\"stop\\\",this).call(this),this.fillResults())}}]),t}();exports.ThroughputTest=ThroughputTest;\\n\\n/***/ }),\\n/* 88 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _interopRequireWildcard(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\\\"Cannot call a class as a function\\\")}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.ResultsHandler=void 0;var _typeof=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\\\"function\\\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\\\"symbol\\\":typeof e},_createClass=function(){function e(e,t){for(var r=0;r<t.length;r++){var s=t[r];s.enumerable=s.enumerable||!1,s.configurable=!0,\\\"value\\\"in s&&(s.writable=!0),Object.defineProperty(e,s.key,s)}}return function(t,r,s){return r&&e(t.prototype,r),s&&e(t,s),t}}(),_timestamps=__webpack_require__(22),Timestamps=_interopRequireWildcard(_timestamps),_messageMaker=__webpack_require__(41),ResultsHandler=function(){function e(){_classCallCheck(this,e),this.start=Timestamps.getCurrent(),this.id=Math.trunc(this.start)+\\\"-\\\"+(0,_messageMaker.randomAsciiString)(20),this.version=\\\"1.1.4\\\",this.failures=[],this.results={},this.forceStopped=!1}return _createClass(e,[{key:\\\"getResults\\\",value:function(){return{id:this.id,version:this.version,forceStopped:this.forceStopped,startTimestamp:this.start,endTimestamp:Timestamps.getCurrent(),failures:this.failures,tests:this.results}}},{key:\\\"getFailureNumber\\\",value:function(){return this.failures.length}},{key:\\\"getId\\\",value:function(){return this.id}},{key:\\\"add\\\",value:function(e,t){this.results[e]=t,t.forceStopped&&!0===t.forceStopped&&(this.forceStopped=!0)}},{key:\\\"failure\\\",value:function(e){\\\"object\\\"===(void 0===e?\\\"undefined\\\":_typeof(e))&&(e=e.toString());var t={timestamp:Timestamps.getCurrent(),reason:e};this.failures.push(t)}}]),e}();exports.ResultsHandler=ResultsHandler;\\n\\n/***/ }),\\n/* 89 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*! precalltest  version = 1.1.4 2017-11-15 */\\n\\nfunction _interopRequireWildcard(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n.default=e,n}function _classCallCheck(e,n){if(!(e instanceof n))throw new TypeError(\\\"Cannot call a class as a function\\\")}Object.defineProperty(exports,\\\"__esModule\\\",{value:!0}),exports.OnlineCheck=void 0;var _createClass=function(){function e(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,\\\"value\\\"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(n,t,i){return t&&e(n.prototype,t),i&&e(n,i),n}}(),_timestamps=__webpack_require__(22),Timestamps=_interopRequireWildcard(_timestamps),OnlineCheck=function(){function e(){_classCallCheck(this,e)}return _createClass(e,[{key:\\\"start\\\",value:function(){var e=this;this.onlineCheck=[],window&&window.addEventListener&&\\\"function\\\"==typeof window.addEventListener&&(window.addEventListener(\\\"offline\\\",function(){e.addEntry()}),window.addEventListener(\\\"online\\\",function(){e.addEntry()}),this.addEntry())}},{key:\\\"addEntry\\\",value:function(){var e=Timestamps.getCurrent();if(navigator&&navigator.onLine){var n=navigator.onLine;this.onlineCheck.push({timestamp:e,online:n})}}},{key:\\\"stop\\\",value:function(){var e=this;return window.removeEventListener(\\\"offline\\\",function(){e.addEntry()}),window.removeEventListener(\\\"online\\\",function(){e.addEntry()}),this.onlineCheck}}]),e}();exports.OnlineCheck=OnlineCheck;\\n\\n/***/ }),\\n/* 90 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = StatsCollector;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_statistics_Events__ = __webpack_require__(43);\\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\\\"return\\\"]) _i[\\\"return\\\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\"); } }; }();\\n\\n\\n\\n\\nvar GlobalOnErrorHandler = __webpack_require__(3);\\nvar logger = __webpack_require__(0).getLogger(__filename);\\n\\n/* Whether we support the browser we are running into for logging statistics */\\nvar browserSupported = __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isChrome() || __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isOpera() || __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isFirefox() || __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isNWJS() || __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isElectron() || __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed() || __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isEdge();\\n\\n/**\\n * The lib-jitsi-meet browser-agnostic names of the browser-specific keys\\n * reported by RTCPeerConnection#getStats mapped by RTCBrowserType.\\n */\\nvar KEYS_BY_BROWSER_TYPE = {};\\n\\nKEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_FIREFOX] = {\\n    'ssrc': 'ssrc',\\n    'packetsReceived': 'packetsReceived',\\n    'packetsLost': 'packetsLost',\\n    'packetsSent': 'packetsSent',\\n    'bytesReceived': 'bytesReceived',\\n    'bytesSent': 'bytesSent',\\n    'framerateMean': 'framerateMean'\\n};\\nKEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_CHROME] = {\\n    'receiveBandwidth': 'googAvailableReceiveBandwidth',\\n    'sendBandwidth': 'googAvailableSendBandwidth',\\n    'remoteAddress': 'googRemoteAddress',\\n    'transportType': 'googTransportType',\\n    'localAddress': 'googLocalAddress',\\n    'activeConnection': 'googActiveConnection',\\n    'ssrc': 'ssrc',\\n    'packetsReceived': 'packetsReceived',\\n    'packetsSent': 'packetsSent',\\n    'packetsLost': 'packetsLost',\\n    'bytesReceived': 'bytesReceived',\\n    'bytesSent': 'bytesSent',\\n    'googFrameHeightReceived': 'googFrameHeightReceived',\\n    'googFrameWidthReceived': 'googFrameWidthReceived',\\n    'googFrameHeightSent': 'googFrameHeightSent',\\n    'googFrameWidthSent': 'googFrameWidthSent',\\n    'googFrameRateReceived': 'googFrameRateReceived',\\n    'googFrameRateSent': 'googFrameRateSent',\\n    'audioInputLevel': 'audioInputLevel',\\n    'audioOutputLevel': 'audioOutputLevel',\\n    'currentRoundTripTime': 'googRtt',\\n    'remoteCandidateType': 'googRemoteCandidateType',\\n    'localCandidateType': 'googLocalCandidateType'\\n};\\nKEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_EDGE] = {\\n    'sendBandwidth': 'googAvailableSendBandwidth',\\n    'remoteAddress': 'remoteAddress',\\n    'transportType': 'protocol',\\n    'localAddress': 'localAddress',\\n    'activeConnection': 'activeConnection',\\n    'ssrc': 'ssrc',\\n    'packetsReceived': 'packetsReceived',\\n    'packetsSent': 'packetsSent',\\n    'packetsLost': 'packetsLost',\\n    'bytesReceived': 'bytesReceived',\\n    'bytesSent': 'bytesSent',\\n    'googFrameHeightReceived': 'frameHeight',\\n    'googFrameWidthReceived': 'frameWidth',\\n    'googFrameHeightSent': 'frameHeight',\\n    'googFrameWidthSent': 'frameWidth',\\n    'googFrameRateReceived': 'framesPerSecond',\\n    'googFrameRateSent': 'framesPerSecond',\\n    'audioInputLevel': 'audioLevel',\\n    'audioOutputLevel': 'audioLevel',\\n    'currentRoundTripTime': 'roundTripTime'\\n};\\nKEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_OPERA] = KEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_CHROME];\\nKEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_NWJS] = KEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_CHROME];\\nKEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_ELECTRON] = KEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_CHROME];\\nKEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_IEXPLORER] = KEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_CHROME];\\nKEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_SAFARI] = KEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_CHROME];\\nKEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_REACT_NATIVE] = KEYS_BY_BROWSER_TYPE[__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_CHROME];\\n\\n/**\\n * Calculates packet lost percent using the number of lost packets and the\\n * number of all packet.\\n * @param lostPackets the number of lost packets\\n * @param totalPackets the number of all packets.\\n * @returns {number} packet loss percent\\n */\\nfunction calculatePacketLoss(lostPackets, totalPackets) {\\n    if (!totalPackets || totalPackets <= 0 || !lostPackets || lostPackets <= 0) {\\n        return 0;\\n    }\\n\\n    return Math.round(lostPackets / totalPackets * 100);\\n}\\n\\n/**\\n * Holds \\\"statistics\\\" for a single SSRC.\\n * @constructor\\n */\\nfunction SsrcStats() {\\n    this.loss = {};\\n    this.bitrate = {\\n        download: 0,\\n        upload: 0\\n    };\\n    this.resolution = {};\\n    this.framerate = 0;\\n}\\n\\n/**\\n * Sets the \\\"loss\\\" object.\\n * @param loss the value to set.\\n */\\nSsrcStats.prototype.setLoss = function (loss) {\\n    this.loss = loss || {};\\n};\\n\\n/**\\n * Sets resolution that belong to the ssrc represented by this instance.\\n * @param resolution new resolution value to be set.\\n */\\nSsrcStats.prototype.setResolution = function (resolution) {\\n    this.resolution = resolution || {};\\n};\\n\\n/**\\n * Adds the \\\"download\\\" and \\\"upload\\\" fields from the \\\"bitrate\\\" parameter to\\n * the respective fields of the \\\"bitrate\\\" field of this object.\\n * @param bitrate an object holding the values to add.\\n */\\nSsrcStats.prototype.addBitrate = function (bitrate) {\\n    this.bitrate.download += bitrate.download;\\n    this.bitrate.upload += bitrate.upload;\\n};\\n\\n/**\\n * Resets the bit rate for given <tt>ssrc</tt> that belong to the peer\\n * represented by this instance.\\n */\\nSsrcStats.prototype.resetBitrate = function () {\\n    this.bitrate.download = 0;\\n    this.bitrate.upload = 0;\\n};\\n\\n/**\\n * Sets the \\\"framerate\\\".\\n * @param framerate the value to set.\\n */\\nSsrcStats.prototype.setFramerate = function (framerate) {\\n    this.framerate = framerate || 0;\\n};\\n\\n/**\\n *\\n */\\nfunction ConferenceStats() {\\n\\n    /**\\n     * The bandwidth\\n     * @type {{}}\\n     */\\n    this.bandwidth = {};\\n\\n    /**\\n     * The bit rate\\n     * @type {{}}\\n     */\\n    this.bitrate = {};\\n\\n    /**\\n     * The packet loss rate\\n     * @type {{}}\\n     */\\n    this.packetLoss = null;\\n\\n    /**\\n     * Array with the transport information.\\n     * @type {Array}\\n     */\\n    this.transport = [];\\n}\\n\\n/* eslint-disable max-params */\\n\\n/**\\n * <tt>StatsCollector</tt> registers for stats updates of given\\n * <tt>peerconnection</tt> in given <tt>interval</tt>. On each update particular\\n * stats are extracted and put in {@link SsrcStats} objects. Once the processing\\n * is done <tt>audioLevelsUpdateCallback</tt> is called with <tt>this</tt>\\n * instance as an event source.\\n *\\n * @param peerconnection WebRTC PeerConnection object.\\n * @param audioLevelsInterval\\n * @param statsInterval stats refresh interval given in ms.\\n * @param eventEmitter\\n * @constructor\\n */\\nfunction StatsCollector(peerconnection, audioLevelsInterval, statsInterval, eventEmitter) {\\n    // StatsCollector depends entirely on the format of the reports returned by\\n    // RTCPeerConnection#getStats. Given that the value of\\n    // RTCBrowserType#getBrowserType() is very unlikely to change at runtime, it\\n    // makes sense to discover whether StatsCollector supports the executing\\n    // browser as soon as possible. Otherwise, (1) getStatValue would have to\\n    // needlessly check a \\\"static\\\" condition multiple times very very often and\\n    // (2) the lack of support for the executing browser would be discovered and\\n    // reported multiple times very very often too late in the execution in some\\n    // totally unrelated callback.\\n    /**\\n     * The RTCBrowserType supported by this StatsCollector. In other words, the\\n     * RTCBrowserType of the browser which initialized this StatsCollector\\n     * instance.\\n     * @private\\n     */\\n    this._browserType = __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].getBrowserType();\\n    var keys = KEYS_BY_BROWSER_TYPE[this._browserType];\\n\\n    if (!keys) {\\n        // eslint-disable-next-line no-throw-literal\\n        throw 'The browser type \\\\'' + this._browserType + '\\\\' isn\\\\'t supported!';\\n    }\\n\\n    /**\\n     * The function which is to be used to retrieve the value associated in a\\n     * report returned by RTCPeerConnection#getStats with a lib-jitsi-meet\\n     * browser-agnostic name/key.\\n     *\\n     * @function\\n     * @private\\n     */\\n    this._getStatValue = this._defineGetStatValueMethod(keys);\\n\\n    this.peerconnection = peerconnection;\\n    this.baselineAudioLevelsReport = null;\\n    this.currentAudioLevelsReport = null;\\n    this.currentStatsReport = null;\\n    this.previousStatsReport = null;\\n    this.audioLevelsIntervalId = null;\\n    this.eventEmitter = eventEmitter;\\n    this.conferenceStats = new ConferenceStats();\\n\\n    // Updates stats interval\\n    this.audioLevelsIntervalMilis = audioLevelsInterval;\\n\\n    this.statsIntervalId = null;\\n    this.statsIntervalMilis = statsInterval;\\n\\n    /**\\n     * Maps SSRC numbers to {@link SsrcStats}.\\n     * @type {Map<number,SsrcStats}\\n     */\\n    this.ssrc2stats = new Map();\\n}\\n\\n/* eslint-enable max-params */\\n\\n/**\\n * Stops stats updates.\\n */\\nStatsCollector.prototype.stop = function () {\\n    if (this.audioLevelsIntervalId) {\\n        clearInterval(this.audioLevelsIntervalId);\\n        this.audioLevelsIntervalId = null;\\n    }\\n\\n    if (this.statsIntervalId) {\\n        clearInterval(this.statsIntervalId);\\n        this.statsIntervalId = null;\\n    }\\n};\\n\\n/**\\n * Callback passed to <tt>getStats</tt> method.\\n * @param error an error that occurred on <tt>getStats</tt> call.\\n */\\nStatsCollector.prototype.errorCallback = function (error) {\\n    GlobalOnErrorHandler.callErrorHandler(error);\\n    logger.error('Get stats error', error);\\n    this.stop();\\n};\\n\\n/**\\n * Starts stats updates.\\n */\\nStatsCollector.prototype.start = function (startAudioLevelStats) {\\n    var self = this;\\n\\n    if (startAudioLevelStats) {\\n        this.audioLevelsIntervalId = setInterval(function () {\\n            // Interval updates\\n            self.peerconnection.getStats(function (report) {\\n                var results = null;\\n\\n                if (!report || !report.result || typeof report.result !== 'function') {\\n                    results = report;\\n                } else {\\n                    results = report.result();\\n                }\\n                self.currentAudioLevelsReport = results;\\n                self.processAudioLevelReport();\\n                self.baselineAudioLevelsReport = self.currentAudioLevelsReport;\\n            }, self.errorCallback);\\n        }, self.audioLevelsIntervalMilis);\\n    }\\n\\n    if (browserSupported) {\\n        this.statsIntervalId = setInterval(function () {\\n            // Interval updates\\n            self.peerconnection.getStats(function (report) {\\n                var results = null;\\n\\n                if (!report || !report.result || typeof report.result !== 'function') {\\n                    // firefox\\n                    results = report;\\n                } else {\\n                    // chrome\\n                    results = report.result();\\n                }\\n\\n                self.currentStatsReport = results;\\n                try {\\n                    self.processStatsReport();\\n                } catch (e) {\\n                    GlobalOnErrorHandler.callErrorHandler(e);\\n                    logger.error('Unsupported key:' + e, e);\\n                }\\n\\n                self.previousStatsReport = self.currentStatsReport;\\n            }, self.errorCallback);\\n        }, self.statsIntervalMilis);\\n    }\\n};\\n\\n/**\\n * Defines a function which (1) is to be used as a StatsCollector method and (2)\\n * gets the value from a specific report returned by RTCPeerConnection#getStats\\n * associated with a lib-jitsi-meet browser-agnostic name.\\n *\\n * @param {Object.<string,string>} keys the map of LibJitsi browser-agnostic\\n * names to RTCPeerConnection#getStats browser-specific keys\\n */\\nStatsCollector.prototype._defineGetStatValueMethod = function (keys) {\\n    // Define the function which converts a lib-jitsi-meet browser-asnostic name\\n    // to a browser-specific key of a report returned by\\n    // RTCPeerConnection#getStats.\\n    var keyFromName = function keyFromName(name) {\\n        var key = keys[name];\\n\\n        if (key) {\\n            return key;\\n        }\\n\\n        // eslint-disable-next-line no-throw-literal\\n        throw 'The property \\\\'' + name + '\\\\' isn\\\\'t supported!';\\n    };\\n\\n    // Define the function which retrieves the value from a specific report\\n    // returned by RTCPeerConnection#getStats associated with a given\\n    // browser-specific key.\\n    var itemStatByKey = void 0;\\n\\n    switch (this._browserType) {\\n        case __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_CHROME:\\n        case __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_OPERA:\\n        case __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_NWJS:\\n        case __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_ELECTRON:\\n            // TODO What about other types of browser which are based on Chrome such\\n            // as NW.js? Every time we want to support a new type browser we have to\\n            // go and add more conditions (here and in multiple other places).\\n            // Cannot we do a feature detection instead of a browser type check? For\\n            // example, if item has a stat property of type function, then it's very\\n            // likely that whoever defined it wanted you to call it in order to\\n            // retrieve the value associated with a specific key.\\n            itemStatByKey = function itemStatByKey(item, key) {\\n                return item.stat(key);\\n            };\\n            break;\\n        case __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_REACT_NATIVE:\\n            // The implementation provided by react-native-webrtc follows the\\n            // Objective-C WebRTC API: RTCStatsReport has a values property of type\\n            // Array in which each element is a key-value pair.\\n            itemStatByKey = function itemStatByKey(item, key) {\\n                var value = void 0;\\n\\n                item.values.some(function (pair) {\\n                    if (pair.hasOwnProperty(key)) {\\n                        value = pair[key];\\n\\n                        return true;\\n                    }\\n\\n                    return false;\\n                });\\n\\n                return value;\\n            };\\n            break;\\n        case __WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].RTC_BROWSER_EDGE:\\n            itemStatByKey = function itemStatByKey(item, key) {\\n                return item[key];\\n            };\\n            break;\\n        default:\\n            itemStatByKey = function itemStatByKey(item, key) {\\n                return item[key];\\n            };\\n    }\\n\\n    // Compose the 2 functions defined above to get a function which retrieves\\n    // the value from a specific report returned by RTCPeerConnection#getStats\\n    // associated with a specific lib-jitsi-meet browser-agnostic name.\\n    return function (item, name) {\\n        return itemStatByKey(item, keyFromName(name));\\n    };\\n};\\n\\n/**\\n * Obtains a stat value from given stat and converts it to a non-negative\\n * number. If the value is either invalid or negative then 0 will be returned.\\n * @param report\\n * @param {string} name\\n * @return {number}\\n * @private\\n */\\nStatsCollector.prototype.getNonNegativeStat = function (report, name) {\\n    var value = this._getStatValue(report, name);\\n\\n    if (typeof value !== 'number') {\\n        value = Number(value);\\n    }\\n\\n    if (isNaN(value)) {\\n        return 0;\\n    }\\n\\n    return Math.max(0, value);\\n};\\n\\n/* eslint-disable no-continue */\\n\\n/**\\n * Stats processing logic.\\n */\\nStatsCollector.prototype.processStatsReport = function () {\\n    var _this = this;\\n\\n    if (!this.previousStatsReport) {\\n        return;\\n    }\\n\\n    var getStatValue = this._getStatValue;\\n    var byteSentStats = {};\\n\\n    for (var idx in this.currentStatsReport) {\\n        if (!this.currentStatsReport.hasOwnProperty(idx)) {\\n            continue;\\n        }\\n        var now = this.currentStatsReport[idx];\\n\\n        // The browser API may return \\\"undefined\\\" values in the array\\n        if (!now) {\\n            continue;\\n        }\\n\\n        try {\\n            var receiveBandwidth = getStatValue(now, 'receiveBandwidth');\\n            var sendBandwidth = getStatValue(now, 'sendBandwidth');\\n\\n            if (receiveBandwidth || sendBandwidth) {\\n                this.conferenceStats.bandwidth = {\\n                    'download': Math.round(receiveBandwidth / 1000),\\n                    'upload': Math.round(sendBandwidth / 1000)\\n                };\\n            }\\n        } catch (e) {/* not supported*/}\\n\\n        if (now.type === 'googCandidatePair') {\\n            var _ret = function () {\\n                var active = void 0,\\n                    ip = void 0,\\n                    localCandidateType = void 0,\\n                    localip = void 0,\\n                    remoteCandidateType = void 0,\\n                    rtt = void 0,\\n                    type = void 0;\\n\\n                try {\\n                    active = getStatValue(now, 'activeConnection');\\n                    if (!active) {\\n                        return 'continue';\\n                    }\\n\\n                    ip = getStatValue(now, 'remoteAddress');\\n                    type = getStatValue(now, 'transportType');\\n                    localip = getStatValue(now, 'localAddress');\\n                    localCandidateType = getStatValue(now, 'localCandidateType');\\n                    remoteCandidateType = getStatValue(now, 'remoteCandidateType');\\n                    rtt = _this.getNonNegativeStat(now, 'currentRoundTripTime');\\n                } catch (e) {/* not supported*/}\\n                if (!ip || !type || !localip || active !== 'true') {\\n                    return 'continue';\\n                }\\n\\n                // Save the address unless it has been saved already.\\n                var conferenceStatsTransport = _this.conferenceStats.transport;\\n\\n                if (!conferenceStatsTransport.some(function (t) {\\n                    return t.ip === ip && t.type === type && t.localip === localip;\\n                })) {\\n                    conferenceStatsTransport.push({\\n                        ip: ip,\\n                        type: type,\\n                        localip: localip,\\n                        p2p: _this.peerconnection.isP2P,\\n                        localCandidateType: localCandidateType,\\n                        remoteCandidateType: remoteCandidateType,\\n                        rtt: rtt\\n                    });\\n                }\\n                return 'continue';\\n            }();\\n\\n            if (_ret === 'continue') continue;\\n        }\\n\\n        if (now.type === 'candidatepair') {\\n            // we need succeeded and selected pairs only\\n            if (now.state !== 'succeeded' || !now.selected) {\\n                continue;\\n            }\\n\\n            var local = this.currentStatsReport[now.localCandidateId];\\n            var remote = this.currentStatsReport[now.remoteCandidateId];\\n\\n            this.conferenceStats.transport.push({\\n                ip: remote.ipAddress + ':' + remote.portNumber,\\n                type: local.transport,\\n                localip: local.ipAddress + ':' + local.portNumber,\\n                p2p: this.peerconnection.isP2P,\\n                localCandidateType: local.candidateType,\\n                remoteCandidateType: remote.candidateType\\n            });\\n        }\\n\\n        // NOTE: Edge's proprietary stats via RTCIceTransport.msGetStats().\\n        if (now.msType === 'transportdiagnostics') {\\n            this.conferenceStats.transport.push({\\n                ip: now.remoteAddress,\\n                type: now.protocol,\\n                localip: now.localAddress,\\n                p2p: this.peerconnection.isP2P\\n            });\\n        }\\n\\n        if (now.type !== 'ssrc' && now.type !== 'outboundrtp' && now.type !== 'inboundrtp' && now.type !== 'track') {\\n            continue;\\n        }\\n\\n        // NOTE: In Edge, stats with type \\\"inboundrtp\\\" and \\\"outboundrtp\\\" are\\n        // completely useless, so ignore them.\\n        if (__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isEdge() && (now.type === 'inboundrtp' || now.type === 'outboundrtp')) {\\n            continue;\\n        }\\n\\n        var before = this.previousStatsReport[idx];\\n        var ssrc = this.getNonNegativeStat(now, 'ssrc');\\n\\n        // If type=\\\"track\\\", take the first SSRC from ssrcIds.\\n        if (now.type === 'track' && Array.isArray(now.ssrcIds)) {\\n            ssrc = Number(now.ssrcIds[0]);\\n        }\\n\\n        if (!before || !ssrc) {\\n            continue;\\n        }\\n\\n        // isRemote is available only in FF and is ignored in case of chrome\\n        // according to the spec\\n        // https://www.w3.org/TR/webrtc-stats/#dom-rtcrtpstreamstats-isremote\\n        // when isRemote is true indicates that the measurements were done at\\n        // the remote endpoint and reported in an RTCP RR/XR.\\n        // Fixes a problem where we are calculating local stats wrong adding\\n        // the sent bytes to the local download bitrate.\\n        // In new W3 stats spec, type=\\\"track\\\" has a remoteSource boolean\\n        // property.\\n        // Edge uses the new format, so skip this check.\\n        if (!__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isEdge() && (now.isRemote === true || now.remoteSource === true)) {\\n            continue;\\n        }\\n\\n        var ssrcStats = this.ssrc2stats.get(ssrc);\\n\\n        if (!ssrcStats) {\\n            ssrcStats = new SsrcStats();\\n            this.ssrc2stats.set(ssrc, ssrcStats);\\n        }\\n\\n        var isDownloadStream = true;\\n        var key = 'packetsReceived';\\n        var packetsNow = getStatValue(now, key);\\n\\n        if (typeof packetsNow === 'undefined' || packetsNow === null || packetsNow === '') {\\n            isDownloadStream = false;\\n            key = 'packetsSent';\\n            packetsNow = getStatValue(now, key);\\n            if (typeof packetsNow === 'undefined' || packetsNow === null) {\\n                logger.warn('No packetsReceived nor packetsSent stat found');\\n            }\\n        }\\n        if (!packetsNow || packetsNow < 0) {\\n            packetsNow = 0;\\n        }\\n\\n        var packetsBefore = this.getNonNegativeStat(before, key);\\n        var packetsDiff = Math.max(0, packetsNow - packetsBefore);\\n\\n        var packetsLostNow = this.getNonNegativeStat(now, 'packetsLost');\\n        var packetsLostBefore = this.getNonNegativeStat(before, 'packetsLost');\\n        var packetsLostDiff = Math.max(0, packetsLostNow - packetsLostBefore);\\n\\n        ssrcStats.setLoss({\\n            packetsTotal: packetsDiff + packetsLostDiff,\\n            packetsLost: packetsLostDiff,\\n            isDownloadStream: isDownloadStream\\n        });\\n\\n        var bytesReceivedNow = this.getNonNegativeStat(now, 'bytesReceived');\\n        var bytesReceivedBefore = this.getNonNegativeStat(before, 'bytesReceived');\\n        var bytesReceived = Math.max(0, bytesReceivedNow - bytesReceivedBefore);\\n\\n        var bytesSent = 0;\\n\\n        // TODO: clean this mess up!\\n        var nowBytesTransmitted = getStatValue(now, 'bytesSent');\\n\\n        if (typeof nowBytesTransmitted === 'number' || typeof nowBytesTransmitted === 'string') {\\n            nowBytesTransmitted = Number(nowBytesTransmitted);\\n            if (!isNaN(nowBytesTransmitted)) {\\n                byteSentStats[ssrc] = nowBytesTransmitted;\\n                if (nowBytesTransmitted > 0) {\\n                    bytesSent = nowBytesTransmitted - getStatValue(before, 'bytesSent');\\n                }\\n            }\\n        }\\n        bytesSent = Math.max(0, bytesSent);\\n\\n        var timeMs = now.timestamp - before.timestamp;\\n        var bitrateReceivedKbps = 0,\\n            bitrateSentKbps = 0;\\n\\n        if (timeMs > 0) {\\n            // TODO is there any reason to round here?\\n            bitrateReceivedKbps = Math.round(bytesReceived * 8 / timeMs);\\n            bitrateSentKbps = Math.round(bytesSent * 8 / timeMs);\\n        }\\n\\n        ssrcStats.addBitrate({\\n            'download': bitrateReceivedKbps,\\n            'upload': bitrateSentKbps\\n        });\\n\\n        var resolution = {\\n            height: null,\\n            width: null\\n        };\\n\\n        try {\\n            var height = void 0,\\n                width = void 0;\\n\\n            if ((height = getStatValue(now, 'googFrameHeightReceived')) && (width = getStatValue(now, 'googFrameWidthReceived'))) {\\n                resolution.height = height;\\n                resolution.width = width;\\n            } else if ((height = getStatValue(now, 'googFrameHeightSent')) && (width = getStatValue(now, 'googFrameWidthSent'))) {\\n                resolution.height = height;\\n                resolution.width = width;\\n            }\\n        } catch (e) {} /* not supported*/\\n\\n        // Tries to get frame rate\\n        var frameRate = void 0;\\n\\n        try {\\n            frameRate = getStatValue(now, 'googFrameRateReceived') || getStatValue(now, 'googFrameRateSent') || 0;\\n        } catch (e) {\\n            // if it fails with previous properties(chrome),\\n            // let's try with another one (FF)\\n            try {\\n                frameRate = this.getNonNegativeStat(now, 'framerateMean');\\n            } catch (err) {/* not supported*/}\\n        }\\n        ssrcStats.setFramerate(Math.round(frameRate || 0));\\n\\n        if (resolution.height && resolution.width) {\\n            ssrcStats.setResolution(resolution);\\n        } else {\\n            ssrcStats.setResolution(null);\\n        }\\n    }\\n\\n    // process stats\\n    var totalPackets = {\\n        download: 0,\\n        upload: 0\\n    };\\n    var lostPackets = {\\n        download: 0,\\n        upload: 0\\n    };\\n    var bitrateDownload = 0;\\n    var bitrateUpload = 0;\\n    var resolutions = {};\\n    var framerates = {};\\n    var audioBitrateDownload = 0;\\n    var audioBitrateUpload = 0;\\n    var videoBitrateDownload = 0;\\n    var videoBitrateUpload = 0;\\n\\n    var _iteratorNormalCompletion = true;\\n    var _didIteratorError = false;\\n    var _iteratorError = undefined;\\n\\n    try {\\n        for (var _iterator = this.ssrc2stats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n            var _ref = _step.value;\\n\\n            var _ref2 = _slicedToArray(_ref, 2);\\n\\n            var _ssrc = _ref2[0];\\n            var _ssrcStats = _ref2[1];\\n\\n            // process packet loss stats\\n            var loss = _ssrcStats.loss;\\n            var type = loss.isDownloadStream ? 'download' : 'upload';\\n\\n            totalPackets[type] += loss.packetsTotal;\\n            lostPackets[type] += loss.packetsLost;\\n\\n            // process bitrate stats\\n            bitrateDownload += _ssrcStats.bitrate.download;\\n            bitrateUpload += _ssrcStats.bitrate.upload;\\n\\n            // collect resolutions and framerates\\n            var track = this.peerconnection.getTrackBySSRC(_ssrc);\\n\\n            if (track) {\\n                if (track.isAudioTrack()) {\\n                    audioBitrateDownload += _ssrcStats.bitrate.download;\\n                    audioBitrateUpload += _ssrcStats.bitrate.upload;\\n                } else {\\n                    videoBitrateDownload += _ssrcStats.bitrate.download;\\n                    videoBitrateUpload += _ssrcStats.bitrate.upload;\\n                }\\n\\n                var participantId = track.getParticipantId();\\n\\n                if (participantId) {\\n                    var _resolution = _ssrcStats.resolution;\\n\\n                    if (_resolution.width && _resolution.height && _resolution.width !== -1 && _resolution.height !== -1) {\\n                        var userResolutions = resolutions[participantId] || {};\\n\\n                        userResolutions[_ssrc] = _resolution;\\n                        resolutions[participantId] = userResolutions;\\n                    }\\n                    if (_ssrcStats.framerate !== 0) {\\n                        var userFramerates = framerates[participantId] || {};\\n\\n                        userFramerates[_ssrc] = _ssrcStats.framerate;\\n                        framerates[participantId] = userFramerates;\\n                    }\\n                } else {\\n                    logger.error('No participant ID returned by ' + track);\\n                }\\n            } else if (this.peerconnection.isP2P) {\\n                // NOTE For JVB connection there are JVB tracks reported in\\n                // the stats, but they do not have corresponding JitsiRemoteTrack\\n                // instances stored in TPC. It is not trivial to figure out that\\n                // a SSRC belongs to JVB, so we print this error ony for the P2P\\n                // connection for the time being.\\n                //\\n                // Also there will be reports for tracks removed from the session,\\n                // for the users who have left the conference.\\n                logger.error('JitsiTrack not found for SSRC ' + _ssrc + (' in ' + this.peerconnection));\\n            }\\n\\n            _ssrcStats.resetBitrate();\\n        }\\n    } catch (err) {\\n        _didIteratorError = true;\\n        _iteratorError = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion && _iterator.return) {\\n                _iterator.return();\\n            }\\n        } finally {\\n            if (_didIteratorError) {\\n                throw _iteratorError;\\n            }\\n        }\\n    }\\n\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_1__service_statistics_Events__[\\\"c\\\" /* BYTE_SENT_STATS */], this.peerconnection, byteSentStats);\\n\\n    this.conferenceStats.bitrate = {\\n        'upload': bitrateUpload,\\n        'download': bitrateDownload\\n    };\\n\\n    this.conferenceStats.bitrate.audio = {\\n        'upload': audioBitrateUpload,\\n        'download': audioBitrateDownload\\n    };\\n\\n    this.conferenceStats.bitrate.video = {\\n        'upload': videoBitrateUpload,\\n        'download': videoBitrateDownload\\n    };\\n\\n    this.conferenceStats.packetLoss = {\\n        total: calculatePacketLoss(lostPackets.download + lostPackets.upload, totalPackets.download + totalPackets.upload),\\n        download: calculatePacketLoss(lostPackets.download, totalPackets.download),\\n        upload: calculatePacketLoss(lostPackets.upload, totalPackets.upload)\\n    };\\n\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_1__service_statistics_Events__[\\\"d\\\" /* CONNECTION_STATS */], this.peerconnection, {\\n        'bandwidth': this.conferenceStats.bandwidth,\\n        'bitrate': this.conferenceStats.bitrate,\\n        'packetLoss': this.conferenceStats.packetLoss,\\n        'resolution': resolutions,\\n        'framerate': framerates,\\n        'transport': this.conferenceStats.transport\\n    });\\n    this.conferenceStats.transport = [];\\n};\\n\\n/**\\n * Stats processing logic.\\n */\\nStatsCollector.prototype.processAudioLevelReport = function () {\\n    if (!this.baselineAudioLevelsReport) {\\n        return;\\n    }\\n\\n    var getStatValue = this._getStatValue;\\n\\n    for (var idx in this.currentAudioLevelsReport) {\\n        if (!this.currentAudioLevelsReport.hasOwnProperty(idx)) {\\n            continue;\\n        }\\n\\n        var now = this.currentAudioLevelsReport[idx];\\n\\n        if (now.type !== 'ssrc' && now.type !== 'track') {\\n            continue;\\n        }\\n\\n        var before = this.baselineAudioLevelsReport[idx];\\n        var ssrc = this.getNonNegativeStat(now, 'ssrc');\\n\\n        if (!ssrc && Array.isArray(now.ssrcIds)) {\\n            ssrc = Number(now.ssrcIds[0]);\\n        }\\n\\n        if (!before) {\\n            logger.warn(ssrc + ' not enough data');\\n            continue;\\n        }\\n\\n        if (!ssrc) {\\n            if (Date.now() - now.timestamp < 3000) {\\n                logger.warn('No ssrc: ');\\n            }\\n            continue;\\n        }\\n\\n        // Audio level\\n        var audioLevel = void 0;\\n\\n        try {\\n            audioLevel = getStatValue(now, 'audioInputLevel') || getStatValue(now, 'audioOutputLevel');\\n        } catch (e) {\\n            /* not supported*/\\n            logger.warn('Audio Levels are not available in the statistics.');\\n            clearInterval(this.audioLevelsIntervalId);\\n\\n            return;\\n        }\\n\\n        if (audioLevel) {\\n            var isLocal = void 0;\\n\\n            // If type=\\\"ssrc\\\" (legacy) check whether they are received packets.\\n            if (now.type === 'ssrc') {\\n                isLocal = !getStatValue(now, 'packetsReceived');\\n\\n                // If type=\\\"track\\\", check remoteSource boolean property.\\n            } else {\\n                isLocal = !now.remoteSource;\\n            }\\n\\n            // According to the W3C WebRTC Stats spec, audioLevel should be in\\n            // 0..1 range (0 == silence). However browsers don't behave that\\n            // way so we must convert it to 0..1.\\n            //\\n            // In Edge the range is -100..0 (-100 == silence) measured in dB,\\n            // so convert to linear. The levels are set to 0 for remote tracks,\\n            // so don't convert those, since 0 means \\\"the maximum\\\" in Edge.\\n            if (__WEBPACK_IMPORTED_MODULE_0__RTC_RTCBrowserType__[\\\"a\\\" /* default */].isEdge()) {\\n                audioLevel = audioLevel < 0 ? Math.pow(10, audioLevel / 20) : 0;\\n\\n                // TODO: Can't find specs about what this value really is, but it\\n                // seems to vary between 0 and around 32k.\\n            } else {\\n                audioLevel = audioLevel / 32767;\\n            }\\n\\n            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_1__service_statistics_Events__[\\\"a\\\" /* AUDIO_LEVEL */], this.peerconnection, ssrc, audioLevel, isLocal);\\n        }\\n    }\\n};\\n\\n/* eslint-enable no-continue */\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/statistics/RTPStatsCollector.js\\\"))\\n\\n/***/ }),\\n/* 91 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n * currentExecutingScript\\n * Get the currently executing script, regardless of its source/trigger/synchronicity. Similar to HTML5's `document.currentScript` but arguably much more useful!\\n * Copyright (c) 2015 James M. Greene\\n * Licensed MIT\\n * https://github.com/JamesMGreene/currentExecutingScript\\n * v0.1.3\\n */\\n(function(root, factory) {\\n  if (true) {\\n    // AMD. Register as an anonymous module.\\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n  } else if (typeof exports === \\\"object\\\") {\\n    // CommonJS-like environments that support `module.exports`,\\n    // like Node.js. Does not work with strict CommonJS!\\n    module.exports = factory();\\n  } else {\\n    // Browser globals (`root` is `window`)\\n    root.currentExecutingScript = factory();\\n  }\\n}(\\n  // Current context/scope\\n  this || window,\\n\\n  // Factory function to return the export\\n  function() {\\n\\nvar scriptReadyRegex = /^(interactive|loaded|complete)$/;\\n\\n// This page's URL (minus query string and fragment identifer hash, if any)\\nvar fullPageUrl = !!window.location ? window.location.href : null;\\nvar pageUrl = fullPageUrl ? fullPageUrl.replace(/#.*$/, \\\"\\\").replace(/\\\\?.*$/, \\\"\\\") || null : null;\\n\\n// Live NodeList collection\\nvar scripts = document.getElementsByTagName(\\\"script\\\");\\n\\n// Check if the browser supports the `readyState` property on `script` elements\\nvar supportsScriptReadyState = \\\"readyState\\\" in (scripts[0] || document.createElement(\\\"script\\\"));\\n\\n// Lousy browser detection for [not] Opera\\nvar isNotOpera = !window.opera || window.opera.toString() !== \\\"[object Opera]\\\";\\n\\n// Detect if `document.currentScript` is supported\\nvar hasNativeCurrentScriptAccessor = \\\"currentScript\\\" in document;\\n\\nvar originalStackDepthConfig;\\n// Detect if the V8 Error Stack Trace API is supported\\nif (\\\"stackTraceLimit\\\" in Error && Error.stackTraceLimit !== Infinity) {\\n  originalStackDepthConfig = Error.stackTraceLimit;\\n  Error.stackTraceLimit = Infinity;\\n}\\n\\n\\n// In some browsers (e.g. Chrome), you can get the current stack from an Error\\n// object instance without needing to throw it. Avoiding an unnecessary\\n// use of `throw` saves time and performance.\\nvar hasStackBeforeThrowing = false,\\n    hasStackAfterThrowing = false;\\n(function() {\\n  try {\\n    var err = new Error();\\n    hasStackBeforeThrowing = typeof err.stack === \\\"string\\\" && !!err.stack;\\n    throw err;\\n  }\\n  catch (thrownErr) {\\n    hasStackAfterThrowing = typeof thrownErr.stack === \\\"string\\\" && !!thrownErr.stack;\\n  }\\n})();\\n\\n\\n// Normalize whitespace within a string\\nfunction normalizeWhitespace(str) {\\n  return str ? str.replace(/^\\\\s+$|\\\\s+$/g, \\\"\\\").replace(/\\\\s\\\\s+/g, \\\" \\\") : \\\"\\\";\\n}\\n\\n// Get script object based on the `src` URL\\nfunction getScriptFromUrl(url, eligibleScripts) {\\n  var i,\\n      script = null;\\n\\n  eligibleScripts = eligibleScripts || scripts;\\n\\n  if (typeof url === \\\"string\\\" && url) {\\n    for (i = eligibleScripts.length; i--; ) {\\n      if (eligibleScripts[i].src === url) {\\n        // NOTE: Could check if the same script URL is used by more than one `script` element\\n        // here... but let's not. That would yield less useful results in \\\"loose\\\" detection. ;)\\n        script = eligibleScripts[i];\\n        break;\\n      }\\n    }\\n  }\\n  return script;\\n}\\n\\n// Get script object based on the caller function's source code body (text)\\nfunction getInlineScriptFromCallerSource(callerFnSource, eligibleScripts) {\\n  var i, inlineScriptText,\\n      script = null,\\n      callerSourceText = normalizeWhitespace(callerFnSource);\\n\\n  eligibleScripts = eligibleScripts || scripts;\\n\\n  if (callerFnSource && callerSourceText) {\\n    for (i = eligibleScripts.length; i--; ) {\\n      // Only look at inline scripts\\n      if (!eligibleScripts[i].hasAttribute(\\\"src\\\")) {\\n        inlineScriptText = normalizeWhitespace(eligibleScripts[i].text);\\n        if (inlineScriptText.indexOf(callerSourceText) !== -1) {\\n          // If more than one match is found, don't return any\\n          if (script) {\\n            script = null;\\n            break;\\n          }\\n          script = eligibleScripts[i];\\n        }\\n      }\\n    }\\n  }\\n\\n  return script;\\n}\\n\\n// If there is only a single inline script on the page, return it; otherwise `null`\\nfunction getSoleInlineScript(eligibleScripts) {\\n  var i, len,\\n      script = null;\\n  eligibleScripts = eligibleScripts || scripts;\\n  for (i = 0, len = eligibleScripts.length; i < len; i++) {\\n    if (!eligibleScripts[i].hasAttribute(\\\"src\\\")) {\\n      if (script) {\\n        script = null;\\n        break;\\n      }\\n      script = eligibleScripts[i];\\n    }\\n  }\\n  return script;\\n}\\n\\n// Get the currently executing script URL from an Error stack trace\\nfunction getScriptUrlFromStack(stack, skipStackDepth) {\\n  var matches, remainingStack,\\n      url = null,\\n      ignoreMessage = typeof skipStackDepth === \\\"number\\\";\\n  skipStackDepth = ignoreMessage ? Math.round(skipStackDepth) : 0;\\n  if (typeof stack === \\\"string\\\" && stack) {\\n    if (ignoreMessage) {\\n      matches = stack.match(/(data:text\\\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\\\/\\\\/[\\\\/]?.+?\\\\/[^:\\\\)]*?)(?::\\\\d+)(?::\\\\d+)?/);\\n    }\\n    else {\\n      matches = stack.match(/^(?:|[^:@]*@|.+\\\\)@(?=data:text\\\\/javascript|blob|http[s]?|file)|.+?\\\\s+(?: at |@)(?:[^:\\\\(]+ )*[\\\\(]?)(data:text\\\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\\\/\\\\/[\\\\/]?.+?\\\\/[^:\\\\)]*?)(?::\\\\d+)(?::\\\\d+)?/);\\n\\n      if (!(matches && matches[1])) {\\n        matches = stack.match(/\\\\)@(data:text\\\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\\\/\\\\/[\\\\/]?.+?\\\\/[^:\\\\)]*?)(?::\\\\d+)(?::\\\\d+)?/);\\n      }\\n    }\\n\\n    if (matches && matches[1]) {\\n      if (skipStackDepth > 0) {\\n        remainingStack = stack.slice(stack.indexOf(matches[0]) + matches[0].length);\\n        url = getScriptUrlFromStack(remainingStack, (skipStackDepth - 1));\\n      }\\n      else {\\n        url = matches[1];\\n      }\\n    }\\n\\n    // TODO: Handle more edge cases!\\n    // Fixes #1\\n    // See https://github.com/JamesMGreene/currentExecutingScript/issues/1\\n\\n    // ???\\n\\n  }\\n  return url;\\n}\\n\\n\\n// Get the farthest currently executing (i.e. yes, EXECUTING) `script` DOM\\n// element for the caller function, regardless of whether it is that `script`\\n// DOM element is currently being evaluated for the first time. The farthest\\n// currently executing `script` DOM element would typically be considered the\\n// originator of the current execution stack.\\nfunction _farthestExecutingScript() {\\n  /*jshint noarg:false */\\n\\n  // TODO: Implement!\\n  // Fixes #3\\n  // See https://github.com/JamesMGreene/currentExecutingScript/issues/3\\n  return null;\\n\\n/*\\n  // Yes, this IS possible, i.e. if a script removes other scripts (or itself)\\n  if (scripts.length === 0) {\\n    return null;\\n  }\\n\\n  // Guaranteed accurate in IE 6-10.\\n  // Not accurate/supported in any other browsers.\\n  if (isNotOpera && supportsScriptReadyState) {\\n    for (var i = scripts.length; i--; ) {\\n      if (scripts[i].readyState === \\\"interactive\\\") {\\n        return scripts[i];\\n      }\\n    }\\n  }\\n\\n  var stack,\\n      e = new Error();\\n  if (hasStackBeforeThrowing) {\\n    stack = e.stack;\\n  }\\n  if (!stack && hasStackAfterThrowing) {\\n    try {\\n      throw e;\\n    }\\n    catch (err) {\\n      // NOTE: Cannot use `err.sourceURL` or `err.fileName` as they will always be THIS script\\n      stack = err.stack;\\n    }\\n  }\\n  if (stack) {\\n    var url = getScriptUrlFromStack(stack, skipStackDepth);\\n    var script = getScriptFromUrl(url, scripts );\\n    if (!script && pageUrl && url === pageUrl) {\\n      // Try to find the correct inline script by searching through\\n      // inline scripts' text content for the caller function's source\\n      // code to be present. If the caller function's source code is\\n      // not available, see if there is only one inline script element\\n      // in the DOM and return that (even though it may be wrong)\\n\\n      // TODO: Implement!\\n      // Fixes #4 in part\\n      // See https://github.com/JamesMGreene/currentExecutingScript/issues/4\\n\\n      var callerFn = _farthestExecutingScript.caller || null,\\n          callerFnStack = [],\\n          callerFnSource = null;\\n\\n      while (callerFn) {\\n        callerFnStack.push(callerFn);\\n        callerFn = callerFn.caller || null;\\n      }\\n      callerFn = callerFnStack.slice(-1)[0];\\n      callerFnSource = callerFn ? (\\\"\\\" + callerFn) : null;\\n\\n\\n      if (callerFnSource) {\\n        script = getInlineScriptFromCallerSource(callerFnSource);\\n      }\\n      else {\\n        // NOTE: This is a loose assumption that could be inaccurate!\\n        //\\n        // Inaccuracies:\\n        //  - If the inline script that initiated the call was also removed from the DOM.\\n        //  - If the call was initiated by an element's inline event handler,\\n        //    e.g. `<a onclick=\\\"(function() { alert(currentExecutingScript()); }()\\\">click</a>`\\n        script = getSoleInlineScript();\\n      }\\n    }\\n    return script;\\n  }\\n\\n  // NOTE: This is a loose assumption that could be inaccurate!\\n  //\\n  // Inaccuracies:\\n  //  - If a script is created dynamically and appended to some position\\n  //    other than the very end of the document.\\n  //  - If multiple scripts are created dynamically and all appended to the\\n  //    same position within the document (and do not have their `async` attributes\\n  //    set to `false`, at least in browsers that support async script evaluation.\\n  //    other than the very end of the document.\\n  //  - If any scripts are added with the `async` attribute set to `true` in a browser\\n  //    that supports it.\\n  //  - May get confused by `script` elements within `svg` elements\\n  return scripts[scripts.length - 1] || null;\\n*/\\n}\\n\\n\\n// Get the originating currently executing (i.e. yes, EXECUTING) `script` DOM\\n// element or attribute node (e.g. `onclick`) for the caller function,\\n// regardless of whether it is that `script` DOM element is currently being\\n// evaluated for the first time. The originating currently executing `script`\\n// DOM element [or attribute node] is the originator of the current execution stack.\\nfunction _originatingExecutingScript() {\\n  // TODO: Implement!\\n  // Fixes #2\\n  // See https://github.com/JamesMGreene/currentExecutingScript/issues/2\\n  return null;\\n}\\n\\n// Get the nearest currently executing (i.e. yes, EXECUTING) `script` DOM\\n// element for the caller function, regardless of whether it is that `script`\\n// DOM element is currently being evaluated for the first time.\\nfunction _nearestExecutingScript() {\\n  /*jshint noarg:false */\\n\\n  // Yes, this IS possible, i.e. if a script removes other scripts (or itself)\\n  if (scripts.length === 0) {\\n    return null;\\n  }\\n\\n  var i, e, stack, url, script,\\n      eligibleScripts = [],\\n      skipStackDepth = _nearestExecutingScript.skipStackDepth || 1,\\n\\n      // TODO: Implement!\\n      // Fixes #4 in part\\n      // See https://github.com/JamesMGreene/currentExecutingScript/issues/4\\n      callerFnSource = null;  //(\\\"\\\" + (_nearestExecutingScript.caller || \\\"\\\")) || null;\\n\\n  // This part will only help in IE 6-10.\\n  for (i = 0; i < scripts.length; i++) {\\n    if (isNotOpera && supportsScriptReadyState) {\\n      if (scriptReadyRegex.test(scripts[i].readyState)) {\\n        eligibleScripts.push(scripts[i]);\\n      }\\n    }\\n    else {\\n      eligibleScripts.push(scripts[i]);\\n    }\\n  }\\n\\n  e = new Error();\\n  if (hasStackBeforeThrowing) {\\n    stack = e.stack;\\n  }\\n  if (!stack && hasStackAfterThrowing) {\\n    try {\\n      throw e;\\n    }\\n    catch (err) {\\n      // NOTE: Cannot use `err.sourceURL` or `err.fileName` as they will always be THIS script\\n      stack = err.stack;\\n    }\\n  }\\n\\n  if (stack) {\\n    url = getScriptUrlFromStack(stack, skipStackDepth);\\n    script = getScriptFromUrl(url, eligibleScripts);\\n\\n    if (!script && pageUrl && url === pageUrl) {\\n      // Try to find the correct inline script by searching through\\n      // inline scripts' text content for the caller function's source\\n      // code to be present.\\n      if (callerFnSource) {\\n        script = getInlineScriptFromCallerSource(callerFnSource, eligibleScripts);\\n      }\\n      // If the caller function's source code is not available, see if\\n      // there is only one inline script element in the DOM and return\\n      // that (even though it may be wrong)...\\n      else {\\n        // NOTE: This is a loose assumption that could be inaccurate!\\n        //\\n        // Inaccuracies:\\n        //  - If the inline script that initiated the call was also removed from the DOM.\\n        //  - If the call was initiated by an element's inline event handler,\\n        //    e.g. `<a onclick=\\\"(function() { alert(currentExecutingScript()); }()\\\">click</a>`\\n        script = getSoleInlineScript(eligibleScripts);\\n      }\\n    }\\n  }\\n\\n  //\\n  // Welcome to the Island of Inaccurate Assumptions!\\n  // NOTE: ALL of the following are loose assumptions that could be inaccurate!\\n  //\\n\\n  if (!script) {\\n    // Inaccuracies:\\n    //  - If the inline script that initiated the call was also removed from the DOM.\\n    //  - If the call was initiated by an element's inline event handler,\\n    //    e.g. `<a onclick=\\\"(function() { alert(currentExecutingScript()); }()\\\">click</a>`\\n    if (eligibleScripts.length === 1) {\\n      script = eligibleScripts[0];\\n    }\\n  }\\n\\n  if (!script) {\\n    // Inaccuracies:\\n    //  - If script currently being synchronously evaluated by the parser is the\\n    //    originator of this call stack but NOT the source script of the caller/invocation\\n    //    e.g.\\n    //    ```html\\n    //    <script id=\\\"a\\\">\\n    //    function getCurrentScriptCallerFn() {\\n    //      return currentExecutingScript.near();\\n    //    }\\n    //    </script>\\n    //    <script id=\\\"b\\\">\\n    //    // Should get `script[id=\\\"a\\\"]` but will get `script[id=\\\"b\\\"]` instead\\n    //    getCurrentScriptCallerFn();\\n    //    </script>\\n    if (hasNativeCurrentScriptAccessor) {\\n      script = document.currentScript;\\n    }\\n  }\\n\\n  if (!script) {\\n    // Inaccuracies:\\n    //  - If script currently being synchronously evaluated by the parser is the\\n    //    originator of this call stack but NOT the source script of the caller/invocation\\n    //    e.g.\\n    //    ```html\\n    //    <script id=\\\"a\\\">\\n    //    function getCurrentScriptCallerFn() {\\n    //      return currentExecutingScript.near();\\n    //    }\\n    //    </script>\\n    //    <script id=\\\"b\\\">\\n    //    // Should get `script[id=\\\"a\\\"]` but will get `script[id=\\\"b\\\"]` instead\\n    //    getCurrentScriptCallerFn();\\n    //    </script>\\n    if (isNotOpera && supportsScriptReadyState) {\\n      for (i = eligibleScripts.length; i--; ) {\\n        if (eligibleScripts[i].readyState === \\\"interactive\\\") {\\n          script = eligibleScripts[i];\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  if (!script) {\\n    // Inaccuracies:\\n    //  - If a script is created dynamically and appended to some position\\n    //    other than the very end of the document.\\n    //  - If multiple scripts are created dynamically and all appended to the\\n    //    same position within the document (and do not have their `async` attributes\\n    //    set to `false`, at least in browsers that support async script evaluation.\\n    //    other than the very end of the document.\\n    //  - If any scripts are added with the `async` attribute set to `true` in a browser\\n    //    that supports it.\\n    //  - May get confused by `script` elements within `svg` elements\\n    //  - If script currently being synchronously evaluated by the parser is the\\n    //    originator of this call stack but NOT the source script of the caller/invocation\\n    //    e.g.\\n    //    ```html\\n    //    <script id=\\\"a\\\">\\n    //    function getCurrentScriptCallerFn() {\\n    //      return currentExecutingScript.near();\\n    //    }\\n    //    </script>\\n    //    <script id=\\\"b\\\">\\n    //    // Should get `script[id=\\\"a\\\"]` but will get `script[id=\\\"b\\\"]` instead\\n    //    getCurrentScriptCallerFn();\\n    //    </script>\\n    //    ```\\n    script = eligibleScripts[eligibleScripts.length - 1] || null;\\n  }\\n\\n  return script;\\n}\\n\\n// Default stack depth to skip over when analyzing call stack frames\\n_nearestExecutingScript.skipStackDepth = 1;\\n\\n\\n\\n    //\\n    // Export the API\\n    //\\n    var currentExecutingScript    = _nearestExecutingScript;      // default\\n    currentExecutingScript.near   = _nearestExecutingScript;\\n    currentExecutingScript.far    = _farthestExecutingScript;\\n    currentExecutingScript.origin = _originatingExecutingScript;\\n\\n\\n    // Just return a value to define the module export.\\n    // This example returns an object, but the module\\n    // can return a function as the exported value.\\n    return currentExecutingScript;\\n  })\\n);\\n\\n\\n/***/ }),\\n/* 92 */\\n/***/ (function(module, exports) {\\n\\nvar Constants = {\\n    LOCAL_JID: 'local'\\n};\\n\\nmodule.exports = Constants;\\n\\n/***/ }),\\n/* 93 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = ComponentsVersions;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__statistics_statistics__ = __webpack_require__(5);\\n\\n\\nvar logger = __webpack_require__(0).getLogger(__filename);\\n\\n/**\\n * The constant for the name of the focus component.\\n * @type {string}\\n */\\nComponentsVersions.FOCUS_COMPONENT = 'focus';\\n\\n/**\\n * The constant for the name of the videobridge component.\\n * @type {string}\\n */\\nComponentsVersions.VIDEOBRIDGE_COMPONENT = 'videobridge';\\n\\n/**\\n * The constant for the name of the XMPP server component.\\n * @type {string}\\n */\\nComponentsVersions.XMPP_SERVER_COMPONENT = 'xmpp';\\n\\n/**\\n * Creates new instance of <tt>ComponentsVersions</tt> which will be discovering\\n * the versions of conferencing system components in given\\n * <tt>JitsiConference</tt>.\\n * @param conference <tt>JitsiConference</tt> instance which will be used to\\n *        listen for focus presence updates.\\n * @constructor\\n */\\nfunction ComponentsVersions(conference) {\\n\\n    this.versions = {};\\n\\n    this.conference = conference;\\n    this.conference.addCommandListener('versions', this.processPresence.bind(this));\\n}\\n\\nComponentsVersions.prototype.processPresence = function (node, mucResource, mucJid) {\\n    var _this = this;\\n\\n    if (node.attributes.xmlns !== 'http://jitsi.org/jitmeet') {\\n        logger.warn('Ignored presence versions node - invalid xmlns', node);\\n\\n        return;\\n    }\\n\\n    if (!this.conference._isFocus(mucJid)) {\\n        logger.warn('Received versions not from the focus user: ' + node, mucJid);\\n\\n        return;\\n    }\\n\\n    var log = [];\\n\\n    node.children.forEach(function (item) {\\n\\n        var componentName = item.attributes.name;\\n\\n        if (componentName !== ComponentsVersions.FOCUS_COMPONENT && componentName !== ComponentsVersions.XMPP_SERVER_COMPONENT && componentName !== ComponentsVersions.VIDEOBRIDGE_COMPONENT) {\\n            logger.warn('Received version for not supported component name: ' + componentName);\\n\\n            return;\\n        }\\n\\n        var version = item.value;\\n\\n        if (_this.versions[componentName] !== version) {\\n            _this.versions[componentName] = version;\\n            logger.info('Got ' + componentName + ' version: ' + version);\\n\\n            log.push({\\n                id: 'component_version',\\n                component: componentName,\\n                version: version\\n            });\\n        }\\n    });\\n\\n    // logs versions to stats\\n    if (log.length > 0) {\\n        __WEBPACK_IMPORTED_MODULE_0__statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify(log));\\n    }\\n};\\n\\n/**\\n * Obtains the version of conferencing system component.\\n * @param componentName the name of the component for which we want to obtain\\n *        the version.\\n * @returns {String} which describes the version of the component identified by\\n *          given <tt>componentName</tt> or <tt>undefined</tt> if not found.\\n */\\nComponentsVersions.prototype.getComponentVersion = function (componentName) {\\n    return this.versions[componentName];\\n};\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/version/ComponentsVersions.js\\\"))\\n\\n/***/ }),\\n/* 94 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__service_connectivity_ConnectionQualityEvents__ = __webpack_require__(31);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_jitsi_meet_logger__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n\\n\\nvar XMPPEvents = __webpack_require__(8);\\nvar VideoType = __webpack_require__(13);\\nvar Resolutions = __webpack_require__(35);\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_2_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * The value to use for the \\\"type\\\" field for messages sent by ConnectionQuality\\n * over the data channel.\\n */\\nvar STATS_MESSAGE_TYPE = 'stats';\\n\\n/**\\n * See media/engine/simulcast.ss from webrtc.org\\n */\\nvar kSimulcastFormats = [{ width: 1920,\\n    height: 1080,\\n    layers: 3,\\n    max: 5000,\\n    target: 4000,\\n    min: 800 }, { width: 1280,\\n    height: 720,\\n    layers: 3,\\n    max: 2500,\\n    target: 2500,\\n    min: 600 }, { width: 960,\\n    height: 540,\\n    layers: 3,\\n    max: 900,\\n    target: 900,\\n    min: 450 }, { width: 640,\\n    height: 360,\\n    layers: 2,\\n    max: 700,\\n    target: 500,\\n    min: 150 }, { width: 480,\\n    height: 270,\\n    layers: 2,\\n    max: 450,\\n    target: 350,\\n    min: 150 }, { width: 320,\\n    height: 180,\\n    layers: 1,\\n    max: 200,\\n    target: 150,\\n    min: 30 }];\\n\\n/**\\n * The initial bitrate for video in kbps.\\n */\\nvar startBitrate = 800;\\n\\n/**\\n * Gets the expected bitrate (in kbps) in perfect network conditions.\\n * @param simulcast {boolean} whether simulcast is enabled or not.\\n * @param resolution {Resolution} the resolution.\\n * @param millisSinceStart {number} the number of milliseconds since sending\\n * video started.\\n */\\nfunction getTarget(simulcast, resolution, millisSinceStart) {\\n    // Completely ignore the bitrate in the first 5 seconds, as the first\\n    // event seems to fire very early and the value is suspicious and causes\\n    // false positives.\\n    if (millisSinceStart < 5000) {\\n        return 1;\\n    }\\n\\n    var target = 0;\\n    var height = Math.min(resolution.height, resolution.width);\\n\\n    if (simulcast) {\\n        // Find the first format with height no bigger than ours.\\n        var simulcastFormat = kSimulcastFormats.find(function (f) {\\n            return f.height <= height;\\n        });\\n\\n        if (simulcastFormat) {\\n            var _loop = function _loop() {\\n                var targetHeight = height;\\n\\n                simulcastFormat = kSimulcastFormats.find(function (f) {\\n                    return f.height === targetHeight;\\n                });\\n                if (simulcastFormat) {\\n                    target += simulcastFormat.target;\\n                } else {\\n                    return 'break';\\n                }\\n            };\\n\\n            // Sum the target fields from all simulcast layers for the given\\n            // resolution (e.g. 720p + 360p + 180p).\\n            for (height = simulcastFormat.height; height >= 180; height /= 2) {\\n                var _ret = _loop();\\n\\n                if (_ret === 'break') break;\\n            }\\n        }\\n    } else {\\n        // See GetMaxDefaultVideoBitrateKbps in\\n        // media/engine/webrtcvideoengine2.cc from webrtc.org\\n        var pixels = resolution.width * resolution.height;\\n\\n        if (pixels <= 320 * 240) {\\n            target = 600;\\n        } else if (pixels <= 640 * 480) {\\n            target = 1700;\\n        } else if (pixels <= 960 * 540) {\\n            target = 2000;\\n        } else {\\n            target = 2500;\\n        }\\n    }\\n\\n    // Allow for an additional 1 second for ramp up -- delay any initial drop\\n    // of connection quality by 1 second.\\n    return Math.min(target, rampUp(Math.max(0, millisSinceStart - 1000)));\\n}\\n\\n/**\\n * Gets the bitrate to which GCC would have ramped up in perfect network\\n * conditions after millisSinceStart milliseconds.\\n * @param millisSinceStart {number} the number of milliseconds since sending\\n * video was enabled.\\n */\\nfunction rampUp(millisSinceStart) {\\n    if (millisSinceStart > 60000) {\\n        return Number.MAX_SAFE_INTEGER;\\n    }\\n\\n    // According to GCC the send side bandwidth estimation grows with at most\\n    // 8% per second.\\n    // https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02#section-5.5\\n    return startBitrate * Math.pow(1.08, millisSinceStart / 1000);\\n}\\n\\n/**\\n * A class which monitors the local statistics coming from the RTC modules, and\\n * calculates a \\\"connection quality\\\" value, in percent, for the media\\n * connection. A value of 100% indicates a very good network connection, and a\\n * value of 0% indicates a poor connection.\\n */\\n\\nvar ConnectionQuality = function () {\\n    /**\\n     *\\n     * @param conference\\n     * @param eventEmitter\\n     * @param options\\n     */\\n    function ConnectionQuality(conference, eventEmitter, options) {\\n        var _this = this;\\n\\n        _classCallCheck(this, ConnectionQuality);\\n\\n        this.eventEmitter = eventEmitter;\\n\\n        /**\\n         * The owning JitsiConference.\\n         */\\n        this._conference = conference;\\n\\n        /**\\n         * Holds statistics about the local connection quality.\\n         */\\n        this._localStats = {\\n            connectionQuality: 100,\\n            jvbRTT: undefined\\n        };\\n\\n        /**\\n         * The time this._localStats.connectionQuality was last updated.\\n         */\\n        this._lastConnectionQualityUpdate = -1;\\n\\n        /**\\n         * Maps a participant ID to an object holding connection quality\\n         * statistics received from this participant.\\n         */\\n        this._remoteStats = {};\\n\\n        /**\\n         * The time that the ICE state last changed to CONNECTED. We use this\\n         * to calculate how much time we as a sender have had to ramp-up.\\n         */\\n        this._timeIceConnected = -1;\\n\\n        /**\\n         * The time that local video was unmuted. We use this to calculate how\\n         * much time we as a sender have had to ramp-up.\\n         */\\n        this._timeVideoUnmuted = -1;\\n\\n        // We assume a global startBitrate value for the sake of simplicity.\\n        if (options.startBitrate && options.startBitrate > 0) {\\n            startBitrate = options.startBitrate;\\n        }\\n\\n        // TODO: consider ignoring these events and letting the user of\\n        // lib-jitsi-meet handle these separately.\\n        conference.on(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"CONNECTION_INTERRUPTED\\\"], function () {\\n            _this._updateLocalConnectionQuality(0);\\n            _this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_0__service_connectivity_ConnectionQualityEvents__[\\\"LOCAL_STATS_UPDATED\\\"], _this._localStats);\\n            _this._broadcastLocalStats();\\n        });\\n\\n        conference.room.addListener(XMPPEvents.ICE_CONNECTION_STATE_CHANGED, function (jingleSession, newState) {\\n            if (!jingleSession.isP2P && newState === 'connected') {\\n                _this._timeIceConnected = window.performance.now();\\n            }\\n        });\\n\\n        // Listen to DataChannel message from other participants in the\\n        // conference, and update the _remoteStats field accordingly.\\n        conference.on(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"ENDPOINT_MESSAGE_RECEIVED\\\"], function (participant, payload) {\\n            if (payload.type === STATS_MESSAGE_TYPE) {\\n                _this._updateRemoteStats(participant.getId(), payload.values);\\n            }\\n        });\\n\\n        // Listen to local statistics events originating from the RTC module\\n        // and update the _localStats field.\\n        // Oh, and by the way, the resolutions of all remote participants are\\n        // also piggy-backed in these \\\"local\\\" statistics. It's obvious, really,\\n        // if one carefully reads the *code* (but not the docs) in\\n        // UI/VideoLayout/VideoLayout.js#updateLocalConnectionStats in\\n        // jitsi-meet\\n        // TODO: We should keep track of the remote resolution in _remoteStats,\\n        // and notify about changes via separate events.\\n        conference.statistics.addConnectionStatsListener(this._updateLocalStats.bind(this));\\n\\n        // Save the last time we were unmuted.\\n        conference.on(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"TRACK_MUTE_CHANGED\\\"], function (track) {\\n            if (track.isVideoTrack()) {\\n                if (track.isMuted()) {\\n                    _this._timeVideoUnmuted = -1;\\n                } else {\\n                    _this._maybeUpdateUnmuteTime();\\n                }\\n            }\\n        });\\n        conference.on(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"TRACK_ADDED\\\"], function (track) {\\n            if (track.isVideoTrack() && !track.isMuted()) {\\n                _this._maybeUpdateUnmuteTime();\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Sets _timeVideoUnmuted if it was previously unset. If it was already set,\\n     * doesn't change it.\\n     */\\n\\n\\n    _createClass(ConnectionQuality, [{\\n        key: '_maybeUpdateUnmuteTime',\\n        value: function _maybeUpdateUnmuteTime() {\\n            if (this._timeVideoUnmuted < 0) {\\n                this._timeVideoUnmuted = window.performance.now();\\n            }\\n        }\\n\\n        /**\\n         * Calculates a new \\\"connection quality\\\" value.\\n         * @param videoType {VideoType} the type of the video source (camera or\\n         * a screen capture).\\n         * @param isMuted {boolean} whether the local video is muted.\\n         * @param resolutionName {Resolution} the input resolution used by the\\n         * camera.\\n         * @returns {*} the newly calculated connection quality.\\n         */\\n\\n    }, {\\n        key: '_calculateConnectionQuality',\\n        value: function _calculateConnectionQuality(videoType, isMuted, resolutionName) {\\n\\n            // resolutionName is an index into Resolutions (where \\\"720\\\" is\\n            // \\\"1280x720\\\" and \\\"960\\\" is \\\"960x720\\\" ...).\\n            var resolution = Resolutions[resolutionName];\\n\\n            var quality = 100;\\n            var packetLoss = void 0;\\n\\n            // TODO: take into account packet loss for received streams\\n\\n            if (this._localStats.packetLoss) {\\n                packetLoss = this._localStats.packetLoss.upload;\\n\\n                // Ugly Hack Alert (UHA):\\n                // The packet loss for the upload direction is calculated based on\\n                // incoming RTCP Receiver Reports. Since we don't have RTCP\\n                // termination for audio, these reports come from the actual\\n                // receivers in the conference and therefore the reported packet\\n                // loss includes loss from the bridge to the receiver.\\n                // When we are sending video this effect is small, because the\\n                // number of video packets is much larger than the number of audio\\n                // packets (and our calculation is based on the total number of\\n                // received and lost packets).\\n                // When video is muted, however, the effect might be significant,\\n                // but we don't know what it is. We do know that it is positive, so\\n                // as a temporary solution, until RTCP termination is implemented\\n                // for the audio streams, we relax the packet loss checks here.\\n                if (isMuted) {\\n                    packetLoss *= 0.5;\\n                }\\n            }\\n\\n            if (isMuted || !resolution || videoType === VideoType.DESKTOP || this._timeIceConnected < 0 || this._timeVideoUnmuted < 0) {\\n\\n                // Calculate a value based on packet loss only.\\n                if (packetLoss === undefined) {\\n                    logger.error('Cannot calculate connection quality, unknown ' + 'packet loss.');\\n                    quality = 100;\\n                } else if (packetLoss <= 2) {\\n                    quality = 100; // Full 5 bars.\\n                } else if (packetLoss <= 4) {\\n                    quality = 70; // 4 bars\\n                } else if (packetLoss <= 6) {\\n                    quality = 50; // 3 bars\\n                } else if (packetLoss <= 8) {\\n                    quality = 30; // 2 bars\\n                } else if (packetLoss <= 12) {\\n                    quality = 10; // 1 bars\\n                } else {\\n                    quality = 0; // Still 1 bar, but slower climb-up.\\n                }\\n            } else {\\n                // Calculate a value based on the sending bitrate.\\n\\n                // time since sending of video was enabled.\\n                var millisSinceStart = window.performance.now() - Math.max(this._timeVideoUnmuted, this._timeIceConnected);\\n\\n                // Figure out if simulcast is in use\\n                var activeTPC = this._conference.getActivePeerConnection();\\n                var isSimulcastOn = Boolean(activeTPC && activeTPC.isSimulcastOn());\\n\\n                // expected sending bitrate in perfect conditions\\n                var target = getTarget(isSimulcastOn, resolution, millisSinceStart);\\n\\n                target = 0.9 * target;\\n\\n                quality = 100 * this._localStats.bitrate.upload / target;\\n\\n                // Whatever the bitrate, drop early if there is significant loss\\n                if (packetLoss && packetLoss >= 10) {\\n                    quality = Math.min(quality, 30);\\n                }\\n            }\\n\\n            // Make sure that the quality doesn't climb quickly\\n            if (this._lastConnectionQualityUpdate > 0) {\\n                var maxIncreasePerSecond = 2;\\n                var prevConnectionQuality = this._localStats.connectionQuality;\\n                var diffSeconds = (window.performance.now() - this._lastConnectionQualityUpdate) / 1000;\\n\\n                quality = Math.min(quality, prevConnectionQuality + diffSeconds * maxIncreasePerSecond);\\n            }\\n\\n            return Math.min(100, quality);\\n        }\\n\\n        /**\\n         * Updates the localConnectionQuality value\\n         * @param values {number} the new value. Should be in [0, 100].\\n         */\\n\\n    }, {\\n        key: '_updateLocalConnectionQuality',\\n        value: function _updateLocalConnectionQuality(value) {\\n            this._localStats.connectionQuality = value;\\n            this._lastConnectionQualityUpdate = window.performance.now();\\n        }\\n\\n        /**\\n         * Broadcasts the local statistics to all other participants in the\\n         * conference.\\n         */\\n\\n    }, {\\n        key: '_broadcastLocalStats',\\n        value: function _broadcastLocalStats() {\\n            // Send only the data that remote participants care about.\\n            var data = {\\n                bitrate: this._localStats.bitrate,\\n                packetLoss: this._localStats.packetLoss,\\n                connectionQuality: this._localStats.connectionQuality,\\n                jvbRTT: this._localStats.jvbRTT\\n            };\\n\\n            try {\\n                this._conference.broadcastEndpointMessage({\\n                    type: STATS_MESSAGE_TYPE,\\n                    values: data });\\n            } catch (e) {\\n                // We often hit this in the beginning of a call, before the data\\n                // channel is ready. It is not a big problem, because we will\\n                // send the statistics again after a few seconds, and the error is\\n                // already logged elsewhere. So just ignore it.\\n\\n                // let errorMsg = \\\"Failed to broadcast local stats\\\";\\n                // logger.error(errorMsg, e);\\n                // GlobalOnErrorHandler.callErrorHandler(\\n                //    new Error(errorMsg + \\\": \\\" + e));\\n            }\\n        }\\n\\n        /**\\n         * Updates the local statistics\\n         * @param {TraceablePeerConnection} tpc the peerconnection which emitted\\n         * the stats\\n         * @param data new statistics\\n         */\\n\\n    }, {\\n        key: '_updateLocalStats',\\n        value: function _updateLocalStats(tpc, data) {\\n            // Update jvbRTT\\n            if (!tpc.isP2P) {\\n                var jvbRTT = data.transport && data.transport.length && data.transport[0].rtt;\\n\\n                this._localStats.jvbRTT = jvbRTT ? jvbRTT : undefined;\\n            }\\n\\n            // Do not continue with processing of other stats if they do not\\n            // originate from the active peerconnection\\n            if (tpc !== this._conference.getActivePeerConnection()) {\\n                return;\\n            }\\n\\n            var key = void 0;\\n            var updateLocalConnectionQuality = !this._conference.isConnectionInterrupted();\\n            var localVideoTrack = this._conference.getLocalVideoTrack();\\n            var videoType = localVideoTrack ? localVideoTrack.videoType : undefined;\\n            var isMuted = localVideoTrack ? localVideoTrack.isMuted() : true;\\n            var resolution = localVideoTrack ? localVideoTrack.resolution : null;\\n\\n            if (!isMuted) {\\n                this._maybeUpdateUnmuteTime();\\n            }\\n\\n            // Copy the fields already in 'data'.\\n            for (key in data) {\\n                if (data.hasOwnProperty(key)) {\\n                    this._localStats[key] = data[key];\\n                }\\n            }\\n\\n            // And re-calculate the connectionQuality field.\\n            if (updateLocalConnectionQuality) {\\n                this._updateLocalConnectionQuality(this._calculateConnectionQuality(videoType, isMuted, resolution));\\n            }\\n\\n            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_0__service_connectivity_ConnectionQualityEvents__[\\\"LOCAL_STATS_UPDATED\\\"], this._localStats);\\n            this._broadcastLocalStats();\\n        }\\n\\n        /**\\n         * Updates remote statistics\\n         * @param id the id of the remote participant\\n         * @param data the statistics received\\n         */\\n\\n    }, {\\n        key: '_updateRemoteStats',\\n        value: function _updateRemoteStats(id, data) {\\n            // Use only the fields we need\\n            this._remoteStats[id] = {\\n                bitrate: data.bitrate,\\n                packetLoss: data.packetLoss,\\n                connectionQuality: data.connectionQuality,\\n                jvbRTT: data.jvbRTT\\n            };\\n\\n            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_0__service_connectivity_ConnectionQualityEvents__[\\\"REMOTE_STATS_UPDATED\\\"], id, this._remoteStats[id]);\\n        }\\n\\n        /**\\n         * Returns the local statistics.\\n         * Exported only for use in jitsi-meet-torture.\\n         */\\n\\n    }, {\\n        key: 'getStats',\\n        value: function getStats() {\\n            return this._localStats;\\n        }\\n    }]);\\n\\n    return ConnectionQuality;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (ConnectionQuality);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/connectivity/ConnectionQuality.js\\\"))\\n\\n/***/ }),\\n/* 95 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = authenticateAndUpgradeRole;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__JitsiConnectionEvents__ = __webpack_require__(26);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__modules_xmpp_xmpp__ = __webpack_require__(45);\\n\\n\\n\\n/**\\n * @typedef {Object} UpgradeRoleError\\n *\\n * @property {JitsiConnectionErrors} [connectionError] - One of\\n * {@link JitsiConnectionErrors} which occurred when trying to connect to the\\n * XMPP server.\\n * @property {String} [authenticationError] - One of XMPP error conditions\\n * returned by Jicofo on authentication attempt. See\\n * {@link https://xmpp.org/rfcs/rfc3920.html#streams-error}.\\n * @property {String} [message] - More details about the error.\\n * @property {Object} [credentials] - The credentials that failed the\\n * authentication.\\n * @property {String} [credentials.jid] - The XMPP ID part of the credentials\\n * that failed the authentication.\\n * @property {string} [credentials.password] - The password part of the\\n * credentials that failed the authentication.\\n *\\n * NOTE If neither one of the errors is present, then the operation has been\\n * canceled.\\n */\\n\\n/* eslint-disable no-invalid-this */\\n\\n/**\\n * Connects to the XMPP server using the specified credentials and contacts\\n * Jicofo in order to obtain a session ID (which is then stored in the local\\n * storage). The user's role of the parent conference will be upgraded to\\n * moderator (by Jicofo). It's also used to join the conference when starting\\n * from anonymous domain and only authenticated users are allowed to create new\\n * rooms.\\n *\\n * @param {Object} options\\n * @param {string} options.id - XMPP user's ID to log in. For example,\\n * user@xmpp-server.com.\\n * @param {string} options.password - XMPP user's password to log in with.\\n * @param {string} [options.roomPassword] - The password to join the MUC with.\\n * @param {Function} [options.onLoginSuccessful] - Callback called when logging\\n * into the XMPP server was successful. The next step will be to obtain a new\\n * session ID from Jicofo and join the MUC using it which will effectively\\n * upgrade the user's role to moderator.\\n * @returns {Object} A <tt>thenable</tt> which (1) settles when the process of\\n * authenticating and upgrading the role of the specified XMPP user finishes and\\n * (2) has a <tt>cancel</tt> method that allows the caller to interrupt the\\n * process. If the process finishes successfully, the session ID has been stored\\n * in the settings and the <tt>thenable</tt> is resolved. If the process\\n * finishes with failure, the <tt>thenable</tt> is rejected with reason of type\\n * {@link UpgradeRoleError} which will have either <tt>connectionError</tt> or\\n * <tt>authenticationError</tt> property set depending on which of the steps has\\n * failed. If <tt>cancel</tt> is called before the process finishes, then the\\n * thenable will be rejected with an empty object (i.e. no error property will\\n * be set on the rejection reason).\\n */\\nfunction authenticateAndUpgradeRole(_ref) {\\n    var _this = this;\\n\\n    var id = _ref.id,\\n        password = _ref.password,\\n        onLoginSuccessful = _ref.onLoginSuccessful,\\n        roomPassword = _ref.roomPassword;\\n\\n    var canceled = false;\\n    var rejectPromise = void 0;\\n    var xmpp = new __WEBPACK_IMPORTED_MODULE_1__modules_xmpp_xmpp__[\\\"a\\\" /* default */](this.connection.options);\\n\\n    var process = new Promise(function (resolve, reject) {\\n        // The process is represented by a Thenable with a cancel method. The\\n        // Thenable is implemented using Promise and the cancel using the\\n        // Promise's reject function.\\n        rejectPromise = reject;\\n\\n        xmpp.addListener(__WEBPACK_IMPORTED_MODULE_0__JitsiConnectionEvents__[\\\"CONNECTION_DISCONNECTED\\\"], function () {\\n            xmpp = undefined;\\n        });\\n        xmpp.addListener(__WEBPACK_IMPORTED_MODULE_0__JitsiConnectionEvents__[\\\"CONNECTION_ESTABLISHED\\\"], function () {\\n            if (canceled) {\\n                return;\\n            }\\n\\n            // Let the caller know that the XMPP login was successful.\\n            onLoginSuccessful && onLoginSuccessful();\\n\\n            // Now authenticate with Jicofo and get a new session ID.\\n            var room = xmpp.createRoom(_this.options.name, _this.options.config);\\n\\n            room.moderator.authenticate().then(function () {\\n                xmpp && xmpp.disconnect();\\n\\n                if (canceled) {\\n                    return;\\n                }\\n\\n                // At this point we should have the new session ID\\n                // stored in the settings. Jicofo will allow to join the\\n                // room.\\n                _this.join(roomPassword);\\n\\n                resolve();\\n            }).catch(function (_ref2) {\\n                var error = _ref2.error,\\n                    message = _ref2.message;\\n\\n                xmpp.disconnect();\\n\\n                reject({\\n                    authenticationError: error,\\n                    message: message\\n                });\\n            });\\n        });\\n        xmpp.addListener(__WEBPACK_IMPORTED_MODULE_0__JitsiConnectionEvents__[\\\"CONNECTION_FAILED\\\"], function (connectionError, message, credentials) {\\n            reject({\\n                connectionError: connectionError,\\n                credentials: credentials,\\n                message: message\\n            });\\n            xmpp = undefined;\\n        });\\n\\n        canceled || xmpp.connect(id, password);\\n    });\\n\\n    /**\\n     * Cancels the process, if it's in progress, of authenticating and upgrading\\n     * the role of the local participant/user.\\n     *\\n     * @public\\n     * @returns {void}\\n     */\\n    process.cancel = function () {\\n        canceled = true;\\n        rejectPromise({});\\n        xmpp && xmpp.disconnect();\\n    };\\n\\n    return process;\\n}\\n\\n/* eslint-enable no-invalid-this */\\n\\n/***/ }),\\n/* 96 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n(function (global, factory) {\\n\\t true ? factory(__webpack_require__(2)) :\\n\\ttypeof define === 'function' && define.amd ? define(['strophe.js'], factory) :\\n\\t(factory(global.window));\\n}(this, (function (strophe_js) { 'use strict';\\n\\nstrophe_js.Strophe.addConnectionPlugin('disco',\\n{\\n    _connection: null,\\n    _identities : [],\\n    _features : [],\\n    _items : [],\\n    /** Function: init\\n     * Plugin init\\n     *\\n     * Parameters:\\n     *   (Strophe.Connection) conn - Strophe connection\\n     */\\n    init: function(conn)\\n    {\\n    this._connection = conn;\\n        this._identities = [];\\n        this._features   = [];\\n        this._items      = [];\\n        // disco info\\n        conn.addHandler(this._onDiscoInfo.bind(this), strophe_js.Strophe.NS.DISCO_INFO, 'iq', 'get', null, null);\\n        // disco items\\n        conn.addHandler(this._onDiscoItems.bind(this), strophe_js.Strophe.NS.DISCO_ITEMS, 'iq', 'get', null, null);\\n    },\\n    /** Function: addIdentity\\n     * See http://xmpp.org/registrar/disco-categories.html\\n     * Parameters:\\n     *   (String) category - category of identity (like client, automation, etc ...)\\n     *   (String) type - type of identity (like pc, web, bot , etc ...)\\n     *   (String) name - name of identity in natural language\\n     *   (String) lang - lang of name parameter\\n     *\\n     * Returns:\\n     *   Boolean\\n     */\\n    addIdentity: function(category, type, name, lang)\\n    {\\n        for (var i=0; i<this._identities.length; i++)\\n        {\\n            if (this._identities[i].category == category &&\\n                this._identities[i].type == type &&\\n                this._identities[i].name == name &&\\n                this._identities[i].lang == lang)\\n            {\\n                return false;\\n            }\\n        }\\n        this._identities.push({category: category, type: type, name: name, lang: lang});\\n        return true;\\n    },\\n    /** Function: addFeature\\n     *\\n     * Parameters:\\n     *   (String) var_name - feature name (like jabber:iq:version)\\n     *\\n     * Returns:\\n     *   boolean\\n     */\\n    addFeature: function(var_name)\\n    {\\n        for (var i=0; i<this._features.length; i++)\\n        {\\n             if (this._features[i] == var_name)\\n                 return false;\\n        }\\n        this._features.push(var_name);\\n        return true;\\n    },\\n    /** Function: removeFeature\\n     *\\n     * Parameters:\\n     *   (String) var_name - feature name (like jabber:iq:version)\\n     *\\n     * Returns:\\n     *   boolean\\n     */\\n    removeFeature: function(var_name)\\n    {\\n        for (var i=0; i<this._features.length; i++)\\n        {\\n             if (this._features[i] === var_name){\\n                 this._features.splice(i,1);\\n                 return true;\\n             }\\n        }\\n        return false;\\n    },\\n    /** Function: addItem\\n     *\\n     * Parameters:\\n     *   (String) jid\\n     *   (String) name\\n     *   (String) node\\n     *   (Function) call_back\\n     *\\n     * Returns:\\n     *   boolean\\n     */\\n    addItem: function(jid, name, node, call_back)\\n    {\\n        if (node && !call_back)\\n            return false;\\n        this._items.push({jid: jid, name: name, node: node, call_back: call_back});\\n        return true;\\n    },\\n    /** Function: info\\n     * Info query\\n     *\\n     * Parameters:\\n     *   (Function) call_back\\n     *   (String) jid\\n     *   (String) node\\n     */\\n    info: function(jid, node, success, error, timeout)\\n    {\\n        var attrs = {xmlns: strophe_js.Strophe.NS.DISCO_INFO};\\n        if (node)\\n            attrs.node = node;\\n\\n        var info = strophe_js.$iq({from:this._connection.jid,\\n                         to:jid, type:'get'}).c('query', attrs);\\n        this._connection.sendIQ(info, success, error, timeout);\\n    },\\n    /** Function: items\\n     * Items query\\n     *\\n     * Parameters:\\n     *   (Function) call_back\\n     *   (String) jid\\n     *   (String) node\\n     */\\n    items: function(jid, node, success, error, timeout)\\n    {\\n        var attrs = {xmlns: strophe_js.Strophe.NS.DISCO_ITEMS};\\n        if (node)\\n            attrs.node = node;\\n\\n        var items = strophe_js.$iq({from:this._connection.jid,\\n                         to:jid, type:'get'}).c('query', attrs);\\n        this._connection.sendIQ(items, success, error, timeout);\\n    },\\n\\n    /** PrivateFunction: _buildIQResult\\n     */\\n    _buildIQResult: function(stanza, query_attrs)\\n    {\\n        var id   =  stanza.getAttribute('id');\\n        var from = stanza.getAttribute('from');\\n        var iqresult = strophe_js.$iq({type: 'result', id: id});\\n\\n        if (from !== null) {\\n            iqresult.attrs({to: from});\\n        }\\n\\n        return iqresult.c('query', query_attrs);\\n    },\\n\\n    /** PrivateFunction: _onDiscoInfo\\n     * Called when receive info request\\n     */\\n    _onDiscoInfo: function(stanza)\\n    {\\n        var node = stanza.getElementsByTagName('query')[0].getAttribute('node');\\n        var attrs = {xmlns: strophe_js.Strophe.NS.DISCO_INFO};\\n        var i;\\n        if (node)\\n        {\\n            attrs.node = node;\\n        }\\n        var iqresult = this._buildIQResult(stanza, attrs);\\n        for (i=0; i<this._identities.length; i++)\\n        {\\n            attrs = {category: this._identities[i].category,\\n                         type    : this._identities[i].type};\\n            if (this._identities[i].name)\\n                attrs.name = this._identities[i].name;\\n            if (this._identities[i].lang)\\n                attrs['xml:lang'] = this._identities[i].lang;\\n            iqresult.c('identity', attrs).up();\\n        }\\n        for (i=0; i<this._features.length; i++)\\n        {\\n            iqresult.c('feature', {'var':this._features[i]}).up();\\n        }\\n        this._connection.send(iqresult.tree());\\n        return true;\\n    },\\n    /** PrivateFunction: _onDiscoItems\\n     * Called when receive items request\\n     */\\n    _onDiscoItems: function(stanza)\\n    {\\n        var query_attrs = {xmlns: strophe_js.Strophe.NS.DISCO_ITEMS};\\n        var node = stanza.getElementsByTagName('query')[0].getAttribute('node');\\n        var items, i;\\n        if (node)\\n        {\\n            query_attrs.node = node;\\n            items = [];\\n            for (i = 0; i < this._items.length; i++)\\n            {\\n                if (this._items[i].node == node)\\n                {\\n                    items = this._items[i].call_back(stanza);\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            items = this._items;\\n        }\\n        var iqresult = this._buildIQResult(stanza, query_attrs);\\n        for (i = 0; i < items.length; i++)\\n        {\\n            var attrs = {jid:  items[i].jid};\\n            if (items[i].name)\\n                attrs.name = items[i].name;\\n            if (items[i].node)\\n                attrs.node = items[i].node;\\n            iqresult.c('item', attrs).up();\\n        }\\n        this._connection.send(iqresult.tree());\\n        return true;\\n    }\\n});\\n\\n})));\\n//# sourceMappingURL=strophe.disco.js.map\\n\\n\\n/***/ }),\\n/* 97 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ChatRoom__ = __webpack_require__(98);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ConnectionPlugin__ = __webpack_require__(23);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__service_xmpp_XMPPEvents__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__service_xmpp_XMPPEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__service_xmpp_XMPPEvents__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\\\"value\\\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global $ */\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * MUC connection plugin.\\n */\\n\\nvar MucConnectionPlugin = function (_ConnectionPluginList) {\\n    _inherits(MucConnectionPlugin, _ConnectionPluginList);\\n\\n    /**\\n     *\\n     * @param xmpp\\n     */\\n    function MucConnectionPlugin(xmpp) {\\n        _classCallCheck(this, MucConnectionPlugin);\\n\\n        var _this = _possibleConstructorReturn(this, (MucConnectionPlugin.__proto__ || Object.getPrototypeOf(MucConnectionPlugin)).call(this));\\n\\n        _this.xmpp = xmpp;\\n        _this.rooms = {};\\n        return _this;\\n    }\\n\\n    /**\\n     *\\n     * @param connection\\n     */\\n\\n\\n    _createClass(MucConnectionPlugin, [{\\n        key: 'init',\\n        value: function init(connection) {\\n            _get(MucConnectionPlugin.prototype.__proto__ || Object.getPrototypeOf(MucConnectionPlugin.prototype), 'init', this).call(this, connection);\\n\\n            // add handlers (just once)\\n            this.connection.addHandler(this.onPresence.bind(this), null, 'presence', null, null, null, null);\\n            this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, 'presence', 'unavailable', null);\\n            this.connection.addHandler(this.onPresenceError.bind(this), null, 'presence', 'error', null);\\n            this.connection.addHandler(this.onMessage.bind(this), null, 'message', null, null);\\n            this.connection.addHandler(this.onMute.bind(this), 'http://jitsi.org/jitmeet/audio', 'iq', 'set', null, null);\\n        }\\n\\n        /**\\n         *\\n         * @param jid\\n         * @param password\\n         * @param options\\n         */\\n\\n    }, {\\n        key: 'createRoom',\\n        value: function createRoom(jid, password, options) {\\n            var roomJid = __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getBareJidFromJid(jid);\\n\\n            if (this.rooms[roomJid]) {\\n                var errmsg = 'You are already in the room!';\\n\\n                logger.error(errmsg);\\n                throw new Error(errmsg);\\n            }\\n            this.rooms[roomJid] = new __WEBPACK_IMPORTED_MODULE_2__ChatRoom__[\\\"a\\\" /* default */](this.connection, jid, password, this.xmpp, options);\\n            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_4__service_xmpp_XMPPEvents___default.a.EMUC_ROOM_ADDED, this.rooms[roomJid]);\\n\\n            return this.rooms[roomJid];\\n        }\\n\\n        /**\\n         *\\n         * @param jid\\n         */\\n\\n    }, {\\n        key: 'doLeave',\\n        value: function doLeave(jid) {\\n            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_4__service_xmpp_XMPPEvents___default.a.EMUC_ROOM_REMOVED, this.rooms[jid]);\\n            delete this.rooms[jid];\\n        }\\n\\n        /**\\n         *\\n         * @param pres\\n         */\\n\\n    }, {\\n        key: 'onPresence',\\n        value: function onPresence(pres) {\\n            var from = pres.getAttribute('from');\\n\\n            // What is this for? A workaround for something?\\n            if (pres.getAttribute('type')) {\\n                return true;\\n            }\\n\\n            var room = this.rooms[__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getBareJidFromJid(from)];\\n\\n            if (!room) {\\n                return;\\n            }\\n\\n            // Parse status.\\n            if ($(pres).find('>x[xmlns=\\\"http://jabber.org/protocol/muc#user\\\"]' + '>status[code=\\\"201\\\"]').length) {\\n                room.createNonAnonymousRoom();\\n            }\\n\\n            room.onPresence(pres);\\n\\n            return true;\\n        }\\n\\n        /**\\n         *\\n         * @param pres\\n         */\\n\\n    }, {\\n        key: 'onPresenceUnavailable',\\n        value: function onPresenceUnavailable(pres) {\\n            var from = pres.getAttribute('from');\\n            var room = this.rooms[__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getBareJidFromJid(from)];\\n\\n            if (!room) {\\n                return;\\n            }\\n\\n            room.onPresenceUnavailable(pres, from);\\n\\n            return true;\\n        }\\n\\n        /**\\n         *\\n         * @param pres\\n         */\\n\\n    }, {\\n        key: 'onPresenceError',\\n        value: function onPresenceError(pres) {\\n            var from = pres.getAttribute('from');\\n            var room = this.rooms[__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getBareJidFromJid(from)];\\n\\n            if (!room) {\\n                return;\\n            }\\n\\n            room.onPresenceError(pres, from);\\n\\n            return true;\\n        }\\n\\n        /**\\n         *\\n         * @param msg\\n         */\\n\\n    }, {\\n        key: 'onMessage',\\n        value: function onMessage(msg) {\\n            // FIXME: this is a hack. but jingle on muc makes nickchanges hard\\n            var from = msg.getAttribute('from');\\n            var room = this.rooms[__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getBareJidFromJid(from)];\\n\\n            if (!room) {\\n                return;\\n            }\\n\\n            room.onMessage(msg, from);\\n\\n            return true;\\n        }\\n\\n        /**\\n         *\\n         * @param iq\\n         */\\n\\n    }, {\\n        key: 'onMute',\\n        value: function onMute(iq) {\\n            var from = iq.getAttribute('from');\\n            var room = this.rooms[__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getBareJidFromJid(from)];\\n\\n            if (!room) {\\n                return;\\n            }\\n\\n            room.onMute(iq);\\n\\n            return true;\\n        }\\n    }]);\\n\\n    return MucConnectionPlugin;\\n}(__WEBPACK_IMPORTED_MODULE_3__ConnectionPlugin__[\\\"a\\\" /* ConnectionPluginListenable */]);\\n\\n/**\\n *\\n * @param XMPP\\n */\\n\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (function (XMPP) {\\n    __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].addConnectionPlugin('emuc', new MucConnectionPlugin(XMPP));\\n});\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/strophe.emuc.js\\\"))\\n\\n/***/ }),\\n/* 98 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__JitsiTranscriptionStatus__ = __webpack_require__(47);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_Listenable__ = __webpack_require__(10);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__settings_Settings__ = __webpack_require__(19);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__moderator__ = __webpack_require__(99);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__recording__ = __webpack_require__(49);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global $, __filename */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\nvar parser = {\\n    packet2JSON: function packet2JSON(packet, nodes) {\\n        var self = this;\\n\\n        // eslint-disable-next-line newline-per-chained-call\\n        $(packet).children().each(function () {\\n            // eslint-disable-next-line no-invalid-this\\n            var tagName = $(this).prop('tagName');\\n            var node = {\\n                tagName: tagName\\n            };\\n\\n            node.attributes = {};\\n\\n            // eslint-disable-next-line no-invalid-this\\n            $($(this)[0].attributes).each(function (index, attr) {\\n                node.attributes[attr.name] = attr.value;\\n            });\\n\\n            // eslint-disable-next-line no-invalid-this\\n            var text = __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getText($(this)[0]);\\n\\n            if (text) {\\n                node.value = text;\\n            }\\n            node.children = [];\\n            nodes.push(node);\\n\\n            // eslint-disable-next-line no-invalid-this\\n            self.packet2JSON($(this), node.children);\\n        });\\n    },\\n    json2packet: function json2packet(nodes, packet) {\\n        for (var i = 0; i < nodes.length; i++) {\\n            var node = nodes[i];\\n\\n            if (node) {\\n                packet.c(node.tagName, node.attributes);\\n                if (node.value) {\\n                    packet.t(node.value);\\n                }\\n                if (node.children) {\\n                    this.json2packet(node.children, packet);\\n                }\\n                packet.up();\\n            }\\n        }\\n\\n        // packet.up();\\n    }\\n};\\n\\n/**\\n * Returns array of JS objects from the presence JSON associated with the passed\\n / nodeName\\n * @param pres the presence JSON\\n * @param nodeName the name of the node (videomuted, audiomuted, etc)\\n */\\nfunction filterNodeFromPresenceJSON(pres, nodeName) {\\n    var res = [];\\n\\n    for (var i = 0; i < pres.length; i++) {\\n        if (pres[i].tagName === nodeName) {\\n            res.push(pres[i]);\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n/**\\n * Constants used to verify if a given JSON message via the MUC should be\\n * considered as a ENDPOINT_MESSAGE\\n */\\nvar VALID_FIELD_NAMES = ['jitsi-meet-muc-msg-topic', 'payload'];\\n\\n/**\\n * Check if the given argument is a valid JSON ENDPOINT_MESSAGE string by\\n * parsing it and checking if it has a field called 'jitsi-meet-muc-msg-topic'\\n * and a field called 'payload'\\n *\\n * @param {string} jsonString check if this string is a valid json string\\n * and contains the special structure\\n * @returns {boolean, object} if given object is a valid JSON string, return\\n * the json object. Otherwise, return false;\\n */\\nfunction tryParseJSONAndVerify(jsonString) {\\n    try {\\n        var json = JSON.parse(jsonString);\\n\\n        // Handle non-exception-throwing cases:\\n        // Neither JSON.parse(false) or JSON.parse(1234) throw errors,\\n        // hence the type-checking,\\n        // but... JSON.parse(null) returns null, and\\n        // typeof null === \\\"object\\\",\\n        // so we must check for that, too.\\n        // Thankfully, null is falsey, so this suffices:\\n        if (json && (typeof json === 'undefined' ? 'undefined' : _typeof(json)) === 'object') {\\n            var topic = json[VALID_FIELD_NAMES[0]];\\n            var payload = json[VALID_FIELD_NAMES[1]];\\n\\n            if ((typeof topic === 'string' || topic instanceof String) && payload) {\\n\\n                return json;\\n            }\\n\\n            logger.debug('parsing valid json but does not have correct ' + 'structure', 'topic: ', topic, 'payload: ', payload);\\n        }\\n    } catch (e) {\\n\\n        return false;\\n    }\\n\\n    return false;\\n}\\n\\n// XXX As ChatRoom constructs XMPP stanzas and Strophe is build around the idea\\n// of chaining function calls, allow long function call chains.\\n/* eslint-disable newline-per-chained-call */\\n\\n/**\\n *\\n */\\n\\nvar ChatRoom = function (_Listenable) {\\n    _inherits(ChatRoom, _Listenable);\\n\\n    /* eslint-disable max-params */\\n\\n    /**\\n     *\\n     * @param connection\\n     * @param jid\\n     * @param password\\n     * @param XMPP\\n     * @param options\\n     */\\n    function ChatRoom(connection, jid, password, XMPP, options) {\\n        _classCallCheck(this, ChatRoom);\\n\\n        var _this = _possibleConstructorReturn(this, (ChatRoom.__proto__ || Object.getPrototypeOf(ChatRoom)).call(this));\\n\\n        _this.xmpp = XMPP;\\n        _this.connection = connection;\\n        _this.roomjid = __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getBareJidFromJid(jid);\\n        _this.myroomjid = jid;\\n        _this.password = password;\\n        logger.info('Joined MUC as ' + _this.myroomjid);\\n        _this.members = {};\\n        _this.presMap = {};\\n        _this.presHandlers = {};\\n        _this.joined = false;\\n        _this.role = null;\\n        _this.focusMucJid = null;\\n        _this.noBridgeAvailable = false;\\n        _this.options = options || {};\\n        _this.moderator = new __WEBPACK_IMPORTED_MODULE_8__moderator__[\\\"a\\\" /* default */](_this.roomjid, _this.xmpp, _this.eventEmitter, {\\n            connection: _this.xmpp.options,\\n            conference: _this.options\\n        });\\n        _this.initPresenceMap(options);\\n        _this.lastPresences = {};\\n        _this.phoneNumber = null;\\n        _this.phonePin = null;\\n        _this.connectionTimes = {};\\n        _this.participantPropertyListener = null;\\n\\n        _this.locked = false;\\n        _this.transcriptionStatus = __WEBPACK_IMPORTED_MODULE_3__JitsiTranscriptionStatus__[\\\"OFF\\\"];\\n        return _this;\\n    }\\n\\n    /* eslint-enable max-params */\\n\\n    /**\\n     *\\n     */\\n\\n\\n    _createClass(ChatRoom, [{\\n        key: 'initPresenceMap',\\n        value: function initPresenceMap() {\\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n            this.presMap.to = this.myroomjid;\\n            this.presMap.xns = 'http://jabber.org/protocol/muc';\\n            this.presMap.nodes = [];\\n            this.presMap.nodes.push({\\n                'tagName': 'user-agent',\\n                'value': navigator.userAgent,\\n                'attributes': { xmlns: 'http://jitsi.org/jitmeet/user-agent' }\\n            });\\n\\n            if (options.enableStatsID) {\\n                this.presMap.nodes.push({\\n                    'tagName': 'stats-id',\\n                    'value': __WEBPACK_IMPORTED_MODULE_5__settings_Settings__[\\\"a\\\" /* default */].callStatsUserName\\n                });\\n            }\\n\\n            // We need to broadcast 'videomuted' status from the beginning, cause\\n            // Jicofo makes decisions based on that. Initialize it with 'false'\\n            // here.\\n            this.addVideoInfoToPresence(false);\\n\\n            if (options.deploymentInfo && options.deploymentInfo.userRegion) {\\n                this.presMap.nodes.push({\\n                    'tagName': 'region',\\n                    'attributes': {\\n                        id: options.deploymentInfo.userRegion,\\n                        xmlns: 'http://jitsi.org/jitsi-meet'\\n                    }\\n                });\\n            }\\n        }\\n\\n        /**\\n         *\\n         * @param devices\\n         */\\n\\n    }, {\\n        key: 'updateDeviceAvailability',\\n        value: function updateDeviceAvailability(devices) {\\n            this.presMap.nodes.push({\\n                'tagName': 'devices',\\n                'children': [{\\n                    'tagName': 'audio',\\n                    'value': devices.audio\\n                }, {\\n                    'tagName': 'video',\\n                    'value': devices.video\\n                }]\\n            });\\n        }\\n\\n        /**\\n         *\\n         * @param password\\n         */\\n\\n    }, {\\n        key: 'join',\\n        value: function join(password) {\\n            var _this2 = this;\\n\\n            this.password = password;\\n            this.moderator.allocateConferenceFocus(function () {\\n                return _this2.sendPresence(true);\\n            });\\n        }\\n\\n        /**\\n         *\\n         * @param fromJoin\\n         */\\n\\n    }, {\\n        key: 'sendPresence',\\n        value: function sendPresence(fromJoin) {\\n            var to = this.presMap.to;\\n\\n            if (!to || !this.joined && !fromJoin) {\\n                // Too early to send presence - not initialized\\n                return;\\n            }\\n\\n            var pres = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$pres\\\"])({ to: to });\\n\\n            // xep-0045 defines: \\\"including in the initial presence stanza an empty\\n            // <x/> element qualified by the 'http://jabber.org/protocol/muc'\\n            // namespace\\\" and subsequent presences should not include that or it can\\n            // be considered as joining, and server can send us the message history\\n            // for the room on every presence\\n            if (fromJoin) {\\n                pres.c('x', { xmlns: this.presMap.xns });\\n\\n                if (this.password) {\\n                    pres.c('password').t(this.password).up();\\n                }\\n                pres.up();\\n            }\\n\\n            parser.json2packet(this.presMap.nodes, pres);\\n            this.connection.send(pres);\\n            if (fromJoin) {\\n                // XXX We're pressed for time here because we're beginning a complex\\n                // and/or lengthy conference-establishment process which supposedly\\n                // involves multiple RTTs. We don't have the time to wait for\\n                // Strophe to decide to send our IQ.\\n                this.connection.flush();\\n            }\\n        }\\n\\n        /**\\n         * Sends the presence unavailable, signaling the server\\n         * we want to leave the room.\\n         */\\n\\n    }, {\\n        key: 'doLeave',\\n        value: function doLeave() {\\n            logger.log('do leave', this.myroomjid);\\n            var pres = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$pres\\\"])({ to: this.myroomjid,\\n                type: 'unavailable' });\\n\\n            this.presMap.length = 0;\\n\\n            // XXX Strophe is asynchronously sending by default. Unfortunately, that\\n            // means that there may not be enough time to send the unavailable\\n            // presence. Switching Strophe to synchronous sending is not much of an\\n            // option because it may lead to a noticeable delay in navigating away\\n            // from the current location. As a compromise, we will try to increase\\n            // the chances of sending the unavailable presence within the short time\\n            // span that we have upon unloading by invoking flush() on the\\n            // connection. We flush() once before sending/queuing the unavailable\\n            // presence in order to attemtp to have the unavailable presence at the\\n            // top of the send queue. We flush() once more after sending/queuing the\\n            // unavailable presence in order to attempt to have it sent as soon as\\n            // possible.\\n            this.connection.flush();\\n            this.connection.send(pres);\\n            this.connection.flush();\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'discoRoomInfo',\\n        value: function discoRoomInfo() {\\n            var _this3 = this;\\n\\n            // https://xmpp.org/extensions/xep-0045.html#disco-roominfo\\n\\n            var getInfo = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({\\n                type: 'get',\\n                to: this.roomjid\\n            }).c('query', { xmlns: __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].NS.DISCO_INFO });\\n\\n            this.connection.sendIQ(getInfo, function (result) {\\n                var locked = $(result).find('>query>feature[var=\\\"muc_passwordprotected\\\"]').length === 1;\\n\\n                if (locked !== _this3.locked) {\\n                    _this3.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.MUC_LOCK_CHANGED, locked);\\n                    _this3.locked = locked;\\n                }\\n            }, function (error) {\\n                __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default.a.callErrorHandler(error);\\n                logger.error('Error getting room info: ', error);\\n            });\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'createNonAnonymousRoom',\\n        value: function createNonAnonymousRoom() {\\n            // http://xmpp.org/extensions/xep-0045.html#createroom-reserved\\n\\n            var getForm = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({ type: 'get',\\n                to: this.roomjid }).c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' }).c('x', { xmlns: 'jabber:x:data',\\n                type: 'submit' });\\n\\n            var self = this;\\n\\n            this.connection.sendIQ(getForm, function (form) {\\n                if (!$(form).find('>query>x[xmlns=\\\"jabber:x:data\\\"]' + '>field[var=\\\"muc#roomconfig_whois\\\"]').length) {\\n                    var errmsg = 'non-anonymous rooms not supported';\\n\\n                    __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default.a.callErrorHandler(new Error(errmsg));\\n                    logger.error(errmsg);\\n\\n                    return;\\n                }\\n\\n                var formSubmit = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({ to: self.roomjid,\\n                    type: 'set' }).c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' });\\n\\n                formSubmit.c('x', { xmlns: 'jabber:x:data',\\n                    type: 'submit' });\\n\\n                formSubmit.c('field', { 'var': 'FORM_TYPE' }).c('value').t('http://jabber.org/protocol/muc#roomconfig').up().up();\\n\\n                formSubmit.c('field', { 'var': 'muc#roomconfig_whois' }).c('value').t('anyone').up().up();\\n\\n                self.connection.sendIQ(formSubmit);\\n            }, function (error) {\\n                __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default.a.callErrorHandler(error);\\n                logger.error('Error getting room configuration form: ', error);\\n            });\\n        }\\n\\n        /**\\n         *\\n         * @param pres\\n         */\\n\\n    }, {\\n        key: 'onPresence',\\n        value: function onPresence(pres) {\\n            var from = pres.getAttribute('from');\\n\\n            // Parse roles.\\n            var member = {};\\n\\n            member.show = $(pres).find('>show').text();\\n            var $statusNode = $(pres).find('>status');\\n            var hasStatus = $statusNode.length;\\n\\n            if (hasStatus) {\\n                member.status = $statusNode.text();\\n            }\\n            var hasStatusUpdate = false;\\n\\n            var mucUserItem = $(pres).find('>x[xmlns=\\\"http://jabber.org/protocol/muc#user\\\"]>item');\\n\\n            member.affiliation = mucUserItem.attr('affiliation');\\n            member.role = mucUserItem.attr('role');\\n\\n            // Focus recognition\\n            var jid = mucUserItem.attr('jid');\\n\\n            member.jid = jid;\\n            member.isFocus = jid && jid.indexOf(this.moderator.getFocusUserJid() + '/') === 0;\\n            member.isHiddenDomain = jid && jid.indexOf('@') > 0 && this.options.hiddenDomain === jid.substring(jid.indexOf('@') + 1, jid.indexOf('/'));\\n\\n            $(pres).find('>x').remove();\\n            var nodes = [];\\n\\n            parser.packet2JSON(pres, nodes);\\n            this.lastPresences[from] = nodes;\\n            var jibri = null;\\n\\n            // process nodes to extract data needed for MUC_JOINED and\\n            // MUC_MEMBER_JOINED events\\n\\n            for (var i = 0; i < nodes.length; i++) {\\n                var node = nodes[i];\\n\\n                switch (node.tagName) {\\n                    case 'nick':\\n                        member.nick = node.value;\\n                        break;\\n                    case 'userId':\\n                        member.id = node.value;\\n                        break;\\n                    case 'stats-id':\\n                        member.statsID = node.value;\\n                        break;\\n                }\\n            }\\n\\n            if (from === this.myroomjid) {\\n                var newRole = member.affiliation === 'owner' ? member.role : 'none';\\n\\n                if (this.role !== newRole) {\\n                    this.role = newRole;\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.LOCAL_ROLE_CHANGED, this.role);\\n                }\\n                if (!this.joined) {\\n                    this.joined = true;\\n                    var now = this.connectionTimes['muc.joined'] = window.performance.now();\\n\\n                    logger.log('(TIME) MUC joined:\\\\t', now);\\n\\n                    // set correct initial state of locked\\n                    if (this.password) {\\n                        this.locked = true;\\n                    }\\n\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.MUC_JOINED);\\n                }\\n            } else if (this.members[from] === undefined) {\\n                // new participant\\n                this.members[from] = member;\\n                logger.log('entered', from, member);\\n                hasStatusUpdate = member.status !== undefined;\\n                if (member.isFocus) {\\n                    this._initFocus(from, jid);\\n                } else {\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.MUC_MEMBER_JOINED, from, member.nick, member.role, member.isHiddenDomain, member.statsID, member.status);\\n\\n                    // we are reporting the status with the join\\n                    // so we do not want a second event about status update\\n                    hasStatusUpdate = false;\\n                }\\n            } else {\\n                // Presence update for existing participant\\n                // Watch role change:\\n                var memberOfThis = this.members[from];\\n\\n                if (memberOfThis.role !== member.role) {\\n                    memberOfThis.role = member.role;\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.MUC_ROLE_CHANGED, from, member.role);\\n                }\\n\\n                if (member.isFocus) {\\n                    // From time to time first few presences of the focus are not\\n                    // containing it's jid. That way we can mark later the focus\\n                    // member instead of not marking it at all and not starting the\\n                    // conference.\\n                    // FIXME: Maybe there is a better way to handle this issue. It\\n                    // seems there is some period of time in prosody that the\\n                    // configuration form is received but not applied. And if any\\n                    // participant joins during that period of time the first\\n                    // presence from the focus won't conain <item jid=\\\"focus...\\\" />.\\n                    memberOfThis.isFocus = true;\\n                    this._initFocus(from, jid);\\n                }\\n\\n                // store the new display name\\n                if (member.displayName) {\\n                    memberOfThis.displayName = member.displayName;\\n                }\\n\\n                // update stored status message to be able to detect changes\\n                if (memberOfThis.status !== member.status) {\\n                    hasStatusUpdate = true;\\n                    memberOfThis.status = member.status;\\n                }\\n            }\\n\\n            // after we had fired member or room joined events, lets fire events\\n            // for the rest info we got in presence\\n            for (var _i = 0; _i < nodes.length; _i++) {\\n                var _node = nodes[_i];\\n\\n                switch (_node.tagName) {\\n                    case 'nick':\\n                        if (!member.isFocus) {\\n                            var displayName = this.xmpp.options.displayJids ? __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(from) : member.nick;\\n\\n                            if (displayName && displayName.length > 0) {\\n                                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.DISPLAY_NAME_CHANGED, from, displayName);\\n                            }\\n                        }\\n                        break;\\n                    case 'bridgeNotAvailable':\\n                        if (member.isFocus && !this.noBridgeAvailable) {\\n                            this.noBridgeAvailable = true;\\n                            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.BRIDGE_DOWN);\\n                        }\\n                        break;\\n                    case 'jibri-recording-status':\\n                        jibri = _node;\\n                        break;\\n                    case 'transcription-status':\\n                        {\\n                            var attributes = _node.attributes;\\n\\n\\n                            if (!attributes) {\\n                                break;\\n                            }\\n\\n                            var status = attributes.status;\\n\\n\\n                            if (status && status !== this.transcriptionStatus) {\\n                                this.transcriptionStatus = status;\\n                                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.TRANSCRIPTION_STATUS_CHANGED, status);\\n                            }\\n\\n                            break;\\n                        }\\n                    case 'call-control':\\n                        {\\n                            var att = _node.attributes;\\n\\n                            if (!att) {\\n                                break;\\n                            }\\n                            this.phoneNumber = att.phone || null;\\n                            this.phonePin = att.pin || null;\\n                            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.PHONE_NUMBER_CHANGED);\\n                            break;\\n                        }\\n                    default:\\n                        this.processNode(_node, from);\\n                }\\n            }\\n\\n            // Trigger status message update if necessary\\n            if (hasStatusUpdate) {\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.PRESENCE_STATUS, from, member.status);\\n            }\\n\\n            if (jibri) {\\n                this.lastJibri = jibri;\\n                if (this.recording) {\\n                    this.recording.handleJibriPresence(jibri);\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Initialize some properties when the focus participant is verified.\\n         * @param from jid of the focus\\n         * @param mucJid the jid of the focus in the muc\\n         */\\n\\n    }, {\\n        key: '_initFocus',\\n        value: function _initFocus(from, mucJid) {\\n            this.focusMucJid = from;\\n            if (!this.recording) {\\n                this.recording = new __WEBPACK_IMPORTED_MODULE_9__recording__[\\\"a\\\" /* default */](this.options.recordingType, this.eventEmitter, this.connection, this.focusMucJid, this.options.jirecon, this.roomjid);\\n                if (this.lastJibri) {\\n                    this.recording.handleJibriPresence(this.lastJibri);\\n                }\\n            }\\n            logger.info('Ignore focus: ' + from + ', real JID: ' + mucJid);\\n        }\\n\\n        /**\\n         * Sets the special listener to be used for \\\"command\\\"s whose name starts\\n         * with \\\"jitsi_participant_\\\".\\n         */\\n\\n    }, {\\n        key: 'setParticipantPropertyListener',\\n        value: function setParticipantPropertyListener(listener) {\\n            this.participantPropertyListener = listener;\\n        }\\n\\n        /**\\n         *\\n         * @param node\\n         * @param from\\n         */\\n\\n    }, {\\n        key: 'processNode',\\n        value: function processNode(node, from) {\\n            // make sure we catch all errors coming from any handler\\n            // otherwise we can remove the presence handler from strophe\\n            try {\\n                var tagHandlers = this.presHandlers[node.tagName];\\n\\n                if (node.tagName.startsWith('jitsi_participant_')) {\\n                    tagHandlers = [this.participantPropertyListener];\\n                }\\n\\n                if (tagHandlers) {\\n                    tagHandlers.forEach(function (handler) {\\n                        handler(node, __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(from), from);\\n                    });\\n                }\\n            } catch (e) {\\n                __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default.a.callErrorHandler(e);\\n                logger.error('Error processing:' + node.tagName + ' node.', e);\\n            }\\n        }\\n\\n        /**\\n         *\\n         * @param body\\n         * @param nickname\\n         */\\n\\n    }, {\\n        key: 'sendMessage',\\n        value: function sendMessage(body, nickname) {\\n            var msg = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$msg\\\"])({ to: this.roomjid,\\n                type: 'groupchat' });\\n\\n            msg.c('body', body).up();\\n            if (nickname) {\\n                msg.c('nick', { xmlns: 'http://jabber.org/protocol/nick' }).t(nickname).up().up();\\n            }\\n            this.connection.send(msg);\\n            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.SENDING_CHAT_MESSAGE, body);\\n        }\\n\\n        /**\\n         *\\n         * @param subject\\n         */\\n\\n    }, {\\n        key: 'setSubject',\\n        value: function setSubject(subject) {\\n            var msg = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$msg\\\"])({ to: this.roomjid,\\n                type: 'groupchat' });\\n\\n            msg.c('subject', subject);\\n            this.connection.send(msg);\\n        }\\n\\n        /**\\n         * Called when participant leaves.\\n         * @param jid the jid of the participant that leaves\\n         * @param skipEvents optional params to skip any events, including check\\n         * whether this is the focus that left\\n         */\\n\\n    }, {\\n        key: 'onParticipantLeft',\\n        value: function onParticipantLeft(jid, skipEvents) {\\n\\n            delete this.lastPresences[jid];\\n\\n            if (skipEvents) {\\n                return;\\n            }\\n\\n            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.MUC_MEMBER_LEFT, jid);\\n\\n            this.moderator.onMucMemberLeft(jid);\\n        }\\n\\n        /**\\n         *\\n         * @param pres\\n         * @param from\\n         */\\n\\n    }, {\\n        key: 'onPresenceUnavailable',\\n        value: function onPresenceUnavailable(pres, from) {\\n            var _this4 = this;\\n\\n            // ignore presence\\n            if ($(pres).find('>ignore[xmlns=\\\"http://jitsi.org/jitmeet/\\\"]').length) {\\n                return true;\\n            }\\n\\n            // room destroyed ?\\n            if ($(pres).find('>x[xmlns=\\\"http://jabber.org/protocol/muc#user\\\"]' + '>destroy').length) {\\n                var reason = void 0;\\n                var reasonSelect = $(pres).find('>x[xmlns=\\\"http://jabber.org/protocol/muc#user\\\"]' + '>destroy>reason');\\n\\n                if (reasonSelect.length) {\\n                    reason = reasonSelect.text();\\n                }\\n\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.MUC_DESTROYED, reason);\\n                this.connection.emuc.doLeave(this.roomjid);\\n\\n                return true;\\n            }\\n\\n            // Status code 110 indicates that this notification is \\\"self-presence\\\".\\n            var isSelfPresence = $(pres).find('>x[xmlns=\\\"http://jabber.org/protocol/muc#user\\\"]>' + 'status[code=\\\"110\\\"]').length;\\n            var isKick = $(pres).find('>x[xmlns=\\\"http://jabber.org/protocol/muc#user\\\"]' + '>status[code=\\\"307\\\"]').length;\\n            var membersKeys = Object.keys(this.members);\\n\\n            if (!isSelfPresence) {\\n                delete this.members[from];\\n                this.onParticipantLeft(from, false);\\n            } else if (membersKeys.length > 0) {\\n                // If the status code is 110 this means we're leaving and we would\\n                // like to remove everyone else from our view, so we trigger the\\n                // event.\\n                membersKeys.forEach(function (jid) {\\n                    var member = _this4.members[jid];\\n\\n                    delete _this4.members[jid];\\n                    _this4.onParticipantLeft(jid, member.isFocus);\\n                });\\n                this.connection.emuc.doLeave(this.roomjid);\\n\\n                // we fire muc_left only if this is not a kick,\\n                // kick has both statuses 110 and 307.\\n                if (!isKick) {\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.MUC_LEFT);\\n                }\\n            }\\n\\n            if (isKick && this.myroomjid === from) {\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.KICKED);\\n            }\\n        }\\n\\n        /**\\n         *\\n         * @param msg\\n         * @param from\\n         */\\n\\n    }, {\\n        key: 'onMessage',\\n        value: function onMessage(msg, from) {\\n            var nick = $(msg).find('>nick[xmlns=\\\"http://jabber.org/protocol/nick\\\"]').text() || __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(from);\\n\\n            var txt = $(msg).find('>body').text();\\n            var type = msg.getAttribute('type');\\n\\n            if (type === 'error') {\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.CHAT_ERROR_RECEIVED, $(msg).find('>text').text(), txt);\\n\\n                return true;\\n            }\\n\\n            var subject = $(msg).find('>subject');\\n\\n            if (subject.length) {\\n                var subjectText = subject.text();\\n\\n                if (subjectText || subjectText === '') {\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.SUBJECT_CHANGED, subjectText);\\n                    logger.log('Subject is changed to ' + subjectText);\\n                }\\n            }\\n\\n            // xep-0203 delay\\n            var stamp = $(msg).find('>delay').attr('stamp');\\n\\n            if (!stamp) {\\n                // or xep-0091 delay, UTC timestamp\\n                stamp = $(msg).find('>[xmlns=\\\"jabber:x:delay\\\"]').attr('stamp');\\n\\n                if (stamp) {\\n                    // the format is CCYYMMDDThh:mm:ss\\n                    var dateParts = stamp.match(/(\\\\d{4})(\\\\d{2})(\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2})/);\\n\\n                    stamp = dateParts[1] + '-' + dateParts[2] + '-' + dateParts[3] + 'Z';\\n                }\\n            }\\n\\n            if (from === this.roomjid && $(msg).find('>x[xmlns=\\\"http://jabber.org/protocol/muc#user\\\"]' + '>status[code=\\\"104\\\"]').length) {\\n                this.discoRoomInfo();\\n            }\\n\\n            var json = tryParseJSONAndVerify(txt);\\n\\n            if (json) {\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.JSON_MESSAGE_RECEIVED, from, json);\\n\\n                return;\\n            }\\n\\n            if (txt) {\\n                logger.log('chat', nick, txt);\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.MESSAGE_RECEIVED, from, nick, txt, this.myroomjid, stamp);\\n            }\\n        }\\n\\n        /**\\n         *\\n         * @param pres\\n         * @param from\\n         */\\n\\n    }, {\\n        key: 'onPresenceError',\\n        value: function onPresenceError(pres, from) {\\n            if ($(pres).find('>error[type=\\\"auth\\\"]' + '>not-authorized[' + 'xmlns=\\\"urn:ietf:params:xml:ns:xmpp-stanzas\\\"]').length) {\\n                logger.log('on password required', from);\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.PASSWORD_REQUIRED);\\n            } else if ($(pres).find('>error[type=\\\"cancel\\\"]' + '>not-allowed[' + 'xmlns=\\\"urn:ietf:params:xml:ns:xmpp-stanzas\\\"]').length) {\\n                var toDomain = __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getDomainFromJid(pres.getAttribute('to'));\\n\\n                if (toDomain === this.xmpp.options.hosts.anonymousdomain) {\\n                    // enter the room by replying with 'not-authorized'. This would\\n                    // result in reconnection from authorized domain.\\n                    // We're either missing Jicofo/Prosody config for anonymous\\n                    // domains or something is wrong.\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.ROOM_JOIN_ERROR);\\n                } else {\\n                    logger.warn('onPresError ', pres);\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.ROOM_CONNECT_NOT_ALLOWED_ERROR);\\n                }\\n            } else if ($(pres).find('>error>service-unavailable').length) {\\n                logger.warn('Maximum users limit for the room has been reached', pres);\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.ROOM_MAX_USERS_ERROR);\\n            } else {\\n                logger.warn('onPresError ', pres);\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.ROOM_CONNECT_ERROR);\\n            }\\n        }\\n\\n        /**\\n         *\\n         * @param jid\\n         */\\n\\n    }, {\\n        key: 'kick',\\n        value: function kick(jid) {\\n            var kickIQ = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({ to: this.roomjid,\\n                type: 'set' }).c('query', { xmlns: 'http://jabber.org/protocol/muc#admin' }).c('item', { nick: __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(jid),\\n                role: 'none' }).c('reason').t('You have been kicked.').up().up().up();\\n\\n            this.connection.sendIQ(kickIQ, function (result) {\\n                return logger.log('Kick participant with jid: ', jid, result);\\n            }, function (error) {\\n                return logger.log('Kick participant error: ', error);\\n            });\\n        }\\n\\n        /* eslint-disable max-params */\\n\\n        /**\\n         *\\n         * @param key\\n         * @param onSuccess\\n         * @param onError\\n         * @param onNotSupported\\n         */\\n\\n    }, {\\n        key: 'lockRoom',\\n        value: function lockRoom(key, onSuccess, onError, onNotSupported) {\\n            var _this5 = this;\\n\\n            // http://xmpp.org/extensions/xep-0045.html#roomconfig\\n            this.connection.sendIQ(Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({\\n                to: this.roomjid,\\n                type: 'get'\\n            }).c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' }), function (res) {\\n                if ($(res).find('>query>x[xmlns=\\\"jabber:x:data\\\"]' + '>field[var=\\\"muc#roomconfig_roomsecret\\\"]').length) {\\n                    var formsubmit = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({\\n                        to: _this5.roomjid,\\n                        type: 'set'\\n                    }).c('query', {\\n                        xmlns: 'http://jabber.org/protocol/muc#owner'\\n                    });\\n\\n                    formsubmit.c('x', {\\n                        xmlns: 'jabber:x:data',\\n                        type: 'submit'\\n                    });\\n                    formsubmit.c('field', { 'var': 'FORM_TYPE' }).c('value').t('http://jabber.org/protocol/muc#roomconfig').up().up();\\n                    formsubmit.c('field', { 'var': 'muc#roomconfig_roomsecret' }).c('value').t(key).up().up();\\n\\n                    // Fixes a bug in prosody 0.9.+\\n                    // https://code.google.com/p/lxmppd/issues/detail?id=373\\n                    formsubmit.c('field', { 'var': 'muc#roomconfig_whois' }).c('value').t('anyone').up().up();\\n\\n                    // FIXME: is muc#roomconfig_passwordprotectedroom required?\\n                    _this5.connection.sendIQ(formsubmit, onSuccess, onError);\\n                } else {\\n                    onNotSupported();\\n                }\\n            }, onError);\\n        }\\n\\n        /* eslint-enable max-params */\\n\\n        /**\\n         *\\n         * @param key\\n         * @param values\\n         */\\n\\n    }, {\\n        key: 'addToPresence',\\n        value: function addToPresence(key, values) {\\n            values.tagName = key;\\n            this.removeFromPresence(key);\\n            this.presMap.nodes.push(values);\\n        }\\n\\n        /**\\n         *\\n         * @param key\\n         */\\n\\n    }, {\\n        key: 'removeFromPresence',\\n        value: function removeFromPresence(key) {\\n            var nodes = this.presMap.nodes.filter(function (node) {\\n                return key !== node.tagName;\\n            });\\n\\n            this.presMap.nodes = nodes;\\n        }\\n\\n        /**\\n         *\\n         * @param name\\n         * @param handler\\n         */\\n\\n    }, {\\n        key: 'addPresenceListener',\\n        value: function addPresenceListener(name, handler) {\\n            if (typeof handler !== 'function') {\\n                throw new Error('\\\"handler\\\" is not a function');\\n            }\\n            var tagHandlers = this.presHandlers[name];\\n\\n            if (!tagHandlers) {\\n                this.presHandlers[name] = tagHandlers = [];\\n            }\\n            if (tagHandlers.indexOf(handler) === -1) {\\n                tagHandlers.push(handler);\\n            } else {\\n                logger.warn('Trying to add the same handler more than once for: ' + name);\\n            }\\n        }\\n\\n        /**\\n         *\\n         * @param name\\n         * @param handler\\n         */\\n\\n    }, {\\n        key: 'removePresenceListener',\\n        value: function removePresenceListener(name, handler) {\\n            var tagHandlers = this.presHandlers[name];\\n            var handlerIdx = tagHandlers ? tagHandlers.indexOf(handler) : -1;\\n\\n            // eslint-disable-next-line no-negated-condition\\n            if (handlerIdx !== -1) {\\n                tagHandlers.splice(handlerIdx, 1);\\n            } else {\\n                logger.warn('Handler for: ' + name + ' was not registered');\\n            }\\n        }\\n\\n        /**\\n         * Checks if the user identified by given <tt>mucJid</tt> is the conference\\n         * focus.\\n         * @param mucJid the full MUC address of the user to be checked.\\n         * @returns {boolean|null} <tt>true</tt> if MUC user is the conference focus\\n         * or <tt>false</tt> if is not. When given <tt>mucJid</tt> does not exist in\\n         * the MUC then <tt>null</tt> is returned.\\n         */\\n\\n    }, {\\n        key: 'isFocus',\\n        value: function isFocus(mucJid) {\\n            var member = this.members[mucJid];\\n\\n            if (member) {\\n                return member.isFocus;\\n            }\\n\\n            return null;\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'isModerator',\\n        value: function isModerator() {\\n            return this.role === 'moderator';\\n        }\\n\\n        /**\\n         *\\n         * @param peerJid\\n         */\\n\\n    }, {\\n        key: 'getMemberRole',\\n        value: function getMemberRole(peerJid) {\\n            if (this.members[peerJid]) {\\n                return this.members[peerJid].role;\\n            }\\n\\n            return null;\\n        }\\n\\n        /**\\n         *\\n         * @param mute\\n         * @param callback\\n         */\\n\\n    }, {\\n        key: 'setVideoMute',\\n        value: function setVideoMute(mute, callback) {\\n            this.sendVideoInfoPresence(mute);\\n            if (callback) {\\n                callback(mute);\\n            }\\n        }\\n\\n        /**\\n         *\\n         * @param mute\\n         * @param callback\\n         */\\n\\n    }, {\\n        key: 'setAudioMute',\\n        value: function setAudioMute(mute, callback) {\\n            return this.sendAudioInfoPresence(mute, callback);\\n        }\\n\\n        /**\\n         *\\n         * @param mute\\n         */\\n\\n    }, {\\n        key: 'addAudioInfoToPresence',\\n        value: function addAudioInfoToPresence(mute) {\\n            this.removeFromPresence('audiomuted');\\n            this.addToPresence('audiomuted', {\\n                attributes: { 'xmlns': 'http://jitsi.org/jitmeet/audio' },\\n                value: mute.toString()\\n            });\\n        }\\n\\n        /**\\n         *\\n         * @param mute\\n         * @param callback\\n         */\\n\\n    }, {\\n        key: 'sendAudioInfoPresence',\\n        value: function sendAudioInfoPresence(mute, callback) {\\n            this.addAudioInfoToPresence(mute);\\n            if (this.connection) {\\n                this.sendPresence();\\n            }\\n            if (callback) {\\n                callback();\\n            }\\n        }\\n\\n        /**\\n         *\\n         * @param mute\\n         */\\n\\n    }, {\\n        key: 'addVideoInfoToPresence',\\n        value: function addVideoInfoToPresence(mute) {\\n            this.removeFromPresence('videomuted');\\n            this.addToPresence('videomuted', {\\n                attributes: { 'xmlns': 'http://jitsi.org/jitmeet/video' },\\n                value: mute.toString()\\n            });\\n        }\\n\\n        /**\\n         *\\n         * @param mute\\n         */\\n\\n    }, {\\n        key: 'sendVideoInfoPresence',\\n        value: function sendVideoInfoPresence(mute) {\\n            this.addVideoInfoToPresence(mute);\\n            if (!this.connection) {\\n                return;\\n            }\\n            this.sendPresence();\\n        }\\n\\n        /**\\n         * Obtains the info about given media advertised in the MUC presence of\\n         * the participant identified by the given endpoint JID.\\n         * @param {string} endpointId the endpoint ID mapped to the participant\\n         * which corresponds to MUC nickname.\\n         * @param {MediaType} mediaType the type of the media for which presence\\n         * info will be obtained.\\n         * @return {PeerMediaInfo} presenceInfo an object with media presence\\n         * info or <tt>null</tt> either if there is no presence available or if\\n         * the media type given is invalid.\\n         */\\n\\n    }, {\\n        key: 'getMediaPresenceInfo',\\n        value: function getMediaPresenceInfo(endpointId, mediaType) {\\n            // Will figure out current muted status by looking up owner's presence\\n            var pres = this.lastPresences[this.roomjid + '/' + endpointId];\\n\\n            if (!pres) {\\n                // No presence available\\n                return null;\\n            }\\n            var data = {\\n                muted: false, // unmuted by default\\n                videoType: undefined // no video type by default\\n            };\\n            var mutedNode = null;\\n\\n            if (mediaType === __WEBPACK_IMPORTED_MODULE_6__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]) {\\n                mutedNode = filterNodeFromPresenceJSON(pres, 'audiomuted');\\n            } else if (mediaType === __WEBPACK_IMPORTED_MODULE_6__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]) {\\n                mutedNode = filterNodeFromPresenceJSON(pres, 'videomuted');\\n                var videoTypeNode = filterNodeFromPresenceJSON(pres, 'videoType');\\n\\n                if (videoTypeNode.length > 0) {\\n                    data.videoType = videoTypeNode[0].value;\\n                }\\n            } else {\\n                logger.error('Unsupported media type: ' + mediaType);\\n\\n                return null;\\n            }\\n\\n            data.muted = mutedNode.length > 0 && mutedNode[0].value === 'true';\\n\\n            return data;\\n        }\\n\\n        /**\\n         * Returns true if the recording is supproted and false if not.\\n         */\\n\\n    }, {\\n        key: 'isRecordingSupported',\\n        value: function isRecordingSupported() {\\n            if (this.recording) {\\n                return this.recording.isSupported();\\n            }\\n\\n            return false;\\n        }\\n\\n        /**\\n         * Returns null if the recording is not supported, \\\"on\\\" if the recording\\n         * started and \\\"off\\\" if the recording is not started.\\n         */\\n\\n    }, {\\n        key: 'getRecordingState',\\n        value: function getRecordingState() {\\n            return this.recording ? this.recording.getState() : undefined;\\n        }\\n\\n        /**\\n         * Returns the url of the recorded video.\\n         */\\n\\n    }, {\\n        key: 'getRecordingURL',\\n        value: function getRecordingURL() {\\n            return this.recording ? this.recording.getURL() : null;\\n        }\\n\\n        /**\\n         * Starts/stops the recording\\n         * @param token token for authentication\\n         * @param statusChangeHandler {function} receives the new status as\\n         * argument.\\n         */\\n\\n    }, {\\n        key: 'toggleRecording',\\n        value: function toggleRecording(options, statusChangeHandler) {\\n            if (this.recording) {\\n                return this.recording.toggleRecording(options, statusChangeHandler);\\n            }\\n\\n            return statusChangeHandler('error', new Error('The conference is not created yet!'));\\n        }\\n\\n        /**\\n         * Returns true if the SIP calls are supported and false otherwise\\n         */\\n\\n    }, {\\n        key: 'isSIPCallingSupported',\\n        value: function isSIPCallingSupported() {\\n            if (this.moderator) {\\n                return this.moderator.isSipGatewayEnabled();\\n            }\\n\\n            return false;\\n        }\\n\\n        /**\\n         * Dials a number.\\n         * @param number the number\\n         */\\n\\n    }, {\\n        key: 'dial',\\n        value: function dial(number) {\\n            return this.connection.rayo.dial(number, 'fromnumber', __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid);\\n        }\\n\\n        /**\\n         * Hangup an existing call\\n         */\\n\\n    }, {\\n        key: 'hangup',\\n        value: function hangup() {\\n            return this.connection.rayo.hangup();\\n        }\\n\\n        /**\\n         * Returns the phone number for joining the conference.\\n         */\\n\\n    }, {\\n        key: 'getPhoneNumber',\\n        value: function getPhoneNumber() {\\n            return this.phoneNumber;\\n        }\\n\\n        /**\\n         * Returns the pin for joining the conference with phone.\\n         */\\n\\n    }, {\\n        key: 'getPhonePin',\\n        value: function getPhonePin() {\\n            return this.phonePin;\\n        }\\n\\n        /**\\n         * Mutes remote participant.\\n         * @param jid of the participant\\n         * @param mute\\n         */\\n\\n    }, {\\n        key: 'muteParticipant',\\n        value: function muteParticipant(jid, mute) {\\n            logger.info('set mute', mute);\\n            var iqToFocus = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({ to: this.focusMucJid,\\n                type: 'set' }).c('mute', {\\n                xmlns: 'http://jitsi.org/jitmeet/audio',\\n                jid: jid\\n            }).t(mute.toString()).up();\\n\\n            this.connection.sendIQ(iqToFocus, function (result) {\\n                return logger.log('set mute', result);\\n            }, function (error) {\\n                return logger.log('set mute error', error);\\n            });\\n        }\\n\\n        /**\\n         *\\n         * @param iq\\n         */\\n\\n    }, {\\n        key: 'onMute',\\n        value: function onMute(iq) {\\n            var from = iq.getAttribute('from');\\n\\n            if (from !== this.focusMucJid) {\\n                logger.warn('Ignored mute from non focus peer');\\n\\n                return false;\\n            }\\n            var mute = $(iq).find('mute');\\n\\n            if (mute.length) {\\n                var doMuteAudio = mute.text() === 'true';\\n\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.AUDIO_MUTED_BY_FOCUS, doMuteAudio);\\n            }\\n\\n            return true;\\n        }\\n\\n        /**\\n         * Leaves the room. Closes the jingle session.\\n         * @returns {Promise} which is resolved if XMPPEvents.MUC_LEFT is received\\n         * less than 5s after sending presence unavailable. Otherwise the promise is\\n         * rejected.\\n         */\\n\\n    }, {\\n        key: 'leave',\\n        value: function leave() {\\n            var _this6 = this;\\n\\n            return new Promise(function (resolve, reject) {\\n                var timeout = setTimeout(function () {\\n                    return onMucLeft(true);\\n                }, 5000);\\n                var eventEmitter = _this6.eventEmitter;\\n\\n                /**\\n                 *\\n                 * @param doReject\\n                 */\\n                function onMucLeft() {\\n                    var doReject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n                    eventEmitter.removeListener(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.MUC_LEFT, onMucLeft);\\n                    clearTimeout(timeout);\\n                    if (doReject) {\\n                        // the timeout expired\\n                        reject(new Error('The timeout for the confirmation about ' + 'leaving the room expired.'));\\n                    } else {\\n                        resolve();\\n                    }\\n                }\\n                eventEmitter.on(__WEBPACK_IMPORTED_MODULE_7__service_xmpp_XMPPEvents___default.a.MUC_LEFT, onMucLeft);\\n                _this6.doLeave();\\n            });\\n        }\\n    }]);\\n\\n    return ChatRoom;\\n}(__WEBPACK_IMPORTED_MODULE_4__util_Listenable__[\\\"a\\\" /* default */]);\\n\\n/* eslint-enable newline-per-chained-call */\\n\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (ChatRoom);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/ChatRoom.js\\\"))\\n\\n/***/ }),\\n/* 99 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = Moderator;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__settings_Settings__ = __webpack_require__(19);\\n/* global $, Promise */\\n\\nvar logger = __webpack_require__(0).getLogger(__filename);\\n\\n\\n\\nvar XMPPEvents = __webpack_require__(8);\\nvar AuthenticationEvents = __webpack_require__(48);\\nvar GlobalOnErrorHandler = __webpack_require__(3);\\n\\n\\n\\n\\n/**\\n *\\n * @param step\\n */\\nfunction createExpBackoffTimer(step) {\\n    var count = 1;\\n\\n    return function (reset) {\\n        // Reset call\\n        if (reset) {\\n            count = 1;\\n\\n            return;\\n        }\\n\\n        // Calculate next timeout\\n        var timeout = Math.pow(2, count - 1);\\n\\n        count += 1;\\n\\n        return timeout * step;\\n    };\\n}\\n\\n/* eslint-disable max-params */\\n\\n/**\\n *\\n * @param roomName\\n * @param xmpp\\n * @param emitter\\n * @param options\\n */\\nfunction Moderator(roomName, xmpp, emitter, options) {\\n    this.roomName = roomName;\\n    this.xmppService = xmpp;\\n    this.getNextTimeout = createExpBackoffTimer(1000);\\n    this.getNextErrorTimeout = createExpBackoffTimer(1000);\\n\\n    // External authentication stuff\\n    this.externalAuthEnabled = false;\\n    this.options = options;\\n\\n    // Sip gateway can be enabled by configuring Jigasi host in config.js or\\n    // it will be enabled automatically if focus detects the component through\\n    // service discovery.\\n    this.sipGatewayEnabled = this.options.connection.hosts && this.options.connection.hosts.call_control !== undefined;\\n\\n    this.eventEmitter = emitter;\\n\\n    this.connection = this.xmppService.connection;\\n\\n    // FIXME: Message listener that talks to POPUP window\\n    /**\\n     *\\n     * @param event\\n     */\\n    function listener(event) {\\n        if (event.data && event.data.sessionId) {\\n            if (event.origin !== window.location.origin) {\\n                logger.warn('Ignoring sessionId from different origin: ' + event.origin);\\n\\n                return;\\n            }\\n            __WEBPACK_IMPORTED_MODULE_2__settings_Settings__[\\\"a\\\" /* default */].sessionId = event.data.sessionId;\\n\\n            // After popup is closed we will authenticate\\n        }\\n    }\\n\\n    // Register\\n    if (window.addEventListener) {\\n        window.addEventListener('message', listener, false);\\n    } else {\\n        window.attachEvent('onmessage', listener);\\n    }\\n}\\n\\n/* eslint-enable max-params */\\n\\nModerator.prototype.isExternalAuthEnabled = function () {\\n    return this.externalAuthEnabled;\\n};\\n\\nModerator.prototype.isSipGatewayEnabled = function () {\\n    return this.sipGatewayEnabled;\\n};\\n\\nModerator.prototype.onMucMemberLeft = function (jid) {\\n    logger.info('Someone left is it focus ? ' + jid);\\n    var resource = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(jid);\\n\\n    if (resource === 'focus') {\\n        logger.info('Focus has left the room - leaving conference');\\n        this.eventEmitter.emit(XMPPEvents.FOCUS_LEFT);\\n    }\\n};\\n\\nModerator.prototype.setFocusUserJid = function (focusJid) {\\n    if (!this.focusUserJid) {\\n        this.focusUserJid = focusJid;\\n        logger.info('Focus jid set to:  ' + this.focusUserJid);\\n    }\\n};\\n\\nModerator.prototype.getFocusUserJid = function () {\\n    return this.focusUserJid;\\n};\\n\\nModerator.prototype.getFocusComponent = function () {\\n    // Get focus component address\\n    var focusComponent = this.options.connection.hosts.focus;\\n\\n    // If not specified use default:  'focus.domain'\\n\\n    if (!focusComponent) {\\n        focusComponent = 'focus.' + this.options.connection.hosts.domain;\\n    }\\n\\n    return focusComponent;\\n};\\n\\nModerator.prototype.createConferenceIq = function () {\\n    // Generate create conference IQ\\n    var elem = Object(__WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"$iq\\\"])({ to: this.getFocusComponent(),\\n        type: 'set' });\\n\\n    // Session Id used for authentication\\n    var sessionId = __WEBPACK_IMPORTED_MODULE_2__settings_Settings__[\\\"a\\\" /* default */].sessionId;\\n\\n    var machineUID = __WEBPACK_IMPORTED_MODULE_2__settings_Settings__[\\\"a\\\" /* default */].machineId;\\n\\n    logger.info('Session ID: ' + sessionId + ' machine UID: ' + machineUID);\\n\\n    elem.c('conference', {\\n        xmlns: 'http://jitsi.org/protocol/focus',\\n        room: this.roomName,\\n        'machine-uid': machineUID\\n    });\\n\\n    if (sessionId) {\\n        elem.attrs({ 'session-id': sessionId });\\n    }\\n    if (this.options.connection.enforcedBridge !== undefined) {\\n        elem.c('property', {\\n            name: 'enforcedBridge',\\n            value: this.options.connection.enforcedBridge\\n        }).up();\\n    }\\n\\n    // Tell the focus we have Jigasi configured\\n    if (this.options.connection.hosts !== undefined && this.options.connection.hosts.call_control !== undefined) {\\n        elem.c('property', {\\n            name: 'call_control',\\n            value: this.options.connection.hosts.call_control\\n        }).up();\\n    }\\n    if (this.options.conference.channelLastN !== undefined) {\\n        elem.c('property', {\\n            name: 'channelLastN',\\n            value: this.options.conference.channelLastN\\n        }).up();\\n    }\\n    elem.c('property', {\\n        name: 'disableRtx',\\n        value: Boolean(this.options.conference.disableRtx)\\n    }).up();\\n    elem.c('property', {\\n        name: 'enableLipSync',\\n        value: this.options.connection.enableLipSync !== false\\n    }).up();\\n    if (this.options.conference.audioPacketDelay !== undefined) {\\n        elem.c('property', {\\n            name: 'audioPacketDelay',\\n            value: this.options.conference.audioPacketDelay\\n        }).up();\\n    }\\n    if (this.options.conference.startBitrate) {\\n        elem.c('property', {\\n            name: 'startBitrate',\\n            value: this.options.conference.startBitrate\\n        }).up();\\n    }\\n    if (this.options.conference.minBitrate) {\\n        elem.c('property', {\\n            name: 'minBitrate',\\n            value: this.options.conference.minBitrate\\n        }).up();\\n    }\\n\\n    var openSctp = void 0;\\n\\n    switch (this.options.conference.openBridgeChannel) {\\n        case 'datachannel':\\n        case true:\\n        case undefined:\\n            openSctp = true;\\n            break;\\n        case 'websocket':\\n            openSctp = false;\\n            break;\\n    }\\n\\n    if (openSctp && !__WEBPACK_IMPORTED_MODULE_1__RTC_RTCBrowserType__[\\\"a\\\" /* default */].supportsDataChannels()) {\\n        openSctp = false;\\n    }\\n\\n    elem.c('property', {\\n        name: 'openSctp',\\n        value: openSctp\\n    }).up();\\n\\n    if (this.options.conference.startAudioMuted !== undefined) {\\n        elem.c('property', {\\n            name: 'startAudioMuted',\\n            value: this.options.conference.startAudioMuted\\n        }).up();\\n    }\\n    if (this.options.conference.startVideoMuted !== undefined) {\\n        elem.c('property', {\\n            name: 'startVideoMuted',\\n            value: this.options.conference.startVideoMuted\\n        }).up();\\n    }\\n    if (this.options.conference.stereo !== undefined) {\\n        elem.c('property', {\\n            name: 'stereo',\\n            value: this.options.conference.stereo\\n        }).up();\\n    }\\n    if (this.options.conference.useRoomAsSharedDocumentName !== undefined) {\\n        elem.c('property', {\\n            name: 'useRoomAsSharedDocumentName',\\n            value: this.options.conference.useRoomAsSharedDocumentName\\n        }).up();\\n    }\\n    elem.up();\\n\\n    return elem;\\n};\\n\\nModerator.prototype.parseSessionId = function (resultIq) {\\n    // eslint-disable-next-line newline-per-chained-call\\n    var sessionId = $(resultIq).find('conference').attr('session-id');\\n\\n    if (sessionId) {\\n        logger.info('Received sessionId:  ' + sessionId);\\n        __WEBPACK_IMPORTED_MODULE_2__settings_Settings__[\\\"a\\\" /* default */].sessionId = sessionId;\\n    }\\n};\\n\\nModerator.prototype.parseConfigOptions = function (resultIq) {\\n    // eslint-disable-next-line newline-per-chained-call\\n    this.setFocusUserJid($(resultIq).find('conference').attr('focusjid'));\\n\\n    var authenticationEnabled = $(resultIq).find('>conference>property' + '[name=\\\\'authentication\\\\'][value=\\\\'true\\\\']').length > 0;\\n\\n    logger.info('Authentication enabled: ' + authenticationEnabled);\\n\\n    this.externalAuthEnabled = $(resultIq).find('>conference>property' + '[name=\\\\'externalAuth\\\\'][value=\\\\'true\\\\']').length > 0;\\n\\n    logger.info('External authentication enabled: ' + this.externalAuthEnabled);\\n\\n    if (!this.externalAuthEnabled) {\\n        // We expect to receive sessionId in 'internal' authentication mode\\n        this.parseSessionId(resultIq);\\n    }\\n\\n    // eslint-disable-next-line newline-per-chained-call\\n    var authIdentity = $(resultIq).find('>conference').attr('identity');\\n\\n    this.eventEmitter.emit(AuthenticationEvents.IDENTITY_UPDATED, authenticationEnabled, authIdentity);\\n\\n    // Check if focus has auto-detected Jigasi component(this will be also\\n    // included if we have passed our host from the config)\\n    if ($(resultIq).find('>conference>property' + '[name=\\\\'sipGatewayEnabled\\\\'][value=\\\\'true\\\\']').length) {\\n        this.sipGatewayEnabled = true;\\n    }\\n\\n    logger.info('Sip gateway enabled:  ' + this.sipGatewayEnabled);\\n};\\n\\n// FIXME We need to show the fact that we're waiting for the focus to the user\\n// (or that the focus is not available)\\n/**\\n * Allocates the conference focus.\\n *\\n * @param {Function} callback - the function to be called back upon the\\n * successful allocation of the conference focus\\n */\\nModerator.prototype.allocateConferenceFocus = function (callback) {\\n    var _this = this;\\n\\n    // Try to use focus user JID from the config\\n    this.setFocusUserJid(this.options.connection.focusUserJid);\\n\\n    // Send create conference IQ\\n    this.connection.sendIQ(this.createConferenceIq(), function (result) {\\n        return _this._allocateConferenceFocusSuccess(result, callback);\\n    }, function (error) {\\n        return _this._allocateConferenceFocusError(error, callback);\\n    });\\n\\n    // XXX We're pressed for time here because we're beginning a complex and/or\\n    // lengthy conference-establishment process which supposedly involves\\n    // multiple RTTs. We don't have the time to wait for Strophe to decide to\\n    // send our IQ.\\n    this.connection.flush();\\n};\\n\\n/**\\n * Invoked by {@link #allocateConferenceFocus} upon its request receiving an\\n * error result.\\n *\\n * @param error - the error result of the request that\\n * {@link #allocateConferenceFocus} sent\\n * @param {Function} callback - the function to be called back upon the\\n * successful allocation of the conference focus\\n */\\nModerator.prototype._allocateConferenceFocusError = function (error, callback) {\\n    var _this2 = this;\\n\\n    // If the session is invalid, remove and try again without session ID to get\\n    // a new one\\n    var invalidSession = $(error).find('>error>session-invalid').length || $(error).find('>error>not-acceptable').length;\\n\\n    if (invalidSession) {\\n        logger.info('Session expired! - removing');\\n        __WEBPACK_IMPORTED_MODULE_2__settings_Settings__[\\\"a\\\" /* default */].sessionId = undefined;\\n    }\\n    if ($(error).find('>error>graceful-shutdown').length) {\\n        this.eventEmitter.emit(XMPPEvents.GRACEFUL_SHUTDOWN);\\n\\n        return;\\n    }\\n\\n    // Check for error returned by the reservation system\\n    var reservationErr = $(error).find('>error>reservation-error');\\n\\n    if (reservationErr.length) {\\n        // Trigger error event\\n        var errorCode = reservationErr.attr('error-code');\\n        var errorTextNode = $(error).find('>error>text');\\n        var errorMsg = void 0;\\n\\n        if (errorTextNode) {\\n            errorMsg = errorTextNode.text();\\n        }\\n        this.eventEmitter.emit(XMPPEvents.RESERVATION_ERROR, errorCode, errorMsg);\\n\\n        return;\\n    }\\n\\n    // Not authorized to create new room\\n    if ($(error).find('>error>not-authorized').length) {\\n        logger.warn('Unauthorized to start the conference', error);\\n        var toDomain = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getDomainFromJid(error.getAttribute('to'));\\n\\n        if (toDomain !== this.options.connection.hosts.anonymousdomain) {\\n            // FIXME \\\"is external\\\" should come either from the focus or\\n            // config.js\\n            this.externalAuthEnabled = true;\\n        }\\n        this.eventEmitter.emit(XMPPEvents.AUTHENTICATION_REQUIRED);\\n\\n        return;\\n    }\\n    var waitMs = this.getNextErrorTimeout();\\n    var errmsg = 'Focus error, retry after ' + waitMs;\\n\\n    GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\\n    logger.error(errmsg, error);\\n\\n    // Show message\\n    var focusComponent = this.getFocusComponent();\\n    var retrySec = waitMs / 1000;\\n\\n    // FIXME: message is duplicated ? Do not show in case of session invalid\\n    // which means just a retry\\n\\n    if (!invalidSession) {\\n        this.eventEmitter.emit(XMPPEvents.FOCUS_DISCONNECTED, focusComponent, retrySec);\\n    }\\n\\n    // Reset response timeout\\n    this.getNextTimeout(true);\\n    window.setTimeout(function () {\\n        return _this2.allocateConferenceFocus(callback);\\n    }, waitMs);\\n};\\n\\n/**\\n * Invoked by {@link #allocateConferenceFocus} upon its request receiving a\\n * success (i.e. non-error) result.\\n *\\n * @param result - the success (i.e. non-error) result of the request that\\n * {@link #allocateConferenceFocus} sent\\n * @param {Function} callback - the function to be called back upon the\\n * successful allocation of the conference focus\\n */\\nModerator.prototype._allocateConferenceFocusSuccess = function (result, callback) {\\n    var _this3 = this;\\n\\n    // Setup config options\\n    this.parseConfigOptions(result);\\n\\n    // Reset the error timeout (because we haven't failed here).\\n    this.getNextErrorTimeout(true);\\n\\n    // eslint-disable-next-line newline-per-chained-call\\n    if ($(result).find('conference').attr('ready') === 'true') {\\n        // Reset the non-error timeout (because we've succeeded here).\\n        this.getNextTimeout(true);\\n\\n        // Exec callback\\n        callback();\\n    } else {\\n        var waitMs = this.getNextTimeout();\\n\\n        logger.info('Waiting for the focus... ' + waitMs);\\n        window.setTimeout(function () {\\n            return _this3.allocateConferenceFocus(callback);\\n        }, waitMs);\\n    }\\n};\\n\\nModerator.prototype.authenticate = function () {\\n    var _this4 = this;\\n\\n    return new Promise(function (resolve, reject) {\\n        _this4.connection.sendIQ(_this4.createConferenceIq(), function (result) {\\n            _this4.parseSessionId(result);\\n            resolve();\\n        }, function (errorIq) {\\n            return reject({\\n                error: $(errorIq).find('iq>error :first').prop('tagName'),\\n                message: $(errorIq).find('iq>error>text').text()\\n            });\\n        });\\n    });\\n};\\n\\nModerator.prototype.getLoginUrl = function (urlCallback, failureCallback) {\\n    this._getLoginUrl( /* popup */false, urlCallback, failureCallback);\\n};\\n\\n/**\\n *\\n * @param {boolean} popup false for {@link Moderator#getLoginUrl} or true for\\n * {@link Moderator#getPopupLoginUrl}\\n * @param urlCb\\n * @param failureCb\\n */\\nModerator.prototype._getLoginUrl = function (popup, urlCb, failureCb) {\\n    var iq = Object(__WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"$iq\\\"])({ to: this.getFocusComponent(),\\n        type: 'get' });\\n    var attrs = {\\n        xmlns: 'http://jitsi.org/protocol/focus',\\n        room: this.roomName,\\n        'machine-uid': __WEBPACK_IMPORTED_MODULE_2__settings_Settings__[\\\"a\\\" /* default */].machineId\\n    };\\n    var str = 'auth url'; // for logger\\n\\n    if (popup) {\\n        attrs.popup = true;\\n        str = 'POPUP ' + str;\\n    }\\n    iq.c('login-url', attrs);\\n\\n    /**\\n     * Implements a failure callback which reports an error message and an error\\n     * through (1) GlobalOnErrorHandler, (2) logger, and (3) failureCb.\\n     *\\n     * @param {string} errmsg the error messsage to report\\n     * @param {*} error the error to report (in addition to errmsg)\\n     */\\n    function reportError(errmsg, err) {\\n        GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\\n        logger.error(errmsg, err);\\n        failureCb(err);\\n    }\\n    this.connection.sendIQ(iq, function (result) {\\n        // eslint-disable-next-line newline-per-chained-call\\n        var url = $(result).find('login-url').attr('url');\\n\\n        url = decodeURIComponent(url);\\n        if (url) {\\n            logger.info('Got ' + str + ': ' + url);\\n            urlCb(url);\\n        } else {\\n            reportError('Failed to get ' + str + ' from the focus', result);\\n        }\\n    }, reportError.bind(undefined, 'Get ' + str + ' error'));\\n};\\n\\nModerator.prototype.getPopupLoginUrl = function (urlCallback, failureCallback) {\\n    this._getLoginUrl( /* popup */true, urlCallback, failureCallback);\\n};\\n\\nModerator.prototype.logout = function (callback) {\\n    var iq = Object(__WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"$iq\\\"])({ to: this.getFocusComponent(),\\n        type: 'set' });\\n    var sessionId = __WEBPACK_IMPORTED_MODULE_2__settings_Settings__[\\\"a\\\" /* default */].sessionId;\\n\\n\\n    if (!sessionId) {\\n        callback();\\n\\n        return;\\n    }\\n    iq.c('logout', {\\n        xmlns: 'http://jitsi.org/protocol/focus',\\n        'session-id': sessionId\\n    });\\n    this.connection.sendIQ(iq, function (result) {\\n        // eslint-disable-next-line newline-per-chained-call\\n        var logoutUrl = $(result).find('logout').attr('logout-url');\\n\\n        if (logoutUrl) {\\n            logoutUrl = decodeURIComponent(logoutUrl);\\n        }\\n        logger.info('Log out OK, url: ' + logoutUrl, result);\\n        __WEBPACK_IMPORTED_MODULE_2__settings_Settings__[\\\"a\\\" /* default */].sessionId = undefined;\\n        callback(logoutUrl);\\n    }, function (error) {\\n        var errmsg = 'Logout error';\\n\\n        GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\\n        logger.error(errmsg, error);\\n    });\\n};\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/moderator.js\\\"))\\n\\n/***/ }),\\n/* 100 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = initJingle;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__util_GlobalOnErrorHandler__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_RandomUtil__ = __webpack_require__(20);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_RandomUtil___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__util_RandomUtil__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__statistics_statistics__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__JingleSessionPC__ = __webpack_require__(101);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ConnectionPlugin__ = __webpack_require__(23);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\\\"value\\\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global $, __filename */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_1_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n// XXX Strophe is build around the idea of chaining function calls so allow long\\n// function call chains.\\n/* eslint-disable newline-per-chained-call */\\n\\n/**\\n *\\n */\\n\\nvar JingleConnectionPlugin = function (_ConnectionPlugin) {\\n    _inherits(JingleConnectionPlugin, _ConnectionPlugin);\\n\\n    /**\\n     * Creates new <tt>JingleConnectionPlugin</tt>\\n     * @param {XMPP} xmpp\\n     * @param {EventEmitter} eventEmitter\\n     * @param {Object} iceConfig an object that holds the iceConfig to be passed\\n     * to the p2p and the jvb <tt>PeerConnection</tt>.\\n     */\\n    function JingleConnectionPlugin(xmpp, eventEmitter, iceConfig) {\\n        _classCallCheck(this, JingleConnectionPlugin);\\n\\n        var _this = _possibleConstructorReturn(this, (JingleConnectionPlugin.__proto__ || Object.getPrototypeOf(JingleConnectionPlugin)).call(this));\\n\\n        _this.xmpp = xmpp;\\n        _this.eventEmitter = eventEmitter;\\n        _this.sessions = {};\\n        _this.jvbIceConfig = iceConfig.jvb;\\n        _this.p2pIceConfig = iceConfig.p2p;\\n        _this.mediaConstraints = {\\n            mandatory: {\\n                'OfferToReceiveAudio': true,\\n                'OfferToReceiveVideo': true\\n\\n                // MozDontOfferDataChannel: true when this is firefox\\n            } };\\n        return _this;\\n    }\\n\\n    /**\\n     *\\n     * @param connection\\n     */\\n\\n\\n    _createClass(JingleConnectionPlugin, [{\\n        key: 'init',\\n        value: function init(connection) {\\n            _get(JingleConnectionPlugin.prototype.__proto__ || Object.getPrototypeOf(JingleConnectionPlugin.prototype), 'init', this).call(this, connection);\\n            this.connection.addHandler(this.onJingle.bind(this), 'urn:xmpp:jingle:1', 'iq', 'set', null, null);\\n        }\\n\\n        /**\\n         *\\n         * @param iq\\n         */\\n\\n    }, {\\n        key: 'onJingle',\\n        value: function onJingle(iq) {\\n            var sid = $(iq).find('jingle').attr('sid');\\n            var action = $(iq).find('jingle').attr('action');\\n            var fromJid = iq.getAttribute('from');\\n\\n            // send ack first\\n            var ack = Object(__WEBPACK_IMPORTED_MODULE_2_strophe_js__[\\\"$iq\\\"])({ type: 'result',\\n                to: fromJid,\\n                id: iq.getAttribute('id')\\n            });\\n\\n            logger.log('on jingle ' + action + ' from ' + fromJid, iq);\\n            var sess = this.sessions[sid];\\n\\n            if (action !== 'session-initiate') {\\n                if (!sess) {\\n                    ack.attrs({ type: 'error' });\\n                    ack.c('error', { type: 'cancel' }).c('item-not-found', {\\n                        xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\\n                    }).up().c('unknown-session', {\\n                        xmlns: 'urn:xmpp:jingle:errors:1'\\n                    });\\n                    logger.warn('invalid session id', iq);\\n                    this.connection.send(ack);\\n\\n                    return true;\\n                }\\n\\n                // local jid is not checked\\n                if (fromJid !== sess.remoteJid) {\\n                    logger.warn('jid mismatch for session id', sid, sess.remoteJid, iq);\\n                    ack.attrs({ type: 'error' });\\n                    ack.c('error', { type: 'cancel' }).c('item-not-found', {\\n                        xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\\n                    }).up().c('unknown-session', {\\n                        xmlns: 'urn:xmpp:jingle:errors:1'\\n                    });\\n                    this.connection.send(ack);\\n\\n                    return true;\\n                }\\n            } else if (sess !== undefined) {\\n                // Existing session with same session id. This might be out-of-order\\n                // if the sess.remoteJid is the same as from.\\n                ack.attrs({ type: 'error' });\\n                ack.c('error', { type: 'cancel' }).c('service-unavailable', {\\n                    xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\\n                }).up();\\n                logger.warn('duplicate session id', sid, iq);\\n                this.connection.send(ack);\\n\\n                return true;\\n            }\\n            var now = window.performance.now();\\n\\n            // see http://xmpp.org/extensions/xep-0166.html#concepts-session\\n\\n            switch (action) {\\n                case 'session-initiate':\\n                    {\\n                        logger.log('(TIME) received session-initiate:\\\\t', now);\\n                        var startMuted = $(iq).find('jingle>startmuted');\\n\\n                        if (startMuted && startMuted.length > 0) {\\n                            var audioMuted = startMuted.attr('audio');\\n                            var videoMuted = startMuted.attr('video');\\n\\n                            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents___default.a.START_MUTED_FROM_FOCUS, audioMuted === 'true', videoMuted === 'true');\\n                        }\\n\\n                        // FIXME that should work most of the time, but we'd have to\\n                        // think how secure it is to assume that user with \\\"focus\\\"\\n                        // nickname is Jicofo.\\n                        var isP2P = __WEBPACK_IMPORTED_MODULE_2_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(fromJid) !== 'focus';\\n\\n                        logger.info('Marking session from ' + fromJid + ' as ' + (isP2P ? '' : '*not*') + ' P2P');\\n                        sess = new __WEBPACK_IMPORTED_MODULE_7__JingleSessionPC__[\\\"a\\\" /* default */]($(iq).find('jingle').attr('sid'), $(iq).attr('to'), fromJid, this.connection, this.mediaConstraints, isP2P ? this.p2pIceConfig : this.jvbIceConfig, isP2P,\\n                        /* initiator */false, this.xmpp.options);\\n\\n                        this.sessions[sess.sid] = sess;\\n\\n                        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents___default.a.CALL_INCOMING, sess, $(iq).find('>jingle'), now);\\n                        __WEBPACK_IMPORTED_MODULE_6__statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"x\\\" /* SESSION_INITIATE_RECEIVED */], { value: now });\\n                        break;\\n                    }\\n                case 'session-accept':\\n                    {\\n                        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents___default.a.CALL_ACCEPTED, sess, $(iq).find('>jingle'));\\n                        break;\\n                    }\\n                case 'content-modify':\\n                    {\\n                        sess.modifyContents($(iq).find('>jingle'));\\n                        break;\\n                    }\\n                case 'transport-info':\\n                    {\\n                        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents___default.a.TRANSPORT_INFO, sess, $(iq).find('>jingle'));\\n                        break;\\n                    }\\n                case 'session-terminate':\\n                    {\\n                        logger.log('terminating...', sess.sid);\\n                        var reasonCondition = null;\\n                        var reasonText = null;\\n\\n                        if ($(iq).find('>jingle>reason').length) {\\n                            reasonCondition = $(iq).find('>jingle>reason>:first')[0].tagName;\\n                            reasonText = $(iq).find('>jingle>reason>text').text();\\n                        }\\n                        this.terminate(sess.sid, reasonCondition, reasonText);\\n                        this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents___default.a.CALL_ENDED, sess, reasonCondition, reasonText);\\n                        break;\\n                    }\\n                case 'transport-replace':\\n                    logger.info('(TIME) Start transport replace', now);\\n                    __WEBPACK_IMPORTED_MODULE_6__statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"A\\\" /* TRANSPORT_REPLACE_START */], { value: now });\\n\\n                    sess.replaceTransport($(iq).find('>jingle'), function () {\\n                        var successTime = window.performance.now();\\n\\n                        logger.info('(TIME) Transport replace success!', successTime);\\n                        __WEBPACK_IMPORTED_MODULE_6__statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"B\\\" /* TRANSPORT_REPLACE_SUCCESS */], { value: successTime });\\n                    }, function (error) {\\n                        __WEBPACK_IMPORTED_MODULE_4__util_GlobalOnErrorHandler___default.a.callErrorHandler(error);\\n                        logger.error('Transport replace failed', error);\\n                        sess.sendTransportReject();\\n                    });\\n                    break;\\n                case 'addsource': // FIXME: proprietary, un-jingleish\\n                case 'source-add':\\n                    // FIXME: proprietary\\n                    sess.addRemoteStream($(iq).find('>jingle>content'));\\n                    break;\\n                case 'removesource': // FIXME: proprietary, un-jingleish\\n                case 'source-remove':\\n                    // FIXME: proprietary\\n                    sess.removeRemoteStream($(iq).find('>jingle>content'));\\n                    break;\\n                default:\\n                    logger.warn('jingle action not implemented', action);\\n                    ack.attrs({ type: 'error' });\\n                    ack.c('error', { type: 'cancel' }).c('bad-request', { xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas' }).up();\\n                    break;\\n            }\\n            this.connection.send(ack);\\n\\n            return true;\\n        }\\n\\n        /**\\n         * Creates new <tt>JingleSessionPC</tt> meant to be used in a direct P2P\\n         * connection, configured as 'initiator'.\\n         * @param {string} me our JID\\n         * @param {string} peer remote participant's JID\\n         * @return {JingleSessionPC}\\n         */\\n\\n    }, {\\n        key: 'newP2PJingleSession',\\n        value: function newP2PJingleSession(me, peer) {\\n            var sess = new __WEBPACK_IMPORTED_MODULE_7__JingleSessionPC__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_5__util_RandomUtil___default.a.randomHexString(12), me, peer, this.connection, this.mediaConstraints, this.p2pIceConfig,\\n            /* P2P */true,\\n            /* initiator */true, this.xmpp.options);\\n\\n            this.sessions[sess.sid] = sess;\\n\\n            return sess;\\n        }\\n\\n        /**\\n         *\\n         * @param sid\\n         * @param reasonCondition\\n         * @param reasonText\\n         */\\n\\n    }, {\\n        key: 'terminate',\\n        value: function terminate(sid, reasonCondition, reasonText) {\\n            if (this.sessions.hasOwnProperty(sid)) {\\n                if (this.sessions[sid].state !== 'ended') {\\n                    this.sessions[sid].onTerminated(reasonCondition, reasonText);\\n                }\\n                delete this.sessions[sid];\\n            }\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'getStunAndTurnCredentials',\\n        value: function getStunAndTurnCredentials() {\\n            var _this2 = this;\\n\\n            // get stun and turn configuration from server via xep-0215\\n            // uses time-limited credentials as described in\\n            // http://tools.ietf.org/html/draft-uberti-behave-turn-rest-00\\n            //\\n            // See https://code.google.com/p/prosody-modules/source/browse/\\n            // mod_turncredentials/mod_turncredentials.lua\\n            // for a prosody module which implements this.\\n            //\\n            // Currently, this doesn't work with updateIce and therefore credentials\\n            // with a long validity have to be fetched before creating the\\n            // peerconnection.\\n            // TODO: implement refresh via updateIce as described in\\n            //      https://code.google.com/p/webrtc/issues/detail?id=1650\\n            this.connection.sendIQ(Object(__WEBPACK_IMPORTED_MODULE_2_strophe_js__[\\\"$iq\\\"])({ type: 'get',\\n                to: this.connection.domain }).c('services', { xmlns: 'urn:xmpp:extdisco:1' }).c('service', { host: 'turn.' + this.connection.domain }), function (res) {\\n                var iceservers = [];\\n\\n                $(res).find('>services>service').each(function (idx, el) {\\n                    // eslint-disable-next-line no-param-reassign\\n                    el = $(el);\\n                    var dict = {};\\n                    var type = el.attr('type');\\n\\n                    switch (type) {\\n                        case 'stun':\\n                            dict.url = 'stun:' + el.attr('host');\\n                            if (el.attr('port')) {\\n                                dict.url += ':' + el.attr('port');\\n                            }\\n                            iceservers.push(dict);\\n                            break;\\n                        case 'turn':\\n                        case 'turns':\\n                            {\\n                                dict.url = type + ':';\\n                                var username = el.attr('username');\\n\\n                                // https://code.google.com/p/webrtc/issues/detail\\n                                // ?id=1508\\n\\n                                if (username) {\\n                                    var match = navigator.userAgent.match(/Chrom(e|ium)\\\\/([0-9]+)\\\\./);\\n\\n                                    if (match && parseInt(match[2], 10) < 28) {\\n                                        dict.url += username + '@';\\n                                    } else {\\n                                        // only works in M28\\n                                        dict.username = username;\\n                                    }\\n                                }\\n                                dict.url += el.attr('host');\\n                                var port = el.attr('port');\\n\\n                                if (port && port !== '3478') {\\n                                    dict.url += ':' + el.attr('port');\\n                                }\\n                                var transport = el.attr('transport');\\n\\n                                if (transport && transport !== 'udp') {\\n                                    dict.url += '?transport=' + transport;\\n                                }\\n\\n                                dict.credential = el.attr('password') || dict.credential;\\n                                iceservers.push(dict);\\n                                break;\\n                            }\\n                    }\\n                });\\n\\n                var options = _this2.xmpp.options;\\n\\n                if (options.useStunTurn) {\\n                    _this2.jvbIceConfig.iceServers = iceservers;\\n                }\\n\\n                if (options.p2p && options.p2p.useStunTurn) {\\n                    _this2.p2pIceConfig.iceServers = iceservers;\\n                }\\n            }, function (err) {\\n                logger.warn('getting turn credentials failed', err);\\n                logger.warn('is mod_turncredentials or similar installed?');\\n            });\\n\\n            // implement push?\\n        }\\n\\n        /**\\n         * Returns the data saved in 'updateLog' in a format to be logged.\\n         */\\n\\n    }, {\\n        key: 'getLog',\\n        value: function getLog() {\\n            var _this3 = this;\\n\\n            var data = {};\\n\\n            Object.keys(this.sessions).forEach(function (sid) {\\n                var session = _this3.sessions[sid];\\n                var pc = session.peerconnection;\\n\\n                if (pc && pc.updateLog) {\\n                    // FIXME: should probably be a .dump call\\n                    data['jingle_' + sid] = {\\n                        updateLog: pc.updateLog,\\n                        stats: pc.stats,\\n                        url: window.location.href\\n                    };\\n                }\\n            });\\n\\n            return data;\\n        }\\n    }]);\\n\\n    return JingleConnectionPlugin;\\n}(__WEBPACK_IMPORTED_MODULE_8__ConnectionPlugin__[\\\"b\\\" /* default */]);\\n\\n/* eslint-enable newline-per-chained-call */\\n\\n/**\\n *\\n * @param XMPP\\n * @param eventEmitter\\n * @param iceConfig\\n */\\n\\n\\nfunction initJingle(XMPP, eventEmitter, iceConfig) {\\n    __WEBPACK_IMPORTED_MODULE_2_strophe_js__[\\\"Strophe\\\"].addConnectionPlugin('jingle', new JingleConnectionPlugin(XMPP, eventEmitter, iceConfig));\\n}\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/strophe.jingle.js\\\"))\\n\\n/***/ }),\\n/* 101 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_async__ = __webpack_require__(102);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_async___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_async__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_StringUtils__ = __webpack_require__(103);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_StringUtils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__util_StringUtils__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__JingleSession__ = __webpack_require__(104);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__JingleSessionState__ = __webpack_require__(51);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__SDP__ = __webpack_require__(52);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__SDPDiffer__ = __webpack_require__(105);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__SDPUtil__ = __webpack_require__(14);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__SignalingLayerImpl__ = __webpack_require__(106);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__statistics_statistics__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13__util_GlobalOnErrorHandler__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global __filename, $ */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_2_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Constant tells how long we're going to wait for IQ response, before timeout\\n * error is  triggered.\\n * @type {number}\\n */\\nvar IQ_TIMEOUT = 10000;\\n\\n/**\\n *\\n */\\n\\nvar JingleSessionPC = function (_JingleSession) {\\n    _inherits(JingleSessionPC, _JingleSession);\\n\\n    _createClass(JingleSessionPC, null, [{\\n        key: 'parseVideoSenders',\\n\\n        /**\\n         * Parses 'senders' attribute of the video content.\\n         * @param {jQuery} jingleContents\\n         * @return {string|null} one of the values of content \\\"senders\\\" attribute\\n         * defined by Jingle. If there is no \\\"senders\\\" attribute or if the value is\\n         * invalid then <tt>null</tt> will be returned.\\n         * @private\\n         */\\n        value: function parseVideoSenders(jingleContents) {\\n            var videoContents = jingleContents.find('>content[name=\\\"video\\\"]');\\n\\n            if (videoContents.length) {\\n                var senders = videoContents[0].getAttribute('senders');\\n\\n                if (senders === 'both' || senders === 'initiator' || senders === 'responder' || senders === 'none') {\\n                    return senders;\\n                }\\n            }\\n\\n            return null;\\n        }\\n\\n        /* eslint-disable max-params */\\n\\n        /**\\n         * Creates new <tt>JingleSessionPC</tt>\\n         * @param {string} sid the Jingle Session ID - random string which\\n         * identifies the session\\n         * @param {string} localJid our JID\\n         * @param {string} remoteJid remote peer JID\\n         * @param {Strophe.Connection} connection Strophe XMPP connection instance\\n         * used to send packets.\\n         * @param mediaConstraints the media constraints object passed to\\n         * createOffer/Answer, as defined by the WebRTC standard\\n         * @param iceConfig the ICE servers config object as defined by the WebRTC\\n         * standard.\\n         * @param {boolean} isP2P indicates whether this instance is\\n         * meant to be used in a direct, peer to peer connection or <tt>false</tt>\\n         * if it's a JVB connection.\\n         * @param {boolean} isInitiator indicates whether or not we are the side\\n         * which sends the 'session-initiate'.\\n         * @param {object} options a set of config options\\n         * @param {boolean} options.webrtcIceUdpDisable <tt>true</tt> to block UDP\\n         * candidates.\\n         * @param {boolean} options.webrtcIceTcpDisable <tt>true</tt> to block TCP\\n         * candidates.\\n         * @param {boolean} options.failICE it's an option used in the tests. Set to\\n         * <tt>true</tt> to block any real candidates and make the ICE fail.\\n         *\\n         * @constructor\\n         *\\n         * @implements {SignalingLayer}\\n         */\\n\\n    }]);\\n\\n    function JingleSessionPC(sid, localJid, remoteJid, connection, mediaConstraints, iceConfig, isP2P, isInitiator, options) {\\n        _classCallCheck(this, JingleSessionPC);\\n\\n        /**\\n         * Stores result of {@link window.performance.now()} at the time when\\n         * ICE enters 'checking' state.\\n         * @type {number|null} null if no value has been stored yet\\n         * @private\\n         */\\n        var _this = _possibleConstructorReturn(this, (JingleSessionPC.__proto__ || Object.getPrototypeOf(JingleSessionPC)).call(this, sid, localJid, remoteJid, connection, mediaConstraints, iceConfig));\\n\\n        _this._iceCheckingStartedTimestamp = null;\\n\\n        /**\\n         * Stores result of {@link window.performance.now()} at the time when\\n         * first ICE candidate is spawned by the peerconnection to mark when\\n         * ICE gathering started. That's, because ICE gathering state changed\\n         * events are not supported by most of the browsers, so we try something\\n         * that will work everywhere. It may not be as accurate, but given that\\n         * 'host' candidate usually comes first, the delay should be minimal.\\n         * @type {number|null} null if no value has been stored yet\\n         * @private\\n         */\\n        _this._gatheringStartedTimestamp = null;\\n\\n        /**\\n         * Indicates whether or not this session is willing to send/receive\\n         * video media. When set to <tt>false</tt> the underlying peer\\n         * connection will disable local video transfer and the remote peer will\\n         * be will be asked to stop sending video via 'content-modify' IQ\\n         * (the senders attribute of video contents will be adjusted\\n         * accordingly). Note that this notification is sent only in P2P\\n         * session, because Jicofo does not support it yet. Obviously when\\n         * the value is changed from <tt>false</tt> to <tt>true</tt> another\\n         * notification will be sent to resume video transfer on the remote\\n         * side.\\n         * @type {boolean}\\n         * @private\\n         */\\n        _this._localVideoActive = true;\\n\\n        /**\\n         * Indicates whether or not the remote peer has video transfer active.\\n         * When set to <tt>true</tt> it means that remote peer is neither\\n         * sending nor willing to receive video. In such case we'll ask\\n         * our peerconnection to stop sending video by calling\\n         * {@link TraceablePeerConnection.setVideoTransferActive} with\\n         * <tt>false</tt>.\\n         * @type {boolean}\\n         * @private\\n         */\\n        _this._remoteVideoActive = true;\\n\\n        /**\\n         * Marks that ICE gathering duration has been reported already. That\\n         * prevents reporting it again, after eventual 'transport-replace' (JVB\\n         * conference migration/ICE restart).\\n         * @type {boolean}\\n         * @private\\n         */\\n        _this._gatheringReported = false;\\n\\n        _this.lasticecandidate = false;\\n        _this.closed = false;\\n\\n        /**\\n         * Indicates whether this instance is an initiator or an answerer of\\n         * the Jingle session.\\n         * @type {boolean}\\n         */\\n        _this.isInitiator = isInitiator;\\n\\n        /**\\n         * Indicates whether or not this <tt>JingleSessionPC</tt> is used in\\n         * a peer to peer type of session.\\n         * @type {boolean} <tt>true</tt> if it's a peer to peer\\n         * session or <tt>false</tt> if it's a JVB session\\n         */\\n        _this.isP2P = isP2P;\\n\\n        /**\\n         * The signaling layer implementation.\\n         * @type {SignalingLayerImpl}\\n         */\\n        _this.signalingLayer = new __WEBPACK_IMPORTED_MODULE_10__SignalingLayerImpl__[\\\"a\\\" /* default */]();\\n\\n        _this.webrtcIceUdpDisable = Boolean(options.webrtcIceUdpDisable);\\n        _this.webrtcIceTcpDisable = Boolean(options.webrtcIceTcpDisable);\\n\\n        /**\\n         * Flag used to enforce ICE failure through the URL parameter for\\n         * the automatic testing purpose.\\n         * @type {boolean}\\n         */\\n        _this.failICE = Boolean(options.failICE);\\n\\n        _this.modificationQueue = __WEBPACK_IMPORTED_MODULE_1_async___default.a.queue(_this._processQueueTasks.bind(_this), 1);\\n\\n        /**\\n         * Flag used to guarantee that the connection established event is\\n         * triggered just once.\\n         * @type {boolean}\\n         */\\n        _this.wasConnected = false;\\n\\n        /**\\n         * Keeps track of how long (in ms) it took from ICE start to ICE\\n         * connect.\\n         *\\n         * @type {number}\\n         */\\n        _this.establishmentDuration = undefined;\\n        return _this;\\n    }\\n\\n    /* eslint-enable max-params */\\n\\n    /**\\n     * Checks whether or not this session instance has been ended and eventually\\n     * logs a message which mentions that given <tt>actionName</tt> was\\n     * cancelled.\\n     * @param {string} actionName\\n     * @return {boolean} <tt>true</tt> if this {@link JingleSessionPC} has\\n     * entered {@link JingleSessionState.ENDED} or <tt>false</tt> otherwise.\\n     * @private\\n     */\\n\\n\\n    _createClass(JingleSessionPC, [{\\n        key: '_assertNotEnded',\\n        value: function _assertNotEnded(actionName) {\\n            if (this.state === __WEBPACK_IMPORTED_MODULE_6__JingleSessionState__[\\\"b\\\" /* ENDED */]) {\\n                logger.log('The session has ended - cancelling action: ' + actionName);\\n\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'doInitialize',\\n        value: function doInitialize() {\\n            var _this2 = this;\\n\\n            this.lasticecandidate = false;\\n\\n            // True if reconnect is in progress\\n            this.isreconnect = false;\\n\\n            // Set to true if the connection was ever stable\\n            this.wasstable = false;\\n\\n            var pcOptions = { disableRtx: this.room.options.disableRtx };\\n\\n            if (this.isP2P) {\\n                // simulcast needs to be disabled for P2P (121) calls\\n                pcOptions.disableSimulcast = true;\\n                pcOptions.disableH264 = this.room.options.p2p && this.room.options.p2p.disableH264;\\n                pcOptions.preferH264 = this.room.options.p2p && this.room.options.p2p.preferH264;\\n\\n                var abtestSuspendVideo = this._abtestSuspendVideoEnabled();\\n\\n                if (typeof abtestSuspendVideo !== 'undefined') {\\n                    pcOptions.abtestSuspendVideo = abtestSuspendVideo;\\n                }\\n            } else {\\n                // H264 does not support simulcast, so it needs to be disabled.\\n                pcOptions.disableSimulcast = this.room.options.disableSimulcast || this.room.options.preferH264 && !this.room.options.disableH264;\\n                pcOptions.preferH264 = this.room.options.preferH264;\\n                pcOptions.enableFirefoxSimulcast = this.room.options.testing && this.room.options.testing.enableFirefoxSimulcast;\\n            }\\n\\n            this.peerconnection = this.rtc.createPeerConnection(this.signalingLayer, this.iceConfig, this.isP2P, pcOptions);\\n\\n            this.peerconnection.onicecandidate = function (ev) {\\n                if (!ev) {\\n                    // There was an incomplete check for ev before which left\\n                    // the last line of the function unprotected from a potential\\n                    // throw of an exception. Consequently, it may be argued that\\n                    // the check is unnecessary. Anyway, I'm leaving it and making\\n                    // the check complete.\\n                    return;\\n                }\\n\\n                // XXX this is broken, candidate is not parsed.\\n                var candidate = ev.candidate;\\n                var now = window.performance.now();\\n\\n                if (candidate) {\\n                    if (_this2._gatheringStartedTimestamp === null) {\\n                        _this2._gatheringStartedTimestamp = now;\\n                    }\\n\\n                    // Discard candidates of disabled protocols.\\n                    var protocol = candidate.protocol;\\n\\n                    if (typeof protocol === 'string') {\\n                        protocol = protocol.toLowerCase();\\n                        if (protocol === 'tcp' || protocol === 'ssltcp') {\\n                            if (_this2.webrtcIceTcpDisable) {\\n                                return;\\n                            }\\n                        } else if (protocol === 'udp') {\\n                            if (_this2.webrtcIceUdpDisable) {\\n                                return;\\n                            }\\n                        }\\n                    }\\n                } else if (!_this2._gatheringReported) {\\n                    // End of gathering\\n                    var eventName = _this2.isP2P ? 'p2p.ice.' : 'ice.';\\n\\n                    eventName += _this2.isInitiator ? 'initiator.' : 'responder.';\\n                    eventName += __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"G\\\" /* _ICE_GATHERING_DURATION */];\\n                    __WEBPACK_IMPORTED_MODULE_11__statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(eventName, { value: now - _this2._gatheringStartedTimestamp });\\n                    _this2._gatheringReported = true;\\n                }\\n                _this2.sendIceCandidate(candidate);\\n            };\\n\\n            // Note there is a change in the spec about closed:\\n            // This value moved into the RTCPeerConnectionState enum in\\n            // the May 13, 2016 draft of the specification, as it reflects the state\\n            // of the RTCPeerConnection, not the signaling connection. You now\\n            // detect a closed connection by checking for connectionState to be\\n            // \\\"closed\\\" instead.\\n            // I suppose at some point this will be moved to onconnectionstatechange\\n            this.peerconnection.onsignalingstatechange = function () {\\n                if (!_this2.peerconnection) {\\n                    return;\\n                }\\n                if (_this2.peerconnection.signalingState === 'stable') {\\n                    _this2.wasstable = true;\\n                } else if ((_this2.peerconnection.signalingState === 'closed' || _this2.peerconnection.connectionState === 'closed') && !_this2.closed) {\\n                    _this2.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.SUSPEND_DETECTED, _this2);\\n                }\\n            };\\n\\n            /**\\n             * The oniceconnectionstatechange event handler contains the code to\\n             * execute when the iceconnectionstatechange event, of type Event,\\n             * is received by this RTCPeerConnection. Such an event is sent when\\n             * the value of RTCPeerConnection.iceConnectionState changes.\\n             */\\n            this.peerconnection.oniceconnectionstatechange = function () {\\n                if (!_this2.peerconnection || !_this2._assertNotEnded('oniceconnectionstatechange')) {\\n                    return;\\n                }\\n                var now = window.performance.now();\\n\\n                if (!_this2.isP2P) {\\n                    _this2.room.connectionTimes['ice.state.' + _this2.peerconnection.iceConnectionState] = now;\\n                }\\n                logger.log('(TIME) ICE ' + _this2.peerconnection.iceConnectionState + (' P2P? ' + _this2.isP2P + ':\\\\t'), now);\\n                var iceConnectionEventName = '' + (_this2.isP2P ? 'p2p.' : '') + __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"E\\\" /* _ICE_CONNECTION_STATE_ */] + '.' + _this2.peerconnection.iceConnectionState;\\n\\n                __WEBPACK_IMPORTED_MODULE_11__statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(iceConnectionEventName, { value: now });\\n                _this2.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.ICE_CONNECTION_STATE_CHANGED, _this2, _this2.peerconnection.iceConnectionState);\\n                switch (_this2.peerconnection.iceConnectionState) {\\n                    case 'checking':\\n                        _this2._iceCheckingStartedTimestamp = now;\\n                        break;\\n                    case 'connected':\\n                        // Informs interested parties that the connection has been\\n                        // restored.\\n                        if (_this2.peerconnection.signalingState === 'stable') {\\n                            if (_this2.isreconnect) {\\n                                _this2.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.CONNECTION_RESTORED, _this2);\\n                            }\\n                        }\\n\\n                        if (!_this2.wasConnected && _this2.wasstable) {\\n                            var eventName = _this2.isP2P ? 'p2p.ice.' : 'ice.';\\n\\n                            eventName += _this2.isInitiator ? 'initiator.' : 'responder.';\\n                            __WEBPACK_IMPORTED_MODULE_11__statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent('' + eventName + __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"D\\\" /* _ICE_CHECKING_DURATION */], {\\n                                value: now - _this2._iceCheckingStartedTimestamp\\n                            });\\n\\n                            // Switch between ICE gathering and ICE checking whichever\\n                            // started first (scenarios are different for initiator\\n                            // vs responder)\\n                            var iceStarted = Math.min(_this2._iceCheckingStartedTimestamp, _this2._gatheringStartedTimestamp);\\n\\n                            _this2.establishmentDuration = now - iceStarted;\\n\\n                            __WEBPACK_IMPORTED_MODULE_11__statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent('' + eventName + __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"F\\\" /* _ICE_ESTABLISHMENT_DURATION */], {\\n                                value: _this2.establishmentDuration\\n                            });\\n                            _this2.wasConnected = true;\\n                            _this2.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.CONNECTION_ESTABLISHED, _this2);\\n                        }\\n                        _this2.isreconnect = false;\\n                        break;\\n                    case 'disconnected':\\n                        if (_this2.closed) {\\n                            break;\\n                        }\\n                        _this2.isreconnect = true;\\n\\n                        // Informs interested parties that the connection has been\\n                        // interrupted.\\n                        if (_this2.wasstable) {\\n                            _this2.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.CONNECTION_INTERRUPTED, _this2);\\n                        }\\n                        break;\\n                    case 'failed':\\n                        _this2.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.CONNECTION_ICE_FAILED, _this2);\\n                        _this2.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.CONFERENCE_SETUP_FAILED, _this2, new Error('ICE fail'));\\n                        break;\\n                }\\n            };\\n            this.peerconnection.onnegotiationneeded = function () {\\n                _this2.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.PEERCONNECTION_READY, _this2);\\n            };\\n\\n            // The signaling layer will bind it's listeners at this point\\n            this.signalingLayer.setChatRoom(this.room);\\n        }\\n\\n        /**\\n         * Sends given candidate in Jingle 'transport-info' message.\\n         * @param {RTCIceCandidate} candidate the WebRTC ICE candidate instance\\n         * @private\\n         */\\n\\n    }, {\\n        key: 'sendIceCandidate',\\n        value: function sendIceCandidate(candidate) {\\n            var _this3 = this;\\n\\n            var localSDP = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](this.peerconnection.localDescription.sdp);\\n\\n            if (candidate && !this.lasticecandidate) {\\n                var ice = __WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].iceparams(localSDP.media[candidate.sdpMLineIndex], localSDP.session);\\n                var jcand = __WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].candidateToJingle(candidate.candidate);\\n\\n                if (!(ice && jcand)) {\\n                    var errorMesssage = 'failed to get ice && jcand';\\n\\n                    __WEBPACK_IMPORTED_MODULE_13__util_GlobalOnErrorHandler___default.a.callErrorHandler(new Error(errorMesssage));\\n                    logger.error(errorMesssage);\\n\\n                    return;\\n                }\\n                ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\\n\\n                if (this.usedrip) {\\n                    if (this.dripContainer.length === 0) {\\n                        // start 20ms callout\\n                        setTimeout(function () {\\n                            if (_this3.dripContainer.length === 0) {\\n                                return;\\n                            }\\n                            _this3.sendIceCandidates(_this3.dripContainer);\\n                            _this3.dripContainer = [];\\n                        }, 20);\\n                    }\\n                    this.dripContainer.push(candidate);\\n                } else {\\n                    this.sendIceCandidates([candidate]);\\n                }\\n            } else {\\n                logger.log('sendIceCandidate: last candidate.');\\n\\n                // FIXME: remember to re-think in ICE-restart\\n                this.lasticecandidate = true;\\n            }\\n        }\\n\\n        /**\\n         * Sends given candidates in Jingle 'transport-info' message.\\n         * @param {Array<RTCIceCandidate>} candidates an array of the WebRTC ICE\\n         * candidate instances\\n         * @private\\n         */\\n\\n    }, {\\n        key: 'sendIceCandidates',\\n        value: function sendIceCandidates(candidates) {\\n            var _this4 = this;\\n\\n            if (!this._assertNotEnded('sendIceCandidates')) {\\n\\n                return;\\n            }\\n\\n            logger.log('sendIceCandidates', candidates);\\n            var cand = Object(__WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"$iq\\\"])({ to: this.remoteJid,\\n                type: 'set' }).c('jingle', { xmlns: 'urn:xmpp:jingle:1',\\n                action: 'transport-info',\\n                initiator: this.initiator,\\n                sid: this.sid });\\n\\n            var localSDP = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](this.peerconnection.localDescription.sdp);\\n\\n            var _loop = function _loop(mid) {\\n                var cands = candidates.filter(function (el) {\\n                    return el.sdpMLineIndex === mid;\\n                });\\n                var mline = __WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].parseMLine(localSDP.media[mid].split('\\\\r\\\\n')[0]);\\n\\n                if (cands.length > 0) {\\n                    var ice = __WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].iceparams(localSDP.media[mid], localSDP.session);\\n\\n                    ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\\n                    cand.c('content', {\\n                        creator: _this4.initiator === _this4.localJid ? 'initiator' : 'responder',\\n                        name: cands[0].sdpMid ? cands[0].sdpMid : mline.media\\n                    }).c('transport', ice);\\n                    for (var i = 0; i < cands.length; i++) {\\n                        var candidate = __WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].candidateToJingle(cands[i].candidate);\\n\\n                        // Mangle ICE candidate if 'failICE' test option is enabled\\n\\n                        if (_this4.failICE) {\\n                            candidate.ip = '1.1.1.1';\\n                        }\\n                        cand.c('candidate', candidate).up();\\n                    }\\n\\n                    // add fingerprint\\n                    var fingerprintLine = __WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].findLine(localSDP.media[mid], 'a=fingerprint:', localSDP.session);\\n\\n                    if (fingerprintLine) {\\n                        var tmp = __WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].parseFingerprint(fingerprintLine);\\n\\n                        tmp.required = true;\\n                        cand.c('fingerprint', { xmlns: 'urn:xmpp:jingle:apps:dtls:0' }).t(tmp.fingerprint);\\n                        delete tmp.fingerprint;\\n                        cand.attrs(tmp);\\n                        cand.up();\\n                    }\\n                    cand.up(); // transport\\n                    cand.up(); // content\\n                }\\n            };\\n\\n            for (var mid = 0; mid < localSDP.media.length; mid++) {\\n                _loop(mid);\\n            }\\n\\n            // might merge last-candidate notification into this, but it is called\\n            // a lot later. See webrtc issue #2340\\n            // logger.log('was this the last candidate', this.lasticecandidate);\\n            this.connection.sendIQ(cand, null, this.newJingleErrorHandler(cand), IQ_TIMEOUT);\\n        }\\n\\n        /**\\n         * {@inheritDoc}\\n         */\\n\\n    }, {\\n        key: 'addIceCandidates',\\n        value: function addIceCandidates(elem) {\\n            var _this5 = this;\\n\\n            if (this.peerconnection.signalingState === 'closed') {\\n                logger.warn('Ignored add ICE candidate when in closed state');\\n\\n                return;\\n            }\\n\\n            var iceCandidates = [];\\n\\n            elem.find('>content>transport>candidate').each(function (idx, candidate) {\\n                var line = __WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].candidateFromJingle(candidate);\\n\\n                line = line.replace('\\\\r\\\\n', '').replace('a=', '');\\n\\n                // FIXME this code does not care to handle\\n                // non-bundle transport\\n                var rtcCandidate = new RTCIceCandidate({\\n                    sdpMLineIndex: 0,\\n\\n                    // FF comes up with more complex names like audio-23423,\\n                    // Given that it works on both Chrome and FF without\\n                    // providing it, let's leave it like this for the time\\n                    // being...\\n                    // sdpMid: 'audio',\\n                    sdpMid: '',\\n                    candidate: line\\n                });\\n\\n                iceCandidates.push(rtcCandidate);\\n            });\\n\\n            if (!iceCandidates.length) {\\n                logger.error('No ICE candidates to add ?', elem[0] && elem[0].outerHTML);\\n\\n                return;\\n            }\\n\\n            // We want to have this task queued, so that we know it is executed,\\n            // after the initial sRD/sLD offer/answer cycle was done (based on\\n            // the assumption that candidates are spawned after the offer/answer\\n            // and XMPP preserves order).\\n            var workFunction = function workFunction(finishedCallback) {\\n                var _iteratorNormalCompletion = true;\\n                var _didIteratorError = false;\\n                var _iteratorError = undefined;\\n\\n                try {\\n                    for (var _iterator = iceCandidates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                        var iceCandidate = _step.value;\\n\\n                        _this5.peerconnection.addIceCandidate(iceCandidate, function () {\\n                            logger.debug('addIceCandidate ok!');\\n                        }, function (error) {\\n                            logger.error('addIceCandidate failed!', error);\\n                        });\\n                    }\\n                } catch (err) {\\n                    _didIteratorError = true;\\n                    _iteratorError = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion && _iterator.return) {\\n                            _iterator.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError) {\\n                            throw _iteratorError;\\n                        }\\n                    }\\n                }\\n\\n                finishedCallback();\\n            };\\n\\n            logger.debug('Queued add (' + iceCandidates.length + ') ICE candidates task...');\\n            this.modificationQueue.push(workFunction);\\n        }\\n\\n        /**\\n         *\\n         * @param contents\\n         */\\n\\n    }, {\\n        key: 'readSsrcInfo',\\n        value: function readSsrcInfo(contents) {\\n            var _this6 = this;\\n\\n            var ssrcs = $(contents).find('>description>' + 'source[xmlns=\\\"urn:xmpp:jingle:apps:rtp:ssma:0\\\"]');\\n\\n            ssrcs.each(function (i, ssrcElement) {\\n                var ssrc = Number(ssrcElement.getAttribute('ssrc'));\\n\\n                if (_this6.isP2P) {\\n                    // In P2P all SSRCs are owner by the remote peer\\n                    _this6.signalingLayer.setSSRCOwner(ssrc, __WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(_this6.remoteJid));\\n                } else {\\n                    $(ssrcElement).find('>ssrc-info[xmlns=\\\"http://jitsi.org/jitmeet\\\"]').each(function (i3, ssrcInfoElement) {\\n                        var owner = ssrcInfoElement.getAttribute('owner');\\n\\n                        if (owner && owner.length) {\\n                            if (isNaN(ssrc) || ssrc < 0) {\\n                                logger.warn('Invalid SSRC ' + ssrc + ' value received' + (' for ' + owner));\\n                            } else {\\n                                _this6.signalingLayer.setSSRCOwner(ssrc, __WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(owner));\\n                            }\\n                        }\\n                    });\\n                }\\n            });\\n        }\\n\\n        /**\\n         * Makes the underlying TraceablePeerConnection generate new SSRC for\\n         * the recvonly video stream.\\n         * @deprecated\\n         */\\n\\n    }, {\\n        key: 'generateRecvonlySsrc',\\n        value: function generateRecvonlySsrc() {\\n            if (this.peerconnection) {\\n                this.peerconnection.generateRecvonlySsrc();\\n            } else {\\n                logger.error('Unable to generate recvonly SSRC - no peerconnection');\\n            }\\n        }\\n\\n        /* eslint-disable max-params */\\n        /**\\n         * Accepts incoming Jingle 'session-initiate' and should send\\n         * 'session-accept' in result.\\n         * @param jingleOffer jQuery selector pointing to the jingle element of\\n         * the offer IQ\\n         * @param success callback called when we accept incoming session\\n         * successfully and receive RESULT packet to 'session-accept' sent.\\n         * @param failure function(error) called if for any reason we fail to accept\\n         * the incoming offer. 'error' argument can be used to log some details\\n         * about the error.\\n         * @param {Array<JitsiLocalTrack>} [localTracks] the optional list of\\n         * the local tracks that will be added, before the offer/answer cycle\\n         * executes. We allow the localTracks to optionally be passed in so that\\n         * the addition of the local tracks and the processing of the initial offer\\n         * can all be done atomically. We want to make sure that any other\\n         * operations which originate in the XMPP Jingle messages related with\\n         * this session to be executed with an assumption that the initial\\n         * offer/answer cycle has been executed already.\\n         */\\n\\n    }, {\\n        key: 'acceptOffer',\\n        value: function acceptOffer(jingleOffer, success, failure, localTracks) {\\n            var _this7 = this;\\n\\n            this.setOfferAnswerCycle(jingleOffer, function () {\\n                // FIXME we may not care about RESULT packet for session-accept\\n                // then we should either call 'success' here immediately or\\n                // modify sendSessionAccept method to do that\\n                _this7.sendSessionAccept(success, failure);\\n            }, failure, localTracks);\\n        }\\n\\n        /* eslint-enable max-params */\\n\\n        /**\\n         * Creates an offer and sends Jingle 'session-initiate' to the remote peer.\\n         * @param {Array<JitsiLocalTrack>} localTracks the local tracks that will be\\n         * added, before the offer/answer cycle executes (for the local track\\n         * addition to be an atomic operation together with the offer/answer).\\n         */\\n\\n    }, {\\n        key: 'invite',\\n        value: function invite(localTracks) {\\n            var _this8 = this;\\n\\n            if (!this.isInitiator) {\\n                throw new Error('Trying to invite from the responder session');\\n            }\\n            var workFunction = function workFunction(finishedCallback) {\\n                var _iteratorNormalCompletion2 = true;\\n                var _didIteratorError2 = false;\\n                var _iteratorError2 = undefined;\\n\\n                try {\\n                    for (var _iterator2 = localTracks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                        var localTrack = _step2.value;\\n\\n                        _this8.peerconnection.addTrack(localTrack);\\n                    }\\n                } catch (err) {\\n                    _didIteratorError2 = true;\\n                    _iteratorError2 = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                            _iterator2.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError2) {\\n                            throw _iteratorError2;\\n                        }\\n                    }\\n                }\\n\\n                _this8.peerconnection.createOffer(function (offerSdp) {\\n                    _this8.peerconnection.setLocalDescription(offerSdp, function () {\\n                        // NOTE that the offer is obtained from\\n                        // the localDescription getter as it needs to go\\n                        // though the transformation chain.\\n                        _this8.sendSessionInitiate(_this8.peerconnection.localDescription.sdp);\\n                        finishedCallback();\\n                    }, function (error) {\\n                        logger.error('Failed to set local SDP', error, offerSdp);\\n                        finishedCallback(error);\\n                    });\\n                }, function (error) {\\n                    logger.error('Failed to create an offer', error, _this8.mediaConstraints);\\n                    finishedCallback(error);\\n                }, _this8.mediaConstraints);\\n            };\\n\\n            this.modificationQueue.push(workFunction, function (error) {\\n                if (error) {\\n                    logger.error('invite error', error);\\n                } else {\\n                    logger.debug('invite executed - OK');\\n                }\\n            });\\n        }\\n\\n        /**\\n         * Sends 'session-initiate' to the remote peer.\\n         *\\n         * NOTE this method is synchronous and we're not waiting for the RESULT\\n         * response which would delay the startup process.\\n         *\\n         * @param {string} offerSdp  - The local session description which will be\\n         * used to generate an offer.\\n         * @private\\n         */\\n\\n    }, {\\n        key: 'sendSessionInitiate',\\n        value: function sendSessionInitiate(offerSdp) {\\n            var init = Object(__WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"$iq\\\"])({\\n                to: this.remoteJid,\\n                type: 'set'\\n            }).c('jingle', {\\n                xmlns: 'urn:xmpp:jingle:1',\\n                action: 'session-initiate',\\n                initiator: this.initiator,\\n                sid: this.sid\\n            });\\n\\n            new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](offerSdp).toJingle(init, this.initiator === this.me ? 'initiator' : 'responder');\\n            init = init.tree();\\n            logger.info('Session-initiate: ', init);\\n            this.connection.sendIQ(init, function () {\\n                logger.info('Got RESULT for \\\"session-initiate\\\"');\\n            }, function (error) {\\n                logger.error('\\\"session-initiate\\\" error', error);\\n            }, IQ_TIMEOUT);\\n        }\\n\\n        /**\\n         * Sets the answer received from the remote peer.\\n         * @param jingleAnswer\\n         */\\n\\n    }, {\\n        key: 'setAnswer',\\n        value: function setAnswer(jingleAnswer) {\\n            if (!this.isInitiator) {\\n                throw new Error('Trying to set an answer on the responder session');\\n            }\\n            this.setOfferAnswerCycle(jingleAnswer, function () {\\n                logger.info('setAnswer - succeeded');\\n            }, function (error) {\\n                logger.error('setAnswer failed: ', error);\\n            });\\n        }\\n\\n        /* eslint-disable max-params */\\n        /**\\n         * This is a setRemoteDescription/setLocalDescription cycle which starts at\\n         * converting Strophe Jingle IQ into remote offer SDP. Once converted\\n         * setRemoteDescription, createAnswer and setLocalDescription calls follow.\\n         * @param jingleOfferAnswerIq jQuery selector pointing to the jingle element\\n         *        of the offer (or answer) IQ\\n         * @param success callback called when sRD/sLD cycle finishes successfully.\\n         * @param failure callback called with an error object as an argument if we\\n         *        fail at any point during setRD, createAnswer, setLD.\\n         * @param {Array<JitsiLocalTrack>} [localTracks] the optional list of\\n         * the local tracks that will be added, before the offer/answer cycle\\n         * executes (for the local track addition to be an atomic operation together\\n         * with the offer/answer).\\n         */\\n\\n    }, {\\n        key: 'setOfferAnswerCycle',\\n        value: function setOfferAnswerCycle(jingleOfferAnswerIq, success, failure, localTracks) {\\n            var _this9 = this;\\n\\n            var workFunction = function workFunction(finishedCallback) {\\n\\n                if (localTracks) {\\n                    var _iteratorNormalCompletion3 = true;\\n                    var _didIteratorError3 = false;\\n                    var _iteratorError3 = undefined;\\n\\n                    try {\\n                        for (var _iterator3 = localTracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n                            var track = _step3.value;\\n\\n                            _this9.peerconnection.addTrack(track);\\n                        }\\n                    } catch (err) {\\n                        _didIteratorError3 = true;\\n                        _iteratorError3 = err;\\n                    } finally {\\n                        try {\\n                            if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                                _iterator3.return();\\n                            }\\n                        } finally {\\n                            if (_didIteratorError3) {\\n                                throw _iteratorError3;\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                var newRemoteSdp = _this9._processNewJingleOfferIq(jingleOfferAnswerIq);\\n                var oldLocalSdp = _this9.peerconnection.localDescription.sdp;\\n\\n                _this9._renegotiate(newRemoteSdp.raw).then(function () {\\n                    if (_this9.state === __WEBPACK_IMPORTED_MODULE_6__JingleSessionState__[\\\"c\\\" /* PENDING */]) {\\n                        _this9.state = __WEBPACK_IMPORTED_MODULE_6__JingleSessionState__[\\\"a\\\" /* ACTIVE */];\\n\\n                        // Sync up video transfer active/inactive only after\\n                        // the initial O/A cycle. We want to adjust the video\\n                        // media direction only in the local SDP and the Jingle\\n                        // contents direction included in the initial\\n                        // offer/answer is mapped to the remote SDP. Jingle\\n                        // 'content-modify' IQ is processed in a way that it\\n                        // will only modify local SDP when remote peer is no\\n                        // longer interested in receiving video content.\\n                        // Changing media direction in the remote SDP will mess\\n                        // up our SDP translation chain (simulcast, video mute,\\n                        // RTX etc.)\\n                        if (_this9.isP2P && !_this9._localVideoActive) {\\n                            _this9.sendContentModify(_this9._localVideoActive);\\n                        }\\n                    }\\n\\n                    // Old local SDP will be available when we're setting answer\\n                    // for the first time, but not when offer and it's fine\\n                    // since we're generating an answer now it will contain all\\n                    // our SSRCs\\n                    if (oldLocalSdp) {\\n                        var newLocalSdp = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](_this9.peerconnection.localDescription.sdp);\\n\\n                        _this9.notifyMySSRCUpdate(new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](oldLocalSdp), newLocalSdp);\\n                    }\\n\\n                    finishedCallback();\\n                }, function (error) {\\n                    logger.error('Error renegotiating after setting new remote ' + (_this9.isInitiator ? 'answer: ' : 'offer: ') + error, newRemoteSdp);\\n                    JingleSessionPC.onJingleFatalError(_this9, error);\\n                    finishedCallback(error);\\n                });\\n            };\\n\\n            this.modificationQueue.push(workFunction, function (error) {\\n                error ? failure(error) : success();\\n            });\\n        }\\n\\n        /* eslint-enable max-params */\\n\\n        /**\\n         * Although it states \\\"replace transport\\\" it does accept full Jingle offer\\n         * which should contain new ICE transport details.\\n         * @param jingleOfferElem an element Jingle IQ that contains new offer and\\n         *        transport info.\\n         * @param success callback called when we succeed to accept new offer.\\n         * @param failure function(error) called when we fail to accept new offer.\\n         */\\n\\n    }, {\\n        key: 'replaceTransport',\\n        value: function replaceTransport(jingleOfferElem, success, failure) {\\n            var _this10 = this;\\n\\n            // We need to first set an offer without the 'data' section to have the\\n            // SCTP stack cleaned up. After that the original offer is set to have\\n            // the SCTP connection established with the new bridge.\\n            this.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.ICE_RESTARTING, this);\\n            var originalOffer = jingleOfferElem.clone();\\n\\n            jingleOfferElem.find('>content[name=\\\\'data\\\\']').remove();\\n\\n            // First set an offer without the 'data' section\\n            this.setOfferAnswerCycle(jingleOfferElem, function () {\\n                // Now set the original offer(with the 'data' section)\\n                _this10.setOfferAnswerCycle(originalOffer, function () {\\n                    var localSDP = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](_this10.peerconnection.localDescription.sdp);\\n\\n                    _this10.sendTransportAccept(localSDP, success, failure);\\n                }, failure);\\n            }, failure);\\n        }\\n\\n        /**\\n         * Sends Jingle 'session-accept' message.\\n         * @param {function()} success callback called when we receive 'RESULT'\\n         *        packet for the 'session-accept'\\n         * @param {function(error)} failure called when we receive an error response\\n         *        or when the request has timed out.\\n         * @private\\n         */\\n\\n    }, {\\n        key: 'sendSessionAccept',\\n        value: function sendSessionAccept(success, failure) {\\n            var _this11 = this;\\n\\n            // NOTE: since we're just reading from it, we don't need to be within\\n            //  the modification queue to access the local description\\n            var localSDP = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](this.peerconnection.localDescription.sdp);\\n            var accept = Object(__WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"$iq\\\"])({ to: this.remoteJid,\\n                type: 'set' }).c('jingle', { xmlns: 'urn:xmpp:jingle:1',\\n                action: 'session-accept',\\n                initiator: this.initiator,\\n                responder: this.responder,\\n                sid: this.sid });\\n\\n            if (this.webrtcIceTcpDisable) {\\n                localSDP.removeTcpCandidates = true;\\n            }\\n            if (this.webrtcIceUdpDisable) {\\n                localSDP.removeUdpCandidates = true;\\n            }\\n            if (this.failICE) {\\n                localSDP.failICE = true;\\n            }\\n            localSDP.toJingle(accept, this.initiator === this.localJid ? 'initiator' : 'responder', null);\\n\\n            // Calling tree() to print something useful\\n            accept = accept.tree();\\n            logger.info('Sending session-accept', accept);\\n            this.connection.sendIQ(accept, success, this.newJingleErrorHandler(accept, function (error) {\\n                failure(error);\\n\\n                // 'session-accept' is a critical timeout and we'll\\n                // have to restart\\n                _this11.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.SESSION_ACCEPT_TIMEOUT, _this11);\\n            }), IQ_TIMEOUT);\\n\\n            // XXX Videobridge needs WebRTC's answer (ICE ufrag and pwd, DTLS\\n            // fingerprint and setup) ASAP in order to start the connection\\n            // establishment.\\n            //\\n            // FIXME Flushing the connection at this point triggers an issue with\\n            // BOSH request handling in Prosody on slow connections.\\n            //\\n            // The problem is that this request will be quite large and it may take\\n            // time before it reaches Prosody. In the meantime Strophe may decide\\n            // to send the next one. And it was observed that a small request with\\n            // 'transport-info' usually follows this one. It does reach Prosody\\n            // before the previous one was completely received. 'rid' on the server\\n            // is increased and Prosody ignores the request with 'session-accept'.\\n            // It will never reach Jicofo and everything in the request table is\\n            // lost. Removing the flush does not guarantee it will never happen, but\\n            // makes it much less likely('transport-info' is bundled with\\n            // 'session-accept' and any immediate requests).\\n            //\\n            // this.connection.flush();\\n        }\\n\\n        /**\\n         * Will send 'content-modify' IQ in order to ask the remote peer to\\n         * either stop or resume sending video media.\\n         * @param {boolean} videoTransferActive <tt>false</tt> to let the other peer\\n         * know that we're not sending nor interested in receiving video contents.\\n         * When set to <tt>true</tt> remote peer will be asked to resume video\\n         * transfer.\\n         * @private\\n         */\\n\\n    }, {\\n        key: 'sendContentModify',\\n        value: function sendContentModify(videoTransferActive) {\\n            var newSendersValue = videoTransferActive ? 'both' : 'none';\\n\\n            var sessionModify = Object(__WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"$iq\\\"])({\\n                to: this.remoteJid,\\n                type: 'set'\\n            }).c('jingle', {\\n                xmlns: 'urn:xmpp:jingle:1',\\n                action: 'content-modify',\\n                initiator: this.initiator,\\n                sid: this.sid\\n            }).c('content', {\\n                name: 'video',\\n                senders: newSendersValue\\n            });\\n\\n            logger.info('Sending content-modify, video senders: ' + newSendersValue);\\n\\n            this.connection.sendIQ(sessionModify, null, this.newJingleErrorHandler(sessionModify), IQ_TIMEOUT);\\n        }\\n\\n        /**\\n         * Sends Jingle 'transport-accept' message which is a response to\\n         * 'transport-replace'.\\n         * @param localSDP the 'SDP' object with local session description\\n         * @param success callback called when we receive 'RESULT' packet for\\n         *        'transport-replace'\\n         * @param failure function(error) called when we receive an error response\\n         *        or when the request has timed out.\\n         * @private\\n         */\\n\\n    }, {\\n        key: 'sendTransportAccept',\\n        value: function sendTransportAccept(localSDP, success, failure) {\\n            var _this12 = this;\\n\\n            var transportAccept = Object(__WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"$iq\\\"])({ to: this.remoteJid,\\n                type: 'set' }).c('jingle', {\\n                xmlns: 'urn:xmpp:jingle:1',\\n                action: 'transport-accept',\\n                initiator: this.initiator,\\n                sid: this.sid\\n            });\\n\\n            localSDP.media.forEach(function (medialines, idx) {\\n                var mline = __WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].parseMLine(medialines.split('\\\\r\\\\n')[0]);\\n\\n                transportAccept.c('content', {\\n                    creator: _this12.initiator === _this12.localJid ? 'initiator' : 'responder',\\n                    name: mline.media\\n                });\\n                localSDP.transportToJingle(idx, transportAccept);\\n                transportAccept.up();\\n            });\\n\\n            // Calling tree() to print something useful to the logger\\n            transportAccept = transportAccept.tree();\\n            logger.info('Sending transport-accept: ', transportAccept);\\n\\n            this.connection.sendIQ(transportAccept, success, this.newJingleErrorHandler(transportAccept, failure), IQ_TIMEOUT);\\n        }\\n\\n        /**\\n         * Sends Jingle 'transport-reject' message which is a response to\\n         * 'transport-replace'.\\n         * @param success callback called when we receive 'RESULT' packet for\\n         *        'transport-replace'\\n         * @param failure function(error) called when we receive an error response\\n         *        or when the request has timed out.\\n         *\\n         * FIXME method should be marked as private, but there's some spaghetti that\\n         *       needs to be fixed prior doing that\\n         */\\n\\n    }, {\\n        key: 'sendTransportReject',\\n        value: function sendTransportReject(success, failure) {\\n            // Send 'transport-reject', so that the focus will\\n            // know that we've failed\\n            var transportReject = Object(__WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"$iq\\\"])({ to: this.remoteJid,\\n                type: 'set' }).c('jingle', {\\n                xmlns: 'urn:xmpp:jingle:1',\\n                action: 'transport-reject',\\n                initiator: this.initiator,\\n                sid: this.sid\\n            });\\n\\n            transportReject = transportReject.tree();\\n            logger.info('Sending \\\\'transport-reject', transportReject);\\n\\n            this.connection.sendIQ(transportReject, success, this.newJingleErrorHandler(transportReject, failure), IQ_TIMEOUT);\\n        }\\n\\n        /**\\n         * @inheritDoc\\n         */\\n\\n    }, {\\n        key: 'terminate',\\n        value: function terminate(success, failure, options) {\\n            if (this.state === __WEBPACK_IMPORTED_MODULE_6__JingleSessionState__[\\\"b\\\" /* ENDED */]) {\\n                return;\\n            }\\n\\n            if (!options || Boolean(options.sendSessionTerminate)) {\\n                var sessionTerminate = Object(__WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"$iq\\\"])({\\n                    to: this.remoteJid,\\n                    type: 'set'\\n                }).c('jingle', {\\n                    xmlns: 'urn:xmpp:jingle:1',\\n                    action: 'session-terminate',\\n                    initiator: this.initiator,\\n                    sid: this.sid\\n                }).c('reason').c(options && options.reason || 'success');\\n\\n                if (options && options.reasonDescription) {\\n                    sessionTerminate.up().c('text').t(options.reasonDescription);\\n                }\\n\\n                // Calling tree() to print something useful\\n                sessionTerminate = sessionTerminate.tree();\\n                logger.info('Sending session-terminate', sessionTerminate);\\n                this.connection.sendIQ(sessionTerminate, success, this.newJingleErrorHandler(sessionTerminate, failure), IQ_TIMEOUT);\\n            } else {\\n                logger.info('Skipped sending session-terminate for ' + this);\\n            }\\n\\n            // this should result in 'onTerminated' being called by strope.jingle.js\\n            this.connection.jingle.terminate(this.sid);\\n        }\\n\\n        /**\\n         *\\n         * @param reasonCondition\\n         * @param reasonText\\n         */\\n\\n    }, {\\n        key: 'onTerminated',\\n        value: function onTerminated(reasonCondition, reasonText) {\\n            this.state = __WEBPACK_IMPORTED_MODULE_6__JingleSessionState__[\\\"b\\\" /* ENDED */];\\n            this.establishmentDuration = undefined;\\n\\n            // Do something with reason and reasonCondition when we start to care\\n            // this.reasonCondition = reasonCondition;\\n            // this.reasonText = reasonText;\\n            logger.info('Session terminated ' + this, reasonCondition, reasonText);\\n\\n            this.close();\\n        }\\n\\n        /**\\n         * Parse the information from the xml sourceAddElem and translate it\\n         *  into sdp lines\\n         * @param {jquery xml element} sourceAddElem the source-add\\n         *  element from jingle\\n         * @param {SDP object} currentRemoteSdp the current remote\\n         *  sdp (as of this new source-add)\\n         * @returns {list} a list of SDP line strings that should\\n         *  be added to the remote SDP\\n         */\\n\\n    }, {\\n        key: '_parseSsrcInfoFromSourceAdd',\\n        value: function _parseSsrcInfoFromSourceAdd(sourceAddElem, currentRemoteSdp) {\\n            var addSsrcInfo = [];\\n\\n            $(sourceAddElem).each(function (i1, content) {\\n                var name = $(content).attr('name');\\n                var lines = '';\\n\\n                $(content).find('ssrc-group[xmlns=\\\"urn:xmpp:jingle:apps:rtp:ssma:0\\\"]').each(function () {\\n                    // eslint-disable-next-line no-invalid-this\\n                    var semantics = this.getAttribute('semantics');\\n                    var ssrcs = $(this) // eslint-disable-line no-invalid-this\\n                    .find('>source').map(function () {\\n                        // eslint-disable-next-line no-invalid-this\\n                        return this.getAttribute('ssrc');\\n                    }).get();\\n\\n                    if (ssrcs.length) {\\n                        lines += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\\\\r\\\\n';\\n                    }\\n                });\\n\\n                // handles both >source and >description>source\\n                var tmp = $(content).find('source[xmlns=\\\"urn:xmpp:jingle:apps:rtp:ssma:0\\\"]');\\n\\n                /* eslint-disable no-invalid-this */\\n                tmp.each(function () {\\n                    var ssrc = $(this).attr('ssrc');\\n\\n                    if (currentRemoteSdp.containsSSRC(ssrc)) {\\n                        logger.warn('Source-add request for existing SSRC: ' + ssrc);\\n\\n                        return;\\n                    }\\n\\n                    // eslint-disable-next-line newline-per-chained-call\\n                    $(this).find('>parameter').each(function () {\\n                        lines += 'a=ssrc:' + ssrc + ' ' + $(this).attr('name');\\n                        if ($(this).attr('value') && $(this).attr('value').length) {\\n                            lines += ':' + $(this).attr('value');\\n                        }\\n                        lines += '\\\\r\\\\n';\\n                    });\\n                });\\n\\n                /* eslint-enable no-invalid-this */\\n                currentRemoteSdp.media.forEach(function (media, i2) {\\n                    if (!__WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].findLine(media, 'a=mid:' + name)) {\\n                        return;\\n                    }\\n                    if (!addSsrcInfo[i2]) {\\n                        addSsrcInfo[i2] = '';\\n                    }\\n                    addSsrcInfo[i2] += lines;\\n                });\\n            });\\n\\n            return addSsrcInfo;\\n        }\\n\\n        /**\\n         * Handles a Jingle source-add message for this Jingle session.\\n         * @param elem An array of Jingle \\\"content\\\" elements.\\n         */\\n\\n    }, {\\n        key: 'addRemoteStream',\\n        value: function addRemoteStream(elem) {\\n            this._addOrRemoveRemoteStream(true /* add */, elem);\\n        }\\n\\n        /**\\n         * Handles a Jingle source-remove message for this Jingle session.\\n         * @param elem An array of Jingle \\\"content\\\" elements.\\n         */\\n\\n    }, {\\n        key: 'removeRemoteStream',\\n        value: function removeRemoteStream(elem) {\\n            this._addOrRemoveRemoteStream(false /* remove */, elem);\\n        }\\n\\n        /**\\n         * Handles either Jingle 'source-add' or 'source-remove' message for this\\n         * Jingle session.\\n         * @param {boolean} isAdd <tt>true</tt> for 'source-add' or <tt>false</tt>\\n         * otherwise.\\n         * @param {Array<Element>} elem an array of Jingle \\\"content\\\" elements.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_addOrRemoveRemoteStream',\\n        value: function _addOrRemoveRemoteStream(isAdd, elem) {\\n            var _this13 = this;\\n\\n            var logPrefix = isAdd ? 'addRemoteStream' : 'removeRemoteStream';\\n\\n            if (isAdd) {\\n                this.readSsrcInfo(elem);\\n            }\\n\\n            var workFunction = function workFunction(finishedCallback) {\\n                if (!_this13.peerconnection.localDescription || !_this13.peerconnection.localDescription.sdp) {\\n                    var errMsg = logPrefix + ' - localDescription not ready yet';\\n\\n                    logger.error(errMsg);\\n                    finishedCallback(errMsg);\\n\\n                    return;\\n                }\\n\\n                logger.log('Processing ' + logPrefix);\\n                logger.log('ICE connection state: ', _this13.peerconnection.iceConnectionState);\\n\\n                var oldLocalSdp = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](_this13.peerconnection.localDescription.sdp);\\n                var sdp = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](_this13.peerconnection.remoteDescription.sdp);\\n                var addOrRemoveSsrcInfo = isAdd ? _this13._parseSsrcInfoFromSourceAdd(elem, sdp) : _this13._parseSsrcInfoFromSourceRemove(elem, sdp);\\n                var newRemoteSdp = isAdd ? _this13._processRemoteAddSource(addOrRemoveSsrcInfo) : _this13._processRemoteRemoveSource(addOrRemoveSsrcInfo);\\n\\n                _this13._renegotiate(newRemoteSdp.raw).then(function () {\\n                    var newLocalSdp = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](_this13.peerconnection.localDescription.sdp);\\n\\n                    logger.log(logPrefix + ' - OK, SDPs: ', oldLocalSdp, newLocalSdp);\\n                    _this13.notifyMySSRCUpdate(oldLocalSdp, newLocalSdp);\\n                    finishedCallback();\\n                }, function (error) {\\n                    logger.error(logPrefix + ' failed:', error);\\n                    finishedCallback(error);\\n                });\\n            };\\n\\n            // Queue and execute\\n            this.modificationQueue.push(workFunction);\\n        }\\n\\n        /**\\n         * The 'task' function will be given a callback it MUST call with either:\\n         *  1) No arguments if it was successful or\\n         *  2) An error argument if there was an error\\n         * If the task wants to process the success or failure of the task, it\\n         * should pass a handler to the .push function, e.g.:\\n         * queue.push(task, (err) => {\\n         *     if (err) {\\n         *         // error handling\\n         *     } else {\\n         *         // success handling\\n         *     }\\n         * });\\n         */\\n\\n    }, {\\n        key: '_processQueueTasks',\\n        value: function _processQueueTasks(task, finishedCallback) {\\n            task(finishedCallback);\\n        }\\n\\n        /**\\n         * Takes in a jingle offer iq, returns the new sdp offer\\n         * @param {jquery xml element} offerIq the incoming offer\\n         * @returns {SDP object} the jingle offer translated to SDP\\n         */\\n\\n    }, {\\n        key: '_processNewJingleOfferIq',\\n        value: function _processNewJingleOfferIq(offerIq) {\\n            var remoteSdp = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */]('');\\n\\n            if (this.webrtcIceTcpDisable) {\\n                remoteSdp.removeTcpCandidates = true;\\n            }\\n            if (this.webrtcIceUdpDisable) {\\n                remoteSdp.removeUdpCandidates = true;\\n            }\\n            if (this.failICE) {\\n                remoteSdp.failICE = true;\\n            }\\n\\n            remoteSdp.fromJingle(offerIq);\\n            this.readSsrcInfo($(offerIq).find('>content'));\\n\\n            return remoteSdp;\\n        }\\n\\n        /**\\n         * Remove the given ssrc lines from the current remote sdp\\n         * @param {list} removeSsrcInfo a list of SDP line strings that\\n         *  should be removed from the remote SDP\\n         * @returns type {SDP Object} the new remote SDP (after removing the lines\\n         *  in removeSsrcInfo\\n         */\\n\\n    }, {\\n        key: '_processRemoteRemoveSource',\\n        value: function _processRemoteRemoveSource(removeSsrcInfo) {\\n            var remoteSdp = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](this.peerconnection.remoteDescription.sdp);\\n\\n            removeSsrcInfo.forEach(function (lines, idx) {\\n                // eslint-disable-next-line no-param-reassign\\n                lines = lines.split('\\\\r\\\\n');\\n                lines.pop(); // remove empty last element;\\n                lines.forEach(function (line) {\\n                    remoteSdp.media[idx] = remoteSdp.media[idx].replace(line + '\\\\r\\\\n', '');\\n                });\\n            });\\n            remoteSdp.raw = remoteSdp.session + remoteSdp.media.join('');\\n\\n            return remoteSdp;\\n        }\\n\\n        /**\\n         * Add the given ssrc lines to the current remote sdp\\n         * @param {list} addSsrcInfo a list of SDP line strings that\\n         *  should be added to the remote SDP\\n         * @returns type {SDP Object} the new remote SDP (after removing the lines\\n         *  in removeSsrcInfo\\n         */\\n\\n    }, {\\n        key: '_processRemoteAddSource',\\n        value: function _processRemoteAddSource(addSsrcInfo) {\\n            var remoteSdp = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](this.peerconnection.remoteDescription.sdp);\\n\\n            addSsrcInfo.forEach(function (lines, idx) {\\n                remoteSdp.media[idx] += lines;\\n            });\\n            remoteSdp.raw = remoteSdp.session + remoteSdp.media.join('');\\n\\n            return remoteSdp;\\n        }\\n\\n        /**\\n         * Do a new o/a flow using the existing remote description\\n         * @param {string} [optionalRemoteSdp] optional, raw remote sdp\\n         *  to use.  If not provided, the remote sdp from the\\n         *  peerconnection will be used\\n         * @returns {Promise} promise which resolves when the\\n         *  o/a flow is complete with no arguments or\\n         *  rejects with an error {string}\\n         */\\n\\n    }, {\\n        key: '_renegotiate',\\n        value: function _renegotiate(optionalRemoteSdp) {\\n            var _this14 = this;\\n\\n            var remoteSdp = optionalRemoteSdp || this.peerconnection.remoteDescription.sdp;\\n\\n            if (!remoteSdp) {\\n                return Promise.reject('Can not renegotiate without remote description,' + ('- current state: ' + this.state));\\n            }\\n\\n            var remoteDescription = new RTCSessionDescription({\\n                type: this.isInitiator ? 'answer' : 'offer',\\n                sdp: remoteSdp\\n            });\\n\\n            return new Promise(function (resolve, reject) {\\n                if (_this14.peerconnection.signalingState === 'closed') {\\n                    reject('Attempted to renegotiate in state closed');\\n\\n                    return;\\n                }\\n                if (_this14.isInitiator) {\\n                    _this14._initiatorRenegotiate(remoteDescription, resolve, reject);\\n                } else {\\n                    _this14._responderRenegotiate(remoteDescription, resolve, reject);\\n                }\\n            });\\n        }\\n\\n        /**\\n         * Renegotiate cycle implementation for the responder case.\\n         * @param {object} remoteDescription the SDP object as defined by the WebRTC\\n         * which will be used as remote description in the cycle.\\n         * @param {function} resolve the success callback\\n         * @param {function} reject the failure callback\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_responderRenegotiate',\\n        value: function _responderRenegotiate(remoteDescription, resolve, reject) {\\n            var _this15 = this;\\n\\n            // FIXME use WebRTC promise API to simplify things\\n            logger.debug('Renegotiate: setting remote description');\\n            this.peerconnection.setRemoteDescription(remoteDescription, function () {\\n                logger.debug('Renegotiate: creating answer');\\n                _this15.peerconnection.createAnswer(function (answer) {\\n                    logger.debug('Renegotiate: setting local description');\\n                    _this15.peerconnection.setLocalDescription(answer, function () {\\n                        resolve();\\n                    }, function (error) {\\n                        reject('setLocalDescription failed: ' + error);\\n                    });\\n                }, function (error) {\\n                    return reject('createAnswer failed: ' + error);\\n                }, _this15.mediaConstraints);\\n            }, function (error) {\\n                return reject('setRemoteDescription failed: ' + error);\\n            });\\n        }\\n\\n        /**\\n         * Renegotiate cycle implementation for the initiator's case.\\n         * @param {object} remoteDescription the SDP object as defined by the WebRTC\\n         * which will be used as remote description in the cycle.\\n         * @param {function} resolve the success callback\\n         * @param {function} reject the failure callback\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_initiatorRenegotiate',\\n        value: function _initiatorRenegotiate(remoteDescription, resolve, reject) {\\n            var _this16 = this;\\n\\n            // FIXME use WebRTC promise API to simplify things\\n            if (this.peerconnection.signalingState === 'have-local-offer') {\\n\\n                // Skip createOffer and setLocalDescription or FF will fail\\n                logger.debug('Renegotiate: setting remote description');\\n                this.peerconnection.setRemoteDescription(remoteDescription, function () {\\n                    // In case when the answer is being set for the first time,\\n                    // full sRD/sLD cycle is required to have the local\\n                    // description updated and SSRCs synchronized correctly.\\n                    // Otherwise SSRCs for streams added after invite, but\\n                    // before the answer was accepted will not be detected.\\n                    // The reason for that is that renegotiate can not be called\\n                    // when adding tracks and they will not be reflected in\\n                    // the local SDP.\\n                    _this16._initiatorRenegotiate(remoteDescription, resolve, reject);\\n                }, function (error) {\\n                    return reject('setRemoteDescription failed: ' + error);\\n                });\\n            } else {\\n                logger.debug('Renegotiate: creating offer');\\n                this.peerconnection.createOffer(function (offer) {\\n                    logger.debug('Renegotiate: setting local description');\\n                    _this16.peerconnection.setLocalDescription(offer, function () {\\n                        logger.debug('Renegotiate: setting remote description');\\n                        _this16.peerconnection.setRemoteDescription(remoteDescription, function () {\\n                            resolve();\\n                        }, function (error) {\\n                            return reject('setRemoteDescription failed: ' + error);\\n                        });\\n                    }, function (error) {\\n                        reject('setLocalDescription failed: ', error);\\n                    });\\n                }, function (error) {\\n                    return reject('createOffer failed: ' + error);\\n                }, this.mediaConstraints);\\n            }\\n        }\\n\\n        /**\\n         * Replaces <tt>oldTrack</tt> with <tt>newTrack</tt> and performs a single\\n         * offer/answer cycle after both operations are done. Either\\n         * <tt>oldTrack</tt> or <tt>newTrack</tt> can be null; replacing a valid\\n         * <tt>oldTrack</tt> with a null <tt>newTrack</tt> effectively just removes\\n         * <tt>oldTrack</tt>\\n         * @param {JitsiLocalTrack|null} oldTrack the current track in use to be\\n         * replaced\\n         * @param {JitsiLocalTrack|null} newTrack the new track to use\\n         * @returns {Promise} which resolves once the replacement is complete\\n         *  with no arguments or rejects with an error {string}\\n         */\\n\\n    }, {\\n        key: 'replaceTrack',\\n        value: function replaceTrack(oldTrack, newTrack) {\\n            var _this17 = this;\\n\\n            var workFunction = function workFunction(finishedCallback) {\\n                // Check if the connection was closed and pretend everything is OK.\\n                // This can happen if a track removal is scheduled but takes place\\n                // after the connection is closed.\\n                if (_this17.peerconnection.signalingState === 'closed' || _this17.peerconnection.connectionState === 'closed' || _this17.closed) {\\n\\n                    finishedCallback();\\n\\n                    return;\\n                }\\n\\n                var oldLocalSdp = _this17.peerconnection.localDescription.sdp;\\n\\n                // NOTE the code below assumes that no more than 1 video track\\n                // can be added to the peer connection.\\n                // Transition from no video to video (possibly screen sharing)\\n                if (!oldTrack && newTrack && newTrack.isVideoTrack()) {\\n                    // Clearing current primary SSRC will make\\n                    // the SdpConsistency generate a new one which will result\\n                    // with:\\n                    // 1. source-remove for the recvonly\\n                    // 2. source-add for the new video stream\\n                    _this17.peerconnection.clearRecvonlySsrc();\\n\\n                    // Transition from video to no video\\n                } else if (oldTrack && oldTrack.isVideoTrack() && !newTrack) {\\n                    // Clearing current primary SSRC and generating the recvonly\\n                    // will result in:\\n                    // 1. source-remove for the old video stream\\n                    // 2. source-add for the recvonly stream\\n                    _this17.peerconnection.clearRecvonlySsrc();\\n                    _this17.peerconnection.generateRecvonlySsrc();\\n                }\\n                if (oldTrack) {\\n                    _this17.peerconnection.removeTrack(oldTrack);\\n                }\\n                if (newTrack) {\\n                    _this17.peerconnection.addTrack(newTrack);\\n                }\\n\\n                if ((oldTrack || newTrack) && _this17.state === __WEBPACK_IMPORTED_MODULE_6__JingleSessionState__[\\\"a\\\" /* ACTIVE */]) {\\n                    _this17._renegotiate().then(function () {\\n                        var newLocalSDP = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](_this17.peerconnection.localDescription.sdp);\\n\\n                        _this17.notifyMySSRCUpdate(new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](oldLocalSdp), newLocalSDP);\\n                        finishedCallback();\\n                    }, finishedCallback /* will be called with en error */);\\n                } else {\\n                    finishedCallback();\\n                }\\n            };\\n\\n            this.modificationQueue.push(workFunction, function (error) {\\n                if (error) {\\n                    logger.error('Replace track error:', error);\\n                } else {\\n                    logger.info('Replace track done!');\\n                }\\n            });\\n        }\\n\\n        /**\\n         * Parse the information from the xml sourceRemoveElem and translate it\\n         *  into sdp lines\\n         * @param {jquery xml element} sourceRemoveElem the source-remove\\n         *  element from jingle\\n         * @param {SDP object} currentRemoteSdp the current remote\\n         *  sdp (as of this new source-remove)\\n         * @returns {list} a list of SDP line strings that should\\n         *  be removed from the remote SDP\\n         */\\n\\n    }, {\\n        key: '_parseSsrcInfoFromSourceRemove',\\n        value: function _parseSsrcInfoFromSourceRemove(sourceRemoveElem, currentRemoteSdp) {\\n            var removeSsrcInfo = [];\\n\\n            $(sourceRemoveElem).each(function (i1, content) {\\n                var name = $(content).attr('name');\\n                var lines = '';\\n\\n                $(content).find('ssrc-group[xmlns=\\\"urn:xmpp:jingle:apps:rtp:ssma:0\\\"]').each(function () {\\n                    /* eslint-disable no-invalid-this */\\n                    var semantics = this.getAttribute('semantics');\\n                    var ssrcs = $(this).find('>source').map(function () {\\n                        return this.getAttribute('ssrc');\\n                    }).get();\\n\\n                    if (ssrcs.length) {\\n                        lines += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\\\\r\\\\n';\\n                    }\\n\\n                    /* eslint-enable no-invalid-this */\\n                });\\n                var ssrcs = [];\\n\\n                // handles both >source and >description>source versions\\n                var tmp = $(content).find('source[xmlns=\\\"urn:xmpp:jingle:apps:rtp:ssma:0\\\"]');\\n\\n                tmp.each(function () {\\n                    // eslint-disable-next-line no-invalid-this\\n                    var ssrc = $(this).attr('ssrc');\\n\\n                    ssrcs.push(ssrc);\\n                });\\n                currentRemoteSdp.media.forEach(function (media, i2) {\\n                    if (!__WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].findLine(media, 'a=mid:' + name)) {\\n                        return;\\n                    }\\n                    if (!removeSsrcInfo[i2]) {\\n                        removeSsrcInfo[i2] = '';\\n                    }\\n                    ssrcs.forEach(function (ssrc) {\\n                        var ssrcLines = __WEBPACK_IMPORTED_MODULE_9__SDPUtil__[\\\"a\\\" /* default */].findLines(media, 'a=ssrc:' + ssrc);\\n\\n                        if (ssrcLines.length) {\\n                            removeSsrcInfo[i2] += ssrcLines.join('\\\\r\\\\n') + '\\\\r\\\\n';\\n                        }\\n                    });\\n                    removeSsrcInfo[i2] += lines;\\n                });\\n            });\\n\\n            return removeSsrcInfo;\\n        }\\n\\n        /**\\n         * Will print an error if there is any difference, between the SSRCs given\\n         * in the <tt>oldSDP</tt> and the ones currently described in\\n         * the peerconnection's local description.\\n         * @param {string} operationName the operation's name which will be printed\\n         * in the error message.\\n         * @param {SDP} oldSDP the old local SDP which will be compared with\\n         * the current one.\\n         * @return {boolean} <tt>true</tt> if there was any change or <tt>false</tt>\\n         * otherwise.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_verifyNoSSRCChanged',\\n        value: function _verifyNoSSRCChanged(operationName, oldSDP) {\\n            var currentLocalSDP = new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](this.peerconnection.localDescription.sdp);\\n            var sdpDiff = new __WEBPACK_IMPORTED_MODULE_8__SDPDiffer__[\\\"a\\\" /* default */](oldSDP, currentLocalSDP);\\n            var addedMedia = sdpDiff.getNewMedia();\\n\\n            if (Object.keys(addedMedia).length) {\\n                logger.error(this + ' - some SSRC were added on ' + operationName, addedMedia);\\n\\n                return false;\\n            }\\n\\n            sdpDiff = new __WEBPACK_IMPORTED_MODULE_8__SDPDiffer__[\\\"a\\\" /* default */](currentLocalSDP, oldSDP);\\n            var removedMedia = sdpDiff.getNewMedia();\\n\\n            if (Object.keys(removedMedia).length) {\\n                logger.error(this + ' - some SSRCs were removed on ' + operationName, removedMedia);\\n\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n\\n        /**\\n         * Adds local track back to this session, as part of the unmute operation.\\n         * @param {JitsiLocalTrack} track\\n         * @return {Promise} a promise that will resolve once the local track is\\n         * added back to this session and renegotiation succeeds. Will be rejected\\n         * with a <tt>string</tt> that provides some error details in case something\\n         * goes wrong.\\n         */\\n\\n    }, {\\n        key: 'addTrackAsUnmute',\\n        value: function addTrackAsUnmute(track) {\\n            return this._addRemoveTrackAsMuteUnmute(false /* add as unmute */, track);\\n        }\\n\\n        /**\\n         * Remove local track as part of the mute operation.\\n         * @param {JitsiLocalTrack} track the local track to be removed\\n         * @return {Promise} a promise which will be resolved once the local track\\n         * is removed from this session and the renegotiation is performed.\\n         * The promise will be rejected with a <tt>string</tt> that the describes\\n         * the error if anything goes wrong.\\n         */\\n\\n    }, {\\n        key: 'removeTrackAsMute',\\n        value: function removeTrackAsMute(track) {\\n            return this._addRemoveTrackAsMuteUnmute(true /* remove as mute */, track);\\n        }\\n\\n        /**\\n         * See {@link addTrackAsUnmute} and {@link removeTrackAsMute}.\\n         * @param {boolean} isMute <tt>true</tt> for \\\"remove as mute\\\" or\\n         * <tt>false</tt> for \\\"add as unmute\\\".\\n         * @param {JitsiLocalTrack} track the track that will be added/removed\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_addRemoveTrackAsMuteUnmute',\\n        value: function _addRemoveTrackAsMuteUnmute(isMute, track) {\\n            var _this18 = this;\\n\\n            if (!track) {\\n                return Promise.reject('invalid \\\"track\\\" argument value');\\n            }\\n            var operationName = isMute ? 'removeTrackMute' : 'addTrackUnmute';\\n            var workFunction = function workFunction(finishedCallback) {\\n                var tpc = _this18.peerconnection;\\n\\n                if (!tpc) {\\n                    finishedCallback('Error:  tried ' + operationName + ' track with no active peer' + 'connection');\\n\\n                    return;\\n                }\\n                var oldLocalSDP = tpc.localDescription.sdp;\\n                var tpcOperation = isMute ? tpc.removeTrackMute.bind(tpc, track) : tpc.addTrackUnmute.bind(tpc, track);\\n\\n                if (!tpcOperation()) {\\n                    finishedCallback(operationName + ' failed!');\\n                } else if (!oldLocalSDP || !tpc.remoteDescription.sdp) {\\n                    finishedCallback();\\n                } else {\\n                    _this18._renegotiate().then(function () {\\n                        // The results are ignored, as this check failure is not\\n                        // enough to fail the whole operation. It will log\\n                        // an error inside.\\n                        _this18._verifyNoSSRCChanged(operationName, new __WEBPACK_IMPORTED_MODULE_7__SDP__[\\\"a\\\" /* default */](oldLocalSDP));\\n                        finishedCallback();\\n                    }, finishedCallback /* will be called with an error */);\\n                }\\n            };\\n\\n            return new Promise(function (resolve, reject) {\\n                _this18.modificationQueue.push(workFunction, function (error) {\\n                    if (error) {\\n                        reject(error);\\n                    } else {\\n                        resolve();\\n                    }\\n                });\\n            });\\n        }\\n\\n        /**\\n         * Resumes or suspends media transfer over the underlying peer connection.\\n         * @param {boolean} audioActive <tt>true</tt> to enable audio media\\n         * transfer or <tt>false</tt> to suspend audio media transmission.\\n         * @param {boolean} videoActive <tt>true</tt> to enable video media\\n         * transfer or <tt>false</tt> to suspend video media transmission.\\n         * @return {Promise} a <tt>Promise</tt> which will resolve once\\n         * the operation is done. It will be rejected with an error description as\\n         * a string in case anything goes wrong.\\n         */\\n\\n    }, {\\n        key: 'setMediaTransferActive',\\n        value: function setMediaTransferActive(audioActive, videoActive) {\\n            var _this19 = this;\\n\\n            if (!this.peerconnection) {\\n                return Promise.reject('Can not modify transfer active state,' + ' before \\\"initialize\\\" is called');\\n            }\\n\\n            var logAudioStr = audioActive ? 'audio active' : 'audio inactive';\\n            var logVideoStr = videoActive ? 'video active' : 'video inactive';\\n\\n            logger.info('Queued make ' + logVideoStr + ', ' + logAudioStr + ' task...');\\n\\n            var workFunction = function workFunction(finishedCallback) {\\n                var isSessionActive = _this19.state === __WEBPACK_IMPORTED_MODULE_6__JingleSessionState__[\\\"a\\\" /* ACTIVE */];\\n\\n                // Because the value is modified on the queue it's impossible to\\n                // check it's final value reliably prior to submitting the task.\\n                // The rule here is that the last submitted state counts.\\n                // Check the values here to avoid unnecessary renegotiation cycle.\\n                var audioActiveChanged = _this19.peerconnection.setAudioTransferActive(audioActive);\\n\\n                if (_this19._localVideoActive !== videoActive) {\\n                    _this19._localVideoActive = videoActive;\\n\\n                    // Do only for P2P - Jicofo will reply with 'bad-request'\\n                    // We don't want to send 'content-modify', before the initial\\n                    // O/A (state === JingleSessionState.ACTIVE), because that will\\n                    // mess up video media direction in the remote SDP.\\n                    // 'content-modify' when processed only affects the media\\n                    // direction in the local SDP. We're doing that, because setting\\n                    // 'inactive' on video media in remote SDP will mess up our SDP\\n                    // translation chain (simulcast, RTX, video mute etc.).\\n                    if (_this19.isP2P && isSessionActive) {\\n                        _this19.sendContentModify(videoActive);\\n                    }\\n                }\\n\\n                var pcVideoActiveChanged = _this19.peerconnection.setVideoTransferActive(_this19._localVideoActive && _this19._remoteVideoActive);\\n\\n                // Will do the sRD/sLD cycle to update SDPs and adjust the media\\n                // direction\\n                if (isSessionActive && (audioActiveChanged || pcVideoActiveChanged)) {\\n                    _this19._renegotiate().then(finishedCallback, finishedCallback /* will be called with an error */);\\n                } else {\\n                    finishedCallback();\\n                }\\n            };\\n\\n            return new Promise(function (resolve, reject) {\\n                _this19.modificationQueue.push(workFunction, function (error) {\\n                    if (error) {\\n                        reject(error);\\n                    } else {\\n                        resolve();\\n                    }\\n                });\\n            });\\n        }\\n\\n        /**\\n         * Will put and execute on the queue a session modify task. Currently it\\n         * only checks the senders attribute of the video content in order to figure\\n         * out if the remote peer has video in the inactive state (stored locally\\n         * in {@link _remoteVideoActive} - see field description for more info).\\n         * @param {jQuery} jingleContents jQuery selector pointing to the jingle\\n         * element of the session modify IQ.\\n         * @see {@link _remoteVideoActive}\\n         * @see {@link _localVideoActive}\\n         */\\n\\n    }, {\\n        key: 'modifyContents',\\n        value: function modifyContents(jingleContents) {\\n            var _this20 = this;\\n\\n            var newVideoSenders = JingleSessionPC.parseVideoSenders(jingleContents);\\n\\n            if (newVideoSenders === null) {\\n                logger.error(this + ' - failed to parse video \\\"senders\\\" attribute in' + '\\\"content-modify\\\" action');\\n\\n                return;\\n            }\\n\\n            var workFunction = function workFunction(finishedCallback) {\\n                if (_this20._assertNotEnded('content-modify') && _this20._modifyRemoteVideoActive(newVideoSenders)) {\\n                    // Will do the sRD/sLD cycle to update SDPs and adjust\\n                    // the media direction\\n                    _this20._renegotiate().then(finishedCallback, finishedCallback /* (error) */);\\n                } else {\\n                    finishedCallback();\\n                }\\n            };\\n\\n            logger.debug(this + ' queued \\\"content-modify\\\" task' + ('(video senders=\\\"' + newVideoSenders + '\\\")'));\\n\\n            this.modificationQueue.push(workFunction, function (error) {\\n                if (error) {\\n                    logger.error('\\\"content-modify\\\" failed', error);\\n                }\\n            });\\n        }\\n\\n        /**\\n         * Processes new value of remote video \\\"senders\\\" Jingle attribute and tries\\n         * to apply it for {@link _remoteVideoActive}.\\n         * @param {string} remoteVideoSenders the value of \\\"senders\\\" attribute of\\n         * Jingle video content element advertised by remote peer.\\n         * @return {boolean} <tt>true</tt> if the change affected state of\\n         * the underlying peerconnection and renegotiation is required for\\n         * the changes to take effect.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_modifyRemoteVideoActive',\\n        value: function _modifyRemoteVideoActive(remoteVideoSenders) {\\n            var isRemoteVideoActive = remoteVideoSenders === 'both' || remoteVideoSenders === 'initiator' && this.isInitiator || remoteVideoSenders === 'responder' && !this.isInitiator;\\n\\n            if (isRemoteVideoActive !== this._remoteVideoActive) {\\n                logger.debug(this + ' new remote video active: ' + isRemoteVideoActive);\\n                this._remoteVideoActive = isRemoteVideoActive;\\n            }\\n\\n            return this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive);\\n        }\\n\\n        /**\\n         * Figures out added/removed ssrcs and send update IQs.\\n         * @param oldSDP SDP object for old description.\\n         * @param newSDP SDP object for new description.\\n         */\\n\\n    }, {\\n        key: 'notifyMySSRCUpdate',\\n        value: function notifyMySSRCUpdate(oldSDP, newSDP) {\\n\\n            if (this.state !== __WEBPACK_IMPORTED_MODULE_6__JingleSessionState__[\\\"a\\\" /* ACTIVE */]) {\\n                logger.warn('Skipping SSRC update in \\\\'' + this.state + ' \\\\' state.');\\n\\n                return;\\n            }\\n\\n            // send source-remove IQ.\\n            var sdpDiffer = new __WEBPACK_IMPORTED_MODULE_8__SDPDiffer__[\\\"a\\\" /* default */](newSDP, oldSDP);\\n            var remove = Object(__WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"$iq\\\"])({ to: this.remoteJid,\\n                type: 'set' }).c('jingle', {\\n                xmlns: 'urn:xmpp:jingle:1',\\n                action: 'source-remove',\\n                initiator: this.initiator,\\n                sid: this.sid\\n            });\\n            var removedAnySSRCs = sdpDiffer.toJingle(remove);\\n\\n            if (removedAnySSRCs) {\\n                logger.info('Sending source-remove', remove.tree());\\n                this.connection.sendIQ(remove, null, this.newJingleErrorHandler(remove), IQ_TIMEOUT);\\n            } else {\\n                logger.log('removal not necessary');\\n            }\\n\\n            // send source-add IQ.\\n            sdpDiffer = new __WEBPACK_IMPORTED_MODULE_8__SDPDiffer__[\\\"a\\\" /* default */](oldSDP, newSDP);\\n            var add = Object(__WEBPACK_IMPORTED_MODULE_3_strophe_js__[\\\"$iq\\\"])({ to: this.remoteJid,\\n                type: 'set' }).c('jingle', {\\n                xmlns: 'urn:xmpp:jingle:1',\\n                action: 'source-add',\\n                initiator: this.initiator,\\n                sid: this.sid\\n            });\\n\\n            var containsNewSSRCs = sdpDiffer.toJingle(add);\\n\\n            if (containsNewSSRCs) {\\n                logger.info('Sending source-add', add.tree());\\n                this.connection.sendIQ(add, null, this.newJingleErrorHandler(add), IQ_TIMEOUT);\\n            } else {\\n                logger.log('addition not necessary');\\n            }\\n        }\\n\\n        /**\\n         * Method returns function(errorResponse) which is a callback to be passed\\n         * to Strophe connection.sendIQ method. An 'error' structure is created that\\n         * is passed as 1st argument to given <tt>failureCb</tt>. The format of this\\n         * structure is as follows:\\n         * {\\n         *  code: {XMPP error response code}\\n         *  reason: {the name of XMPP error reason element or 'timeout' if the\\n          *          request has timed out within <tt>IQ_TIMEOUT</tt> milliseconds}\\n         *  source: {request.tree() that provides original request}\\n         *  session: {this JingleSessionPC.toString()}\\n         * }\\n         * @param request Strophe IQ instance which is the request to be dumped into\\n         *        the error structure\\n         * @param failureCb function(error) called when error response was returned\\n         *        or when a timeout has occurred.\\n         * @returns {function(this:JingleSessionPC)}\\n         */\\n\\n    }, {\\n        key: 'newJingleErrorHandler',\\n        value: function newJingleErrorHandler(request, failureCb) {\\n            var _this21 = this;\\n\\n            return function (errResponse) {\\n\\n                var error = {};\\n\\n                // Get XMPP error code and condition(reason)\\n                var errorElSel = $(errResponse).find('error');\\n\\n                if (errorElSel.length) {\\n                    error.code = errorElSel.attr('code');\\n                    var errorReasonSel = $(errResponse).find('error :first');\\n\\n                    if (errorReasonSel.length) {\\n                        error.reason = errorReasonSel[0].tagName;\\n                    }\\n\\n                    var errorMsgSel = errorElSel.find('>text');\\n\\n                    if (errorMsgSel.length) {\\n                        error.msg = errorMsgSel.text();\\n                    }\\n                }\\n\\n                if (!errResponse) {\\n                    error.reason = 'timeout';\\n                }\\n\\n                error.session = _this21.toString();\\n\\n                if (failureCb) {\\n                    failureCb(error);\\n                } else if (_this21.state === __WEBPACK_IMPORTED_MODULE_6__JingleSessionState__[\\\"b\\\" /* ENDED */] && error.reason === 'item-not-found') {\\n                    // When remote peer decides to terminate the session, but it\\n                    // still have few messages on the queue for processing,\\n                    // it will first send us 'session-terminate' (we enter ENDED)\\n                    // and then follow with 'item-not-found' for the queued requests\\n                    // We don't want to have that logged on error level.\\n                    logger.debug('Jingle error: ' + JSON.stringify(error));\\n                } else {\\n                    __WEBPACK_IMPORTED_MODULE_13__util_GlobalOnErrorHandler___default.a.callErrorHandler(new Error('Jingle error: ' + JSON.stringify(error)));\\n                }\\n            };\\n        }\\n\\n        /**\\n         *\\n         * @param session\\n         * @param error\\n         */\\n\\n    }, {\\n        key: 'getIceConnectionState',\\n\\n\\n        /**\\n         * Returns the ice connection state for the peer connection.\\n         * @returns the ice connection state for the peer connection.\\n         */\\n        value: function getIceConnectionState() {\\n            return this.peerconnection.iceConnectionState;\\n        }\\n\\n        /**\\n         * Closes the peerconnection.\\n         */\\n\\n    }, {\\n        key: 'close',\\n        value: function close() {\\n            this.closed = true;\\n\\n            // The signaling layer will remove it's listeners\\n            this.signalingLayer.setChatRoom(null);\\n\\n            // do not try to close if already closed.\\n            this.peerconnection && (this.peerconnection.signalingState && this.peerconnection.signalingState !== 'closed' || this.peerconnection.connectionState && this.peerconnection.connectionState !== 'closed') && this.peerconnection.close();\\n        }\\n\\n        /**\\n         * Converts to string with minor summary.\\n         * @return {string}\\n         */\\n\\n    }, {\\n        key: 'toString',\\n        value: function toString() {\\n            return 'JingleSessionPC[p2p=' + this.isP2P + ',' + ('initiator=' + this.isInitiator + ',sid=' + this.sid + ']');\\n        }\\n\\n        /**\\n         * If the A/B test for suspend video is disabled according to the room's\\n         * configuration, returns undefined. Otherwise returns a boolean which\\n         * indicates whether the suspend video option should be enabled or disabled.\\n         */\\n\\n    }, {\\n        key: '_abtestSuspendVideoEnabled',\\n        value: function _abtestSuspendVideoEnabled() {\\n            if (!this.room.options.abTesting || !this.room.options.abTesting.enableSuspendVideoTest) {\\n                return;\\n            }\\n\\n            // We want the two participants in a P2P call to agree on the value of\\n            // the \\\"suspend\\\" option. We use the JID of the initiator, because it is\\n            // both randomly selected and agreed upon by both participants.\\n            var jid = this._getInitiatorJid();\\n\\n            return Object(__WEBPACK_IMPORTED_MODULE_4__util_StringUtils__[\\\"integerHash\\\"])(jid) % 2 === 0;\\n        }\\n    }], [{\\n        key: 'onJingleFatalError',\\n        value: function onJingleFatalError(session, error) {\\n            if (this.room) {\\n                this.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.CONFERENCE_SETUP_FAILED, session, error);\\n                this.room.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_12__service_xmpp_XMPPEvents___default.a.JINGLE_FATAL_ERROR, session, error);\\n            }\\n        }\\n    }]);\\n\\n    return JingleSessionPC;\\n}(__WEBPACK_IMPORTED_MODULE_5__JingleSession__[\\\"a\\\" /* default */]);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (JingleSessionPC);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/JingleSessionPC.js\\\"))\\n\\n/***/ }),\\n/* 102 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* WEBPACK VAR INJECTION */(function(process, setImmediate) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n * async\\n * https://github.com/caolan/async\\n *\\n * Copyright 2010-2014 Caolan McMahon\\n * Released under the MIT license\\n */\\n/*jshint onevar: false, indent:4 */\\n/*global setImmediate: false, setTimeout: false, console: false */\\n(function () {\\n\\n    var async = {};\\n\\n    // global on the server, window in the browser\\n    var root, previous_async;\\n\\n    root = this;\\n    if (root != null) {\\n      previous_async = root.async;\\n    }\\n\\n    async.noConflict = function () {\\n        root.async = previous_async;\\n        return async;\\n    };\\n\\n    function only_once(fn) {\\n        var called = false;\\n        return function() {\\n            if (called) throw new Error(\\\"Callback was already called.\\\");\\n            called = true;\\n            fn.apply(root, arguments);\\n        }\\n    }\\n\\n    //// cross-browser compatiblity functions ////\\n\\n    var _toString = Object.prototype.toString;\\n\\n    var _isArray = Array.isArray || function (obj) {\\n        return _toString.call(obj) === '[object Array]';\\n    };\\n\\n    var _each = function (arr, iterator) {\\n        if (arr.forEach) {\\n            return arr.forEach(iterator);\\n        }\\n        for (var i = 0; i < arr.length; i += 1) {\\n            iterator(arr[i], i, arr);\\n        }\\n    };\\n\\n    var _map = function (arr, iterator) {\\n        if (arr.map) {\\n            return arr.map(iterator);\\n        }\\n        var results = [];\\n        _each(arr, function (x, i, a) {\\n            results.push(iterator(x, i, a));\\n        });\\n        return results;\\n    };\\n\\n    var _reduce = function (arr, iterator, memo) {\\n        if (arr.reduce) {\\n            return arr.reduce(iterator, memo);\\n        }\\n        _each(arr, function (x, i, a) {\\n            memo = iterator(memo, x, i, a);\\n        });\\n        return memo;\\n    };\\n\\n    var _keys = function (obj) {\\n        if (Object.keys) {\\n            return Object.keys(obj);\\n        }\\n        var keys = [];\\n        for (var k in obj) {\\n            if (obj.hasOwnProperty(k)) {\\n                keys.push(k);\\n            }\\n        }\\n        return keys;\\n    };\\n\\n    //// exported async module functions ////\\n\\n    //// nextTick implementation with browser-compatible fallback ////\\n    if (typeof process === 'undefined' || !(process.nextTick)) {\\n        if (typeof setImmediate === 'function') {\\n            async.nextTick = function (fn) {\\n                // not a direct alias for IE10 compatibility\\n                setImmediate(fn);\\n            };\\n            async.setImmediate = async.nextTick;\\n        }\\n        else {\\n            async.nextTick = function (fn) {\\n                setTimeout(fn, 0);\\n            };\\n            async.setImmediate = async.nextTick;\\n        }\\n    }\\n    else {\\n        async.nextTick = process.nextTick;\\n        if (typeof setImmediate !== 'undefined') {\\n            async.setImmediate = function (fn) {\\n              // not a direct alias for IE10 compatibility\\n              setImmediate(fn);\\n            };\\n        }\\n        else {\\n            async.setImmediate = async.nextTick;\\n        }\\n    }\\n\\n    async.each = function (arr, iterator, callback) {\\n        callback = callback || function () {};\\n        if (!arr.length) {\\n            return callback();\\n        }\\n        var completed = 0;\\n        _each(arr, function (x) {\\n            iterator(x, only_once(done) );\\n        });\\n        function done(err) {\\n          if (err) {\\n              callback(err);\\n              callback = function () {};\\n          }\\n          else {\\n              completed += 1;\\n              if (completed >= arr.length) {\\n                  callback();\\n              }\\n          }\\n        }\\n    };\\n    async.forEach = async.each;\\n\\n    async.eachSeries = function (arr, iterator, callback) {\\n        callback = callback || function () {};\\n        if (!arr.length) {\\n            return callback();\\n        }\\n        var completed = 0;\\n        var iterate = function () {\\n            iterator(arr[completed], function (err) {\\n                if (err) {\\n                    callback(err);\\n                    callback = function () {};\\n                }\\n                else {\\n                    completed += 1;\\n                    if (completed >= arr.length) {\\n                        callback();\\n                    }\\n                    else {\\n                        iterate();\\n                    }\\n                }\\n            });\\n        };\\n        iterate();\\n    };\\n    async.forEachSeries = async.eachSeries;\\n\\n    async.eachLimit = function (arr, limit, iterator, callback) {\\n        var fn = _eachLimit(limit);\\n        fn.apply(null, [arr, iterator, callback]);\\n    };\\n    async.forEachLimit = async.eachLimit;\\n\\n    var _eachLimit = function (limit) {\\n\\n        return function (arr, iterator, callback) {\\n            callback = callback || function () {};\\n            if (!arr.length || limit <= 0) {\\n                return callback();\\n            }\\n            var completed = 0;\\n            var started = 0;\\n            var running = 0;\\n\\n            (function replenish () {\\n                if (completed >= arr.length) {\\n                    return callback();\\n                }\\n\\n                while (running < limit && started < arr.length) {\\n                    started += 1;\\n                    running += 1;\\n                    iterator(arr[started - 1], function (err) {\\n                        if (err) {\\n                            callback(err);\\n                            callback = function () {};\\n                        }\\n                        else {\\n                            completed += 1;\\n                            running -= 1;\\n                            if (completed >= arr.length) {\\n                                callback();\\n                            }\\n                            else {\\n                                replenish();\\n                            }\\n                        }\\n                    });\\n                }\\n            })();\\n        };\\n    };\\n\\n\\n    var doParallel = function (fn) {\\n        return function () {\\n            var args = Array.prototype.slice.call(arguments);\\n            return fn.apply(null, [async.each].concat(args));\\n        };\\n    };\\n    var doParallelLimit = function(limit, fn) {\\n        return function () {\\n            var args = Array.prototype.slice.call(arguments);\\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\\n        };\\n    };\\n    var doSeries = function (fn) {\\n        return function () {\\n            var args = Array.prototype.slice.call(arguments);\\n            return fn.apply(null, [async.eachSeries].concat(args));\\n        };\\n    };\\n\\n\\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\\n        arr = _map(arr, function (x, i) {\\n            return {index: i, value: x};\\n        });\\n        if (!callback) {\\n            eachfn(arr, function (x, callback) {\\n                iterator(x.value, function (err) {\\n                    callback(err);\\n                });\\n            });\\n        } else {\\n            var results = [];\\n            eachfn(arr, function (x, callback) {\\n                iterator(x.value, function (err, v) {\\n                    results[x.index] = v;\\n                    callback(err);\\n                });\\n            }, function (err) {\\n                callback(err, results);\\n            });\\n        }\\n    };\\n    async.map = doParallel(_asyncMap);\\n    async.mapSeries = doSeries(_asyncMap);\\n    async.mapLimit = function (arr, limit, iterator, callback) {\\n        return _mapLimit(limit)(arr, iterator, callback);\\n    };\\n\\n    var _mapLimit = function(limit) {\\n        return doParallelLimit(limit, _asyncMap);\\n    };\\n\\n    // reduce only has a series version, as doing reduce in parallel won't\\n    // work in many situations.\\n    async.reduce = function (arr, memo, iterator, callback) {\\n        async.eachSeries(arr, function (x, callback) {\\n            iterator(memo, x, function (err, v) {\\n                memo = v;\\n                callback(err);\\n            });\\n        }, function (err) {\\n            callback(err, memo);\\n        });\\n    };\\n    // inject alias\\n    async.inject = async.reduce;\\n    // foldl alias\\n    async.foldl = async.reduce;\\n\\n    async.reduceRight = function (arr, memo, iterator, callback) {\\n        var reversed = _map(arr, function (x) {\\n            return x;\\n        }).reverse();\\n        async.reduce(reversed, memo, iterator, callback);\\n    };\\n    // foldr alias\\n    async.foldr = async.reduceRight;\\n\\n    var _filter = function (eachfn, arr, iterator, callback) {\\n        var results = [];\\n        arr = _map(arr, function (x, i) {\\n            return {index: i, value: x};\\n        });\\n        eachfn(arr, function (x, callback) {\\n            iterator(x.value, function (v) {\\n                if (v) {\\n                    results.push(x);\\n                }\\n                callback();\\n            });\\n        }, function (err) {\\n            callback(_map(results.sort(function (a, b) {\\n                return a.index - b.index;\\n            }), function (x) {\\n                return x.value;\\n            }));\\n        });\\n    };\\n    async.filter = doParallel(_filter);\\n    async.filterSeries = doSeries(_filter);\\n    // select alias\\n    async.select = async.filter;\\n    async.selectSeries = async.filterSeries;\\n\\n    var _reject = function (eachfn, arr, iterator, callback) {\\n        var results = [];\\n        arr = _map(arr, function (x, i) {\\n            return {index: i, value: x};\\n        });\\n        eachfn(arr, function (x, callback) {\\n            iterator(x.value, function (v) {\\n                if (!v) {\\n                    results.push(x);\\n                }\\n                callback();\\n            });\\n        }, function (err) {\\n            callback(_map(results.sort(function (a, b) {\\n                return a.index - b.index;\\n            }), function (x) {\\n                return x.value;\\n            }));\\n        });\\n    };\\n    async.reject = doParallel(_reject);\\n    async.rejectSeries = doSeries(_reject);\\n\\n    var _detect = function (eachfn, arr, iterator, main_callback) {\\n        eachfn(arr, function (x, callback) {\\n            iterator(x, function (result) {\\n                if (result) {\\n                    main_callback(x);\\n                    main_callback = function () {};\\n                }\\n                else {\\n                    callback();\\n                }\\n            });\\n        }, function (err) {\\n            main_callback();\\n        });\\n    };\\n    async.detect = doParallel(_detect);\\n    async.detectSeries = doSeries(_detect);\\n\\n    async.some = function (arr, iterator, main_callback) {\\n        async.each(arr, function (x, callback) {\\n            iterator(x, function (v) {\\n                if (v) {\\n                    main_callback(true);\\n                    main_callback = function () {};\\n                }\\n                callback();\\n            });\\n        }, function (err) {\\n            main_callback(false);\\n        });\\n    };\\n    // any alias\\n    async.any = async.some;\\n\\n    async.every = function (arr, iterator, main_callback) {\\n        async.each(arr, function (x, callback) {\\n            iterator(x, function (v) {\\n                if (!v) {\\n                    main_callback(false);\\n                    main_callback = function () {};\\n                }\\n                callback();\\n            });\\n        }, function (err) {\\n            main_callback(true);\\n        });\\n    };\\n    // all alias\\n    async.all = async.every;\\n\\n    async.sortBy = function (arr, iterator, callback) {\\n        async.map(arr, function (x, callback) {\\n            iterator(x, function (err, criteria) {\\n                if (err) {\\n                    callback(err);\\n                }\\n                else {\\n                    callback(null, {value: x, criteria: criteria});\\n                }\\n            });\\n        }, function (err, results) {\\n            if (err) {\\n                return callback(err);\\n            }\\n            else {\\n                var fn = function (left, right) {\\n                    var a = left.criteria, b = right.criteria;\\n                    return a < b ? -1 : a > b ? 1 : 0;\\n                };\\n                callback(null, _map(results.sort(fn), function (x) {\\n                    return x.value;\\n                }));\\n            }\\n        });\\n    };\\n\\n    async.auto = function (tasks, callback) {\\n        callback = callback || function () {};\\n        var keys = _keys(tasks);\\n        var remainingTasks = keys.length\\n        if (!remainingTasks) {\\n            return callback();\\n        }\\n\\n        var results = {};\\n\\n        var listeners = [];\\n        var addListener = function (fn) {\\n            listeners.unshift(fn);\\n        };\\n        var removeListener = function (fn) {\\n            for (var i = 0; i < listeners.length; i += 1) {\\n                if (listeners[i] === fn) {\\n                    listeners.splice(i, 1);\\n                    return;\\n                }\\n            }\\n        };\\n        var taskComplete = function () {\\n            remainingTasks--\\n            _each(listeners.slice(0), function (fn) {\\n                fn();\\n            });\\n        };\\n\\n        addListener(function () {\\n            if (!remainingTasks) {\\n                var theCallback = callback;\\n                // prevent final callback from calling itself if it errors\\n                callback = function () {};\\n\\n                theCallback(null, results);\\n            }\\n        });\\n\\n        _each(keys, function (k) {\\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\n            var taskCallback = function (err) {\\n                var args = Array.prototype.slice.call(arguments, 1);\\n                if (args.length <= 1) {\\n                    args = args[0];\\n                }\\n                if (err) {\\n                    var safeResults = {};\\n                    _each(_keys(results), function(rkey) {\\n                        safeResults[rkey] = results[rkey];\\n                    });\\n                    safeResults[k] = args;\\n                    callback(err, safeResults);\\n                    // stop subsequent errors hitting callback multiple times\\n                    callback = function () {};\\n                }\\n                else {\\n                    results[k] = args;\\n                    async.setImmediate(taskComplete);\\n                }\\n            };\\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\n            var ready = function () {\\n                return _reduce(requires, function (a, x) {\\n                    return (a && results.hasOwnProperty(x));\\n                }, true) && !results.hasOwnProperty(k);\\n            };\\n            if (ready()) {\\n                task[task.length - 1](taskCallback, results);\\n            }\\n            else {\\n                var listener = function () {\\n                    if (ready()) {\\n                        removeListener(listener);\\n                        task[task.length - 1](taskCallback, results);\\n                    }\\n                };\\n                addListener(listener);\\n            }\\n        });\\n    };\\n\\n    async.retry = function(times, task, callback) {\\n        var DEFAULT_TIMES = 5;\\n        var attempts = [];\\n        // Use defaults if times not passed\\n        if (typeof times === 'function') {\\n            callback = task;\\n            task = times;\\n            times = DEFAULT_TIMES;\\n        }\\n        // Make sure times is a number\\n        times = parseInt(times, 10) || DEFAULT_TIMES;\\n        var wrappedTask = function(wrappedCallback, wrappedResults) {\\n            var retryAttempt = function(task, finalAttempt) {\\n                return function(seriesCallback) {\\n                    task(function(err, result){\\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\n                    }, wrappedResults);\\n                };\\n            };\\n            while (times) {\\n                attempts.push(retryAttempt(task, !(times-=1)));\\n            }\\n            async.series(attempts, function(done, data){\\n                data = data[data.length - 1];\\n                (wrappedCallback || callback)(data.err, data.result);\\n            });\\n        }\\n        // If a callback is passed, run this as a controll flow\\n        return callback ? wrappedTask() : wrappedTask\\n    };\\n\\n    async.waterfall = function (tasks, callback) {\\n        callback = callback || function () {};\\n        if (!_isArray(tasks)) {\\n          var err = new Error('First argument to waterfall must be an array of functions');\\n          return callback(err);\\n        }\\n        if (!tasks.length) {\\n            return callback();\\n        }\\n        var wrapIterator = function (iterator) {\\n            return function (err) {\\n                if (err) {\\n                    callback.apply(null, arguments);\\n                    callback = function () {};\\n                }\\n                else {\\n                    var args = Array.prototype.slice.call(arguments, 1);\\n                    var next = iterator.next();\\n                    if (next) {\\n                        args.push(wrapIterator(next));\\n                    }\\n                    else {\\n                        args.push(callback);\\n                    }\\n                    async.setImmediate(function () {\\n                        iterator.apply(null, args);\\n                    });\\n                }\\n            };\\n        };\\n        wrapIterator(async.iterator(tasks))();\\n    };\\n\\n    var _parallel = function(eachfn, tasks, callback) {\\n        callback = callback || function () {};\\n        if (_isArray(tasks)) {\\n            eachfn.map(tasks, function (fn, callback) {\\n                if (fn) {\\n                    fn(function (err) {\\n                        var args = Array.prototype.slice.call(arguments, 1);\\n                        if (args.length <= 1) {\\n                            args = args[0];\\n                        }\\n                        callback.call(null, err, args);\\n                    });\\n                }\\n            }, callback);\\n        }\\n        else {\\n            var results = {};\\n            eachfn.each(_keys(tasks), function (k, callback) {\\n                tasks[k](function (err) {\\n                    var args = Array.prototype.slice.call(arguments, 1);\\n                    if (args.length <= 1) {\\n                        args = args[0];\\n                    }\\n                    results[k] = args;\\n                    callback(err);\\n                });\\n            }, function (err) {\\n                callback(err, results);\\n            });\\n        }\\n    };\\n\\n    async.parallel = function (tasks, callback) {\\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\\n    };\\n\\n    async.parallelLimit = function(tasks, limit, callback) {\\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\n    };\\n\\n    async.series = function (tasks, callback) {\\n        callback = callback || function () {};\\n        if (_isArray(tasks)) {\\n            async.mapSeries(tasks, function (fn, callback) {\\n                if (fn) {\\n                    fn(function (err) {\\n                        var args = Array.prototype.slice.call(arguments, 1);\\n                        if (args.length <= 1) {\\n                            args = args[0];\\n                        }\\n                        callback.call(null, err, args);\\n                    });\\n                }\\n            }, callback);\\n        }\\n        else {\\n            var results = {};\\n            async.eachSeries(_keys(tasks), function (k, callback) {\\n                tasks[k](function (err) {\\n                    var args = Array.prototype.slice.call(arguments, 1);\\n                    if (args.length <= 1) {\\n                        args = args[0];\\n                    }\\n                    results[k] = args;\\n                    callback(err);\\n                });\\n            }, function (err) {\\n                callback(err, results);\\n            });\\n        }\\n    };\\n\\n    async.iterator = function (tasks) {\\n        var makeCallback = function (index) {\\n            var fn = function () {\\n                if (tasks.length) {\\n                    tasks[index].apply(null, arguments);\\n                }\\n                return fn.next();\\n            };\\n            fn.next = function () {\\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\n            };\\n            return fn;\\n        };\\n        return makeCallback(0);\\n    };\\n\\n    async.apply = function (fn) {\\n        var args = Array.prototype.slice.call(arguments, 1);\\n        return function () {\\n            return fn.apply(\\n                null, args.concat(Array.prototype.slice.call(arguments))\\n            );\\n        };\\n    };\\n\\n    var _concat = function (eachfn, arr, fn, callback) {\\n        var r = [];\\n        eachfn(arr, function (x, cb) {\\n            fn(x, function (err, y) {\\n                r = r.concat(y || []);\\n                cb(err);\\n            });\\n        }, function (err) {\\n            callback(err, r);\\n        });\\n    };\\n    async.concat = doParallel(_concat);\\n    async.concatSeries = doSeries(_concat);\\n\\n    async.whilst = function (test, iterator, callback) {\\n        if (test()) {\\n            iterator(function (err) {\\n                if (err) {\\n                    return callback(err);\\n                }\\n                async.whilst(test, iterator, callback);\\n            });\\n        }\\n        else {\\n            callback();\\n        }\\n    };\\n\\n    async.doWhilst = function (iterator, test, callback) {\\n        iterator(function (err) {\\n            if (err) {\\n                return callback(err);\\n            }\\n            var args = Array.prototype.slice.call(arguments, 1);\\n            if (test.apply(null, args)) {\\n                async.doWhilst(iterator, test, callback);\\n            }\\n            else {\\n                callback();\\n            }\\n        });\\n    };\\n\\n    async.until = function (test, iterator, callback) {\\n        if (!test()) {\\n            iterator(function (err) {\\n                if (err) {\\n                    return callback(err);\\n                }\\n                async.until(test, iterator, callback);\\n            });\\n        }\\n        else {\\n            callback();\\n        }\\n    };\\n\\n    async.doUntil = function (iterator, test, callback) {\\n        iterator(function (err) {\\n            if (err) {\\n                return callback(err);\\n            }\\n            var args = Array.prototype.slice.call(arguments, 1);\\n            if (!test.apply(null, args)) {\\n                async.doUntil(iterator, test, callback);\\n            }\\n            else {\\n                callback();\\n            }\\n        });\\n    };\\n\\n    async.queue = function (worker, concurrency) {\\n        if (concurrency === undefined) {\\n            concurrency = 1;\\n        }\\n        function _insert(q, data, pos, callback) {\\n          if (!q.started){\\n            q.started = true;\\n          }\\n          if (!_isArray(data)) {\\n              data = [data];\\n          }\\n          if(data.length == 0) {\\n             // call drain immediately if there are no tasks\\n             return async.setImmediate(function() {\\n                 if (q.drain) {\\n                     q.drain();\\n                 }\\n             });\\n          }\\n          _each(data, function(task) {\\n              var item = {\\n                  data: task,\\n                  callback: typeof callback === 'function' ? callback : null\\n              };\\n\\n              if (pos) {\\n                q.tasks.unshift(item);\\n              } else {\\n                q.tasks.push(item);\\n              }\\n\\n              if (q.saturated && q.tasks.length === q.concurrency) {\\n                  q.saturated();\\n              }\\n              async.setImmediate(q.process);\\n          });\\n        }\\n\\n        var workers = 0;\\n        var q = {\\n            tasks: [],\\n            concurrency: concurrency,\\n            saturated: null,\\n            empty: null,\\n            drain: null,\\n            started: false,\\n            paused: false,\\n            push: function (data, callback) {\\n              _insert(q, data, false, callback);\\n            },\\n            kill: function () {\\n              q.drain = null;\\n              q.tasks = [];\\n            },\\n            unshift: function (data, callback) {\\n              _insert(q, data, true, callback);\\n            },\\n            process: function () {\\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\n                    var task = q.tasks.shift();\\n                    if (q.empty && q.tasks.length === 0) {\\n                        q.empty();\\n                    }\\n                    workers += 1;\\n                    var next = function () {\\n                        workers -= 1;\\n                        if (task.callback) {\\n                            task.callback.apply(task, arguments);\\n                        }\\n                        if (q.drain && q.tasks.length + workers === 0) {\\n                            q.drain();\\n                        }\\n                        q.process();\\n                    };\\n                    var cb = only_once(next);\\n                    worker(task.data, cb);\\n                }\\n            },\\n            length: function () {\\n                return q.tasks.length;\\n            },\\n            running: function () {\\n                return workers;\\n            },\\n            idle: function() {\\n                return q.tasks.length + workers === 0;\\n            },\\n            pause: function () {\\n                if (q.paused === true) { return; }\\n                q.paused = true;\\n                q.process();\\n            },\\n            resume: function () {\\n                if (q.paused === false) { return; }\\n                q.paused = false;\\n                q.process();\\n            }\\n        };\\n        return q;\\n    };\\n    \\n    async.priorityQueue = function (worker, concurrency) {\\n        \\n        function _compareTasks(a, b){\\n          return a.priority - b.priority;\\n        };\\n        \\n        function _binarySearch(sequence, item, compare) {\\n          var beg = -1,\\n              end = sequence.length - 1;\\n          while (beg < end) {\\n            var mid = beg + ((end - beg + 1) >>> 1);\\n            if (compare(item, sequence[mid]) >= 0) {\\n              beg = mid;\\n            } else {\\n              end = mid - 1;\\n            }\\n          }\\n          return beg;\\n        }\\n        \\n        function _insert(q, data, priority, callback) {\\n          if (!q.started){\\n            q.started = true;\\n          }\\n          if (!_isArray(data)) {\\n              data = [data];\\n          }\\n          if(data.length == 0) {\\n             // call drain immediately if there are no tasks\\n             return async.setImmediate(function() {\\n                 if (q.drain) {\\n                     q.drain();\\n                 }\\n             });\\n          }\\n          _each(data, function(task) {\\n              var item = {\\n                  data: task,\\n                  priority: priority,\\n                  callback: typeof callback === 'function' ? callback : null\\n              };\\n              \\n              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\n\\n              if (q.saturated && q.tasks.length === q.concurrency) {\\n                  q.saturated();\\n              }\\n              async.setImmediate(q.process);\\n          });\\n        }\\n        \\n        // Start with a normal queue\\n        var q = async.queue(worker, concurrency);\\n        \\n        // Override push to accept second parameter representing priority\\n        q.push = function (data, priority, callback) {\\n          _insert(q, data, priority, callback);\\n        };\\n        \\n        // Remove unshift function\\n        delete q.unshift;\\n\\n        return q;\\n    };\\n\\n    async.cargo = function (worker, payload) {\\n        var working     = false,\\n            tasks       = [];\\n\\n        var cargo = {\\n            tasks: tasks,\\n            payload: payload,\\n            saturated: null,\\n            empty: null,\\n            drain: null,\\n            drained: true,\\n            push: function (data, callback) {\\n                if (!_isArray(data)) {\\n                    data = [data];\\n                }\\n                _each(data, function(task) {\\n                    tasks.push({\\n                        data: task,\\n                        callback: typeof callback === 'function' ? callback : null\\n                    });\\n                    cargo.drained = false;\\n                    if (cargo.saturated && tasks.length === payload) {\\n                        cargo.saturated();\\n                    }\\n                });\\n                async.setImmediate(cargo.process);\\n            },\\n            process: function process() {\\n                if (working) return;\\n                if (tasks.length === 0) {\\n                    if(cargo.drain && !cargo.drained) cargo.drain();\\n                    cargo.drained = true;\\n                    return;\\n                }\\n\\n                var ts = typeof payload === 'number'\\n                            ? tasks.splice(0, payload)\\n                            : tasks.splice(0, tasks.length);\\n\\n                var ds = _map(ts, function (task) {\\n                    return task.data;\\n                });\\n\\n                if(cargo.empty) cargo.empty();\\n                working = true;\\n                worker(ds, function () {\\n                    working = false;\\n\\n                    var args = arguments;\\n                    _each(ts, function (data) {\\n                        if (data.callback) {\\n                            data.callback.apply(null, args);\\n                        }\\n                    });\\n\\n                    process();\\n                });\\n            },\\n            length: function () {\\n                return tasks.length;\\n            },\\n            running: function () {\\n                return working;\\n            }\\n        };\\n        return cargo;\\n    };\\n\\n    var _console_fn = function (name) {\\n        return function (fn) {\\n            var args = Array.prototype.slice.call(arguments, 1);\\n            fn.apply(null, args.concat([function (err) {\\n                var args = Array.prototype.slice.call(arguments, 1);\\n                if (typeof console !== 'undefined') {\\n                    if (err) {\\n                        if (console.error) {\\n                            console.error(err);\\n                        }\\n                    }\\n                    else if (console[name]) {\\n                        _each(args, function (x) {\\n                            console[name](x);\\n                        });\\n                    }\\n                }\\n            }]));\\n        };\\n    };\\n    async.log = _console_fn('log');\\n    async.dir = _console_fn('dir');\\n    /*async.info = _console_fn('info');\\n    async.warn = _console_fn('warn');\\n    async.error = _console_fn('error');*/\\n\\n    async.memoize = function (fn, hasher) {\\n        var memo = {};\\n        var queues = {};\\n        hasher = hasher || function (x) {\\n            return x;\\n        };\\n        var memoized = function () {\\n            var args = Array.prototype.slice.call(arguments);\\n            var callback = args.pop();\\n            var key = hasher.apply(null, args);\\n            if (key in memo) {\\n                async.nextTick(function () {\\n                    callback.apply(null, memo[key]);\\n                });\\n            }\\n            else if (key in queues) {\\n                queues[key].push(callback);\\n            }\\n            else {\\n                queues[key] = [callback];\\n                fn.apply(null, args.concat([function () {\\n                    memo[key] = arguments;\\n                    var q = queues[key];\\n                    delete queues[key];\\n                    for (var i = 0, l = q.length; i < l; i++) {\\n                      q[i].apply(null, arguments);\\n                    }\\n                }]));\\n            }\\n        };\\n        memoized.memo = memo;\\n        memoized.unmemoized = fn;\\n        return memoized;\\n    };\\n\\n    async.unmemoize = function (fn) {\\n      return function () {\\n        return (fn.unmemoized || fn).apply(null, arguments);\\n      };\\n    };\\n\\n    async.times = function (count, iterator, callback) {\\n        var counter = [];\\n        for (var i = 0; i < count; i++) {\\n            counter.push(i);\\n        }\\n        return async.map(counter, iterator, callback);\\n    };\\n\\n    async.timesSeries = function (count, iterator, callback) {\\n        var counter = [];\\n        for (var i = 0; i < count; i++) {\\n            counter.push(i);\\n        }\\n        return async.mapSeries(counter, iterator, callback);\\n    };\\n\\n    async.seq = function (/* functions... */) {\\n        var fns = arguments;\\n        return function () {\\n            var that = this;\\n            var args = Array.prototype.slice.call(arguments);\\n            var callback = args.pop();\\n            async.reduce(fns, args, function (newargs, fn, cb) {\\n                fn.apply(that, newargs.concat([function () {\\n                    var err = arguments[0];\\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\\n                    cb(err, nextargs);\\n                }]))\\n            },\\n            function (err, results) {\\n                callback.apply(that, [err].concat(results));\\n            });\\n        };\\n    };\\n\\n    async.compose = function (/* functions... */) {\\n      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\n    };\\n\\n    var _applyEach = function (eachfn, fns /*args...*/) {\\n        var go = function () {\\n            var that = this;\\n            var args = Array.prototype.slice.call(arguments);\\n            var callback = args.pop();\\n            return eachfn(fns, function (fn, cb) {\\n                fn.apply(that, args.concat([cb]));\\n            },\\n            callback);\\n        };\\n        if (arguments.length > 2) {\\n            var args = Array.prototype.slice.call(arguments, 2);\\n            return go.apply(this, args);\\n        }\\n        else {\\n            return go;\\n        }\\n    };\\n    async.applyEach = doParallel(_applyEach);\\n    async.applyEachSeries = doSeries(_applyEach);\\n\\n    async.forever = function (fn, callback) {\\n        function next(err) {\\n            if (err) {\\n                if (callback) {\\n                    return callback(err);\\n                }\\n                throw err;\\n            }\\n            fn(next);\\n        }\\n        next();\\n    };\\n\\n    // Node.js\\n    if (typeof module !== 'undefined' && module.exports) {\\n        module.exports = async;\\n    }\\n    // AMD / RequireJS\\n    else if (true) {\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\\n            return async;\\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n    }\\n    // included directly via <script> tag\\n    else {\\n        root.async = async;\\n    }\\n\\n}());\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34), __webpack_require__(39).setImmediate))\\n\\n/***/ }),\\n/* 103 */\\n/***/ (function(module, exports) {\\n\\n/**\\n * Implements a simple hash code for a string (see\\n * https://en.wikipedia.org/wiki/Java_hashCode()).\\n *\\n * @param {string} The string to return a hash of.\\n * @return {Number} the integer hash code of the string.\\n */\\nfunction integerHash(string) {\\n    if (!string) {\\n        return 0;\\n    }\\n\\n    var char = void 0,\\n        hash = 0,\\n        i = void 0;\\n\\n    for (i = 0; i < string.length; i++) {\\n        char = string.charCodeAt(i);\\n        hash += char * Math.pow(31, string.length - 1 - i);\\n        hash = Math.abs(hash | 0); // eslint-disable-line no-bitwise\\n    }\\n\\n    return hash;\\n}\\n\\nmodule.exports = { integerHash: integerHash };\\n\\n/***/ }),\\n/* 104 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JingleSessionState__ = __webpack_require__(51);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/* global __filename */\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * JingleSession provides an API to manage a single Jingle session. We will\\n * have different implementations depending on the underlying interface used\\n * (i.e. WebRTC and ORTC) and here we hold the code common to all of them.\\n */\\n\\nvar JingleSession = function () {\\n\\n  /* eslint-disable max-params */\\n\\n  /**\\n   * Creates new <tt>JingleSession</tt>.\\n   * @param {string} sid the Jingle session identifier\\n   * @param {string} localJid our JID\\n   * @param {string} remoteJid the JID of the remote peer\\n   * @param {Strophe.Connection} connection the XMPP connection\\n   * @param {Object} mediaConstraints the media constraints object passed to\\n   * the PeerConnection onCreateAnswer/Offer as defined by the WebRTC.\\n   * @param {Object} iceConfig the ICE servers config object as defined by\\n   * the WebRTC. Passed to the PeerConnection's constructor.\\n   */\\n  function JingleSession(sid, localJid, remoteJid, connection, mediaConstraints, iceConfig) {\\n    _classCallCheck(this, JingleSession);\\n\\n    this.sid = sid;\\n    this.localJid = localJid;\\n    this.remoteJid = remoteJid;\\n    this.connection = connection;\\n    this.mediaConstraints = mediaConstraints;\\n    this.iceConfig = iceConfig;\\n\\n    /**\\n     * Whether to use dripping or not. Dripping is sending trickle\\n     * candidates not one-by-one.\\n     */\\n    this.usedrip = true;\\n\\n    /**\\n     *  When dripping is used, stores ICE candidates which are to be sent.\\n     */\\n    this.dripContainer = [];\\n\\n    /**\\n     * The chat room instance associated with the session.\\n     * @type {ChatRoom}\\n     */\\n    this.room = null;\\n\\n    /**\\n     * Jingle session state - uninitialized until {@link initialize} is\\n     * called @type {JingleSessionState}\\n     */\\n    this.state = null;\\n\\n    /**\\n     * The RTC service instance\\n     * @type {RTC}\\n     */\\n    this.rtc = null;\\n  }\\n\\n  /* eslint-enable max-params */\\n\\n  /**\\n   * Prepares this object to initiate a session.\\n   * @param {boolean} isInitiator whether we will be the Jingle initiator.\\n   * @param {ChatRoom} room the chat room for the conference associated with\\n   * this session\\n   * @param {RTC} rtc the RTC service instance\\n   */\\n\\n\\n  _createClass(JingleSession, [{\\n    key: 'initialize',\\n    value: function initialize(isInitiator, room, rtc) {\\n      if (this.state !== null) {\\n        var errmsg = 'attempt to initiate on session ' + this.sid + '\\\\n                   in state ' + this.state;\\n\\n        logger.error(errmsg);\\n        throw new Error(errmsg);\\n      }\\n      this.room = room;\\n      this.rtc = rtc;\\n      this.state = __WEBPACK_IMPORTED_MODULE_1__JingleSessionState__[\\\"c\\\" /* PENDING */];\\n      this.initiator = isInitiator ? this.localJid : this.remoteJid;\\n      this.responder = isInitiator ? this.remoteJid : this.localJid;\\n      this.doInitialize();\\n    }\\n\\n    /**\\n     * The implementing class finishes initialization here. Called at the end of\\n     * {@link initialize}.\\n     * @protected\\n     */\\n\\n  }, {\\n    key: 'doInitialize',\\n    value: function doInitialize() {} // eslint-disable-line no-empty-function\\n\\n    /* eslint-disable no-unused-vars, no-empty-function */\\n\\n    /**\\n     * Adds the ICE candidates found in the 'contents' array as remote\\n     * candidates?\\n     * Note: currently only used on transport-info\\n     *\\n     * @param contents\\n     */\\n\\n  }, {\\n    key: 'addIceCandidates',\\n    value: function addIceCandidates(contents) {}\\n\\n    /* eslint-enable no-unused-vars, no-empty-function */\\n\\n    /**\\n     * Returns current state of this <tt>JingleSession</tt> instance.\\n     * @returns {JingleSessionState} the current state of this session instance.\\n     */\\n\\n  }, {\\n    key: 'getState',\\n    value: function getState() {\\n      return this.state;\\n    }\\n\\n    /* eslint-disable no-unused-vars, no-empty-function */\\n\\n    /**\\n     * Handles an 'add-source' event.\\n     *\\n     * @param contents an array of Jingle 'content' elements.\\n     */\\n\\n  }, {\\n    key: 'addSources',\\n    value: function addSources(contents) {}\\n\\n    /**\\n     * Handles a 'remove-source' event.\\n     *\\n     * @param contents an array of Jingle 'content' elements.\\n     */\\n\\n  }, {\\n    key: 'removeSources',\\n    value: function removeSources(contents) {}\\n\\n    /**\\n     * Terminates this Jingle session by sending session-terminate\\n     * @param success a callback called once the 'session-terminate' packet has\\n     * been acknowledged with RESULT.\\n     * @param failure a callback called when either timeout occurs or ERROR\\n     * response is received.\\n     * @param {Object} options\\n     * @param {string} [options.reason] XMPP Jingle error condition\\n     * @param {string} [options.reasonDescription] some meaningful error message\\n     * @param {boolean} [options.sendSessionTerminate=true] set to false to skip\\n     * sending session-terminate. It may not make sense to send it if the XMPP\\n     * connection has been closed already or if the remote peer has disconnected\\n     */\\n\\n  }, {\\n    key: 'terminate',\\n    value: function terminate(success, failure, options) {}\\n\\n    /**\\n     * Handles an offer from the remote peer (prepares to accept a session).\\n     * @param jingle the 'jingle' XML element.\\n     * @param success callback called when we the incoming session has been\\n     * accepted\\n     * @param failure callback called when we fail for any reason, will supply\\n     * error object with details(which is meant more to be printed to the logger\\n     * than analysed in the code, as the error is unrecoverable anyway)\\n     */\\n\\n  }, {\\n    key: 'acceptOffer',\\n    value: function acceptOffer(jingle, success, failure) {}\\n\\n    /**\\n     * Returns the JID of the initiator of the jingle session.\\n     */\\n\\n  }, {\\n    key: '_getInitiatorJid',\\n    value: function _getInitiatorJid() {\\n      return this.isInitiator ? this.localJid : this.remoteJid;\\n    }\\n\\n    /* eslint-enable no-unused-vars, no-empty-function */\\n\\n  }]);\\n\\n  return JingleSession;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (JingleSession);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/JingleSession.js\\\"))\\n\\n/***/ }),\\n/* 105 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = SDPDiffer;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SDPUtil__ = __webpack_require__(14);\\n\\n\\n// this could be useful in Array.prototype.\\n/**\\n *\\n * @param array1\\n * @param array2\\n */\\nfunction arrayEquals(array1, array2) {\\n    // if the other array is a falsy value, return\\n    if (!array2) {\\n        return false;\\n    }\\n\\n    // compare lengths - can save a lot of time\\n    if (array1.length !== array2.length) {\\n        return false;\\n    }\\n\\n    for (var i = 0, l = array1.length; i < l; i++) {\\n        // Check if we have nested arrays\\n        if (array1[i] instanceof Array && array2[i] instanceof Array) {\\n            // recurse into the nested arrays\\n            if (!array1[i].equals(array2[i])) {\\n                return false;\\n            }\\n        } else if (array1[i] !== array2[i]) {\\n            // Warning - two different object instances will never be\\n            // equal: {x:20} != {x:20}\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n\\n/**\\n *\\n * @param mySDP\\n * @param otherSDP\\n */\\nfunction SDPDiffer(mySDP, otherSDP) {\\n    this.mySDP = mySDP;\\n    this.otherSDP = otherSDP;\\n    if (!mySDP) {\\n        throw new Error('\\\"mySDP\\\" is undefined!');\\n    } else if (!otherSDP) {\\n        throw new Error('\\\"otherSDP\\\" is undefined!');\\n    }\\n}\\n\\n/**\\n * Returns map of MediaChannel that contains media contained in\\n * 'mySDP', but not contained in 'otherSdp'. Mapped by channel idx.\\n */\\nSDPDiffer.prototype.getNewMedia = function () {\\n\\n    var myMedias = this.mySDP.getMediaSsrcMap();\\n    var othersMedias = this.otherSDP.getMediaSsrcMap();\\n    var newMedia = {};\\n\\n    Object.keys(othersMedias).forEach(function (othersMediaIdx) {\\n        var myMedia = myMedias[othersMediaIdx];\\n        var othersMedia = othersMedias[othersMediaIdx];\\n\\n        if (!myMedia && othersMedia) {\\n            // Add whole channel\\n            newMedia[othersMediaIdx] = othersMedia;\\n\\n            return;\\n        }\\n\\n        // Look for new ssrcs across the channel\\n        Object.keys(othersMedia.ssrcs).forEach(function (ssrc) {\\n            if (Object.keys(myMedia.ssrcs).indexOf(ssrc) === -1) {\\n                // Allocate channel if we've found ssrc that doesn't exist in\\n                // our channel\\n                if (!newMedia[othersMediaIdx]) {\\n                    newMedia[othersMediaIdx] = {\\n                        mediaindex: othersMedia.mediaindex,\\n                        mid: othersMedia.mid,\\n                        ssrcs: {},\\n                        ssrcGroups: []\\n                    };\\n                }\\n                newMedia[othersMediaIdx].ssrcs[ssrc] = othersMedia.ssrcs[ssrc];\\n            }\\n        });\\n\\n        // Look for new ssrc groups across the channels\\n        othersMedia.ssrcGroups.forEach(function (otherSsrcGroup) {\\n\\n            // try to match the other ssrc-group with an ssrc-group of ours\\n            var matched = false;\\n\\n            for (var i = 0; i < myMedia.ssrcGroups.length; i++) {\\n                var mySsrcGroup = myMedia.ssrcGroups[i];\\n\\n                if (otherSsrcGroup.semantics === mySsrcGroup.semantics && arrayEquals(otherSsrcGroup.ssrcs, mySsrcGroup.ssrcs)) {\\n\\n                    matched = true;\\n                    break;\\n                }\\n            }\\n\\n            if (!matched) {\\n                // Allocate channel if we've found an ssrc-group that doesn't\\n                // exist in our channel\\n\\n                if (!newMedia[othersMediaIdx]) {\\n                    newMedia[othersMediaIdx] = {\\n                        mediaindex: othersMedia.mediaindex,\\n                        mid: othersMedia.mid,\\n                        ssrcs: {},\\n                        ssrcGroups: []\\n                    };\\n                }\\n                newMedia[othersMediaIdx].ssrcGroups.push(otherSsrcGroup);\\n            }\\n        });\\n    });\\n\\n    return newMedia;\\n};\\n\\n/**\\n * TODO: document!\\n */\\nSDPDiffer.prototype.toJingle = function (modify) {\\n    var sdpMediaSsrcs = this.getNewMedia();\\n\\n    var modified = false;\\n\\n    Object.keys(sdpMediaSsrcs).forEach(function (mediaindex) {\\n        modified = true;\\n        var media = sdpMediaSsrcs[mediaindex];\\n\\n        modify.c('content', { name: media.mid });\\n\\n        modify.c('description', { xmlns: 'urn:xmpp:jingle:apps:rtp:1',\\n            media: media.mid });\\n\\n        // FIXME: not completely sure this operates on blocks and / or handles\\n        // different ssrcs correctly\\n        // generate sources from lines\\n        Object.keys(media.ssrcs).forEach(function (ssrcNum) {\\n            var mediaSsrc = media.ssrcs[ssrcNum];\\n\\n            modify.c('source', { xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\\n            modify.attrs({ ssrc: mediaSsrc.ssrc });\\n\\n            // iterate over ssrc lines\\n            mediaSsrc.lines.forEach(function (line) {\\n                var idx = line.indexOf(' ');\\n                var kv = line.substr(idx + 1);\\n\\n                modify.c('parameter');\\n                if (kv.indexOf(':') === -1) {\\n                    modify.attrs({ name: kv });\\n                } else {\\n                    var nv = kv.split(':', 2);\\n                    var name = nv[0];\\n                    var value = __WEBPACK_IMPORTED_MODULE_0__SDPUtil__[\\\"a\\\" /* default */].filterSpecialChars(nv[1]);\\n\\n                    modify.attrs({ name: name });\\n                    modify.attrs({ value: value });\\n                }\\n                modify.up(); // end of parameter\\n            });\\n            modify.up(); // end of source\\n        });\\n\\n        // generate source groups from lines\\n        media.ssrcGroups.forEach(function (ssrcGroup) {\\n            if (ssrcGroup.ssrcs.length) {\\n\\n                modify.c('ssrc-group', {\\n                    semantics: ssrcGroup.semantics,\\n                    xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'\\n                });\\n\\n                ssrcGroup.ssrcs.forEach(function (ssrc) {\\n                    modify.c('source', { ssrc: ssrc }).up(); // end of source\\n                });\\n                modify.up(); // end of ssrc-group\\n            }\\n        });\\n\\n        modify.up(); // end of description\\n        modify.up(); // end of content\\n    });\\n\\n    return modified;\\n};\\n\\n/***/ }),\\n/* 106 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__service_RTC_SignalingEvents__ = __webpack_require__(53);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__service_RTC_SignalingLayer__ = __webpack_require__(107);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global __filename */\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Default XMPP implementation of the {@link SignalingLayer} interface. Obtains\\n * the data from the MUC presence.\\n */\\n\\nvar SignalingLayerImpl = function (_SignalingLayer) {\\n    _inherits(SignalingLayerImpl, _SignalingLayer);\\n\\n    /**\\n     * Creates new instance.\\n     */\\n    function SignalingLayerImpl() {\\n        _classCallCheck(this, SignalingLayerImpl);\\n\\n        /**\\n         * A map that stores SSRCs of remote streams. And is used only locally\\n         * We store the mapping when jingle is received, and later is used\\n         * onaddstream webrtc event where we have only the ssrc\\n         * FIXME: This map got filled and never cleaned and can grow during long\\n         * conference\\n         * @type {Map<number, string>} maps SSRC number to jid\\n         */\\n        var _this = _possibleConstructorReturn(this, (SignalingLayerImpl.__proto__ || Object.getPrototypeOf(SignalingLayerImpl)).call(this));\\n\\n        _this.ssrcOwners = new Map();\\n\\n        /**\\n         *\\n         * @type {ChatRoom|null}\\n         */\\n        _this.chatRoom = null;\\n        return _this;\\n    }\\n\\n    /**\\n     * Sets the <tt>ChatRoom</tt> instance used and binds presence listeners.\\n     * @param {ChatRoom} room\\n     */\\n\\n\\n    _createClass(SignalingLayerImpl, [{\\n        key: 'setChatRoom',\\n        value: function setChatRoom(room) {\\n            var _this2 = this;\\n\\n            var oldChatRoom = this.chatRoom;\\n\\n            this.chatRoom = room;\\n            if (oldChatRoom) {\\n                oldChatRoom.removePresenceListener('audiomuted', this._audioMuteHandler);\\n                oldChatRoom.removePresenceListener('videomuted', this._videoMuteHandler);\\n                oldChatRoom.removePresenceListener('videoType', this._videoTypeHandler);\\n            }\\n            if (room) {\\n                // SignalingEvents\\n                this._audioMuteHandler = function (node, from) {\\n                    _this2.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_2__service_RTC_SignalingEvents__[\\\"a\\\" /* PEER_MUTED_CHANGED */], from, __WEBPACK_IMPORTED_MODULE_1__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */], node.value === 'true');\\n                };\\n                room.addPresenceListener('audiomuted', this._audioMuteHandler);\\n\\n                this._videoMuteHandler = function (node, from) {\\n                    _this2.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_2__service_RTC_SignalingEvents__[\\\"a\\\" /* PEER_MUTED_CHANGED */], from, __WEBPACK_IMPORTED_MODULE_1__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */], node.value === 'true');\\n                };\\n                room.addPresenceListener('videomuted', this._videoMuteHandler);\\n\\n                this._videoTypeHandler = function (node, from) {\\n                    _this2.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_2__service_RTC_SignalingEvents__[\\\"b\\\" /* PEER_VIDEO_TYPE_CHANGED */], from, node.value);\\n                };\\n                room.addPresenceListener('videoType', this._videoTypeHandler);\\n            }\\n        }\\n\\n        /**\\n         * @inheritDoc\\n         */\\n\\n    }, {\\n        key: 'getPeerMediaInfo',\\n        value: function getPeerMediaInfo(owner, mediaType) {\\n            if (this.chatRoom) {\\n                return this.chatRoom.getMediaPresenceInfo(owner, mediaType);\\n            }\\n            logger.error('Requested peer media info, before room was set');\\n        }\\n\\n        /**\\n         * @inheritDoc\\n         */\\n\\n    }, {\\n        key: 'getSSRCOwner',\\n        value: function getSSRCOwner(ssrc) {\\n            return this.ssrcOwners.get(ssrc);\\n        }\\n\\n        /**\\n         * Set an SSRC owner.\\n         * @param {number} ssrc an SSRC to be owned\\n         * @param {string} endpointId owner's ID (MUC nickname)\\n         * @throws TypeError if <tt>ssrc</tt> is not a number\\n         */\\n\\n    }, {\\n        key: 'setSSRCOwner',\\n        value: function setSSRCOwner(ssrc, endpointId) {\\n            if (typeof ssrc !== 'number') {\\n                throw new TypeError('SSRC(' + ssrc + ') must be a number');\\n            }\\n            this.ssrcOwners.set(ssrc, endpointId);\\n        }\\n    }]);\\n\\n    return SignalingLayerImpl;\\n}(__WEBPACK_IMPORTED_MODULE_3__service_RTC_SignalingLayer__[\\\"a\\\" /* default */]);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (SignalingLayerImpl);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/SignalingLayerImpl.js\\\"))\\n\\n/***/ }),\\n/* 107 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__modules_util_Listenable__ = __webpack_require__(10);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n/**\\n * An object that carries the info about specific media type advertised by\\n * participant in the signaling channel.\\n * @typedef {Object} PeerMediaInfo\\n * @property {boolean} muted indicates if the media is currently muted\\n * @property {VideoType|undefined} videoType the type of the video if applicable\\n */\\n\\n/**\\n * Interface used to expose the information carried over the signaling channel\\n * which is not available to the RTC module in the media SDP.\\n *\\n * @interface SignalingLayer\\n */\\n\\nvar SignalingLayer = function (_Listenable) {\\n  _inherits(SignalingLayer, _Listenable);\\n\\n  function SignalingLayer() {\\n    _classCallCheck(this, SignalingLayer);\\n\\n    return _possibleConstructorReturn(this, (SignalingLayer.__proto__ || Object.getPrototypeOf(SignalingLayer)).apply(this, arguments));\\n  }\\n\\n  _createClass(SignalingLayer, [{\\n    key: 'getSSRCOwner',\\n\\n\\n    /**\\n     * Obtains the endpoint ID for given SSRC.\\n     * @param {number} ssrc the SSRC number.\\n     * @return {string|null} the endpoint ID for given media SSRC.\\n     */\\n    value: function getSSRCOwner(ssrc) {\\n      // eslint-disable-line no-unused-vars\\n      throw new Error('not implemented');\\n    }\\n\\n    /**\\n     * Obtains the info about given media advertised in the MUC presence of\\n     * the participant identified by the given MUC JID.\\n     * @param {string} owner the MUC jid of the participant for whom\\n     * {@link PeerMediaInfo} will be obtained.\\n     * @param {MediaType} mediaType the type of the media for which presence\\n     * info will be obtained.\\n     * @return {PeerMediaInfo|null} presenceInfo an object with media presence\\n     * info or <tt>null</tt> either if there is no presence available for given\\n     * JID or if the media type given is invalid.\\n     */\\n\\n  }, {\\n    key: 'getPeerMediaInfo',\\n    value: function getPeerMediaInfo(owner, mediaType) {\\n      // eslint-disable-line no-unused-vars\\n      throw new Error('not implemented');\\n    }\\n  }]);\\n\\n  return SignalingLayer;\\n}(__WEBPACK_IMPORTED_MODULE_0__modules_util_Listenable__[\\\"a\\\" /* default */]);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (SignalingLayer);\\n\\n/***/ }),\\n/* 108 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__);\\n/* global __filename */\\n/**\\n * Strophe logger implementation. Logs from level WARN and above.\\n */\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * This is the last HTTP error status captured from Strophe debug logs.\\n * The purpose of storing it is to distinguish between the network and\\n * infrastructure reason for connection being dropped (see connectionHandler in\\n * xmpp.js). The value will be cleared (-1) if the subsequent request succeeds\\n * which means that the failure could be transient.\\n *\\n * FIXME in the latest Strophe (not released on npm) there is API to handle\\n * particular HTTP errors, but there is no way to learn if the subsequent\\n * request succeeded in order to tell if the error was one time incident or if\\n * it was the reason for dropping the connection by Strophe (the connection is\\n * dropped after 5 subsequent failures). Ideally Strophe should provide more\\n * details about the reason on why the connection stopped.\\n *\\n * @type {number}\\n */\\nvar lastErrorStatus = -1;\\n\\n/**\\n * A regular expression used to catch Strophe's log message indicating that the\\n * last BOSH request was successful. When there is such message seen the\\n * {@link lastErrorStatus} will be set back to '-1'.\\n * @type {RegExp}\\n */\\nvar resetLastErrorStatusRegExpr = /request id \\\\d+.\\\\d+ got 200/;\\n\\n/**\\n * A regular expression used to capture the current value of the BOSH request\\n * error status (HTTP error code or '0' or something else).\\n * @type {RegExp}\\n */\\nvar lastErrorStatusRegExpr = /request errored, status: (\\\\d+), number of errors: \\\\d+/;\\n\\n/**\\n *\\n */\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (function () {\\n\\n    __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].log = function (level, msg) {\\n        // Our global handler reports uncaught errors to the stats which may\\n        // interpret those as partial call failure.\\n        // Strophe log entry about secondary request timeout does not mean that\\n        // it's a final failure(the request will be restarted), so we lower it's\\n        // level here to a warning.\\n        logger.trace('Strophe', level, msg);\\n        if (typeof msg === 'string' && msg.indexOf('Request ') !== -1 && msg.indexOf('timed out (secondary), restarting') !== -1) {\\n            // eslint-disable-next-line no-param-reassign\\n            level = __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].LogLevel.WARN;\\n        }\\n\\n        /* eslint-disable no-case-declarations */\\n        switch (level) {\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].LogLevel.DEBUG:\\n                // The log message which reports successful status is logged on\\n                // Strophe's DEBUG level.\\n                if (lastErrorStatus !== -1 && resetLastErrorStatusRegExpr.test(msg)) {\\n                    logger.debug('Reset lastErrorStatus');\\n                    lastErrorStatus = -1;\\n                }\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].LogLevel.WARN:\\n                logger.warn('Strophe: ' + msg);\\n                var errStatusCapture = lastErrorStatusRegExpr.exec(msg);\\n\\n                if (errStatusCapture && errStatusCapture.length === 2) {\\n                    lastErrorStatus = parseInt(errStatusCapture[1], 10);\\n                    logger.debug('lastErrorStatus set to: ' + lastErrorStatus);\\n                }\\n                break;\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].LogLevel.ERROR:\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].LogLevel.FATAL:\\n                // eslint-disable-next-line no-param-reassign\\n                msg = 'Strophe: ' + msg;\\n                __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default.a.callErrorHandler(new Error(msg));\\n                logger.error(msg);\\n                break;\\n        }\\n\\n        /* eslint-enable no-case-declarations */\\n    };\\n\\n    /**\\n     * Returns error status (HTTP error code) of the last BOSH request.\\n     *\\n     * @return {number} HTTP error code, '0' for unknown or \\\"god knows what\\\"\\n     * (this is a hack).\\n     */\\n    __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getLastErrorStatus = function () {\\n        return lastErrorStatus;\\n    };\\n\\n    __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].getStatusString = function (status) {\\n        switch (status) {\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.ERROR:\\n                return 'ERROR';\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.CONNECTING:\\n                return 'CONNECTING';\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.CONNFAIL:\\n                return 'CONNFAIL';\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.AUTHENTICATING:\\n                return 'AUTHENTICATING';\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.AUTHFAIL:\\n                return 'AUTHFAIL';\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.CONNECTED:\\n                return 'CONNECTED';\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.DISCONNECTED:\\n                return 'DISCONNECTED';\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.DISCONNECTING:\\n                return 'DISCONNECTING';\\n            case __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].Status.ATTACHED:\\n                return 'ATTACHED';\\n            default:\\n                return 'unknown';\\n        }\\n    };\\n});\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/strophe.util.js\\\"))\\n\\n/***/ }),\\n/* 109 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ConnectionPlugin__ = __webpack_require__(23);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\\\"value\\\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Ping every 10 sec\\n */\\nvar PING_INTERVAL = 10000;\\n\\n/**\\n * Ping timeout error after 15 sec of waiting.\\n */\\nvar PING_TIMEOUT = 15000;\\n\\n/**\\n * Will close the connection after 3 consecutive ping errors.\\n */\\nvar PING_THRESHOLD = 3;\\n\\n/**\\n * XEP-0199 ping plugin.\\n *\\n * Registers \\\"urn:xmpp:ping\\\" namespace under Strophe.NS.PING.\\n */\\n\\nvar PingConnectionPlugin = function (_ConnectionPlugin) {\\n    _inherits(PingConnectionPlugin, _ConnectionPlugin);\\n\\n    /**\\n     * Contructs new object\\n     * @param {XMPP} xmpp the xmpp module.\\n     * @constructor\\n     */\\n    function PingConnectionPlugin(xmpp) {\\n        _classCallCheck(this, PingConnectionPlugin);\\n\\n        var _this = _possibleConstructorReturn(this, (PingConnectionPlugin.__proto__ || Object.getPrototypeOf(PingConnectionPlugin)).call(this));\\n\\n        _this.failedPings = 0;\\n        _this.xmpp = xmpp;\\n        return _this;\\n    }\\n\\n    /**\\n     * Initializes the plugin. Method called by Strophe.\\n     * @param connection Strophe connection instance.\\n     */\\n\\n\\n    _createClass(PingConnectionPlugin, [{\\n        key: 'init',\\n        value: function init(connection) {\\n            _get(PingConnectionPlugin.prototype.__proto__ || Object.getPrototypeOf(PingConnectionPlugin.prototype), 'init', this).call(this, connection);\\n            __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].addNamespace('PING', 'urn:xmpp:ping');\\n        }\\n\\n        /* eslint-disable max-params */\\n\\n        /**\\n         * Sends \\\"ping\\\" to given <tt>jid</tt>\\n         * @param jid the JID to which ping request will be sent.\\n         * @param success callback called on success.\\n         * @param error callback called on error.\\n         * @param timeout ms how long are we going to wait for the response. On\\n         * timeout <tt>error<//t> callback is called with undefined error argument.\\n         */\\n\\n    }, {\\n        key: 'ping',\\n        value: function ping(jid, success, error, timeout) {\\n            var iq = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({\\n                type: 'get',\\n                to: jid\\n            });\\n\\n            iq.c('ping', { xmlns: __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].NS.PING });\\n            this.connection.sendIQ(iq, success, error, timeout);\\n        }\\n\\n        /* eslint-enable max-params */\\n\\n        /**\\n         * Checks if given <tt>jid</tt> has XEP-0199 ping support.\\n         * @param jid the JID to be checked for ping support.\\n         * @param callback function with boolean argument which will be\\n         * <tt>true</tt> if XEP-0199 ping is supported by given <tt>jid</tt>\\n         */\\n\\n    }, {\\n        key: 'hasPingSupport',\\n        value: function hasPingSupport(jid, callback) {\\n            this.xmpp.caps.getFeatures(jid).then(function (features) {\\n                return callback(features.has('urn:xmpp:ping'));\\n            }, function (error) {\\n                var errmsg = 'Ping feature discovery error';\\n\\n                __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default.a.callErrorHandler(new Error(errmsg + ': ' + error));\\n                logger.error(errmsg, error);\\n                callback(false);\\n            });\\n        }\\n\\n        /**\\n         * Starts to send ping in given interval to specified remote JID.\\n         * This plugin supports only one such task and <tt>stopInterval</tt>\\n         * must be called before starting a new one.\\n         * @param remoteJid remote JID to which ping requests will be sent to.\\n         * @param interval task interval in ms.\\n         */\\n\\n    }, {\\n        key: 'startInterval',\\n        value: function startInterval(remoteJid) {\\n            var _this2 = this;\\n\\n            var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PING_INTERVAL;\\n\\n            if (this.intervalId) {\\n                var errmsg = 'Ping task scheduled already';\\n\\n                __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default.a.callErrorHandler(new Error(errmsg));\\n                logger.error(errmsg);\\n\\n                return;\\n            }\\n            this.intervalId = window.setInterval(function () {\\n                _this2.ping(remoteJid, function () {\\n                    _this2.failedPings = 0;\\n                }, function (error) {\\n                    _this2.failedPings += 1;\\n                    var errmsg = 'Ping ' + (error ? 'error' : 'timeout');\\n\\n                    if (_this2.failedPings >= PING_THRESHOLD) {\\n                        __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default.a.callErrorHandler(new Error(errmsg));\\n                        logger.error(errmsg, error);\\n\\n                        // FIXME it doesn't help to disconnect when 3rd PING\\n                        // times out, it only stops Strophe from retrying.\\n                        // Not really sure what's the right thing to do in that\\n                        // situation, but just closing the connection makes no\\n                        // sense.\\n                        // self.connection.disconnect();\\n                    } else {\\n                        logger.warn(errmsg, error);\\n                    }\\n                }, PING_TIMEOUT);\\n            }, interval);\\n            logger.info('XMPP pings will be sent every ' + interval + ' ms');\\n        }\\n\\n        /**\\n         * Stops current \\\"ping\\\"  interval task.\\n         */\\n\\n    }, {\\n        key: 'stopInterval',\\n        value: function stopInterval() {\\n            if (this.intervalId) {\\n                window.clearInterval(this.intervalId);\\n                this.intervalId = null;\\n                this.failedPings = 0;\\n                logger.info('Ping interval cleared');\\n            }\\n        }\\n    }]);\\n\\n    return PingConnectionPlugin;\\n}(__WEBPACK_IMPORTED_MODULE_3__ConnectionPlugin__[\\\"b\\\" /* default */]);\\n\\n/**\\n *\\n * @param xmpp\\n */\\n\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (function (xmpp) {\\n    __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].addConnectionPlugin('ping', new PingConnectionPlugin(xmpp));\\n});\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/strophe.ping.js\\\"))\\n\\n/***/ }),\\n/* 110 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ConnectionPlugin__ = __webpack_require__(23);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\\\"value\\\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global $ */\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\nvar RAYO_XMLNS = 'urn:xmpp:rayo:1';\\n\\n/**\\n *\\n */\\n\\nvar RayoConnectionPlugin = function (_ConnectionPlugin) {\\n    _inherits(RayoConnectionPlugin, _ConnectionPlugin);\\n\\n    function RayoConnectionPlugin() {\\n        _classCallCheck(this, RayoConnectionPlugin);\\n\\n        return _possibleConstructorReturn(this, (RayoConnectionPlugin.__proto__ || Object.getPrototypeOf(RayoConnectionPlugin)).apply(this, arguments));\\n    }\\n\\n    _createClass(RayoConnectionPlugin, [{\\n        key: 'init',\\n\\n        /**\\n         *\\n         * @param connection\\n         */\\n        value: function init(connection) {\\n            _get(RayoConnectionPlugin.prototype.__proto__ || Object.getPrototypeOf(RayoConnectionPlugin.prototype), 'init', this).call(this, connection);\\n\\n            this.connection.addHandler(this.onRayo.bind(this), RAYO_XMLNS, 'iq', 'set', null, null);\\n        }\\n\\n        /**\\n         *\\n         * @param iq\\n         */\\n\\n    }, {\\n        key: 'onRayo',\\n        value: function onRayo(iq) {\\n            logger.info('Rayo IQ', iq);\\n        }\\n\\n        /* eslint-disable max-params */\\n\\n        /**\\n         *\\n         * @param to\\n         * @param from\\n         * @param roomName\\n         * @param roomPass\\n         * @param focusMucJid\\n         */\\n\\n    }, {\\n        key: 'dial',\\n        value: function dial(to, from, roomName, roomPass, focusMucJid) {\\n            var _this2 = this;\\n\\n            return new Promise(function (resolve, reject) {\\n                if (!focusMucJid) {\\n                    reject(new Error('Internal error!'));\\n\\n                    return;\\n                }\\n                var req = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({\\n                    type: 'set',\\n                    to: focusMucJid\\n                });\\n\\n                req.c('dial', {\\n                    xmlns: RAYO_XMLNS,\\n                    to: to,\\n                    from: from\\n                });\\n                req.c('header', {\\n                    name: 'JvbRoomName',\\n                    value: roomName\\n                }).up();\\n\\n                if (roomPass && roomPass.length) {\\n                    req.c('header', {\\n                        name: 'JvbRoomPassword',\\n                        value: roomPass\\n                    }).up();\\n                }\\n\\n                _this2.connection.sendIQ(req, function (result) {\\n                    logger.info('Dial result ', result);\\n\\n                    // eslint-disable-next-line newline-per-chained-call\\n                    var resource = $(result).find('ref').attr('uri');\\n\\n                    _this2.callResource = resource.substr('xmpp:'.length);\\n                    logger.info('Received call resource: ' + _this2.callResource);\\n                    resolve();\\n                }, function (error) {\\n                    logger.info('Dial error ', error);\\n                    reject(error);\\n                });\\n            });\\n        }\\n\\n        /* eslint-enable max-params */\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'hangup',\\n        value: function hangup() {\\n            var _this3 = this;\\n\\n            return new Promise(function (resolve, reject) {\\n                if (!_this3.callResource) {\\n                    reject(new Error('No call in progress'));\\n                    logger.warn('No call in progress');\\n\\n                    return;\\n                }\\n\\n                var req = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({\\n                    type: 'set',\\n                    to: _this3.callResource\\n                });\\n\\n                req.c('hangup', {\\n                    xmlns: RAYO_XMLNS\\n                });\\n\\n                _this3.connection.sendIQ(req, function (result) {\\n                    logger.info('Hangup result ', result);\\n                    _this3.callResource = null;\\n                    resolve();\\n                }, function (error) {\\n                    logger.info('Hangup error ', error);\\n                    _this3.callResource = null;\\n                    reject(new Error('Hangup error '));\\n                });\\n            });\\n        }\\n    }]);\\n\\n    return RayoConnectionPlugin;\\n}(__WEBPACK_IMPORTED_MODULE_2__ConnectionPlugin__[\\\"b\\\" /* default */]);\\n\\n/**\\n *\\n */\\n\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (function () {\\n    __WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"Strophe\\\"].addConnectionPlugin('rayo', new RayoConnectionPlugin());\\n});\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/strophe.rayo.js\\\"))\\n\\n/***/ }),\\n/* 111 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ConnectionPlugin__ = __webpack_require__(23);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\\\"value\\\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n/**\\n *  Logs raw stanzas and makes them available for download as JSON\\n */\\n\\nvar StropheLogger = function (_ConnectionPlugin) {\\n  _inherits(StropheLogger, _ConnectionPlugin);\\n\\n  /**\\n   *\\n   */\\n  function StropheLogger() {\\n    _classCallCheck(this, StropheLogger);\\n\\n    var _this = _possibleConstructorReturn(this, (StropheLogger.__proto__ || Object.getPrototypeOf(StropheLogger)).call(this));\\n\\n    _this.log = [];\\n    return _this;\\n  }\\n\\n  /**\\n   *\\n   * @param connection\\n   */\\n\\n\\n  _createClass(StropheLogger, [{\\n    key: 'init',\\n    value: function init(connection) {\\n      _get(StropheLogger.prototype.__proto__ || Object.getPrototypeOf(StropheLogger.prototype), 'init', this).call(this, connection);\\n      this.connection.rawInput = this.logIncoming.bind(this);\\n      this.connection.rawOutput = this.logOutgoing.bind(this);\\n    }\\n\\n    /**\\n     *\\n     * @param stanza\\n     */\\n\\n  }, {\\n    key: 'logIncoming',\\n    value: function logIncoming(stanza) {\\n      this.log.push([new Date().getTime(), 'incoming', stanza]);\\n    }\\n\\n    /**\\n     *\\n     * @param stanza\\n     */\\n\\n  }, {\\n    key: 'logOutgoing',\\n    value: function logOutgoing(stanza) {\\n      this.log.push([new Date().getTime(), 'outgoing', stanza]);\\n    }\\n  }]);\\n\\n  return StropheLogger;\\n}(__WEBPACK_IMPORTED_MODULE_1__ConnectionPlugin__[\\\"b\\\" /* default */]);\\n\\n/**\\n *\\n */\\n\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (function () {\\n  __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].addConnectionPlugin('logger', new StropheLogger());\\n});\\n\\n/***/ }),\\n/* 112 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_xmpp_XMPPEvents__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_xmpp_XMPPEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__service_xmpp_XMPPEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_Listenable__ = __webpack_require__(10);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global $ */\\n\\n // eslint-disable-line camelcase\\n\\n\\n\\n\\n/**\\n * The property\\n */\\nvar IDENTITY_PROPERTIES = ['category', 'type', 'lang', 'name'];\\nvar IDENTITY_PROPERTIES_FOR_COMPARE = ['category', 'type', 'lang'];\\nvar HASH = 'sha-1';\\n\\n/**\\n *\\n * @param a\\n * @param b\\n */\\nfunction compareIdentities(a, b) {\\n    var res = 0;\\n\\n    IDENTITY_PROPERTIES_FOR_COMPARE.some(function (key) {\\n        return (res = a[key] > b[key] && 1 || a[key] < b[key] && -1) !== 0;\\n    });\\n\\n    return res;\\n}\\n\\n/**\\n * Implements xep-0115 ( http://xmpp.org/extensions/xep-0115.html )\\n */\\n\\nvar Caps = function (_Listenable) {\\n    _inherits(Caps, _Listenable);\\n\\n    /**\\n     * Constructs new Caps instance.\\n     * @param {Strophe.Connection} connection the strophe connection object\\n     * @param {String} node the value of the node attribute of the \\\"c\\\" xml node\\n     * that will be sent to the other participants\\n     */\\n    function Caps() {\\n        var connection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n        var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http://jitsi.org/jitsimeet';\\n\\n        _classCallCheck(this, Caps);\\n\\n        var _this = _possibleConstructorReturn(this, (Caps.__proto__ || Object.getPrototypeOf(Caps)).call(this));\\n\\n        _this.node = node;\\n        _this.disco = connection.disco;\\n        if (!_this.disco) {\\n            throw new Error('Missing strophe-plugins ' + '(disco plugin is required)!');\\n        }\\n\\n        _this.versionToCapabilities = Object.create(null);\\n        _this.jidToVersion = Object.create(null);\\n        _this.version = '';\\n        _this.rooms = new Set();\\n\\n        var emuc = connection.emuc;\\n\\n        emuc.addListener(__WEBPACK_IMPORTED_MODULE_1__service_xmpp_XMPPEvents___default.a.EMUC_ROOM_ADDED, function (room) {\\n            return _this._addChatRoom(room);\\n        });\\n        emuc.addListener(__WEBPACK_IMPORTED_MODULE_1__service_xmpp_XMPPEvents___default.a.EMUC_ROOM_REMOVED, function (room) {\\n            return _this._removeChatRoom(room);\\n        });\\n        Object.keys(emuc.rooms).forEach(function (jid) {\\n            _this._addChatRoom(emuc.rooms[jid]);\\n        });\\n\\n        __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].addNamespace('CAPS', 'http://jabber.org/protocol/caps');\\n        _this.disco.addFeature(__WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].NS.CAPS);\\n        connection.addHandler(_this._handleCaps.bind(_this), __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].NS.CAPS);\\n\\n        _this._onMucMemberLeft = _this._removeJidToVersionEntry.bind(_this);\\n        return _this;\\n    }\\n\\n    /**\\n     * Adds new feature to the list of supported features for the local\\n     * participant\\n     * @param {String} feature the name of the feature.\\n     * @param {boolean} submit if true - new presence with updated \\\"c\\\" node\\n     * will be sent.\\n     */\\n\\n\\n    _createClass(Caps, [{\\n        key: 'addFeature',\\n        value: function addFeature(feature) {\\n            var submit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n            this.disco.addFeature(feature);\\n            this._generateVersion();\\n            if (submit) {\\n                this.submit();\\n            }\\n        }\\n\\n        /**\\n         * Removes a feature from the list of supported features for the local\\n         * participant\\n         * @param {String} feature the name of the feature.\\n         * @param {boolean} submit if true - new presence with updated \\\"c\\\" node\\n         * will be sent.\\n         */\\n\\n    }, {\\n        key: 'removeFeature',\\n        value: function removeFeature(feature) {\\n            var submit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n            this.disco.removeFeature(feature);\\n            this._generateVersion();\\n            if (submit) {\\n                this.submit();\\n            }\\n        }\\n\\n        /**\\n         * Sends new presence stanza for every room from the list of rooms.\\n         */\\n\\n    }, {\\n        key: 'submit',\\n        value: function submit() {\\n            this.rooms.forEach(function (room) {\\n                return room.sendPresence();\\n            });\\n        }\\n\\n        /**\\n         * Returns a set with the features for a participant.\\n         * @param {String} jid the jid of the participant\\n         * @param {int} timeout the timeout in ms for reply from the participant.\\n         * @returns {Promise<Set<String>, Error>}\\n         */\\n\\n    }, {\\n        key: 'getFeatures',\\n        value: function getFeatures(jid) {\\n            var _this2 = this;\\n\\n            var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;\\n\\n            var user = jid in this.jidToVersion ? this.jidToVersion[jid] : null;\\n\\n            if (!user || !(user.version in this.versionToCapabilities)) {\\n                var node = user ? user.node + '#' + user.version : null;\\n\\n                return new Promise(function (resolve, reject) {\\n                    return _this2.disco.info(jid, node, function (response) {\\n                        var features = new Set();\\n\\n                        $(response).find('>query>feature').each(function (idx, el) {\\n                            return features.add(el.getAttribute('var'));\\n                        });\\n                        if (user) {\\n                            // TODO: Maybe use the version + node + hash as keys?\\n                            _this2.versionToCapabilities[user.version] = features;\\n                        }\\n                        resolve(features);\\n                    }, reject, timeout);\\n                });\\n            }\\n\\n            return Promise.resolve(this.versionToCapabilities[user.version]);\\n        }\\n\\n        /**\\n         * Adds ChatRoom instance to the list of rooms. Adds listeners to the room\\n         * and adds \\\"c\\\" element to the presences of the room.\\n         * @param {ChatRoom} room the room.\\n         */\\n\\n    }, {\\n        key: '_addChatRoom',\\n        value: function _addChatRoom(room) {\\n            this.rooms.add(room);\\n            room.addListener(__WEBPACK_IMPORTED_MODULE_1__service_xmpp_XMPPEvents___default.a.MUC_MEMBER_LEFT, this._onMucMemberLeft);\\n            this._fixChatRoomPresenceMap(room);\\n        }\\n\\n        /**\\n         * Removes ChatRoom instance from the list of rooms. Removes listeners\\n         * added from the Caps class.\\n         * @param {ChatRoom} room the room.\\n         */\\n\\n    }, {\\n        key: '_removeChatRoom',\\n        value: function _removeChatRoom(room) {\\n            this.rooms.delete(room);\\n            room.removeListener(__WEBPACK_IMPORTED_MODULE_1__service_xmpp_XMPPEvents___default.a.MUC_MEMBER_LEFT, this._onMucMemberLeft);\\n        }\\n\\n        /**\\n         * Creates/updates the \\\"c\\\" xml node into the presence of the passed room.\\n         * @param {ChatRoom} room the room.\\n         */\\n\\n    }, {\\n        key: '_fixChatRoomPresenceMap',\\n        value: function _fixChatRoomPresenceMap(room) {\\n            room.addToPresence('c', {\\n                attributes: {\\n                    xmlns: __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].NS.CAPS,\\n                    hash: HASH,\\n                    node: this.node,\\n                    ver: this.version\\n                }\\n            });\\n        }\\n\\n        /**\\n         * Handles this.version changes.\\n         */\\n\\n    }, {\\n        key: '_notifyVersionChanged',\\n        value: function _notifyVersionChanged() {\\n            var _this3 = this;\\n\\n            // update the version for all rooms\\n            this.rooms.forEach(function (room) {\\n                return _this3._fixChatRoomPresenceMap(room);\\n            });\\n            this.submit();\\n        }\\n\\n        /**\\n         * Generates the value for the \\\"ver\\\" attribute.\\n         */\\n\\n    }, {\\n        key: '_generateVersion',\\n        value: function _generateVersion() {\\n            var identities = this.disco._identities.sort(compareIdentities).reduce(function (accumulatedValue, identity) {\\n                return IDENTITY_PROPERTIES.reduce(function (tmp, key, idx) {\\n                    return tmp + (idx === 0 ? '' : '/') + identity[key];\\n                }, '') + '<';\\n            }, '');\\n            var features = this.disco._features.sort().reduce(function (tmp, feature) {\\n                return tmp + feature + '<';\\n            }, '');\\n\\n            this.version = Object(__WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"b64_sha1\\\"])(identities + features);\\n            this._notifyVersionChanged();\\n        }\\n\\n        /**\\n         * Parses the \\\"c\\\" xml node from presence.\\n         * @param {DOMElement} stanza the presence packet\\n         */\\n\\n    }, {\\n        key: '_handleCaps',\\n        value: function _handleCaps(stanza) {\\n            var from = stanza.getAttribute('from');\\n            var caps = stanza.querySelector('c');\\n            var version = caps.getAttribute('ver');\\n            var node = caps.getAttribute('node');\\n            var oldVersion = this.jidToVersion[from];\\n\\n            this.jidToVersion[from] = { version: version,\\n                node: node };\\n            if (oldVersion && oldVersion.version !== version) {\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_1__service_xmpp_XMPPEvents___default.a.PARTCIPANT_FEATURES_CHANGED, from);\\n            }\\n\\n            // return true to not remove the handler from Strophe\\n            return true;\\n        }\\n\\n        /**\\n         * Removes entry from this.jidToVersion map.\\n         * @param {String} jid the jid to be removed.\\n         */\\n\\n    }, {\\n        key: '_removeJidToVersionEntry',\\n        value: function _removeJidToVersionEntry(jid) {\\n            if (jid in this.jidToVersion) {\\n                delete this.jidToVersion[jid];\\n            }\\n        }\\n    }]);\\n\\n    return Caps;\\n}(__WEBPACK_IMPORTED_MODULE_2__util_Listenable__[\\\"a\\\" /* default */]);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (Caps);\\n\\n/***/ }),\\n/* 113 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = JitsiConferenceEventManager;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__service_authentication_AuthenticationEvents__ = __webpack_require__(48);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__service_authentication_AuthenticationEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__service_authentication_AuthenticationEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_util_EventEmitterForwarder__ = __webpack_require__(114);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_util_EventEmitterForwarder___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__modules_util_EventEmitterForwarder__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__ = __webpack_require__(32);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__service_RTC_VideoType__ = __webpack_require__(13);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__service_RTC_VideoType___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__service_RTC_VideoType__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__ = __webpack_require__(5);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents__);\\n/* global __filename */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_4_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Setups all event listeners related to conference\\n * @param conference {JitsiConference} the conference\\n */\\nfunction JitsiConferenceEventManager(conference) {\\n    this.conference = conference;\\n\\n    // Listeners related to the conference only\\n    conference.on(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"TRACK_MUTE_CHANGED\\\"], function (track) {\\n        if (!track.isLocal() || !conference.statistics) {\\n            return;\\n        }\\n        var session = track.isP2P ? conference.p2pJingleSession : conference.jvbJingleSession;\\n\\n        // TPC will be null, before the conference starts, but the event\\n        // still should be queued\\n        var tpc = session && session.peerconnection || null;\\n\\n        conference.statistics.sendMuteEvent(tpc, track.isMuted(), track.getType());\\n    });\\n    conference.on(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONNECTION_INTERRUPTED\\\"], __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].sendEventToAll.bind(__WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */], __WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"f\\\" /* CONNECTION_INTERRUPTED */]));\\n    conference.on(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONNECTION_RESTORED\\\"], __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].sendEventToAll.bind(__WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */], __WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"g\\\" /* CONNECTION_RESTORED */]));\\n}\\n\\n/**\\n * Setups event listeners related to conference.chatRoom\\n */\\nJitsiConferenceEventManager.prototype.setupChatRoomListeners = function () {\\n    var _this = this;\\n\\n    var conference = this.conference;\\n    var chatRoom = conference.room;\\n\\n    this.chatRoomForwarder = new __WEBPACK_IMPORTED_MODULE_3__modules_util_EventEmitterForwarder___default.a(chatRoom, this.conference.eventEmitter);\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.ICE_RESTARTING, function (jingleSession) {\\n        if (!jingleSession.isP2P) {\\n            // If using DataChannel as bridge channel, it must be closed\\n            // before ICE restart, otherwise Chrome will not trigger \\\"opened\\\"\\n            // event for the channel established with the new bridge.\\n            // TODO: This may be bypassed when using a WebSocket as bridge\\n            // channel.\\n            conference.rtc.closeBridgeChannel();\\n        }\\n\\n        // else: there are no DataChannels in P2P session (at least for now)\\n    });\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.AUDIO_MUTED_BY_FOCUS, function (value) {\\n        __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"v\\\" /* REMOTELY_MUTED */]);\\n\\n        // set isMutedByFocus when setAudioMute Promise ends\\n        conference.rtc.setAudioMute(value).then(function () {\\n            conference.isMutedByFocus = true;\\n        }, function () {\\n            return logger.warn('Error while audio muting due to focus request');\\n        });\\n    });\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.SUBJECT_CHANGED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"SUBJECT_CHANGED\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.MUC_JOINED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_JOINED\\\"]);\\n\\n    // send some analytics events\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.MUC_JOINED, function () {\\n        _this.conference.isJvbConnectionInterrupted = false;\\n\\n        Object.keys(chatRoom.connectionTimes).forEach(function (key) {\\n            var value = chatRoom.connectionTimes[key];\\n            var eventName = 'conference.' + __WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"C\\\" /* _CONNECTION_TIMES_ */] + key;\\n\\n            __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(eventName, { value: value });\\n        });\\n        Object.keys(chatRoom.xmpp.connectionTimes).forEach(function (key) {\\n            var value = chatRoom.xmpp.connectionTimes[key];\\n            var eventName = 'xmpp.' + __WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"C\\\" /* _CONNECTION_TIMES_ */] + key;\\n\\n            __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(eventName, { value: value });\\n        });\\n    });\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.ROOM_JOIN_ERROR, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"CONNECTION_ERROR\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.ROOM_CONNECT_ERROR, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"CONNECTION_ERROR\\\"]);\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.ROOM_CONNECT_NOT_ALLOWED_ERROR, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"NOT_ALLOWED_ERROR\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.ROOM_MAX_USERS_ERROR, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"CONFERENCE_MAX_USERS\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.PASSWORD_REQUIRED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"PASSWORD_REQUIRED\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.AUTHENTICATION_REQUIRED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"AUTHENTICATION_REQUIRED\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.BRIDGE_DOWN, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"VIDEOBRIDGE_NOT_AVAILABLE\\\"]);\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.BRIDGE_DOWN, function () {\\n        return __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"b\\\" /* BRIDGE_DOWN */]);\\n    });\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.RESERVATION_ERROR, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"RESERVATION_ERROR\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.GRACEFUL_SHUTDOWN, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"GRACEFUL_SHUTDOWN\\\"]);\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.JINGLE_FATAL_ERROR, function (session, error) {\\n        if (!session.isP2P) {\\n            conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"JINGLE_FATAL_ERROR\\\"], error);\\n        }\\n    });\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.CONNECTION_ICE_FAILED, function (jingleSession) {\\n        conference._onIceConnectionFailed(jingleSession);\\n    });\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.MUC_DESTROYED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"CONFERENCE_DESTROYED\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.CHAT_ERROR_RECEIVED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_ERROR\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"CHAT_ERROR\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.FOCUS_DISCONNECTED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"FOCUS_DISCONNECTED\\\"]);\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.FOCUS_LEFT, function () {\\n        __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"k\\\" /* FOCUS_LEFT */]);\\n        conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"FOCUS_LEFT\\\"]);\\n    });\\n\\n    var eventLogHandler = function eventLogHandler(reason) {\\n        return __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].sendEventToAll(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"c\\\" /* CONFERENCE_ERROR_ */] + '.' + reason);\\n    };\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.SESSION_ACCEPT_TIMEOUT, function (jingleSession) {\\n        eventLogHandler(jingleSession.isP2P ? 'p2pSessionAcceptTimeout' : 'sessionAcceptTimeout');\\n    });\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.RECORDER_STATE_CHANGED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"RECORDER_STATE_CHANGED\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.TRANSCRIPTION_STATUS_CHANGED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"TRANSCRIPTION_STATUS_CHANGED\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.VIDEO_SIP_GW_AVAILABILITY_CHANGED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"VIDEO_SIP_GW_AVAILABILITY_CHANGED\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.VIDEO_SIP_GW_SESSION_STATE_CHANGED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"VIDEO_SIP_GW_SESSION_STATE_CHANGED\\\"]);\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.PHONE_NUMBER_CHANGED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"PHONE_NUMBER_CHANGED\\\"]);\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.CONFERENCE_SETUP_FAILED, function (jingleSession, error) {\\n        if (!jingleSession.isP2P) {\\n            conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_FAILED\\\"], __WEBPACK_IMPORTED_MODULE_5__JitsiConferenceErrors__[\\\"SETUP_FAILED\\\"], error);\\n        }\\n    });\\n\\n    chatRoom.setParticipantPropertyListener(function (node, from) {\\n        var participant = conference.getParticipantById(from);\\n\\n        if (!participant) {\\n            return;\\n        }\\n\\n        participant.setProperty(node.tagName.substring('jitsi_participant_'.length), node.value);\\n    });\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.KICKED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"KICKED\\\"]);\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.KICKED, function () {\\n        conference.room = null;\\n        conference.leave();\\n    });\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.SUSPEND_DETECTED, conference.onSuspendDetected.bind(conference));\\n\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.MUC_LOCK_CHANGED, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"LOCK_STATE_CHANGED\\\"]);\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.MUC_MEMBER_JOINED, conference.onMemberJoined.bind(conference));\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.MUC_MEMBER_LEFT, conference.onMemberLeft.bind(conference));\\n    this.chatRoomForwarder.forward(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.MUC_LEFT, __WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"CONFERENCE_LEFT\\\"]);\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.DISPLAY_NAME_CHANGED, conference.onDisplayNameChanged.bind(conference));\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.LOCAL_ROLE_CHANGED, function (role) {\\n        conference.onLocalRoleChanged(role);\\n\\n        // log all events for the recorder operated by the moderator\\n        if (conference.statistics && conference.isModerator()) {\\n            conference.on(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"RECORDER_STATE_CHANGED\\\"], function (status, error) {\\n                var logObject = {\\n                    id: 'recorder_status',\\n                    status: status\\n                };\\n\\n                if (error) {\\n                    logObject.error = error;\\n                }\\n                __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify(logObject));\\n            });\\n        }\\n    });\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.MUC_ROLE_CHANGED, conference.onUserRoleChanged.bind(conference));\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_2__service_authentication_AuthenticationEvents___default.a.IDENTITY_UPDATED, function (authEnabled, authIdentity) {\\n        conference.authEnabled = authEnabled;\\n        conference.authIdentity = authIdentity;\\n        conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"AUTH_STATUS_CHANGED\\\"], authEnabled, authIdentity);\\n    });\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.MESSAGE_RECEIVED,\\n\\n    // eslint-disable-next-line max-params\\n    function (jid, displayName, txt, myJid, ts) {\\n        var id = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(jid);\\n\\n        conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"MESSAGE_RECEIVED\\\"], id, txt, ts);\\n    });\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.PRESENCE_STATUS, function (jid, status) {\\n        var id = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(jid);\\n        var participant = conference.getParticipantById(id);\\n\\n        if (!participant || participant._status === status) {\\n            return;\\n        }\\n        participant._status = status;\\n        conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"USER_STATUS_CHANGED\\\"], id, status);\\n    });\\n\\n    chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.JSON_MESSAGE_RECEIVED, function (from, payload) {\\n        var id = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(from);\\n        var participant = conference.getParticipantById(id);\\n\\n        if (participant) {\\n            conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"ENDPOINT_MESSAGE_RECEIVED\\\"], participant, payload);\\n        } else {\\n            logger.warn('Ignored XMPPEvents.JSON_MESSAGE_RECEIVED for not existing ' + ('participant: ' + from), payload);\\n        }\\n    });\\n\\n    chatRoom.addPresenceListener('startmuted', function (data, from) {\\n        var isModerator = false;\\n\\n        if (conference.myUserId() === from && conference.isModerator()) {\\n            isModerator = true;\\n        } else {\\n            var participant = conference.getParticipantById(from);\\n\\n            if (participant && participant.isModerator()) {\\n                isModerator = true;\\n            }\\n        }\\n\\n        if (!isModerator) {\\n            return;\\n        }\\n\\n        var startAudioMuted = data.attributes.audio === 'true';\\n        var startVideoMuted = data.attributes.video === 'true';\\n\\n        var updated = false;\\n\\n        if (startAudioMuted !== conference.startMutedPolicy.audio) {\\n            conference.startMutedPolicy.audio = startAudioMuted;\\n            updated = true;\\n        }\\n\\n        if (startVideoMuted !== conference.startMutedPolicy.video) {\\n            conference.startMutedPolicy.video = startVideoMuted;\\n            updated = true;\\n        }\\n\\n        if (updated) {\\n            conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"START_MUTED_POLICY_CHANGED\\\"], conference.startMutedPolicy);\\n        }\\n    });\\n\\n    chatRoom.addPresenceListener('devices', function (data, from) {\\n        var isAudioAvailable = false;\\n        var isVideoAvailable = false;\\n\\n        data.children.forEach(function (config) {\\n            if (config.tagName === 'audio') {\\n                isAudioAvailable = config.value === 'true';\\n            }\\n            if (config.tagName === 'video') {\\n                isVideoAvailable = config.value === 'true';\\n            }\\n        });\\n\\n        var availableDevices = void 0;\\n\\n        if (conference.myUserId() === from) {\\n            availableDevices = conference.availableDevices;\\n        } else {\\n            var participant = conference.getParticipantById(from);\\n\\n            if (!participant) {\\n                return;\\n            }\\n\\n            availableDevices = participant._availableDevices;\\n        }\\n\\n        var updated = false;\\n\\n        if (availableDevices.audio !== isAudioAvailable) {\\n            updated = true;\\n            availableDevices.audio = isAudioAvailable;\\n        }\\n\\n        if (availableDevices.video !== isVideoAvailable) {\\n            updated = true;\\n            availableDevices.video = isVideoAvailable;\\n        }\\n\\n        if (updated) {\\n            conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"AVAILABLE_DEVICES_CHANGED\\\"], from, availableDevices);\\n        }\\n    });\\n\\n    if (conference.statistics) {\\n        // FIXME ICE related events should end up in RTCEvents eventually\\n        chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.CONNECTION_ICE_FAILED, function (session) {\\n            conference.statistics.sendIceConnectionFailedEvent(session.peerconnection);\\n        });\\n\\n        // FIXME XMPPEvents.ADD_ICE_CANDIDATE_FAILED is never emitted\\n        chatRoom.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.ADD_ICE_CANDIDATE_FAILED, function (e, pc) {\\n            conference.statistics.sendAddIceCandidateFailed(e, pc);\\n        });\\n    }\\n};\\n\\n/**\\n * Setups event listeners related to conference.rtc\\n */\\nJitsiConferenceEventManager.prototype.setupRTCListeners = function () {\\n    var conference = this.conference;\\n    var rtc = conference.rtc;\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.REMOTE_TRACK_ADDED, conference.onRemoteTrackAdded.bind(conference));\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.REMOTE_TRACK_REMOVED, conference.onRemoteTrackRemoved.bind(conference));\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.DOMINANT_SPEAKER_CHANGED, function (id) {\\n        if (conference.lastDominantSpeaker !== id && conference.room) {\\n            conference.lastDominantSpeaker = id;\\n            conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"DOMINANT_SPEAKER_CHANGED\\\"], id);\\n        }\\n        if (conference.statistics && conference.myUserId() === id) {\\n            // We are the new dominant speaker.\\n            conference.statistics.sendDominantSpeakerEvent();\\n        }\\n    });\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.DATA_CHANNEL_OPEN, function () {\\n        var now = window.performance.now();\\n\\n        logger.log('(TIME) data channel opened ', now);\\n        conference.room.connectionTimes['data.channel.opened'] = now;\\n        __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(__WEBPACK_IMPORTED_MODULE_1__service_statistics_AnalyticsEvents__[\\\"h\\\" /* DATA_CHANNEL_OPEN */], { value: now });\\n\\n        conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"DATA_CHANNEL_OPENED\\\"]);\\n    });\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.AVAILABLE_DEVICES_CHANGED, function (devices) {\\n        return conference.room.updateDeviceAvailability(devices);\\n    });\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.ENDPOINT_MESSAGE_RECEIVED, function (from, payload) {\\n        var participant = conference.getParticipantById(from);\\n\\n        if (participant) {\\n            conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"ENDPOINT_MESSAGE_RECEIVED\\\"], participant, payload);\\n        } else {\\n            logger.warn('Ignored ENDPOINT_MESSAGE_RECEIVED for not existing ' + ('participant: ' + from), payload);\\n        }\\n    });\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.LOCAL_UFRAG_CHANGED, function (tpc, ufrag) {\\n        if (!tpc.isP2P) {\\n            __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify({\\n                id: 'local_ufrag',\\n                value: ufrag\\n            }));\\n        }\\n    });\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.REMOTE_UFRAG_CHANGED, function (tpc, ufrag) {\\n        if (!tpc.isP2P) {\\n            __WEBPACK_IMPORTED_MODULE_10__modules_statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify({\\n                id: 'remote_ufrag',\\n                value: ufrag\\n            }));\\n        }\\n    });\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.CREATE_ANSWER_FAILED, function (e, tpc) {\\n        conference.statistics.sendCreateAnswerFailed(e, tpc);\\n    });\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.CREATE_OFFER_FAILED, function (e, tpc) {\\n        conference.statistics.sendCreateOfferFailed(e, tpc);\\n    });\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.SET_LOCAL_DESCRIPTION_FAILED, function (e, tpc) {\\n        conference.statistics.sendSetLocalDescFailed(e, tpc);\\n    });\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.SET_REMOTE_DESCRIPTION_FAILED, function (e, tpc) {\\n        conference.statistics.sendSetRemoteDescFailed(e, tpc);\\n    });\\n\\n    rtc.addListener(__WEBPACK_IMPORTED_MODULE_8__service_RTC_RTCEvents___default.a.LOCAL_TRACK_SSRC_UPDATED, function (track, ssrc) {\\n        // when starting screen sharing, the track is created and when\\n        // we do set local description and we process the ssrc we\\n        // will be notified for it and we will report it with the event\\n        // for screen sharing\\n        if (track.isVideoTrack() && track.videoType === __WEBPACK_IMPORTED_MODULE_9__service_RTC_VideoType___default.a.DESKTOP) {\\n            conference.statistics.sendScreenSharingEvent(true, ssrc);\\n        }\\n    });\\n};\\n\\n/**\\n * Setups event listeners related to conference.xmpp\\n */\\nJitsiConferenceEventManager.prototype.setupXMPPListeners = function () {\\n    var conference = this.conference;\\n\\n    conference.xmpp.caps.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.PARTCIPANT_FEATURES_CHANGED, function (from) {\\n        var participant = conference.getParticipantById(__WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(from));\\n\\n        if (participant) {\\n            conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"PARTCIPANT_FEATURES_CHANGED\\\"], participant);\\n        }\\n    });\\n    conference.xmpp.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.CALL_INCOMING, conference.onIncomingCall.bind(conference));\\n    conference.xmpp.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.CALL_ACCEPTED, conference.onCallAccepted.bind(conference));\\n    conference.xmpp.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.TRANSPORT_INFO, conference.onTransportInfo.bind(conference));\\n    conference.xmpp.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.CALL_ENDED, conference.onCallEnded.bind(conference));\\n\\n    conference.xmpp.addListener(__WEBPACK_IMPORTED_MODULE_11__service_xmpp_XMPPEvents___default.a.START_MUTED_FROM_FOCUS, function (audioMuted, videoMuted) {\\n        if (conference.options.config.ignoreStartMuted) {\\n            return;\\n        }\\n\\n        conference.startAudioMuted = audioMuted;\\n        conference.startVideoMuted = videoMuted;\\n\\n        // mute existing local tracks because this is initial mute from\\n        // Jicofo\\n        conference.getLocalTracks().forEach(function (track) {\\n            switch (track.getType()) {\\n                case __WEBPACK_IMPORTED_MODULE_7__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]:\\n                    conference.startAudioMuted && track.mute();\\n                    break;\\n                case __WEBPACK_IMPORTED_MODULE_7__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]:\\n                    conference.startVideoMuted && track.mute();\\n                    break;\\n            }\\n        });\\n\\n        conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"STARTED_MUTED\\\"]);\\n    });\\n};\\n\\n/**\\n * Setups event listeners related to conference.statistics\\n */\\nJitsiConferenceEventManager.prototype.setupStatisticsListeners = function () {\\n    var conference = this.conference;\\n\\n    if (!conference.statistics) {\\n        return;\\n    }\\n\\n    /* eslint-disable max-params */\\n    conference.statistics.addAudioLevelListener(function (tpc, ssrc, level, isLocal) {\\n        conference.rtc.setAudioLevel(tpc, ssrc, level, isLocal);\\n    });\\n\\n    /* eslint-enable max-params */\\n\\n    // Forward the \\\"before stats disposed\\\" event\\n    conference.statistics.addBeforeDisposedListener(function () {\\n        conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_6__JitsiConferenceEvents__[\\\"BEFORE_STATISTICS_DISPOSED\\\"]);\\n    });\\n    conference.statistics.addByteSentStatsListener(function (tpc, stats) {\\n        conference.getLocalTracks(__WEBPACK_IMPORTED_MODULE_7__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]).forEach(function (track) {\\n            var ssrc = tpc.getLocalSSRC(track);\\n\\n            if (!ssrc || !stats.hasOwnProperty(ssrc)) {\\n                return;\\n            }\\n\\n            track._onByteSentStatsReceived(tpc, stats[ssrc]);\\n        });\\n    });\\n};\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"JitsiConferenceEventManager.js\\\"))\\n\\n/***/ }),\\n/* 114 */\\n/***/ (function(module, exports) {\\n\\n/**\\n * Implements utility to forward events from one eventEmitter to another.\\n * @param src {object} instance of EventEmitter or another class that implements\\n * addListener method which will register listener to EventEmitter instance.\\n * @param dest {object} instance of EventEmitter or another class that\\n * implements emit method which will emit an event.\\n */\\nfunction EventEmitterForwarder(src, dest) {\\n    if (!src || !dest || typeof src.addListener !== 'function' || typeof dest.emit !== 'function') {\\n        throw new Error('Invalid arguments passed to EventEmitterForwarder');\\n    }\\n    this.src = src;\\n    this.dest = dest;\\n}\\n\\n/**\\n * Adds event to be forwarded from src to dest.\\n * @param srcEvent {string} the event that EventEmitterForwarder is listening\\n * for.\\n * @param dstEvent {string} the event that will be fired from dest.\\n * @param arguments all other passed arguments are going to be fired with\\n * dstEvent.\\n */\\nEventEmitterForwarder.prototype.forward = function () {\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n        args[_key] = arguments[_key];\\n    }\\n\\n    var srcEvent = args[0];\\n\\n    // This will be the \\\"this\\\" value for emit function.\\n\\n    args[0] = this.dest;\\n\\n    // Using bind.apply to pass the arguments as Array-like object (\\\"arguments\\\")\\n    this.src.addListener(srcEvent, Function.prototype.bind.apply(this.dest.emit, args));\\n};\\n\\nmodule.exports = EventEmitterForwarder;\\n\\n/***/ }),\\n/* 115 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* WEBPACK VAR INJECTION */(function(__filename) {var logger = __webpack_require__(0).getLogger(__filename);\\n\\n/**\\n *\\n * @param localAudio\\n * @param peerConnection\\n */\\nfunction JitsiDTMFManager(localAudio, peerConnection) {\\n    var audioTrack = localAudio.getTrack();\\n\\n    if (!audioTrack) {\\n        throw new Error('Failed to initialize DTMFSender: no audio track.');\\n    }\\n    this.dtmfSender = peerConnection.peerconnection.createDTMFSender(audioTrack);\\n    logger.debug('Initialized DTMFSender');\\n}\\n\\nJitsiDTMFManager.prototype.sendTones = function (tones, duration, pause) {\\n    this.dtmfSender.insertDTMF(tones, duration || 200, pause || 200);\\n};\\n/* WEBPACK VAR INJECTION */}.call(exports, \\\"modules/DTMF/JitsiDTMFManager.js\\\"))\\n\\n/***/ }),\\n/* 116 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__modules_connectivity_ParticipantConnectionStatus__ = __webpack_require__(36);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__service_RTC_MediaType__ = __webpack_require__(4);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Represents a participant in (i.e. a member of) a conference.\\n */\\n\\nvar JitsiParticipant = function () {\\n\\n    /* eslint-disable max-params */\\n\\n    /**\\n     * Initializes a new JitsiParticipant instance.\\n     *\\n     * @constructor\\n     * @param jid the conference XMPP jid\\n     * @param conference\\n     * @param displayName\\n     * @param {Boolean} hidden - True if the new JitsiParticipant instance is to\\n     * represent a hidden participant; otherwise, false.\\n     * @param {string} statsID - optional participant statsID\\n     * @param {string} status - the initial status if any.\\n     */\\n    function JitsiParticipant(jid, conference, displayName, hidden, statsID, status) {\\n        _classCallCheck(this, JitsiParticipant);\\n\\n        this._jid = jid;\\n        this._id = __WEBPACK_IMPORTED_MODULE_0_strophe_js__[\\\"Strophe\\\"].getResourceFromJid(jid);\\n        this._conference = conference;\\n        this._displayName = displayName;\\n        this._supportsDTMF = false;\\n        this._tracks = [];\\n        this._role = 'none';\\n        this._status = status;\\n        this._availableDevices = {\\n            audio: undefined,\\n            video: undefined\\n        };\\n        this._hidden = hidden;\\n        this._statsID = statsID;\\n        this._connectionStatus = __WEBPACK_IMPORTED_MODULE_2__modules_connectivity_ParticipantConnectionStatus__[\\\"a\\\" /* ParticipantConnectionStatus */].ACTIVE;\\n        this._properties = {};\\n    }\\n\\n    /* eslint-enable max-params */\\n\\n    /**\\n     * @returns {JitsiConference} The conference that this participant belongs\\n     * to.\\n     */\\n\\n\\n    _createClass(JitsiParticipant, [{\\n        key: 'getConference',\\n        value: function getConference() {\\n            return this._conference;\\n        }\\n\\n        /**\\n         * Gets the value of a property of this participant.\\n         */\\n\\n    }, {\\n        key: 'getProperty',\\n        value: function getProperty(name) {\\n            return this._properties[name];\\n        }\\n\\n        /**\\n         * Checks whether this <tt>JitsiParticipant</tt> has any video tracks which\\n         * are muted according to their underlying WebRTC <tt>MediaStreamTrack</tt>\\n         * muted status.\\n         * @return {boolean} <tt>true</tt> if this <tt>participant</tt> contains any\\n         * video <tt>JitsiTrack</tt>s which are muted as defined in\\n         * {@link JitsiTrack.isWebRTCTrackMuted}.\\n         */\\n\\n    }, {\\n        key: 'hasAnyVideoTrackWebRTCMuted',\\n        value: function hasAnyVideoTrackWebRTCMuted() {\\n            return this.getTracks().some(function (jitsiTrack) {\\n                return jitsiTrack.getType() === __WEBPACK_IMPORTED_MODULE_3__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */] && jitsiTrack.isWebRTCTrackMuted();\\n            });\\n        }\\n\\n        /**\\n         * Updates participant's connection status.\\n         * @param {string} state the current participant connection state.\\n         * {@link ParticipantConnectionStatus}.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_setConnectionStatus',\\n        value: function _setConnectionStatus(status) {\\n            this._connectionStatus = status;\\n        }\\n\\n        /**\\n         * Return participant's connectivity status.\\n         *\\n         * @returns {string} the connection status\\n         * <tt>ParticipantConnectionStatus</tt> of the user.\\n         * {@link ParticipantConnectionStatus}.\\n         */\\n\\n    }, {\\n        key: 'getConnectionStatus',\\n        value: function getConnectionStatus() {\\n            return this._connectionStatus;\\n        }\\n\\n        /**\\n         * Sets the value of a property of this participant, and fires an event if\\n         * the value has changed.\\n         * @name the name of the property.\\n         * @value the value to set.\\n         */\\n\\n    }, {\\n        key: 'setProperty',\\n        value: function setProperty(name, value) {\\n            var oldValue = this._properties[name];\\n\\n            if (value !== oldValue) {\\n                this._properties[name] = value;\\n                this._conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"PARTICIPANT_PROPERTY_CHANGED\\\"], this, name, oldValue, value);\\n            }\\n        }\\n\\n        /**\\n         * @returns {Array.<JitsiTrack>} The list of media tracks for this\\n         * participant.\\n         */\\n\\n    }, {\\n        key: 'getTracks',\\n        value: function getTracks() {\\n            return this._tracks.slice();\\n        }\\n\\n        /**\\n         * @param {MediaType} mediaType\\n         * @returns {Array.<JitsiTrack>} an array of media tracks for this\\n         * participant, for given media type.\\n         */\\n\\n    }, {\\n        key: 'getTracksByMediaType',\\n        value: function getTracksByMediaType(mediaType) {\\n            return this.getTracks().filter(function (track) {\\n                return track.getType() === mediaType;\\n            });\\n        }\\n\\n        /**\\n         * @returns {String} The ID of this participant.\\n         */\\n\\n    }, {\\n        key: 'getId',\\n        value: function getId() {\\n            return this._id;\\n        }\\n\\n        /**\\n         * @returns {String} The JID of this participant.\\n         */\\n\\n    }, {\\n        key: 'getJid',\\n        value: function getJid() {\\n            return this._jid;\\n        }\\n\\n        /**\\n         * @returns {String} The human-readable display name of this participant.\\n         */\\n\\n    }, {\\n        key: 'getDisplayName',\\n        value: function getDisplayName() {\\n            return this._displayName;\\n        }\\n\\n        /**\\n         * @returns {String} The stats ID of this participant.\\n         */\\n\\n    }, {\\n        key: 'getStatsID',\\n        value: function getStatsID() {\\n            return this._statsID;\\n        }\\n\\n        /**\\n         * @returns {String} The status of the participant.\\n         */\\n\\n    }, {\\n        key: 'getStatus',\\n        value: function getStatus() {\\n            return this._status;\\n        }\\n\\n        /**\\n         * @returns {Boolean} Whether this participant is a moderator or not.\\n         */\\n\\n    }, {\\n        key: 'isModerator',\\n        value: function isModerator() {\\n            return this._role === 'moderator';\\n        }\\n\\n        /**\\n         * @returns {Boolean} Whether this participant is a hidden participant. Some\\n         * special system participants may want to join hidden (like for example the\\n         * recorder).\\n         */\\n\\n    }, {\\n        key: 'isHidden',\\n        value: function isHidden() {\\n            return this._hidden;\\n        }\\n\\n        // Gets a link to an etherpad instance advertised by the participant?\\n        // getEtherpad() {\\n        // }\\n\\n        /**\\n         * @returns {Boolean} Whether this participant has muted their audio.\\n         */\\n\\n    }, {\\n        key: 'isAudioMuted',\\n        value: function isAudioMuted() {\\n            return this._isMediaTypeMuted(__WEBPACK_IMPORTED_MODULE_3__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]);\\n        }\\n\\n        /**\\n         * Determines whether all JitsiTracks which are of a specific MediaType and\\n         * which belong to this JitsiParticipant are muted.\\n         *\\n         * @param {MediaType} mediaType - The MediaType of the JitsiTracks to be\\n         * checked.\\n         * @private\\n         * @returns {Boolean} True if all JitsiTracks which are of the specified\\n         * mediaType and which belong to this JitsiParticipant are muted; otherwise,\\n         * false.\\n         */\\n\\n    }, {\\n        key: '_isMediaTypeMuted',\\n        value: function _isMediaTypeMuted(mediaType) {\\n            return this.getTracks().reduce(function (muted, track) {\\n                return muted && (track.getType() !== mediaType || track.isMuted());\\n            }, true);\\n        }\\n\\n        /**\\n         * @returns {Boolean} Whether this participant has muted their video.\\n         */\\n\\n    }, {\\n        key: 'isVideoMuted',\\n        value: function isVideoMuted() {\\n            return this._isMediaTypeMuted(__WEBPACK_IMPORTED_MODULE_3__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]);\\n        }\\n\\n        /**\\n         * @returns {String} The role of this participant.\\n         */\\n\\n    }, {\\n        key: 'getRole',\\n        value: function getRole() {\\n            return this._role;\\n        }\\n\\n        /**\\n         *\\n         */\\n\\n    }, {\\n        key: 'supportsDTMF',\\n        value: function supportsDTMF() {\\n            return this._supportsDTMF;\\n        }\\n\\n        /**\\n         * Returns a set with the features for the participant.\\n         * @param {int} timeout the timeout in ms for reply from the participant.\\n         * @returns {Promise<Set<String>, Error>}\\n         */\\n\\n    }, {\\n        key: 'getFeatures',\\n        value: function getFeatures() {\\n            var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5000;\\n\\n            return this._conference.xmpp.caps.getFeatures(this._jid, timeout);\\n        }\\n    }]);\\n\\n    return JitsiParticipant;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (JitsiParticipant);\\n\\n/***/ }),\\n/* 117 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__ = __webpack_require__(6);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/* global __filename */\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Emits {@link JitsiConferenceEvents.JVB121_STATUS} events based on the current\\n * P2P status and the conference participants count. See the event description\\n * for more info.\\n */\\n\\nvar Jvb121EventGenerator = function () {\\n    /**\\n     * Creates new <tt>Jvb121EventGenerator</tt> for the given conference.\\n     * @param {JitsiConference} conference\\n     */\\n    function Jvb121EventGenerator(conference) {\\n        var _this = this;\\n\\n        _classCallCheck(this, Jvb121EventGenerator);\\n\\n        this._conference = conference;\\n\\n        /**\\n         * Indicates whether it's a one to one JVB conference (<tt>true</tt>)\\n         * or a multiparty (<tt>false</tt>). Will be also <tt>false</tt> if\\n         * the conference is currently in the P2P mode.\\n         * @type {boolean}\\n         * @private\\n         */\\n        this._jvb121 = true;\\n\\n        this._conference.addEventListener(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"USER_JOINED\\\"], function () {\\n            return _this.evaluateStatus();\\n        });\\n        this._conference.addEventListener(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"USER_LEFT\\\"], function () {\\n            return _this.evaluateStatus();\\n        });\\n        this._conference.addEventListener(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"P2P_STATUS\\\"], function () {\\n            return _this.evaluateStatus();\\n        });\\n    }\\n\\n    /**\\n     * Checks whether the JVB121 value should be updated and a new event\\n     * emitted.\\n     */\\n\\n\\n    _createClass(Jvb121EventGenerator, [{\\n        key: 'evaluateStatus',\\n        value: function evaluateStatus() {\\n            var oldStatus = this._jvb121;\\n            var newStatus = !this._conference.isP2PActive() && this._conference.getParticipantCount() <= 2;\\n\\n            if (oldStatus !== newStatus) {\\n                this._jvb121 = newStatus;\\n                logger.debug('JVB121 status ' + oldStatus + ' => ' + newStatus);\\n                this._conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_1__JitsiConferenceEvents__[\\\"JVB121_STATUS\\\"], oldStatus, newStatus);\\n            }\\n        }\\n    }]);\\n\\n    return Jvb121EventGenerator;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (Jvb121EventGenerator);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/event/Jvb121EventGenerator.js\\\"))\\n\\n/***/ }),\\n/* 118 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__ = __webpack_require__(6);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n/**\\n * The value which we use to say, every sound over this threshold\\n * is talking on the mic.\\n * @type {number}\\n */\\nvar SPEECH_DETECT_THRESHOLD = 0.6;\\n\\n/**\\n * The <tt>P2PDominantSpeakerDetection</tt> is activated only when p2p is\\n * currently used.\\n * Listens for changes in the audio level changes of the local p2p audio track\\n * or remote p2p one and fires dominant speaker events to be able to use\\n * features depending on those events (speaker stats), to make them work without\\n * the video bridge.\\n */\\n\\nvar P2PDominantSpeakerDetection = function () {\\n    /**\\n     * Creates P2PDominantSpeakerDetection\\n     * @param conference the JitsiConference instance that created us.\\n     * @constructor\\n     */\\n    function P2PDominantSpeakerDetection(conference) {\\n        _classCallCheck(this, P2PDominantSpeakerDetection);\\n\\n        this.conference = conference;\\n\\n        conference.addEventListener(__WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__[\\\"TRACK_AUDIO_LEVEL_CHANGED\\\"], this._audioLevel.bind(this));\\n\\n        this.myUserID = this.conference.myUserId();\\n    }\\n\\n    /**\\n     * Receives audio level events for all streams in the conference.\\n     *\\n     * @param {String} id - The participant id\\n     * @param {number} audioLevel - The audio level.\\n     */\\n\\n\\n    _createClass(P2PDominantSpeakerDetection, [{\\n        key: '_audioLevel',\\n        value: function _audioLevel(id, audioLevel) {\\n\\n            // we do not process if p2p is not active\\n            // or audio level is under certain threshold\\n            // or if the audio level is for local audio track which is muted\\n            if (!this.conference.isP2PActive() || audioLevel <= SPEECH_DETECT_THRESHOLD || id === this.myUserID && this.conference.getLocalAudioTrack().isMuted()) {\\n                return;\\n            }\\n\\n            this.conference.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__[\\\"DOMINANT_SPEAKER_CHANGED\\\"], id);\\n        }\\n    }]);\\n\\n    return P2PDominantSpeakerDetection;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (P2PDominantSpeakerDetection);\\n\\n/***/ }),\\n/* 119 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_RTC_RTCEvents__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_RTC_RTCEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__service_RTC_RTCEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Handles a WebRTC RTCPeerConnection or a WebSocket instance to communicate\\n * with the videobridge.\\n */\\n\\nvar BridgeChannel = function () {\\n    /**\\n     * Binds \\\"ondatachannel\\\" event listener on the given RTCPeerConnection\\n     * instance, or creates a WebSocket connection with the videobridge.\\n     * At least one of both, peerconnection or wsUrl parameters, must be\\n     * given.\\n     * @param {RTCPeerConnection} [peerconnection] WebRTC peer connection\\n     * instance.\\n     * @param {string} [wsUrl] WebSocket URL.\\n     * @param {EventEmitter} eventEmitter EventEmitter instance.\\n     */\\n    function BridgeChannel(peerconnection, wsUrl, emitter) {\\n        var _this = this;\\n\\n        _classCallCheck(this, BridgeChannel);\\n\\n        if (!peerconnection && !wsUrl) {\\n            throw new TypeError('At least peerconnection or wsUrl must be given');\\n        } else if (peerconnection && wsUrl) {\\n            throw new TypeError('Just one of peerconnection or wsUrl must be given');\\n        }\\n\\n        if (peerconnection) {\\n            logger.debug('constructor() with peerconnection');\\n        } else {\\n            logger.debug('constructor() with wsUrl:\\\"' + wsUrl + '\\\"');\\n        }\\n\\n        // The underlying WebRTC RTCDataChannel or WebSocket instance.\\n        // @type {RTCDataChannel|WebSocket}\\n        this._channel = null;\\n\\n        // @type {EventEmitter}\\n        this._eventEmitter = emitter;\\n\\n        // Whether a RTCDataChannel or WebSocket is internally used.\\n        // @type {string} \\\"datachannel\\\" / \\\"websocket\\\"\\n        this._mode = null;\\n\\n        // If a RTCPeerConnection is given, listen for new RTCDataChannel\\n        // event.\\n        if (peerconnection) {\\n            peerconnection.ondatachannel = function (event) {\\n                // NOTE: We assume that the \\\"onDataChannel\\\" event just fires\\n                // once.\\n\\n                var datachannel = event.channel;\\n\\n                // Handle the RTCDataChannel.\\n                _this._handleChannel(datachannel);\\n                _this._mode = 'datachannel';\\n            };\\n\\n            // Otherwise create a WebSocket connection.\\n        } else if (wsUrl) {\\n            // Create a WebSocket instance.\\n            var ws = new WebSocket(wsUrl);\\n\\n            // Handle the WebSocket.\\n            this._handleChannel(ws);\\n            this._mode = 'websocket';\\n        }\\n    }\\n\\n    /**\\n     * The channel mode.\\n     * @return {string} \\\"datachannel\\\" or \\\"websocket\\\" (or null if not yet set).\\n     */\\n\\n\\n    _createClass(BridgeChannel, [{\\n        key: 'close',\\n\\n\\n        /**\\n         * Closes the currently opened channel.\\n         */\\n        value: function close() {\\n            if (this._channel) {\\n                try {\\n                    this._channel.close();\\n                } catch (error) {} // eslint-disable-line no-empty\\n\\n                this._channel = null;\\n            }\\n        }\\n\\n        /**\\n         * Whether there is an underlying RTCDataChannel or WebSocket and it's\\n         * open.\\n         * @return {boolean}\\n         */\\n\\n    }, {\\n        key: 'isOpen',\\n        value: function isOpen() {\\n            return this._channel && (this._channel.readyState === 'open' || this._channel.readyState === WebSocket.OPEN);\\n        }\\n\\n        /**\\n         * Sends message via the channel.\\n         * @param {string} to The id of the endpoint that should receive the\\n         * message. If \\\"\\\" the message will be sent to all participants.\\n         * @param  {object} payload The payload of the message.\\n         * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\\n         * {@link https://developer.mozilla.org/docs/Web/API/RTCDataChannel/send})\\n         * or from WebSocket#send or Error with \\\"No opened channel\\\" message.\\n         */\\n\\n    }, {\\n        key: 'sendMessage',\\n        value: function sendMessage(to, payload) {\\n            this._send({\\n                colibriClass: 'EndpointMessage',\\n                msgPayload: payload,\\n                to: to\\n            });\\n        }\\n\\n        /**\\n         * Sends a \\\"lastN value changed\\\" message via the channel.\\n         * @param {number} value The new value for lastN. -1 means unlimited.\\n         */\\n\\n    }, {\\n        key: 'sendSetLastNMessage',\\n        value: function sendSetLastNMessage(value) {\\n            var jsonObject = {\\n                colibriClass: 'LastNChangedEvent',\\n                lastN: value\\n            };\\n\\n            this._send(jsonObject);\\n            logger.log('Channel lastN set to: ' + value);\\n        }\\n\\n        /**\\n         * Sends a \\\"pinned endpoint changed\\\" message via the channel.\\n         * @param {string} endpointId The id of the pinned endpoint.\\n         * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\\n         * {@link https://developer.mozilla.org/docs/Web/API/RTCDataChannel/send})\\n         * or from WebSocket#send or Error with \\\"No opened channel\\\" message.\\n         */\\n\\n    }, {\\n        key: 'sendPinnedEndpointMessage',\\n        value: function sendPinnedEndpointMessage(endpointId) {\\n            logger.log('sending pinned changed notification to the bridge for endpoint ', endpointId);\\n\\n            this._send({\\n                colibriClass: 'PinnedEndpointChangedEvent',\\n                pinnedEndpoint: endpointId || null\\n            });\\n        }\\n\\n        /**\\n         * Sends a \\\"selected endpoint changed\\\" message via the channel.\\n         * @param {string} endpointId The id of the selected endpoint.\\n         * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\\n         * {@link https://developer.mozilla.org/docs/Web/API/RTCDataChannel/send})\\n         * or from WebSocket#send or Error with \\\"No opened channel\\\" message.\\n         */\\n\\n    }, {\\n        key: 'sendSelectedEndpointMessage',\\n        value: function sendSelectedEndpointMessage(endpointId) {\\n            logger.log('sending selected changed notification to the bridge for endpoint ', endpointId);\\n\\n            this._send({\\n                colibriClass: 'SelectedEndpointChangedEvent',\\n                selectedEndpoint: endpointId || null\\n            });\\n        }\\n\\n        /**\\n         * Sends a \\\"receiver video constraint\\\" message via the channel.\\n         * @param {Number} maxFrameHeightPixels the maximum frame height,\\n         * in pixels, this receiver is willing to receive\\n         */\\n\\n    }, {\\n        key: 'sendReceiverVideoConstraintMessage',\\n        value: function sendReceiverVideoConstraintMessage(maxFrameHeightPixels) {\\n            logger.log('sending a ReceiverVideoConstraint message with ' + ('a maxFrameHeight of ' + maxFrameHeightPixels + ' pixels'));\\n            this._send({\\n                colibriClass: 'ReceiverVideoConstraint',\\n                maxFrameHeight: maxFrameHeightPixels\\n            });\\n        }\\n\\n        /**\\n         * Set events on the given RTCDataChannel or WebSocket instance.\\n         */\\n\\n    }, {\\n        key: '_handleChannel',\\n        value: function _handleChannel(channel) {\\n            var _this2 = this;\\n\\n            var emitter = this._eventEmitter;\\n\\n            channel.onopen = function () {\\n                logger.info(_this2._mode + ' channel opened');\\n\\n                // Code sample for sending string and/or binary data.\\n                // Sends string message to the bridge:\\n                //     channel.send(\\\"Hello bridge!\\\");\\n                // Sends 12 bytes binary message to the bridge:\\n                //     channel.send(new ArrayBuffer(12));\\n\\n                emitter.emit(__WEBPACK_IMPORTED_MODULE_1__service_RTC_RTCEvents___default.a.DATA_CHANNEL_OPEN);\\n            };\\n\\n            channel.onerror = function (error) {\\n                logger.error('Channel error:', error);\\n            };\\n\\n            channel.onmessage = function (_ref) {\\n                var data = _ref.data;\\n\\n                // JSON object.\\n                var obj = void 0;\\n\\n                try {\\n                    obj = JSON.parse(data);\\n                } catch (error) {\\n                    __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default.a.callErrorHandler(error);\\n                    logger.error('Failed to parse channel message as JSON: ', data, error);\\n\\n                    return;\\n                }\\n\\n                var colibriClass = obj.colibriClass;\\n\\n                switch (colibriClass) {\\n                    case 'DominantSpeakerEndpointChangeEvent':\\n                        {\\n                            // Endpoint ID from the Videobridge.\\n                            var dominantSpeakerEndpoint = obj.dominantSpeakerEndpoint;\\n\\n                            logger.info('Channel new dominant speaker event: ', dominantSpeakerEndpoint);\\n                            emitter.emit(__WEBPACK_IMPORTED_MODULE_1__service_RTC_RTCEvents___default.a.DOMINANT_SPEAKER_CHANGED, dominantSpeakerEndpoint);\\n                            break;\\n                        }\\n                    case 'EndpointConnectivityStatusChangeEvent':\\n                        {\\n                            var endpoint = obj.endpoint;\\n                            var isActive = obj.active === 'true';\\n\\n                            logger.info('Endpoint connection status changed: ' + endpoint + ' active ? ' + isActive);\\n                            emitter.emit(__WEBPACK_IMPORTED_MODULE_1__service_RTC_RTCEvents___default.a.ENDPOINT_CONN_STATUS_CHANGED, endpoint, isActive);\\n\\n                            break;\\n                        }\\n                    case 'EndpointMessage':\\n                        {\\n                            emitter.emit(__WEBPACK_IMPORTED_MODULE_1__service_RTC_RTCEvents___default.a.ENDPOINT_MESSAGE_RECEIVED, obj.from, obj.msgPayload);\\n\\n                            break;\\n                        }\\n                    case 'LastNEndpointsChangeEvent':\\n                        {\\n                            // The new/latest list of last-n endpoint IDs.\\n                            var lastNEndpoints = obj.lastNEndpoints;\\n\\n                            logger.info('Channel new last-n event: ', lastNEndpoints, obj);\\n                            emitter.emit(__WEBPACK_IMPORTED_MODULE_1__service_RTC_RTCEvents___default.a.LASTN_ENDPOINT_CHANGED, lastNEndpoints, obj);\\n\\n                            break;\\n                        }\\n                    default:\\n                        {\\n                            logger.debug('Channel JSON-formatted message: ', obj);\\n\\n                            // The received message appears to be appropriately formatted\\n                            // (i.e. is a JSON object which assigns a value to the\\n                            // mandatory property colibriClass) so don't just swallow it,\\n                            // expose it to public consumption.\\n                            emitter.emit('rtc.datachannel.' + colibriClass, obj);\\n                        }\\n                }\\n            };\\n\\n            channel.onclose = function () {\\n                logger.info('Channel closed');\\n\\n                // Remove the channel.\\n                _this2._channel = null;\\n            };\\n\\n            // Store the channel.\\n            this._channel = channel;\\n        }\\n\\n        /**\\n         * Sends passed object via the channel.\\n         * @param {object} jsonObject The object that will be sent.\\n         * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\\n         * {@link https://developer.mozilla.org/docs/Web/API/RTCDataChannel/send})\\n         * or from WebSocket#send or Error with \\\"No opened channel\\\" message.\\n         */\\n\\n    }, {\\n        key: '_send',\\n        value: function _send(jsonObject) {\\n            var channel = this._channel;\\n\\n            if (!this.isOpen()) {\\n                throw new Error('No opened channel');\\n            }\\n\\n            channel.send(JSON.stringify(jsonObject));\\n        }\\n    }, {\\n        key: 'mode',\\n        get: function get() {\\n            return this._mode;\\n        }\\n    }]);\\n\\n    return BridgeChannel;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (BridgeChannel);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/BridgeChannel.js\\\"))\\n\\n/***/ }),\\n/* 120 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JitsiTrack__ = __webpack_require__(54);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__JitsiTrackError__ = __webpack_require__(12);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__JitsiTrackErrors__ = __webpack_require__(17);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__JitsiTrackEvents__ = __webpack_require__(18);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__RTCUtils__ = __webpack_require__(28);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__service_RTC_CameraFacingMode__ = __webpack_require__(55);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__service_RTC_CameraFacingMode___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__service_RTC_CameraFacingMode__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__service_RTC_VideoType__ = __webpack_require__(13);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__service_RTC_VideoType___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__service_RTC_VideoType__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__statistics_statistics__ = __webpack_require__(5);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\\\"value\\\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global __filename, Promise */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Represents a single media track(either audio or video).\\n * One <tt>JitsiLocalTrack</tt> corresponds to one WebRTC MediaStreamTrack.\\n */\\n\\nvar JitsiLocalTrack = function (_JitsiTrack) {\\n    _inherits(JitsiLocalTrack, _JitsiTrack);\\n\\n    /**\\n     * Constructs new JitsiLocalTrack instanse.\\n     *\\n     * @constructor\\n     * @param {Object} trackInfo\\n     * @param {number} trackInfo.rtcId the ID assigned by the RTC module\\n     * @param trackInfo.stream WebRTC MediaStream, parent of the track\\n     * @param trackInfo.track underlying WebRTC MediaStreamTrack for new\\n     * JitsiRemoteTrack\\n     * @param trackInfo.mediaType the MediaType of the JitsiRemoteTrack\\n     * @param trackInfo.videoType the VideoType of the JitsiRemoteTrack\\n     * @param trackInfo.resolution the video resolution if it's a video track\\n     * @param trackInfo.deviceId the ID of the local device for this track\\n     * @param trackInfo.facingMode the camera facing mode used in getUserMedia\\n     * call\\n     * @param {sourceId} trackInfo.sourceId - The id of the desktop sharing\\n     * source. NOTE: defined for desktop sharing tracks only.\\n     */\\n    function JitsiLocalTrack(_ref) {\\n        var deviceId = _ref.deviceId,\\n            facingMode = _ref.facingMode,\\n            mediaType = _ref.mediaType,\\n            resolution = _ref.resolution,\\n            rtcId = _ref.rtcId,\\n            sourceId = _ref.sourceId,\\n            sourceType = _ref.sourceType,\\n            stream = _ref.stream,\\n            track = _ref.track,\\n            videoType = _ref.videoType;\\n\\n        _classCallCheck(this, JitsiLocalTrack);\\n\\n        /**\\n         * The ID assigned by the RTC module on instance creation.\\n         *\\n         * @type {number}\\n         */\\n        var _this = _possibleConstructorReturn(this, (JitsiLocalTrack.__proto__ || Object.getPrototypeOf(JitsiLocalTrack)).call(this,\\n        /* conference */null, stream, track,\\n        /* streamInactiveHandler */function () {\\n            return _this.emit(__WEBPACK_IMPORTED_MODULE_4__JitsiTrackEvents__[\\\"LOCAL_TRACK_STOPPED\\\"]);\\n        }, mediaType, videoType));\\n\\n        _this.rtcId = rtcId;\\n        _this.sourceId = sourceId;\\n        _this.sourceType = sourceType;\\n\\n        if (__WEBPACK_IMPORTED_MODULE_5__RTCBrowserType__[\\\"a\\\" /* default */].usesNewGumFlow()) {\\n            // Get the resolution from the track itself because it cannot be\\n            // certain which resolution webrtc has fallen back to using.\\n            _this.resolution = track.getSettings().height;\\n\\n            // Cache the constraints of the track in case of any this track\\n            // model needs to call getUserMedia again, such as when unmuting.\\n            _this._constraints = track.getConstraints();\\n        } else {\\n            // FIXME Currently, Firefox is ignoring our constraints about\\n            // resolutions so we do not store it, to avoid wrong reporting of\\n            // local track resolution.\\n            _this.resolution = __WEBPACK_IMPORTED_MODULE_5__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox() ? null : resolution;\\n        }\\n\\n        _this.deviceId = deviceId;\\n\\n        /**\\n         * The <tt>Promise</tt> which represents the progress of a previously\\n         * queued/scheduled {@link _setMuted} (from the point of view of\\n         * {@link _queueSetMuted}).\\n         *\\n         * @private\\n         * @type {Promise}\\n         */\\n        _this._prevSetMuted = Promise.resolve();\\n\\n        /**\\n         * The facing mode of the camera from which this JitsiLocalTrack\\n         * instance was obtained.\\n         *\\n         * @private\\n         * @type {CameraFacingMode|undefined}\\n         */\\n        _this._facingMode = facingMode;\\n\\n        // Currently there is no way to know the MediaStreamTrack ended due to\\n        // to device disconnect in Firefox through e.g. \\\"readyState\\\" property.\\n        // Instead we will compare current track's label with device labels from\\n        // enumerateDevices() list.\\n        _this._trackEnded = false;\\n\\n        /**\\n         * Indicates whether data has been sent or not.\\n         */\\n        _this._hasSentData = false;\\n\\n        /**\\n         * Used only for detection of audio problems. We want to check only once\\n         * whether the track is sending data ot not. This flag is set to false\\n         * after the check.\\n         */\\n        _this._testDataSent = true;\\n\\n        // Currently there is no way to determine with what device track was\\n        // created (until getConstraints() support), however we can associate\\n        // tracks with real devices obtained from enumerateDevices() call as\\n        // soon as it's called.\\n        _this._realDeviceId = _this.deviceId === '' ? undefined : _this.deviceId;\\n\\n        /**\\n         * On mute event we are waiting for 3s to check if the stream is going\\n         * to be still muted before firing the event for camera issue detected\\n         * (NO_DATA_FROM_SOURCE).\\n         */\\n        _this._noDataFromSourceTimeout = null;\\n\\n        _this._onDeviceListChanged = function (devices) {\\n            _this._setRealDeviceIdFromDeviceList(devices);\\n\\n            // Mark track as ended for those browsers that do not support\\n            // \\\"readyState\\\" property. We do not touch tracks created with\\n            // default device ID \\\"\\\".\\n            if (typeof _this.getTrack().readyState === 'undefined' && typeof _this._realDeviceId !== 'undefined' && !devices.find(function (d) {\\n                return d.deviceId === _this._realDeviceId;\\n            })) {\\n                _this._trackEnded = true;\\n            }\\n        };\\n\\n        // Subscribe each created local audio track to\\n        // RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED event. This is different from\\n        // handling this event for remote tracks (which are handled in RTC.js),\\n        // because there might be local tracks not attached to a conference.\\n        if (_this.isAudioTrack() && __WEBPACK_IMPORTED_MODULE_6__RTCUtils__[\\\"a\\\" /* default */].isDeviceChangeAvailable('output')) {\\n            _this._onAudioOutputDeviceChanged = _this.setAudioOutput.bind(_this);\\n            __WEBPACK_IMPORTED_MODULE_6__RTCUtils__[\\\"a\\\" /* default */].addListener(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.AUDIO_OUTPUT_DEVICE_CHANGED, _this._onAudioOutputDeviceChanged);\\n        }\\n\\n        __WEBPACK_IMPORTED_MODULE_6__RTCUtils__[\\\"a\\\" /* default */].addListener(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.DEVICE_LIST_CHANGED, _this._onDeviceListChanged);\\n\\n        _this._initNoDataFromSourceHandlers();\\n        return _this;\\n    }\\n\\n    /**\\n     * Returns if associated MediaStreamTrack is in the 'ended' state\\n     *\\n     * @returns {boolean}\\n     */\\n\\n\\n    _createClass(JitsiLocalTrack, [{\\n        key: 'isEnded',\\n        value: function isEnded() {\\n            return this.getTrack().readyState === 'ended' || this._trackEnded;\\n        }\\n\\n        /**\\n         * Sets handlers to the MediaStreamTrack object that will detect camera\\n         * issues.\\n         */\\n\\n    }, {\\n        key: '_initNoDataFromSourceHandlers',\\n        value: function _initNoDataFromSourceHandlers() {\\n            var _this2 = this;\\n\\n            if (this.isVideoTrack() && this.videoType === __WEBPACK_IMPORTED_MODULE_10__service_RTC_VideoType___default.a.CAMERA) {\\n                var _onNoDataFromSourceError = this._onNoDataFromSourceError.bind(this);\\n\\n                this._setHandler('track_mute', function () {\\n                    if (_this2._checkForCameraIssues()) {\\n                        var now = window.performance.now();\\n\\n                        _this2._noDataFromSourceTimeout = setTimeout(_onNoDataFromSourceError, 3000);\\n                        _this2._setHandler('track_unmute', function () {\\n                            _this2._clearNoDataFromSourceMuteResources();\\n                            __WEBPACK_IMPORTED_MODULE_12__statistics_statistics__[\\\"a\\\" /* default */].sendEventToAll(_this2.getType() + '.' + __WEBPACK_IMPORTED_MODULE_11__service_statistics_AnalyticsEvents__[\\\"I\\\" /* _TRACK_UNMUTE */], { value: window.performance.now() - now });\\n                        });\\n                    }\\n                });\\n                this._setHandler('track_ended', _onNoDataFromSourceError);\\n            }\\n        }\\n\\n        /**\\n         * Clears all timeouts and handlers set on MediaStreamTrack mute event.\\n         * FIXME: Change the name of the method with better one.\\n         */\\n\\n    }, {\\n        key: '_clearNoDataFromSourceMuteResources',\\n        value: function _clearNoDataFromSourceMuteResources() {\\n            if (this._noDataFromSourceTimeout) {\\n                clearTimeout(this._noDataFromSourceTimeout);\\n                this._noDataFromSourceTimeout = null;\\n            }\\n            this._setHandler('track_unmute', undefined);\\n        }\\n\\n        /**\\n         * Called when potential camera issue is detected. Clears the handlers and\\n         * timeouts set on MediaStreamTrack muted event. Verifies that the camera\\n         * issue persists and fires NO_DATA_FROM_SOURCE event.\\n         */\\n\\n    }, {\\n        key: '_onNoDataFromSourceError',\\n        value: function _onNoDataFromSourceError() {\\n            this._clearNoDataFromSourceMuteResources();\\n            if (this._checkForCameraIssues()) {\\n                this._fireNoDataFromSourceEvent();\\n            }\\n        }\\n\\n        /**\\n         * Fires NO_DATA_FROM_SOURCE event and logs it to analytics and callstats.\\n         */\\n\\n    }, {\\n        key: '_fireNoDataFromSourceEvent',\\n        value: function _fireNoDataFromSourceEvent() {\\n            this.emit(__WEBPACK_IMPORTED_MODULE_4__JitsiTrackEvents__[\\\"NO_DATA_FROM_SOURCE\\\"]);\\n            var eventName = this.getType() + '.' + __WEBPACK_IMPORTED_MODULE_11__service_statistics_AnalyticsEvents__[\\\"H\\\" /* _NO_DATA_FROM_SOURCE */];\\n\\n            __WEBPACK_IMPORTED_MODULE_12__statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(eventName);\\n            var log = { name: eventName };\\n\\n            if (this.isAudioTrack()) {\\n                log.isReceivingData = this._isReceivingData();\\n            }\\n            __WEBPACK_IMPORTED_MODULE_12__statistics_statistics__[\\\"a\\\" /* default */].sendLog(JSON.stringify(log));\\n        }\\n\\n        /**\\n         * Sets real device ID by comparing track information with device\\n         * information. This is temporary solution until getConstraints() method\\n         * will be implemented in browsers.\\n         *\\n         * @param {MediaDeviceInfo[]} devices - list of devices obtained from\\n         * enumerateDevices() call\\n         */\\n\\n    }, {\\n        key: '_setRealDeviceIdFromDeviceList',\\n        value: function _setRealDeviceIdFromDeviceList(devices) {\\n            var track = this.getTrack();\\n\\n            // FIXME for temasys video track, label refers to id not the actual\\n            // device\\n            var device = devices.find(function (d) {\\n                return d.kind === track.kind + 'input' && d.label === track.label;\\n            });\\n\\n            if (device) {\\n                this._realDeviceId = device.deviceId;\\n            }\\n        }\\n\\n        /**\\n         * Sets the stream property of JitsiLocalTrack object and sets all stored\\n         * handlers to it.\\n         *\\n         * @param {MediaStream} stream the new stream.\\n         * @protected\\n         */\\n\\n    }, {\\n        key: '_setStream',\\n        value: function _setStream(stream) {\\n            _get(JitsiLocalTrack.prototype.__proto__ || Object.getPrototypeOf(JitsiLocalTrack.prototype), '_setStream', this).call(this, stream);\\n\\n            if (stream) {\\n                // Store the MSID for video mute/unmute purposes.\\n                this.storedMSID = this.getMSID();\\n                logger.debug('Setting new MSID: ' + this.storedMSID + ' on ' + this);\\n            } else {\\n                logger.debug('Setting \\\\'null\\\\' stream on ' + this);\\n            }\\n        }\\n\\n        /**\\n         * Asynchronously mutes this track.\\n         *\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: 'mute',\\n        value: function mute() {\\n            return this._queueSetMuted(true);\\n        }\\n\\n        /**\\n         * Asynchronously unmutes this track.\\n         *\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: 'unmute',\\n        value: function unmute() {\\n            return this._queueSetMuted(false);\\n        }\\n\\n        /**\\n         * Initializes a new Promise to execute {@link #_setMuted}. May be called\\n         * multiple times in a row and the invocations of {@link #_setMuted} and,\\n         * consequently, {@link #mute} and/or {@link #unmute} will be resolved in a\\n         * serialized fashion.\\n         *\\n         * @param {boolean} muted - The value to invoke <tt>_setMuted</tt> with.\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: '_queueSetMuted',\\n        value: function _queueSetMuted(muted) {\\n            var setMuted = this._setMuted.bind(this, muted);\\n\\n            this._prevSetMuted = this._prevSetMuted.then(setMuted, setMuted);\\n\\n            return this._prevSetMuted;\\n        }\\n\\n        /**\\n         * Mutes / unmutes this track.\\n         *\\n         * @param {boolean} muted - If <tt>true</tt>, this track will be muted;\\n         * otherwise, this track will be unmuted.\\n         * @private\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: '_setMuted',\\n        value: function _setMuted(muted) {\\n            var _this3 = this;\\n\\n            if (this.isMuted() === muted) {\\n                return Promise.resolve();\\n            }\\n\\n            if (this.disposed) {\\n                return Promise.reject(new __WEBPACK_IMPORTED_MODULE_2__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_3__JitsiTrackErrors__[\\\"TRACK_IS_DISPOSED\\\"]));\\n            }\\n\\n            var promise = Promise.resolve();\\n\\n            // A function that will print info about muted status transition\\n            var logMuteInfo = function logMuteInfo() {\\n                return logger.info('Mute ' + _this3 + ': ' + muted);\\n            };\\n\\n            if (this.isAudioTrack() || this.videoType === __WEBPACK_IMPORTED_MODULE_10__service_RTC_VideoType___default.a.DESKTOP || !__WEBPACK_IMPORTED_MODULE_5__RTCBrowserType__[\\\"a\\\" /* default */].doesVideoMuteByStreamRemove()) {\\n                logMuteInfo();\\n                if (this.track) {\\n                    this.track.enabled = !muted;\\n                }\\n            } else if (muted) {\\n                promise = new Promise(function (resolve, reject) {\\n                    logMuteInfo();\\n                    _this3._removeStreamFromConferenceAsMute(function () {\\n                        // FIXME: Maybe here we should set the SRC for the\\n                        // containers to something\\n                        // We don't want any events to be fired on this stream\\n                        _this3._unregisterHandlers();\\n                        _this3._stopStream();\\n                        _this3._setStream(null);\\n                        resolve();\\n                    }, reject);\\n                });\\n            } else {\\n                logMuteInfo();\\n\\n                // This path is only for camera.\\n                var streamOptions = {\\n                    cameraDeviceId: this.getDeviceId(),\\n                    devices: [__WEBPACK_IMPORTED_MODULE_8__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]],\\n                    facingMode: this.getCameraFacingMode()\\n                };\\n\\n                if (__WEBPACK_IMPORTED_MODULE_5__RTCBrowserType__[\\\"a\\\" /* default */].usesNewGumFlow()) {\\n                    promise = __WEBPACK_IMPORTED_MODULE_6__RTCUtils__[\\\"a\\\" /* default */].newObtainAudioAndVideoPermissions(Object.assign({}, streamOptions, { constraints: { video: this._constraints } }));\\n                } else {\\n                    if (this.resolution) {\\n                        streamOptions.resolution = this.resolution;\\n                    }\\n\\n                    promise = __WEBPACK_IMPORTED_MODULE_6__RTCUtils__[\\\"a\\\" /* default */].obtainAudioAndVideoPermissions(streamOptions);\\n                }\\n\\n                promise.then(function (streamsInfo) {\\n                    var mediaType = _this3.getType();\\n                    var streamInfo = __WEBPACK_IMPORTED_MODULE_5__RTCBrowserType__[\\\"a\\\" /* default */].usesNewGumFlow() ? streamsInfo.find(function (info) {\\n                        return info.track.kind === mediaType;\\n                    }) : streamsInfo.find(function (info) {\\n                        return info.mediaType === mediaType;\\n                    });\\n\\n                    if (streamInfo) {\\n                        _this3._setStream(streamInfo.stream);\\n                        _this3.track = streamInfo.track;\\n\\n                        // This is not good when video type changes after\\n                        // unmute, but let's not crash here\\n                        if (_this3.videoType !== streamInfo.videoType) {\\n                            logger.warn(_this3 + ': video type has changed after unmute!', _this3.videoType, streamInfo.videoType);\\n                            _this3.videoType = streamInfo.videoType;\\n                        }\\n                    } else {\\n                        throw new __WEBPACK_IMPORTED_MODULE_2__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_3__JitsiTrackErrors__[\\\"TRACK_NO_STREAM_FOUND\\\"]);\\n                    }\\n\\n                    _this3.containers = _this3.containers.map(function (cont) {\\n                        return __WEBPACK_IMPORTED_MODULE_6__RTCUtils__[\\\"a\\\" /* default */].attachMediaStream(cont, _this3.stream);\\n                    });\\n\\n                    return _this3._addStreamToConferenceAsUnmute();\\n                });\\n            }\\n\\n            return promise.then(function () {\\n                return _this3._sendMuteStatus(muted);\\n            }).then(function () {\\n                return _this3.emit(__WEBPACK_IMPORTED_MODULE_4__JitsiTrackEvents__[\\\"TRACK_MUTE_CHANGED\\\"], _this3);\\n            });\\n        }\\n\\n        /**\\n         * Adds stream to conference and marks it as \\\"unmute\\\" operation.\\n         *\\n         * @private\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: '_addStreamToConferenceAsUnmute',\\n        value: function _addStreamToConferenceAsUnmute() {\\n            var _this4 = this;\\n\\n            if (!this.conference) {\\n                return Promise.resolve();\\n            }\\n\\n            // FIXME it would be good to not included conference as part of this\\n            // process. Only TraceablePeerConnections to which the track is attached\\n            // should care about this action. The TPCs to which the track is not\\n            // attached can sync up when track is re-attached.\\n            // A problem with that is that the \\\"modify sources\\\" queue is part of\\n            // the JingleSessionPC and it would be excluded from the process. One\\n            // solution would be to extract class between TPC and JingleSessionPC\\n            // which would contain the queue and would notify the signaling layer\\n            // when local SSRCs are changed. This would help to separate XMPP from\\n            // the RTC module.\\n            return new Promise(function (resolve, reject) {\\n                _this4.conference._addLocalTrackAsUnmute(_this4).then(resolve, function (error) {\\n                    return reject(new Error(error));\\n                });\\n            });\\n        }\\n\\n        /**\\n         * Removes stream from conference and marks it as \\\"mute\\\" operation.\\n         *\\n         * @param {Function} successCallback will be called on success\\n         * @param {Function} errorCallback will be called on error\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_removeStreamFromConferenceAsMute',\\n        value: function _removeStreamFromConferenceAsMute(successCallback, errorCallback) {\\n            if (!this.conference) {\\n                successCallback();\\n\\n                return;\\n            }\\n            this.conference._removeLocalTrackAsMute(this).then(successCallback, function (error) {\\n                return errorCallback(new Error(error));\\n            });\\n        }\\n\\n        /**\\n         * Sends mute status for a track to conference if any.\\n         *\\n         * @param {boolean} mute - If track is muted.\\n         * @private\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: '_sendMuteStatus',\\n        value: function _sendMuteStatus(mute) {\\n            var _this5 = this;\\n\\n            if (!this.conference || !this.conference.room) {\\n                return Promise.resolve();\\n            }\\n\\n            return new Promise(function (resolve) {\\n                _this5.conference.room[_this5.isAudioTrack() ? 'setAudioMute' : 'setVideoMute'](mute, resolve);\\n            });\\n        }\\n\\n        /**\\n         * @inheritdoc\\n         *\\n         * Stops sending the media track. And removes it from the HTML.\\n         * NOTE: Works for local tracks only.\\n         *\\n         * @extends JitsiTrack#dispose\\n         * @returns {Promise}\\n         */\\n\\n    }, {\\n        key: 'dispose',\\n        value: function dispose() {\\n            var _this6 = this;\\n\\n            var promise = Promise.resolve();\\n\\n            if (this.conference) {\\n                promise = this.conference.removeTrack(this);\\n            }\\n\\n            if (this.stream) {\\n                this._stopStream();\\n                this.detach();\\n            }\\n\\n            __WEBPACK_IMPORTED_MODULE_6__RTCUtils__[\\\"a\\\" /* default */].removeListener(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.DEVICE_LIST_CHANGED, this._onDeviceListChanged);\\n\\n            if (this._onAudioOutputDeviceChanged) {\\n                __WEBPACK_IMPORTED_MODULE_6__RTCUtils__[\\\"a\\\" /* default */].removeListener(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged);\\n            }\\n\\n            return promise.then(function () {\\n                return _get(JitsiLocalTrack.prototype.__proto__ || Object.getPrototypeOf(JitsiLocalTrack.prototype), 'dispose', _this6).call(_this6);\\n            });\\n        }\\n\\n        /**\\n         * Returns <tt>true</tt> - if the stream is muted and <tt>false</tt>\\n         * otherwise.\\n         *\\n         * @returns {boolean} <tt>true</tt> - if the stream is muted and\\n         * <tt>false</tt> otherwise.\\n         */\\n\\n    }, {\\n        key: 'isMuted',\\n        value: function isMuted() {\\n            // this.stream will be null when we mute local video on Chrome\\n            if (!this.stream) {\\n                return true;\\n            }\\n            if (this.isVideoTrack() && !this.isActive()) {\\n                return true;\\n            }\\n\\n            return !this.track || !this.track.enabled;\\n        }\\n\\n        /**\\n         * Sets the JitsiConference object associated with the track. This is temp\\n         * solution.\\n         *\\n         * @param conference the JitsiConference object\\n         */\\n\\n    }, {\\n        key: '_setConference',\\n        value: function _setConference(conference) {\\n            this.conference = conference;\\n\\n            // We want to keep up with postponed events which should have been fired\\n            // on \\\"attach\\\" call, but for local track we not always have the\\n            // conference before attaching. However this may result in duplicated\\n            // events if they have been triggered on \\\"attach\\\" already.\\n            for (var i = 0; i < this.containers.length; i++) {\\n                this._maybeFireTrackAttached(this.containers[i]);\\n            }\\n        }\\n\\n        /**\\n         * Returns <tt>true</tt>.\\n         *\\n         * @returns {boolean} <tt>true</tt>\\n         */\\n\\n    }, {\\n        key: 'isLocal',\\n        value: function isLocal() {\\n            return true;\\n        }\\n\\n        /**\\n         * Returns device id associated with track.\\n         *\\n         * @returns {string}\\n         */\\n\\n    }, {\\n        key: 'getDeviceId',\\n        value: function getDeviceId() {\\n            return this._realDeviceId || this.deviceId;\\n        }\\n\\n        /**\\n         * Returns the participant id which owns the track.\\n         *\\n         * @returns {string} the id of the participants. It corresponds to the\\n         * Colibri endpoint id/MUC nickname in case of Jitsi-meet.\\n         */\\n\\n    }, {\\n        key: 'getParticipantId',\\n        value: function getParticipantId() {\\n            return this.conference && this.conference.myUserId();\\n        }\\n\\n        /**\\n         * Handles bytes sent statistics.\\n         *\\n         * @param {TraceablePeerConnection} tpc the source of the \\\"bytes sent\\\" stat\\n         * @param {number} bytesSent the new value\\n         * NOTE: used only for audio tracks to detect audio issues.\\n         */\\n\\n    }, {\\n        key: '_onByteSentStatsReceived',\\n        value: function _onByteSentStatsReceived(tpc, bytesSent) {\\n            var _this7 = this;\\n\\n            if (bytesSent > 0) {\\n                this._hasSentData = true;\\n            }\\n            var iceConnectionState = tpc.getConnectionState();\\n\\n            if (this._testDataSent && iceConnectionState === 'connected') {\\n                setTimeout(function () {\\n                    if (!_this7._hasSentData) {\\n                        logger.warn(_this7 + ' \\\\'bytes sent\\\\' <= 0:                         ' + _this7._bytesSent);\\n\\n                        // we are not receiving anything from the microphone\\n                        _this7._fireNoDataFromSourceEvent();\\n                    }\\n                }, 3000);\\n                this._testDataSent = false;\\n            }\\n        }\\n\\n        /**\\n         * Returns facing mode for video track from camera. For other cases (e.g.\\n         * audio track or 'desktop' video track) returns undefined.\\n         *\\n         * @returns {CameraFacingMode|undefined}\\n         */\\n\\n    }, {\\n        key: 'getCameraFacingMode',\\n        value: function getCameraFacingMode() {\\n            if (this.isVideoTrack() && this.videoType === __WEBPACK_IMPORTED_MODULE_10__service_RTC_VideoType___default.a.CAMERA) {\\n                // MediaStreamTrack#getSettings() is not implemented in many\\n                // browsers, so we need feature checking here. Progress on the\\n                // respective browser's implementation can be tracked at\\n                // https://bugs.chromium.org/p/webrtc/issues/detail?id=2481 for\\n                // Chromium and https://bugzilla.mozilla.org/show_bug.cgi?id=1213517\\n                // for Firefox. Even if a browser implements getSettings() already,\\n                // it might still not return anything for 'facingMode'.\\n                var trackSettings = void 0;\\n\\n                try {\\n                    trackSettings = this.track.getSettings();\\n                } catch (e) {\\n                    // XXX React-native-webrtc, for example, defines\\n                    // MediaStreamTrack#getSettings() but the implementation throws\\n                    // a \\\"Not implemented\\\" Error.\\n                }\\n                if (trackSettings && 'facingMode' in trackSettings) {\\n                    return trackSettings.facingMode;\\n                }\\n\\n                if (typeof this._facingMode !== 'undefined') {\\n                    return this._facingMode;\\n                }\\n\\n                // In most cases we are showing a webcam. So if we've gotten here,\\n                // it should be relatively safe to assume that we are probably\\n                // showing the user-facing camera.\\n                return __WEBPACK_IMPORTED_MODULE_7__service_RTC_CameraFacingMode___default.a.USER;\\n            }\\n\\n            return undefined;\\n        }\\n\\n        /**\\n         * Stops the associated MediaStream.\\n         */\\n\\n    }, {\\n        key: '_stopStream',\\n        value: function _stopStream() {\\n\\n            /**\\n             * Indicates that we are executing {@link #_stopStream} i.e.\\n             * {@link RTCUtils#stopMediaStream} for the <tt>MediaStream</tt>\\n             * associated with this <tt>JitsiTrack</tt> instance.\\n             *\\n             * @private\\n             * @type {boolean}\\n             */\\n            this._stopStreamInProgress = true;\\n\\n            try {\\n                __WEBPACK_IMPORTED_MODULE_6__RTCUtils__[\\\"a\\\" /* default */].stopMediaStream(this.stream);\\n            } finally {\\n                this._stopStreamInProgress = false;\\n            }\\n        }\\n\\n        /**\\n         * Switches the camera facing mode if the WebRTC implementation supports the\\n         * custom MediaStreamTrack._switchCamera method. Currently, the method in\\n         * question is implemented in react-native-webrtc only. When such a WebRTC\\n         * implementation is executing, the method is the preferred way to switch\\n         * between the front/user-facing and the back/environment-facing cameras\\n         * because it will likely be (as is the case of react-native-webrtc)\\n         * noticeably faster that creating a new MediaStreamTrack via a new\\n         * getUserMedia call with the switched facingMode constraint value.\\n         * Moreover, the approach with a new getUserMedia call may not even work:\\n         * WebRTC on Android and iOS is either very slow to open the camera a second\\n         * time or plainly freezes attempting to do that.\\n         */\\n\\n    }, {\\n        key: '_switchCamera',\\n        value: function _switchCamera() {\\n            if (this.isVideoTrack() && this.videoType === __WEBPACK_IMPORTED_MODULE_10__service_RTC_VideoType___default.a.CAMERA && typeof this.track._switchCamera === 'function') {\\n                this.track._switchCamera();\\n\\n                this._facingMode = this._facingMode === __WEBPACK_IMPORTED_MODULE_7__service_RTC_CameraFacingMode___default.a.ENVIRONMENT ? __WEBPACK_IMPORTED_MODULE_7__service_RTC_CameraFacingMode___default.a.USER : __WEBPACK_IMPORTED_MODULE_7__service_RTC_CameraFacingMode___default.a.ENVIRONMENT;\\n            }\\n        }\\n\\n        /**\\n         * Detects camera issues on ended and mute events from MediaStreamTrack.\\n         *\\n         * @returns {boolean} true if an issue is detected and false otherwise\\n         */\\n\\n    }, {\\n        key: '_checkForCameraIssues',\\n        value: function _checkForCameraIssues() {\\n            if (!this.isVideoTrack() || this._stopStreamInProgress || this.videoType === __WEBPACK_IMPORTED_MODULE_10__service_RTC_VideoType___default.a.DESKTOP) {\\n                return false;\\n            }\\n\\n            return !this._isReceivingData();\\n        }\\n\\n        /**\\n         * Checks whether the attached MediaStream is receiving data from source or\\n         * not. If the stream property is null(because of mute or another reason)\\n         * this method will return false.\\n         * NOTE: This method doesn't indicate problem with the streams directly.\\n         * For example in case of video mute the method will return false or if the\\n         * user has disposed the track.\\n         *\\n         * @returns {boolean} true if the stream is receiving data and false\\n         * this otherwise.\\n         */\\n\\n    }, {\\n        key: '_isReceivingData',\\n        value: function _isReceivingData() {\\n            if (!this.stream) {\\n                return false;\\n            }\\n\\n            // In older version of the spec there is no muted property and\\n            // readyState can have value muted. In the latest versions\\n            // readyState can have values \\\"live\\\" and \\\"ended\\\" and there is\\n            // muted boolean property. If the stream is muted that means that\\n            // we aren't receiving any data from the source. We want to notify\\n            // the users for error if the stream is muted or ended on it's\\n            // creation.\\n            return this.stream.getTracks().some(function (track) {\\n                return (!('readyState' in track) || track.readyState === 'live') && (!('muted' in track) || track.muted !== true);\\n            });\\n        }\\n\\n        /**\\n         * Creates a text representation of this local track instance.\\n         *\\n         * @return {string}\\n         */\\n\\n    }, {\\n        key: 'toString',\\n        value: function toString() {\\n            return 'LocalTrack[' + this.rtcId + ',' + this.getType() + ']';\\n        }\\n    }]);\\n\\n    return JitsiLocalTrack;\\n}(__WEBPACK_IMPORTED_MODULE_1__JitsiTrack__[\\\"a\\\" /* default */]);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (JitsiLocalTrack);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/JitsiLocalTrack.js\\\"))\\n\\n/***/ }),\\n/* 121 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_yaeti__ = __webpack_require__(122);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_yaeti___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_yaeti__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__RTCSessionDescription__ = __webpack_require__(125);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils__ = __webpack_require__(128);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__errors__ = __webpack_require__(129);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_RandomUtil__ = __webpack_require__(20);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_RandomUtil___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__util_RandomUtil__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__xmpp_SDPUtil__ = __webpack_require__(14);\\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\\\"return\\\"]) _i[\\\"return\\\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\"); } }; }();\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/* global __filename, RTCIceGatherer, RTCIceTransport, RTCDtlsTransport,\\nRTCRtpSender, RTCRtpReceiver */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\nvar RTCSignalingState = {\\n    stable: 'stable',\\n    haveLocalOffer: 'have-local-offer',\\n    haveRemoteOffer: 'have-remote-offer',\\n    closed: 'closed'\\n};\\n\\nvar RTCIceGatheringState = {\\n    new: 'new',\\n    gathering: 'gathering',\\n    complete: 'complete'\\n};\\n\\nvar CNAME = 'jitsi-ortc-cname-' + __WEBPACK_IMPORTED_MODULE_5__util_RandomUtil___default.a.randomInt(10000, 99999);\\n\\n/**\\n * RTCPeerConnection shim for ORTC based endpoints (such as Edge).\\n *\\n * The interface is based on the W3C specification of 2015, which matches\\n * the implementation of Chrome nowadays:\\n *\\n *   https://www.w3.org/TR/2015/WD-webrtc-20150210/\\n *\\n * It also implements Plan-B for multi-stream, and assumes single BUNDLEd\\n * transport and rtcp-mux.\\n */\\n\\nvar ortcRTCPeerConnection = function (_yaeti$EventTarget) {\\n    _inherits(ortcRTCPeerConnection, _yaeti$EventTarget);\\n\\n    /**\\n     */\\n    function ortcRTCPeerConnection(pcConfig) {\\n        _classCallCheck(this, ortcRTCPeerConnection);\\n\\n        var _this = _possibleConstructorReturn(this, (ortcRTCPeerConnection.__proto__ || Object.getPrototypeOf(ortcRTCPeerConnection)).call(this));\\n\\n        logger.debug('constructor() pcConfig:', pcConfig);\\n\\n        // Buffered local ICE candidates (in WebRTC format).\\n        // @type {sequence<RTCIceCandidate>}\\n        _this._bufferedIceCandidates = [];\\n\\n        // Closed flag.\\n        // @type {Boolean}\\n        _this._closed = false;\\n\\n        // RTCDtlsTransport.\\n        // @type {RTCDtlsTransport}\\n        _this._dtlsTransport = null;\\n\\n        // RTCIceGatherer.\\n        // @type {RTCIceGatherer}\\n        _this._iceGatherer = null;\\n\\n        // RTCPeerConnection iceGatheringState.\\n        // NOTE: This should not be needed, but Edge does not implement\\n        // iceGatherer.state.\\n        // @type {RTCIceGatheringState}\\n        _this._iceGatheringState = RTCIceGatheringState.new;\\n\\n        // RTCIceTransport.\\n        // @type {RTCIceTransport}\\n        _this._iceTransport = null;\\n\\n        // Local RTP capabilities (filtered with remote ones).\\n        // @type {RTCRtpCapabilities}\\n        _this._localCapabilities = null;\\n\\n        // Local RTCSessionDescription.\\n        // @type {RTCSessionDescription}\\n        _this._localDescription = null;\\n\\n        // Map with info regarding local media.\\n        // - index: MediaStreamTrack.id\\n        // - value: Object\\n        //   - rtpSender: Associated RTCRtpSender instance\\n        //   - stream: Associated MediaStream instance\\n        //   - ssrc: Provisional or definitive SSRC\\n        //   - rtxSsrc: Provisional or definitive SSRC for RTX\\n        //   - sending: Boolean indicating whether rtpSender.send() was called.\\n        _this._localTrackInfos = new Map();\\n\\n        // Ordered Map with MID as key and kind as value.\\n        // @type {map<String, String>}\\n        _this._mids = new Map();\\n\\n        // Remote RTCSessionDescription.\\n        // @type {RTCSessionDescription}\\n        _this._remoteDescription = null;\\n\\n        // Map of remote streams.\\n        // - index: MediaStream.jitsiRemoteId (as signaled in remote SDP)\\n        // - value: MediaStream (locally generated so id does not match)\\n        // @type {map<Number, MediaStream>}\\n        _this._remoteStreams = new Map();\\n\\n        // Map with info about receiving media.\\n        // - index: Media SSRC\\n        // - value: Object\\n        //   - kind: 'audio' / 'video'\\n        //   - ssrc: Media SSRC\\n        //   - rtxSsrc: RTX SSRC (may be unset)\\n        //   - streamId: MediaStream.jitsiRemoteId\\n        //   - trackId: MediaStreamTrack.jitsiRemoteId\\n        //   - cname: CNAME\\n        //   - stream: MediaStream\\n        //   - track: MediaStreamTrack\\n        //   - rtpReceiver: Associated RTCRtpReceiver instance\\n        // @type {map<Number, Object>}\\n        _this._remoteTrackInfos = new Map();\\n\\n        // Local SDP global fields.\\n        _this._sdpGlobalFields = {\\n            id: __WEBPACK_IMPORTED_MODULE_6__xmpp_SDPUtil__[\\\"a\\\" /* default */].generateSsrc(),\\n            version: 0\\n        };\\n\\n        // RTCPeerConnection signalingState.\\n        // @type {RTCSignalingState}\\n        _this._signalingState = RTCSignalingState.stable;\\n\\n        // Create the RTCIceGatherer.\\n        _this._setIceGatherer(pcConfig);\\n\\n        // Create the RTCIceTransport.\\n        _this._setIceTransport(_this._iceGatherer);\\n\\n        // Create the RTCDtlsTransport.\\n        _this._setDtlsTransport(_this._iceTransport);\\n        return _this;\\n    }\\n\\n    /**\\n     * Current ICE+DTLS connection state.\\n     * @return {RTCPeerConnectionState}\\n     */\\n\\n\\n    _createClass(ortcRTCPeerConnection, [{\\n        key: 'addIceCandidate',\\n\\n\\n        /**\\n         * Adds a remote ICE candidate. Implements both the old callbacks based\\n         * signature and the new Promise based style.\\n         *\\n         * Arguments in Promise mode:\\n         * @param {RTCIceCandidate} candidate\\n         *\\n         * Arguments in callbacks mode:\\n         * @param {RTCIceCandidate} candidate\\n         * @param {function()} callback\\n         * @param {function(error)} errback\\n         */\\n        value: function addIceCandidate(candidate) {\\n            var usePromise = void 0;\\n            var callback = void 0;\\n            var errback = void 0;\\n\\n            if (!candidate) {\\n                throw new TypeError('candidate missing');\\n            }\\n\\n            if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {\\n                usePromise = true;\\n            } else {\\n                usePromise = false;\\n                callback = arguments.length <= 1 ? undefined : arguments[1];\\n                errback = arguments.length <= 2 ? undefined : arguments[2];\\n\\n                if (typeof callback !== 'function') {\\n                    throw new TypeError('callback missing');\\n                }\\n\\n                if (typeof errback !== 'function') {\\n                    throw new TypeError('errback missing');\\n                }\\n            }\\n\\n            logger.debug('addIceCandidate() candidate:', candidate);\\n\\n            if (usePromise) {\\n                return this._addIceCandidate(candidate);\\n            }\\n\\n            this._addIceCandidate(candidate).then(function () {\\n                return callback();\\n            }).catch(function (error) {\\n                return errback(error);\\n            });\\n        }\\n\\n        /**\\n         * Adds a local MediaStream.\\n         * @param {MediaStream} stream.\\n         * NOTE: Deprecated API.\\n         */\\n\\n    }, {\\n        key: 'addStream',\\n        value: function addStream(stream) {\\n            logger.debug('addStream()');\\n\\n            this._addStream(stream);\\n        }\\n\\n        /**\\n         * Closes the RTCPeerConnection and all the underlying ORTC objects.\\n         */\\n\\n    }, {\\n        key: 'close',\\n        value: function close() {\\n            if (this._closed) {\\n                return;\\n            }\\n\\n            this._closed = true;\\n\\n            logger.debug('close()');\\n\\n            this._updateAndEmitSignalingStateChange(RTCSignalingState.closed);\\n\\n            // Close RTCIceGatherer.\\n            // NOTE: Not yet implemented by Edge.\\n            try {\\n                this._iceGatherer.close();\\n            } catch (error) {\\n                logger.warn('iceGatherer.close() failed:' + error);\\n            }\\n\\n            // Close RTCIceTransport.\\n            try {\\n                this._iceTransport.stop();\\n            } catch (error) {\\n                logger.warn('iceTransport.stop() failed:' + error);\\n            }\\n\\n            // Close RTCDtlsTransport.\\n            try {\\n                this._dtlsTransport.stop();\\n            } catch (error) {\\n                logger.warn('dtlsTransport.stop() failed:' + error);\\n            }\\n\\n            // Close and clear RTCRtpSenders.\\n            var _iteratorNormalCompletion = true;\\n            var _didIteratorError = false;\\n            var _iteratorError = undefined;\\n\\n            try {\\n                for (var _iterator = this._localTrackInfos.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                    var info = _step.value;\\n\\n                    var rtpSender = info.rtpSender;\\n\\n                    try {\\n                        rtpSender.stop();\\n                    } catch (error) {\\n                        logger.warn('rtpSender.stop() failed:' + error);\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError = true;\\n                _iteratorError = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion && _iterator.return) {\\n                        _iterator.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError) {\\n                        throw _iteratorError;\\n                    }\\n                }\\n            }\\n\\n            this._localTrackInfos.clear();\\n\\n            // Close and clear RTCRtpReceivers.\\n            var _iteratorNormalCompletion2 = true;\\n            var _didIteratorError2 = false;\\n            var _iteratorError2 = undefined;\\n\\n            try {\\n                for (var _iterator2 = this._remoteTrackInfos.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                    var _info = _step2.value;\\n\\n                    var rtpReceiver = _info.rtpReceiver;\\n\\n                    try {\\n                        rtpReceiver.stop();\\n                    } catch (error) {\\n                        logger.warn('rtpReceiver.stop() failed:' + error);\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError2 = true;\\n                _iteratorError2 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                        _iterator2.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError2) {\\n                        throw _iteratorError2;\\n                    }\\n                }\\n            }\\n\\n            this._remoteTrackInfos.clear();\\n\\n            // Clear remote streams.\\n            this._remoteStreams.clear();\\n        }\\n\\n        /**\\n         * Creates a local answer. Implements both the old callbacks based signature\\n         * and the new Promise based style.\\n         *\\n         * Arguments in Promise mode:\\n         * @param {RTCOfferOptions} [options]\\n         *\\n         * Arguments in callbacks mode:\\n         * @param {function(desc)} callback\\n         * @param {function(error)} errback\\n         * @param {MediaConstraints} [constraints]\\n         */\\n\\n    }, {\\n        key: 'createAnswer',\\n        value: function createAnswer() {\\n            var usePromise = void 0;\\n            var options = void 0;\\n            var callback = void 0;\\n            var errback = void 0;\\n\\n            if (arguments.length <= 1) {\\n                usePromise = true;\\n                options = arguments.length <= 0 ? undefined : arguments[0];\\n            } else {\\n                usePromise = false;\\n                callback = arguments.length <= 0 ? undefined : arguments[0];\\n                errback = arguments.length <= 1 ? undefined : arguments[1];\\n                options = arguments.length <= 2 ? undefined : arguments[2];\\n\\n                if (typeof callback !== 'function') {\\n                    throw new TypeError('callback missing');\\n                }\\n\\n                if (typeof errback !== 'function') {\\n                    throw new TypeError('errback missing');\\n                }\\n            }\\n\\n            logger.debug('createAnswer() options:', options);\\n\\n            if (usePromise) {\\n                return this._createAnswer(options);\\n            }\\n\\n            this._createAnswer(options).then(function (desc) {\\n                return callback(desc);\\n            }).catch(function (error) {\\n                return errback(error);\\n            });\\n        }\\n\\n        /**\\n         * Creates a RTCDataChannel.\\n         */\\n\\n    }, {\\n        key: 'createDataChannel',\\n        value: function createDataChannel() {\\n            logger.debug('createDataChannel()');\\n\\n            // NOTE: DataChannels not implemented in Edge.\\n            throw new Error('createDataChannel() not supported in Edge');\\n        }\\n\\n        /**\\n         * Creates a local offer. Implements both the old callbacks based signature\\n         * and the new Promise based style.\\n         *\\n         * Arguments in Promise mode:\\n         * @param {RTCOfferOptions} [options]\\n         *\\n         * Arguments in callbacks mode:\\n         * @param {function(desc)} callback\\n         * @param {function(error)} errback\\n         * @param {MediaConstraints} [constraints]\\n         */\\n\\n    }, {\\n        key: 'createOffer',\\n        value: function createOffer() {\\n            var usePromise = void 0;\\n            var options = void 0;\\n            var callback = void 0;\\n            var errback = void 0;\\n\\n            if (arguments.length <= 1) {\\n                usePromise = true;\\n                options = arguments.length <= 0 ? undefined : arguments[0];\\n            } else {\\n                usePromise = false;\\n                callback = arguments.length <= 0 ? undefined : arguments[0];\\n                errback = arguments.length <= 1 ? undefined : arguments[1];\\n                options = arguments.length <= 2 ? undefined : arguments[2];\\n\\n                if (typeof callback !== 'function') {\\n                    throw new TypeError('callback missing');\\n                }\\n\\n                if (typeof errback !== 'function') {\\n                    throw new TypeError('errback missing');\\n                }\\n            }\\n\\n            logger.debug('createOffer() options:', options);\\n\\n            if (usePromise) {\\n                return this._createOffer(options);\\n            }\\n\\n            this._createOffer(options).then(function (desc) {\\n                return callback(desc);\\n            }).catch(function (error) {\\n                return errback(error);\\n            });\\n        }\\n\\n        /**\\n         * Gets a sequence of local MediaStreams.\\n         * @return {sequence<MediaStream>}\\n         */\\n\\n    }, {\\n        key: 'getLocalStreams',\\n        value: function getLocalStreams() {\\n            return Array.from(this._localTrackInfos.values()).map(function (info) {\\n                return info.stream;\\n            }).filter(function (elem, pos, arr) {\\n                return arr.indexOf(elem) === pos;\\n            });\\n        }\\n\\n        /**\\n         * Gets a sequence of remote MediaStreams.\\n         * @return {sequence<MediaStream>}\\n         */\\n\\n    }, {\\n        key: 'getRemoteStreams',\\n        value: function getRemoteStreams() {\\n            return Array.from(this._remoteStreams.values());\\n        }\\n\\n        /**\\n         * Get RTP statistics. Implements both the old callbacks based signature\\n         * and the new Promise based style.\\n         *\\n         * Arguments in Promise mode:\\n         * @param {MediaStreamTrack} [selector]\\n         *\\n         * Arguments in callbacks mode:\\n         * @param {MediaStreamTrack} [selector]\\n         * @param {function(desc)} callback\\n         * @param {function(error)} errback\\n         */\\n\\n    }, {\\n        key: 'getStats',\\n        value: function getStats() {\\n            var usePromise = void 0;\\n            var selector = void 0;\\n            var callback = void 0;\\n            var errback = void 0;\\n\\n            if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'function') {\\n                usePromise = false;\\n                callback = arguments.length <= 0 ? undefined : arguments[0];\\n                errback = arguments.length <= 1 ? undefined : arguments[1];\\n            } else if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'function') {\\n                usePromise = false;\\n                selector = arguments.length <= 0 ? undefined : arguments[0];\\n                callback = arguments.length <= 1 ? undefined : arguments[1];\\n                errback = arguments.length <= 2 ? undefined : arguments[2];\\n            } else {\\n                usePromise = true;\\n                selector = arguments.length <= 0 ? undefined : arguments[0];\\n            }\\n\\n            if (!usePromise && !errback) {\\n                errback = function errback(error) {\\n                    logger.error('getStats() failed: ' + error);\\n                    logger.error(error.stack);\\n                };\\n            }\\n\\n            if (usePromise) {\\n                return this._getStats(selector);\\n            }\\n\\n            this._getStats(selector).then(function (stats) {\\n                return callback(stats);\\n            }).catch(function (error) {\\n                return errback(error);\\n            });\\n        }\\n\\n        /**\\n         * Removes a local MediaStream.\\n         * @param {MediaStream} stream.\\n         * NOTE: Deprecated API.\\n         */\\n\\n    }, {\\n        key: 'removeStream',\\n        value: function removeStream(stream) {\\n            logger.debug('removeStream()');\\n\\n            this._removeStream(stream);\\n        }\\n\\n        /**\\n         * Applies a local description. Implements both the old callbacks based\\n         * signature and the new Promise based style.\\n         *\\n         * Arguments in Promise mode:\\n         * @param {RTCSessionDescriptionInit} desc\\n         *\\n         * Arguments in callbacks mode:\\n         * @param {RTCSessionDescription} desc\\n         * @param {function()} callback\\n         * @param {function(error)} errback\\n         */\\n\\n    }, {\\n        key: 'setLocalDescription',\\n        value: function setLocalDescription(desc) {\\n            var usePromise = void 0;\\n            var callback = void 0;\\n            var errback = void 0;\\n\\n            if (!desc) {\\n                throw new TypeError('description missing');\\n            }\\n\\n            if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {\\n                usePromise = true;\\n            } else {\\n                usePromise = false;\\n                callback = arguments.length <= 1 ? undefined : arguments[1];\\n                errback = arguments.length <= 2 ? undefined : arguments[2];\\n\\n                if (typeof callback !== 'function') {\\n                    throw new TypeError('callback missing');\\n                }\\n\\n                if (typeof errback !== 'function') {\\n                    throw new TypeError('errback missing');\\n                }\\n            }\\n\\n            logger.debug('setLocalDescription() desc:', desc);\\n\\n            if (usePromise) {\\n                return this._setLocalDescription(desc);\\n            }\\n\\n            this._setLocalDescription(desc).then(function () {\\n                return callback();\\n            }).catch(function (error) {\\n                return errback(error);\\n            });\\n        }\\n\\n        /**\\n         * Applies a remote description. Implements both the old callbacks based\\n         * signature and the new Promise based style.\\n         *\\n         * Arguments in Promise mode:\\n         * @param {RTCSessionDescriptionInit} desc\\n         *\\n         * Arguments in callbacks mode:\\n         * @param {RTCSessionDescription} desc\\n         * @param {function()} callback\\n         * @param {function(error)} errback\\n         */\\n\\n    }, {\\n        key: 'setRemoteDescription',\\n        value: function setRemoteDescription(desc) {\\n            var usePromise = void 0;\\n            var callback = void 0;\\n            var errback = void 0;\\n\\n            if (!desc) {\\n                throw new TypeError('description missing');\\n            }\\n\\n            if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {\\n                usePromise = true;\\n            } else {\\n                usePromise = false;\\n                callback = arguments.length <= 1 ? undefined : arguments[1];\\n                errback = arguments.length <= 2 ? undefined : arguments[2];\\n\\n                if (typeof callback !== 'function') {\\n                    throw new TypeError('callback missing');\\n                }\\n\\n                if (typeof errback !== 'function') {\\n                    throw new TypeError('errback missing');\\n                }\\n            }\\n\\n            logger.debug('setRemoteDescription() desc:', desc);\\n\\n            if (usePromise) {\\n                return this._setRemoteDescription(desc);\\n            }\\n\\n            this._setRemoteDescription(desc).then(function () {\\n                return callback();\\n            }).catch(function (error) {\\n                return errback(error);\\n            });\\n        }\\n\\n        /**\\n         * Promise based implementation for addIceCandidate().\\n         * @return {Promise}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_addIceCandidate',\\n        value: function _addIceCandidate(candidate) {\\n            // eslint-disable-line no-unused-vars\\n            if (this._closed) {\\n                return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('RTCPeerConnection closed'));\\n            }\\n\\n            // NOTE: Edge does not support Trickle-ICE so just candidates in the\\n            // remote SDP are applied. Candidates given later would be just\\n            // ignored, so notify the called about that.\\n            return Promise.reject(new Error('addIceCandidate() not supported'));\\n        }\\n\\n        /**\\n         * Implementation for addStream().\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_addStream',\\n        value: function _addStream(stream) {\\n            if (this._closed) {\\n                throw new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('RTCPeerConnection closed');\\n            }\\n\\n            // Create a RTCRtpSender for each track.\\n            var _iteratorNormalCompletion3 = true;\\n            var _didIteratorError3 = false;\\n            var _iteratorError3 = undefined;\\n\\n            try {\\n                for (var _iterator3 = stream.getTracks()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n                    var track = _step3.value;\\n\\n                    // Ignore if ended.\\n                    if (track.readyState === 'ended') {\\n                        logger.warn('ignoring ended MediaStreamTrack');\\n\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    // Ignore if track is already present.\\n                    if (this._localTrackInfos.has(track.id)) {\\n                        logger.warn('ignoring already handled MediaStreamTrack');\\n\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    var rtpSender = new RTCRtpSender(track, this._dtlsTransport);\\n\\n                    // Store it in the map.\\n                    this._localTrackInfos.set(track.id, {\\n                        rtpSender: rtpSender,\\n                        stream: stream\\n                    });\\n                }\\n\\n                // Check for local tracks removal.\\n            } catch (err) {\\n                _didIteratorError3 = true;\\n                _iteratorError3 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                        _iterator3.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError3) {\\n                        throw _iteratorError3;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion4 = true;\\n            var _didIteratorError4 = false;\\n            var _iteratorError4 = undefined;\\n\\n            try {\\n                for (var _iterator4 = this._localTrackInfos[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n                    var _ref = _step4.value;\\n\\n                    var _ref2 = _slicedToArray(_ref, 2);\\n\\n                    var trackId = _ref2[0];\\n                    var info = _ref2[1];\\n\\n                    var _track = info.rtpSender.track;\\n\\n                    // Check if any of the local tracks has been stopped.\\n                    if (_track.readyState === 'ended') {\\n                        logger.warn('_addStream() an already handled track was stopped, ' + ('track.id:' + _track.id));\\n\\n                        try {\\n                            info.rtpSender.stop();\\n                        } catch (error) {\\n                            logger.warn('rtpSender.stop() failed:' + error);\\n                        }\\n\\n                        // Remove from the map.\\n                        this._localTrackInfos.delete(_track.id);\\n\\n                        // Also, if the stream was already handled, check whether tracks\\n                        // have been removed via stream.removeTrack() and, if so, stop\\n                        // their RtpSenders.\\n                    } else if (info.stream === stream && !stream.getTrackById(trackId)) {\\n                        logger.warn('_addStream() a track in this stream was removed, ' + ('track.id:' + trackId));\\n\\n                        try {\\n                            info.rtpSender.stop();\\n                        } catch (error) {\\n                            logger.warn('rtpSender.stop() failed:' + error);\\n                        }\\n\\n                        // Remove from the map.\\n                        this._localTrackInfos.delete(_track.id);\\n                    }\\n                }\\n\\n                // It may need to renegotiate.\\n            } catch (err) {\\n                _didIteratorError4 = true;\\n                _iteratorError4 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n                        _iterator4.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError4) {\\n                        throw _iteratorError4;\\n                    }\\n                }\\n            }\\n\\n            this._emitNegotiationNeeded();\\n        }\\n\\n        /**\\n         * Promise based implementation for createAnswer().\\n         * @returns {Promise}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_createAnswer',\\n        value: function _createAnswer(options) {\\n            // eslint-disable-line no-unused-vars\\n            if (this._closed) {\\n                return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('RTCPeerConnection closed'));\\n            }\\n\\n            if (this.signalingState !== RTCSignalingState.haveRemoteOffer) {\\n                return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('invalid signalingState \\\"' + this.signalingState + '\\\"'));\\n            }\\n\\n            // Create an answer.\\n            var localDescription = this._createLocalDescription('answer');\\n\\n            // Resolve with it.\\n            return Promise.resolve(localDescription);\\n        }\\n\\n        /**\\n         * Creates the local RTCSessionDescription.\\n         * @param {String} type - 'offer' / 'answer'.\\n         * @return {RTCSessionDescription}\\n         */\\n\\n    }, {\\n        key: '_createLocalDescription',\\n        value: function _createLocalDescription(type) {\\n            var sdpObject = {};\\n            var localIceParameters = this._iceGatherer.getLocalParameters();\\n            var localIceCandidates = this._iceGatherer.getLocalCandidates();\\n            var localDtlsParameters = this._dtlsTransport.getLocalParameters();\\n            var remoteDtlsParameters = this._dtlsTransport.getRemoteParameters();\\n            var localCapabilities = this._localCapabilities;\\n            var localTrackInfos = this._localTrackInfos;\\n\\n            // Increase SDP version if an offer.\\n            if (type === 'offer') {\\n                this._sdpGlobalFields.version++;\\n            }\\n\\n            // SDP global fields.\\n            sdpObject.version = 0;\\n            sdpObject.origin = {\\n                address: '127.0.0.1',\\n                ipVer: 4,\\n                netType: 'IN',\\n                sessionId: this._sdpGlobalFields.id,\\n                sessionVersion: this._sdpGlobalFields.version,\\n                username: 'jitsi-ortc-webrtc-shim'\\n            };\\n            sdpObject.name = '-';\\n            sdpObject.timing = {\\n                start: 0,\\n                stop: 0\\n            };\\n            sdpObject.msidSemantic = {\\n                semantic: 'WMS',\\n                token: '*'\\n            };\\n            sdpObject.groups = [{\\n                mids: Array.from(this._mids.keys()).join(' '),\\n                type: 'BUNDLE'\\n            }];\\n            sdpObject.media = [];\\n\\n            // DTLS fingerprint.\\n            sdpObject.fingerprint = {\\n                hash: localDtlsParameters.fingerprints[0].value,\\n                type: localDtlsParameters.fingerprints[0].algorithm\\n            };\\n\\n            // Let's check whether there is video RTX.\\n            var hasVideoRtx = false;\\n\\n            var _iteratorNormalCompletion5 = true;\\n            var _didIteratorError5 = false;\\n            var _iteratorError5 = undefined;\\n\\n            try {\\n                for (var _iterator5 = localCapabilities.codecs[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\\n                    var codec = _step5.value;\\n\\n                    if (codec.kind === 'video' && codec.name === 'rtx') {\\n                        hasVideoRtx = true;\\n                        break;\\n                    }\\n                }\\n\\n                // Add m= sections.\\n            } catch (err) {\\n                _didIteratorError5 = true;\\n                _iteratorError5 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\\n                        _iterator5.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError5) {\\n                        throw _iteratorError5;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion6 = true;\\n            var _didIteratorError6 = false;\\n            var _iteratorError6 = undefined;\\n\\n            try {\\n                for (var _iterator6 = this._mids[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\\n                    var _ref3 = _step6.value;\\n\\n                    var _ref4 = _slicedToArray(_ref3, 2);\\n\\n                    var mid = _ref4[0];\\n                    var kind = _ref4[1];\\n\\n                    addMediaSection.call(this, mid, kind);\\n                }\\n\\n                // Create a RTCSessionDescription.\\n            } catch (err) {\\n                _didIteratorError6 = true;\\n                _iteratorError6 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\\n                        _iterator6.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError6) {\\n                        throw _iteratorError6;\\n                    }\\n                }\\n            }\\n\\n            var localDescription = new __WEBPACK_IMPORTED_MODULE_2__RTCSessionDescription__[\\\"a\\\" /* default */]({\\n                type: type,\\n                _sdpObject: sdpObject\\n            });\\n\\n            logger.debug('_createLocalDescription():', localDescription);\\n\\n            return localDescription;\\n\\n            /**\\n             * Add a m= section.\\n             */\\n            function addMediaSection(mid, kind) {\\n                var mediaObject = {};\\n\\n                // m= line.\\n                mediaObject.type = kind;\\n\\n                switch (kind) {\\n                    case 'audio':\\n                    case 'video':\\n                        mediaObject.protocol = 'RTP/SAVPF';\\n                        mediaObject.port = 9;\\n                        mediaObject.direction = 'sendrecv';\\n                        break;\\n                    case 'application':\\n                        mediaObject.protocol = 'DTLS/SCTP';\\n                        mediaObject.port = 0; // Reject m section.\\n                        mediaObject.payloads = '0'; // Just put something.\\n                        mediaObject.direction = 'inactive';\\n                        break;\\n                }\\n\\n                // c= line.\\n                mediaObject.connection = {\\n                    ip: '127.0.0.1',\\n                    version: 4\\n                };\\n\\n                // a=mid attribute.\\n                mediaObject.mid = mid;\\n\\n                // ICE.\\n                mediaObject.iceUfrag = localIceParameters.usernameFragment;\\n                mediaObject.icePwd = localIceParameters.password;\\n                mediaObject.candidates = [];\\n\\n                var _iteratorNormalCompletion7 = true;\\n                var _didIteratorError7 = false;\\n                var _iteratorError7 = undefined;\\n\\n                try {\\n                    for (var _iterator7 = localIceCandidates[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\\n                        var candidate = _step7.value;\\n\\n                        var candidateObject = {};\\n\\n                        // rtcp-mux is assumed, so component is always 1 (RTP).\\n                        candidateObject.component = 1;\\n                        candidateObject.foundation = candidate.foundation;\\n                        candidateObject.ip = candidate.ip;\\n                        candidateObject.port = candidate.port;\\n                        candidateObject.priority = candidate.priority;\\n                        candidateObject.transport = candidate.protocol.toLowerCase();\\n                        candidateObject.type = candidate.type;\\n                        if (candidateObject.transport === 'tcp') {\\n                            candidateObject.tcptype = candidate.tcpType;\\n                        }\\n\\n                        mediaObject.candidates.push(candidateObject);\\n                    }\\n                } catch (err) {\\n                    _didIteratorError7 = true;\\n                    _iteratorError7 = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion7 && _iterator7.return) {\\n                            _iterator7.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError7) {\\n                            throw _iteratorError7;\\n                        }\\n                    }\\n                }\\n\\n                mediaObject.endOfCandidates = 'end-of-candidates';\\n\\n                // DTLS.\\n                // If 'offer' always use 'actpass'.\\n                if (type === 'offer') {\\n                    mediaObject.setup = 'actpass';\\n                } else {\\n                    mediaObject.setup = remoteDtlsParameters.role === 'server' ? 'active' : 'passive';\\n                }\\n\\n                if (kind === 'audio' || kind === 'video') {\\n                    mediaObject.rtp = [];\\n                    mediaObject.rtcpFb = [];\\n                    mediaObject.fmtp = [];\\n\\n                    // Array of payload types.\\n                    var payloads = [];\\n\\n                    // Add codecs.\\n                    var _iteratorNormalCompletion8 = true;\\n                    var _didIteratorError8 = false;\\n                    var _iteratorError8 = undefined;\\n\\n                    try {\\n                        for (var _iterator8 = localCapabilities.codecs[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\\n                            var _codec = _step8.value;\\n\\n                            if (_codec.kind && _codec.kind !== kind) {\\n                                continue; // eslint-disable-line no-continue\\n                            }\\n\\n                            payloads.push(_codec.preferredPayloadType);\\n\\n                            var rtpObject = {\\n                                codec: _codec.name,\\n                                payload: _codec.preferredPayloadType,\\n                                rate: _codec.clockRate\\n                            };\\n\\n                            if (_codec.numChannels > 1) {\\n                                rtpObject.encoding = _codec.numChannels;\\n                            }\\n\\n                            mediaObject.rtp.push(rtpObject);\\n\\n                            // If codec has parameters add them into a=fmtp attributes.\\n                            if (_codec.parameters) {\\n                                var paramFmtp = {\\n                                    config: '',\\n                                    payload: _codec.preferredPayloadType\\n                                };\\n\\n                                var _iteratorNormalCompletion11 = true;\\n                                var _didIteratorError11 = false;\\n                                var _iteratorError11 = undefined;\\n\\n                                try {\\n                                    for (var _iterator11 = Object.keys(_codec.parameters)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\\n                                        var name = _step11.value;\\n\\n                                        /* eslint-disable max-depth */\\n                                        if (paramFmtp.config) {\\n                                            paramFmtp.config += ';';\\n                                        }\\n                                        /* eslint-enable max-depth */\\n\\n                                        paramFmtp.config += name + '=' + _codec.parameters[name];\\n                                    }\\n                                } catch (err) {\\n                                    _didIteratorError11 = true;\\n                                    _iteratorError11 = err;\\n                                } finally {\\n                                    try {\\n                                        if (!_iteratorNormalCompletion11 && _iterator11.return) {\\n                                            _iterator11.return();\\n                                        }\\n                                    } finally {\\n                                        if (_didIteratorError11) {\\n                                            throw _iteratorError11;\\n                                        }\\n                                    }\\n                                }\\n\\n                                if (paramFmtp.config) {\\n                                    mediaObject.fmtp.push(paramFmtp);\\n                                }\\n                            }\\n\\n                            // Set RTCP feedback.\\n                            var _iteratorNormalCompletion12 = true;\\n                            var _didIteratorError12 = false;\\n                            var _iteratorError12 = undefined;\\n\\n                            try {\\n                                for (var _iterator12 = (_codec.rtcpFeedback || [])[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\\n                                    var fb = _step12.value;\\n\\n                                    mediaObject.rtcpFb.push({\\n                                        payload: _codec.preferredPayloadType,\\n                                        subtype: fb.parameter || undefined,\\n                                        type: fb.type\\n                                    });\\n                                }\\n                            } catch (err) {\\n                                _didIteratorError12 = true;\\n                                _iteratorError12 = err;\\n                            } finally {\\n                                try {\\n                                    if (!_iteratorNormalCompletion12 && _iterator12.return) {\\n                                        _iterator12.return();\\n                                    }\\n                                } finally {\\n                                    if (_didIteratorError12) {\\n                                        throw _iteratorError12;\\n                                    }\\n                                }\\n                            }\\n                        }\\n\\n                        // If there are no codecs, set this m section as unavailable.\\n                    } catch (err) {\\n                        _didIteratorError8 = true;\\n                        _iteratorError8 = err;\\n                    } finally {\\n                        try {\\n                            if (!_iteratorNormalCompletion8 && _iterator8.return) {\\n                                _iterator8.return();\\n                            }\\n                        } finally {\\n                            if (_didIteratorError8) {\\n                                throw _iteratorError8;\\n                            }\\n                        }\\n                    }\\n\\n                    if (payloads.length === 0) {\\n                        mediaObject.payloads = '9'; // Just put something.\\n                        mediaObject.port = 0;\\n                        mediaObject.direction = 'inactive';\\n                    } else {\\n                        mediaObject.payloads = payloads.join(' ');\\n                    }\\n\\n                    // SSRCs.\\n                    mediaObject.ssrcs = [];\\n                    mediaObject.ssrcGroups = [];\\n\\n                    // Add RTP sending stuff.\\n                    var _iteratorNormalCompletion9 = true;\\n                    var _didIteratorError9 = false;\\n                    var _iteratorError9 = undefined;\\n\\n                    try {\\n                        for (var _iterator9 = localTrackInfos.values()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\\n                            var info = _step9.value;\\n\\n                            var rtpSender = info.rtpSender;\\n                            var streamId = info.stream.id;\\n                            var track = rtpSender.track;\\n\\n                            // Ignore if ended.\\n                            if (track.readyState === 'ended') {\\n                                continue; // eslint-disable-line no-continue\\n                            }\\n\\n                            if (track.kind !== kind) {\\n                                continue; // eslint-disable-line no-continue\\n                            }\\n\\n                            // Set a random provisional SSRC if not set.\\n                            if (!info.ssrc) {\\n                                info.ssrc = __WEBPACK_IMPORTED_MODULE_6__xmpp_SDPUtil__[\\\"a\\\" /* default */].generateSsrc();\\n                            }\\n\\n                            // Whether RTX should be enabled.\\n                            var enableRtx = hasVideoRtx && track.kind === 'video';\\n\\n                            // Set a random provisional RTX SSRC if not set.\\n                            if (enableRtx && !info.rtxSsrc) {\\n                                info.rtxSsrc = info.ssrc + 1;\\n                            }\\n\\n                            mediaObject.ssrcs.push({\\n                                attribute: 'cname',\\n                                id: info.ssrc,\\n                                value: CNAME\\n                            });\\n\\n                            mediaObject.ssrcs.push({\\n                                attribute: 'msid',\\n                                id: info.ssrc,\\n                                value: streamId + ' ' + track.id\\n                            });\\n\\n                            mediaObject.ssrcs.push({\\n                                attribute: 'mslabel',\\n                                id: info.ssrc,\\n                                value: streamId\\n                            });\\n\\n                            mediaObject.ssrcs.push({\\n                                attribute: 'label',\\n                                id: info.ssrc,\\n                                value: track.id\\n                            });\\n\\n                            if (enableRtx) {\\n                                mediaObject.ssrcs.push({\\n                                    attribute: 'cname',\\n                                    id: info.rtxSsrc,\\n                                    value: CNAME\\n                                });\\n\\n                                mediaObject.ssrcs.push({\\n                                    attribute: 'msid',\\n                                    id: info.rtxSsrc,\\n                                    value: streamId + ' ' + track.id\\n                                });\\n\\n                                mediaObject.ssrcs.push({\\n                                    attribute: 'mslabel',\\n                                    id: info.rtxSsrc,\\n                                    value: streamId\\n                                });\\n\\n                                mediaObject.ssrcs.push({\\n                                    attribute: 'label',\\n                                    id: info.rtxSsrc,\\n                                    value: track.id\\n                                });\\n\\n                                mediaObject.ssrcGroups.push({\\n                                    semantics: 'FID',\\n                                    ssrcs: info.ssrc + ' ' + info.rtxSsrc\\n                                });\\n                            }\\n                        }\\n\\n                        // RTP header extensions.\\n                    } catch (err) {\\n                        _didIteratorError9 = true;\\n                        _iteratorError9 = err;\\n                    } finally {\\n                        try {\\n                            if (!_iteratorNormalCompletion9 && _iterator9.return) {\\n                                _iterator9.return();\\n                            }\\n                        } finally {\\n                            if (_didIteratorError9) {\\n                                throw _iteratorError9;\\n                            }\\n                        }\\n                    }\\n\\n                    mediaObject.ext = [];\\n\\n                    var _iteratorNormalCompletion10 = true;\\n                    var _didIteratorError10 = false;\\n                    var _iteratorError10 = undefined;\\n\\n                    try {\\n                        for (var _iterator10 = localCapabilities.headerExtensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\\n                            var extension = _step10.value;\\n\\n                            if (extension.kind && extension.kind !== kind) {\\n                                continue; // eslint-disable-line no-continue\\n                            }\\n\\n                            mediaObject.ext.push({\\n                                value: extension.preferredId,\\n                                uri: extension.uri\\n                            });\\n                        }\\n\\n                        // a=rtcp-mux attribute.\\n                    } catch (err) {\\n                        _didIteratorError10 = true;\\n                        _iteratorError10 = err;\\n                    } finally {\\n                        try {\\n                            if (!_iteratorNormalCompletion10 && _iterator10.return) {\\n                                _iterator10.return();\\n                            }\\n                        } finally {\\n                            if (_didIteratorError10) {\\n                                throw _iteratorError10;\\n                            }\\n                        }\\n                    }\\n\\n                    mediaObject.rtcpMux = 'rtcp-mux';\\n\\n                    // a=rtcp-rsize.\\n                    mediaObject.rtcpRsize = 'rtcp-rsize';\\n                }\\n\\n                // Add the media section.\\n                sdpObject.media.push(mediaObject);\\n            }\\n        }\\n\\n        /**\\n         * Promise based implementation for createOffer().\\n         * @returns {Promise}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_createOffer',\\n        value: function _createOffer(options) {\\n            // eslint-disable-line no-unused-vars\\n            if (this._closed) {\\n                return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('RTCPeerConnection closed'));\\n            }\\n\\n            if (this.signalingState !== RTCSignalingState.stable) {\\n                return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('invalid signalingState \\\"' + this.signalingState + '\\\"'));\\n            }\\n\\n            // NOTE: P2P mode not yet supported, so createOffer() should never be\\n            // called.\\n            return Promise.reject(new Error('createoOffer() not yet supported'));\\n        }\\n\\n        /**\\n         * Emit 'addstream' event.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_emitAddStream',\\n        value: function _emitAddStream(stream) {\\n            if (this._closed) {\\n                return;\\n            }\\n\\n            logger.debug('emitting \\\"addstream\\\"');\\n\\n            var event = new __WEBPACK_IMPORTED_MODULE_1_yaeti___default.a.Event('addstream');\\n\\n            event.stream = stream;\\n            this.dispatchEvent(event);\\n        }\\n\\n        /**\\n         * May emit buffered ICE candidates.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_emitBufferedIceCandidates',\\n        value: function _emitBufferedIceCandidates() {\\n            if (this._closed) {\\n                return;\\n            }\\n\\n            var _iteratorNormalCompletion13 = true;\\n            var _didIteratorError13 = false;\\n            var _iteratorError13 = undefined;\\n\\n            try {\\n                for (var _iterator13 = this._bufferedIceCandidates[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\\n                    var sdpCandidate = _step13.value;\\n\\n                    if (!sdpCandidate) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    // Now we have set the MID values of the SDP O/A, so let's fill the\\n                    // sdpMIndex of the candidate.\\n                    sdpCandidate.sdpMIndex = this._mids.keys().next().value;\\n\\n                    logger.debug('emitting buffered \\\"icecandidate\\\", candidate:', sdpCandidate);\\n\\n                    var event = new __WEBPACK_IMPORTED_MODULE_1_yaeti___default.a.Event('icecandidate');\\n\\n                    event.candidate = sdpCandidate;\\n                    this.dispatchEvent(event);\\n                }\\n            } catch (err) {\\n                _didIteratorError13 = true;\\n                _iteratorError13 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion13 && _iterator13.return) {\\n                        _iterator13.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError13) {\\n                        throw _iteratorError13;\\n                    }\\n                }\\n            }\\n\\n            this._bufferedIceCandidates = [];\\n        }\\n\\n        /**\\n         * May emit 'connectionstatechange' event.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_emitConnectionStateChange',\\n        value: function _emitConnectionStateChange() {\\n            if (this._closed && this.connectionState !== 'closed') {\\n                return;\\n            }\\n\\n            logger.debug('emitting \\\"connectionstatechange\\\", connectionState:', this.connectionState);\\n\\n            var event = new __WEBPACK_IMPORTED_MODULE_1_yaeti___default.a.Event('connectionstatechange');\\n\\n            this.dispatchEvent(event);\\n        }\\n\\n        /**\\n         * May emit 'icecandidate' event.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_emitIceCandidate',\\n        value: function _emitIceCandidate(candidate) {\\n            if (this._closed) {\\n                return;\\n            }\\n\\n            var sdpCandidate = null;\\n\\n            if (candidate) {\\n                // NOTE: We assume BUNDLE so let's just emit candidates for the\\n                // first m= section.\\n                var sdpMIndex = this._mids.keys().next().value;\\n                var sdpMLineIndex = 0;\\n                var sdpAttribute = 'candidate:' + candidate.foundation + ' 1 ' + candidate.protocol + (' ' + candidate.priority + ' ' + candidate.ip + ' ' + candidate.port) + (' typ ' + candidate.type);\\n\\n                if (candidate.relatedAddress) {\\n                    sdpAttribute += ' raddr ' + candidate.relatedAddress;\\n                }\\n                if (candidate.relatedPort) {\\n                    sdpAttribute += ' rport ' + candidate.relatedPort;\\n                }\\n                if (candidate.protocol === 'tcp') {\\n                    sdpAttribute += ' tcptype ' + candidate.tcpType;\\n                }\\n\\n                sdpCandidate = {\\n                    candidate: sdpAttribute,\\n                    component: 1, // rtcp-mux assumed, so always 1 (RTP).\\n                    foundation: candidate.foundation,\\n                    ip: candidate.ip,\\n                    port: candidate.port,\\n                    priority: candidate.priority,\\n                    protocol: candidate.protocol,\\n                    type: candidate.type,\\n                    sdpMIndex: sdpMIndex,\\n                    sdpMLineIndex: sdpMLineIndex\\n                };\\n\\n                if (candidate.protocol === 'tcp') {\\n                    sdpCandidate.tcptype = candidate.tcpType;\\n                }\\n                if (candidate.relatedAddress) {\\n                    sdpCandidate.relatedAddress = candidate.relatedAddress;\\n                }\\n                if (candidate.relatedPort) {\\n                    sdpCandidate.relatedPort = candidate.relatedPort;\\n                }\\n            }\\n\\n            // If we don't have yet a local description, buffer the candidate.\\n            if (this._localDescription) {\\n                logger.debug('emitting \\\"icecandidate\\\", candidate:', sdpCandidate);\\n\\n                var event = new __WEBPACK_IMPORTED_MODULE_1_yaeti___default.a.Event('icecandidate');\\n\\n                event.candidate = sdpCandidate;\\n                this.dispatchEvent(event);\\n            } else {\\n                logger.debug('buffering gathered ICE candidate:', sdpCandidate);\\n\\n                this._bufferedIceCandidates.push(sdpCandidate);\\n            }\\n        }\\n\\n        /**\\n         * May emit 'iceconnectionstatechange' event.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_emitIceConnectionStateChange',\\n        value: function _emitIceConnectionStateChange() {\\n            if (this._closed && this.iceConnectionState !== 'closed') {\\n                return;\\n            }\\n\\n            logger.debug('emitting \\\"iceconnectionstatechange\\\", iceConnectionState:', this.iceConnectionState);\\n\\n            var event = new __WEBPACK_IMPORTED_MODULE_1_yaeti___default.a.Event('iceconnectionstatechange');\\n\\n            this.dispatchEvent(event);\\n        }\\n\\n        /**\\n         * May emit 'negotiationneeded' event.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_emitNegotiationNeeded',\\n        value: function _emitNegotiationNeeded() {\\n            // Ignore if signalingState is not 'stable'.\\n            if (this.signalingState !== RTCSignalingState.stable) {\\n                return;\\n            }\\n\\n            logger.debug('emitting \\\"negotiationneeded\\\"');\\n\\n            var event = new __WEBPACK_IMPORTED_MODULE_1_yaeti___default.a.Event('negotiationneeded');\\n\\n            this.dispatchEvent(event);\\n        }\\n\\n        /**\\n         * Emit 'removestream' event.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_emitRemoveStream',\\n        value: function _emitRemoveStream(stream) {\\n            if (this._closed) {\\n                return;\\n            }\\n\\n            logger.debug('emitting \\\"removestream\\\"');\\n\\n            var event = new __WEBPACK_IMPORTED_MODULE_1_yaeti___default.a.Event('removestream');\\n\\n            event.stream = stream;\\n            this.dispatchEvent(event);\\n        }\\n\\n        /**\\n         * Get RTP parameters for a RTCRtpReceiver.\\n         * @private\\n         * @return {RTCRtpParameters}\\n         */\\n\\n    }, {\\n        key: '_getParametersForRtpReceiver',\\n        value: function _getParametersForRtpReceiver(kind, data) {\\n            var ssrc = data.ssrc;\\n            var rtxSsrc = data.rtxSsrc;\\n            var cname = data.cname;\\n            var localCapabilities = this._localCapabilities;\\n            var parameters = {\\n                codecs: [],\\n                degradationPreference: 'balanced',\\n                encodings: [],\\n                headerExtensions: [],\\n                muxId: '',\\n                rtcp: {\\n                    cname: cname,\\n                    compound: true, // NOTE: Implemented in Edge.\\n                    mux: true,\\n                    reducedSize: true // NOTE: Not yet implemented in Edge.\\n                }\\n            };\\n\\n            var codecs = [];\\n            var codecPayloadType = void 0;\\n\\n            var _iteratorNormalCompletion14 = true;\\n            var _didIteratorError14 = false;\\n            var _iteratorError14 = undefined;\\n\\n            try {\\n                for (var _iterator14 = localCapabilities.codecs[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\\n                    var codecCapability = _step14.value;\\n\\n                    if (codecCapability.kind !== kind || codecCapability.name === 'rtx') {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    codecPayloadType = codecCapability.preferredPayloadType;\\n                    codecs.push({\\n                        clockRate: codecCapability.clockRate,\\n                        maxptime: codecCapability.maxptime,\\n                        mimeType: codecCapability.mimeType,\\n                        name: codecCapability.name,\\n                        numChannels: codecCapability.numChannels,\\n                        parameters: codecCapability.parameters,\\n                        payloadType: codecCapability.preferredPayloadType,\\n                        ptime: codecCapability.ptime,\\n                        rtcpFeedback: codecCapability.rtcpFeedback\\n                    });\\n\\n                    break;\\n                }\\n            } catch (err) {\\n                _didIteratorError14 = true;\\n                _iteratorError14 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion14 && _iterator14.return) {\\n                        _iterator14.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError14) {\\n                        throw _iteratorError14;\\n                    }\\n                }\\n            }\\n\\n            if (rtxSsrc) {\\n                var _iteratorNormalCompletion15 = true;\\n                var _didIteratorError15 = false;\\n                var _iteratorError15 = undefined;\\n\\n                try {\\n                    for (var _iterator15 = localCapabilities.codecs[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\\n                        var _codecCapability = _step15.value;\\n\\n                        if (_codecCapability.kind !== kind || _codecCapability.name !== 'rtx') {\\n                            continue; // eslint-disable-line no-continue\\n                        }\\n\\n                        codecs.push({\\n                            clockRate: _codecCapability.clockRate,\\n                            mimeType: _codecCapability.mimeType,\\n                            name: 'rtx',\\n                            parameters: _codecCapability.parameters,\\n                            payloadType: _codecCapability.preferredPayloadType,\\n                            rtcpFeedback: _codecCapability.rtcpFeedback\\n                        });\\n\\n                        break;\\n                    }\\n                } catch (err) {\\n                    _didIteratorError15 = true;\\n                    _iteratorError15 = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion15 && _iterator15.return) {\\n                            _iterator15.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError15) {\\n                            throw _iteratorError15;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            parameters.codecs = codecs;\\n\\n            var encoding = {\\n                active: true,\\n                codecPayloadType: codecPayloadType,\\n                ssrc: ssrc\\n            };\\n\\n            if (rtxSsrc) {\\n                encoding.rtx = {\\n                    ssrc: rtxSsrc\\n                };\\n            }\\n\\n            parameters.encodings.push(encoding);\\n\\n            var _iteratorNormalCompletion16 = true;\\n            var _didIteratorError16 = false;\\n            var _iteratorError16 = undefined;\\n\\n            try {\\n                for (var _iterator16 = localCapabilities.headerExtensions[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\\n                    var extension = _step16.value;\\n\\n                    if (extension.kind !== kind) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    parameters.headerExtensions.push({\\n                        encrypt: extension.preferredEncrypt,\\n                        id: extension.preferredId,\\n                        uri: extension.uri\\n                    });\\n                }\\n            } catch (err) {\\n                _didIteratorError16 = true;\\n                _iteratorError16 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion16 && _iterator16.return) {\\n                        _iterator16.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError16) {\\n                        throw _iteratorError16;\\n                    }\\n                }\\n            }\\n\\n            return parameters;\\n        }\\n\\n        /**\\n         * Get RTP parameters for a RTCRtpSender.\\n         * @private\\n         * @return {RTCRtpParameters}\\n         */\\n\\n    }, {\\n        key: '_getParametersForRtpSender',\\n        value: function _getParametersForRtpSender(kind, data) {\\n            var ssrc = data.ssrc;\\n            var rtxSsrc = data.rtxSsrc;\\n            var cname = CNAME;\\n            var localCapabilities = this._localCapabilities;\\n            var parameters = {\\n                codecs: [],\\n                degradationPreference: 'balanced',\\n                encodings: [],\\n                headerExtensions: [],\\n                muxId: '',\\n                rtcp: {\\n                    cname: cname,\\n                    compound: true, // NOTE: Implemented in Edge.\\n                    mux: true,\\n                    reducedSize: true // NOTE: Not yet implemented in Edge.\\n                }\\n            };\\n\\n            var codecs = [];\\n            var codecPayloadType = void 0;\\n\\n            var _iteratorNormalCompletion17 = true;\\n            var _didIteratorError17 = false;\\n            var _iteratorError17 = undefined;\\n\\n            try {\\n                for (var _iterator17 = localCapabilities.codecs[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\\n                    var codecCapability = _step17.value;\\n\\n                    if (codecCapability.kind !== kind || codecCapability.name === 'rtx') {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    codecPayloadType = codecCapability.preferredPayloadType;\\n                    codecs.push({\\n                        clockRate: codecCapability.clockRate,\\n                        maxptime: codecCapability.maxptime,\\n                        mimeType: codecCapability.mimeType,\\n                        name: codecCapability.name,\\n                        numChannels: codecCapability.numChannels,\\n                        parameters: codecCapability.parameters,\\n                        payloadType: codecCapability.preferredPayloadType,\\n                        ptime: codecCapability.ptime,\\n                        rtcpFeedback: codecCapability.rtcpFeedback\\n                    });\\n\\n                    break;\\n                }\\n            } catch (err) {\\n                _didIteratorError17 = true;\\n                _iteratorError17 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion17 && _iterator17.return) {\\n                        _iterator17.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError17) {\\n                        throw _iteratorError17;\\n                    }\\n                }\\n            }\\n\\n            if (rtxSsrc) {\\n                var _iteratorNormalCompletion18 = true;\\n                var _didIteratorError18 = false;\\n                var _iteratorError18 = undefined;\\n\\n                try {\\n                    for (var _iterator18 = localCapabilities.codecs[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\\n                        var _codecCapability2 = _step18.value;\\n\\n                        if (_codecCapability2.kind !== kind || _codecCapability2.name !== 'rtx') {\\n                            continue; // eslint-disable-line no-continue\\n                        }\\n\\n                        codecs.push({\\n                            clockRate: _codecCapability2.clockRate,\\n                            mimeType: _codecCapability2.mimeType,\\n                            name: 'rtx',\\n                            parameters: _codecCapability2.parameters,\\n                            payloadType: _codecCapability2.preferredPayloadType,\\n                            rtcpFeedback: _codecCapability2.rtcpFeedback\\n                        });\\n\\n                        break;\\n                    }\\n                } catch (err) {\\n                    _didIteratorError18 = true;\\n                    _iteratorError18 = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion18 && _iterator18.return) {\\n                            _iterator18.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError18) {\\n                            throw _iteratorError18;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            parameters.codecs = codecs;\\n\\n            var encoding = {\\n                active: true,\\n                codecPayloadType: codecPayloadType,\\n                ssrc: ssrc\\n            };\\n\\n            if (rtxSsrc) {\\n                encoding.rtx = {\\n                    ssrc: rtxSsrc\\n                };\\n            }\\n\\n            parameters.encodings.push(encoding);\\n\\n            var _iteratorNormalCompletion19 = true;\\n            var _didIteratorError19 = false;\\n            var _iteratorError19 = undefined;\\n\\n            try {\\n                for (var _iterator19 = localCapabilities.headerExtensions[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\\n                    var extension = _step19.value;\\n\\n                    if (extension.kind !== kind) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    parameters.headerExtensions.push({\\n                        encrypt: extension.preferredEncrypt,\\n                        id: extension.preferredId,\\n                        uri: extension.uri\\n                    });\\n                }\\n            } catch (err) {\\n                _didIteratorError19 = true;\\n                _iteratorError19 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion19 && _iterator19.return) {\\n                        _iterator19.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError19) {\\n                        throw _iteratorError19;\\n                    }\\n                }\\n            }\\n\\n            return parameters;\\n        }\\n\\n        /**\\n         * Promise based implementation for getStats().\\n         * @return {Promise} RTCStats dictionary.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_getStats',\\n        value: function _getStats(selector) {\\n            // eslint-disable-line no-unused-vars\\n            if (this._closed) {\\n                return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('RTCPeerConnection closed'));\\n            }\\n\\n            var iceGatherer = this._iceGatherer;\\n            var iceTransport = this._iceTransport;\\n            var rtpSenders = [];\\n            var rtpReceivers = [];\\n            var promises = [];\\n\\n            // Get RtpSenders.\\n            var _iteratorNormalCompletion20 = true;\\n            var _didIteratorError20 = false;\\n            var _iteratorError20 = undefined;\\n\\n            try {\\n                for (var _iterator20 = this._localTrackInfos.values()[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\\n                    var info = _step20.value;\\n                    var rtpSender = info.rtpSender,\\n                        sending = info.sending;\\n\\n\\n                    if (sending) {\\n                        rtpSenders.push(rtpSender);\\n                    }\\n                }\\n\\n                // Get RtpReceivers.\\n            } catch (err) {\\n                _didIteratorError20 = true;\\n                _iteratorError20 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion20 && _iterator20.return) {\\n                        _iterator20.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError20) {\\n                        throw _iteratorError20;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion21 = true;\\n            var _didIteratorError21 = false;\\n            var _iteratorError21 = undefined;\\n\\n            try {\\n                for (var _iterator21 = this._remoteTrackInfos.values()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\\n                    var _info2 = _step21.value;\\n                    var rtpReceiver = _info2.rtpReceiver;\\n\\n\\n                    rtpReceivers.push(rtpReceiver);\\n                }\\n\\n                // Collect all the stats.\\n            } catch (err) {\\n                _didIteratorError21 = true;\\n                _iteratorError21 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion21 && _iterator21.return) {\\n                        _iterator21.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError21) {\\n                        throw _iteratorError21;\\n                    }\\n                }\\n            }\\n\\n            if (iceGatherer) {\\n                promises.push(iceGatherer.getStats().catch(function () {\\n                    return null;\\n                }));\\n            }\\n\\n            if (iceTransport) {\\n                promises.push(iceTransport.getStats().catch(function () {\\n                    return null;\\n                }));\\n\\n                // NOTE: Proprietary stuff in Edge.\\n                if (typeof iceTransport.msGetStats === 'function') {\\n                    promises.push(iceTransport.msGetStats().catch(function () {\\n                        return null;\\n                    }));\\n                }\\n            }\\n\\n            var _loop = function _loop(rtpSender) {\\n                var isAudio = rtpSender.track.kind === 'audio';\\n\\n                promises.push(rtpSender.getStats().then(function (data) {\\n                    // Remove audioLevel from type=\\\"track\\\" stats if this is\\n                    // not an audio sender.\\n                    if (!isAudio) {\\n                        var _iteratorNormalCompletion26 = true;\\n                        var _didIteratorError26 = false;\\n                        var _iteratorError26 = undefined;\\n\\n                        try {\\n                            for (var _iterator26 = Object.keys(data)[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {\\n                                var key = _step26.value;\\n\\n                                var stat = data[key];\\n\\n                                if (stat.type === 'track') {\\n                                    delete stat.audioLevel;\\n                                }\\n                            }\\n                        } catch (err) {\\n                            _didIteratorError26 = true;\\n                            _iteratorError26 = err;\\n                        } finally {\\n                            try {\\n                                if (!_iteratorNormalCompletion26 && _iterator26.return) {\\n                                    _iterator26.return();\\n                                }\\n                            } finally {\\n                                if (_didIteratorError26) {\\n                                    throw _iteratorError26;\\n                                }\\n                            }\\n                        }\\n                    }\\n\\n                    return data;\\n                }).catch(function () {\\n                    return null;\\n                }));\\n            };\\n\\n            var _iteratorNormalCompletion22 = true;\\n            var _didIteratorError22 = false;\\n            var _iteratorError22 = undefined;\\n\\n            try {\\n                for (var _iterator22 = rtpSenders[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\\n                    var rtpSender = _step22.value;\\n\\n                    _loop(rtpSender);\\n                }\\n            } catch (err) {\\n                _didIteratorError22 = true;\\n                _iteratorError22 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion22 && _iterator22.return) {\\n                        _iterator22.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError22) {\\n                        throw _iteratorError22;\\n                    }\\n                }\\n            }\\n\\n            var _loop2 = function _loop2(rtpReceiver) {\\n                var isAudio = rtpReceiver.track.kind === 'audio';\\n\\n                promises.push(rtpReceiver.getStats().then(function (data) {\\n                    // Remove audioLevel from type=\\\"track\\\" stats if this is\\n                    // not an audio receiver.\\n                    if (!isAudio) {\\n                        var _iteratorNormalCompletion27 = true;\\n                        var _didIteratorError27 = false;\\n                        var _iteratorError27 = undefined;\\n\\n                        try {\\n                            for (var _iterator27 = Object.keys(data)[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {\\n                                var key = _step27.value;\\n\\n                                var stat = data[key];\\n\\n                                if (stat.type === 'track') {\\n                                    delete stat.audioLevel;\\n                                }\\n                            }\\n                        } catch (err) {\\n                            _didIteratorError27 = true;\\n                            _iteratorError27 = err;\\n                        } finally {\\n                            try {\\n                                if (!_iteratorNormalCompletion27 && _iterator27.return) {\\n                                    _iterator27.return();\\n                                }\\n                            } finally {\\n                                if (_didIteratorError27) {\\n                                    throw _iteratorError27;\\n                                }\\n                            }\\n                        }\\n                    }\\n\\n                    return data;\\n                }).catch(function () {\\n                    return null;\\n                }));\\n            };\\n\\n            var _iteratorNormalCompletion23 = true;\\n            var _didIteratorError23 = false;\\n            var _iteratorError23 = undefined;\\n\\n            try {\\n                for (var _iterator23 = rtpReceivers[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {\\n                    var rtpReceiver = _step23.value;\\n\\n                    _loop2(rtpReceiver);\\n                }\\n            } catch (err) {\\n                _didIteratorError23 = true;\\n                _iteratorError23 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion23 && _iterator23.return) {\\n                        _iterator23.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError23) {\\n                        throw _iteratorError23;\\n                    }\\n                }\\n            }\\n\\n            return Promise.all(promises).then(function (datas) {\\n                var stats = {};\\n\\n                var _iteratorNormalCompletion24 = true;\\n                var _didIteratorError24 = false;\\n                var _iteratorError24 = undefined;\\n\\n                try {\\n                    for (var _iterator24 = datas[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {\\n                        var data = _step24.value;\\n\\n                        if (!data) {\\n                            continue; // eslint-disable-line no-continue\\n                        }\\n\\n                        var _iteratorNormalCompletion25 = true;\\n                        var _didIteratorError25 = false;\\n                        var _iteratorError25 = undefined;\\n\\n                        try {\\n                            for (var _iterator25 = Object.keys(data)[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {\\n                                var key = _step25.value;\\n\\n                                stats[key] = data[key];\\n                            }\\n                        } catch (err) {\\n                            _didIteratorError25 = true;\\n                            _iteratorError25 = err;\\n                        } finally {\\n                            try {\\n                                if (!_iteratorNormalCompletion25 && _iterator25.return) {\\n                                    _iterator25.return();\\n                                }\\n                            } finally {\\n                                if (_didIteratorError25) {\\n                                    throw _iteratorError25;\\n                                }\\n                            }\\n                        }\\n                    }\\n                } catch (err) {\\n                    _didIteratorError24 = true;\\n                    _iteratorError24 = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion24 && _iterator24.return) {\\n                            _iterator24.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError24) {\\n                            throw _iteratorError24;\\n                        }\\n                    }\\n                }\\n\\n                return stats;\\n            });\\n        }\\n\\n        /**\\n         * Handles the local initial answer.\\n         * @return {Promise}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_handleLocalInitialAnswer',\\n        value: function _handleLocalInitialAnswer(desc) {\\n            logger.debug('_handleLocalInitialAnswer(), desc:', desc);\\n\\n            var sdpObject = desc.sdpObject;\\n\\n            // Update local capabilities as decided by the app.\\n            this._localCapabilities = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"a\\\" /* extractCapabilities */](sdpObject);\\n\\n            logger.debug('local capabilities:', this._localCapabilities);\\n\\n            // NOTE: We assume that the answer given by the app does not change\\n            // SSRC or PT values. If so, things won't work as expected.\\n        }\\n\\n        /**\\n         * Handles a local re-answer.\\n         * @return {Promise}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_handleLocalReAnswer',\\n        value: function _handleLocalReAnswer(desc) {\\n            logger.debug('_handleLocalReAnswer(), desc:', desc);\\n\\n            var sdpObject = desc.sdpObject;\\n\\n            // Update local capabilities as decided by the app.\\n            this._localCapabilities = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"a\\\" /* extractCapabilities */](sdpObject);\\n\\n            logger.debug('local capabilities:', this._localCapabilities);\\n\\n            // NOTE: We assume that the answer given by the app does not change\\n            // SSRC or PT values. If so, things won't work as expected.\\n        }\\n\\n        /**\\n         * Handles the remote initial offer.\\n         * @return {Promise}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_handleRemoteInitialOffer',\\n        value: function _handleRemoteInitialOffer(desc) {\\n            logger.debug('_handleRemoteInitialOffer(), desc:', desc);\\n\\n            var sdpObject = desc.sdpObject;\\n\\n            // Set MID values.\\n            this._mids = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"e\\\" /* extractMids */](sdpObject);\\n\\n            // Get remote RTP capabilities.\\n            var remoteCapabilities = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"a\\\" /* extractCapabilities */](sdpObject);\\n\\n            logger.debug('remote capabilities:', remoteCapabilities);\\n\\n            // Get local RTP capabilities (filter them with remote capabilities).\\n            this._localCapabilities = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"g\\\" /* getLocalCapabilities */](remoteCapabilities);\\n\\n            // Start ICE and DTLS.\\n            this._startIceAndDtls(desc);\\n        }\\n\\n        /**\\n         * Handles a remote re-offer.\\n         * @return {Promise}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_handleRemoteReOffer',\\n        value: function _handleRemoteReOffer(desc) {\\n            logger.debug('_handleRemoteReOffer(), desc:', desc);\\n\\n            var sdpObject = desc.sdpObject;\\n\\n            // Update MID values (just in case).\\n            this._mids = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"e\\\" /* extractMids */](sdpObject);\\n\\n            // Get remote RTP capabilities (filter them with remote capabilities).\\n            var remoteCapabilities = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"a\\\" /* extractCapabilities */](sdpObject);\\n\\n            logger.debug('remote capabilities:', remoteCapabilities);\\n\\n            // Update local RTP capabilities (just in case).\\n            this._localCapabilities = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"g\\\" /* getLocalCapabilities */](remoteCapabilities);\\n        }\\n\\n        /**\\n         * Start receiving remote media.\\n         */\\n\\n    }, {\\n        key: '_receiveMedia',\\n        value: function _receiveMedia() {\\n            logger.debug('_receiveMedia()');\\n\\n            var currentRemoteSsrcs = new Set(this._remoteTrackInfos.keys());\\n            var newRemoteTrackInfos = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"f\\\" /* extractTrackInfos */](this._remoteDescription.sdpObject);\\n\\n            // Map of new remote MediaStream indexed by MediaStream.jitsiRemoteId.\\n            var addedRemoteStreams = new Map();\\n\\n            // Map of remote MediaStream indexed by added MediaStreamTrack.\\n            // NOTE: Just filled for already existing streams.\\n            var addedRemoteTracks = new Map();\\n\\n            // Map of remote MediaStream indexed by removed MediaStreamTrack.\\n            var removedRemoteTracks = new Map();\\n\\n            logger.debug('_receiveMedia() remote track infos:', newRemoteTrackInfos);\\n\\n            // Check new tracks.\\n            var _iteratorNormalCompletion28 = true;\\n            var _didIteratorError28 = false;\\n            var _iteratorError28 = undefined;\\n\\n            try {\\n                for (var _iterator28 = newRemoteTrackInfos[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {\\n                    var _ref5 = _step28.value;\\n\\n                    var _ref6 = _slicedToArray(_ref5, 2);\\n\\n                    var ssrc = _ref6[0];\\n                    var info = _ref6[1];\\n\\n                    // If already handled, ignore it.\\n                    if (currentRemoteSsrcs.has(ssrc)) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    logger.debug('_receiveMedia() new remote track, ssrc:' + ssrc);\\n\\n                    // Otherwise append to the map.\\n                    this._remoteTrackInfos.set(ssrc, info);\\n\\n                    var kind = info.kind;\\n                    var rtxSsrc = info.rtxSsrc;\\n                    var streamRemoteId = info.streamId;\\n                    var trackRemoteId = info.trackId;\\n                    var cname = info.cname;\\n                    var isNewStream = !this._remoteStreams.has(streamRemoteId);\\n                    var stream = void 0;\\n\\n                    if (isNewStream) {\\n                        logger.debug('_receiveMedia() new remote stream, id:' + streamRemoteId);\\n\\n                        // Create a new MediaStream.\\n                        stream = new MediaStream();\\n\\n                        // Set custom property with the remote id.\\n                        stream.jitsiRemoteId = streamRemoteId;\\n\\n                        addedRemoteStreams.set(streamRemoteId, stream);\\n                        this._remoteStreams.set(streamRemoteId, stream);\\n                    } else {\\n                        stream = this._remoteStreams.get(streamRemoteId);\\n                    }\\n\\n                    var rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);\\n                    var parameters = this._getParametersForRtpReceiver(kind, {\\n                        ssrc: ssrc,\\n                        rtxSsrc: rtxSsrc,\\n                        cname: cname\\n                    });\\n\\n                    // Store the track into the info object.\\n                    // NOTE: This should not be needed, but Edge has a bug:\\n                    //   https://developer.microsoft.com/en-us/microsoft-edge/platform/\\n                    //   issues/12399497/\\n                    info.track = rtpReceiver.track;\\n\\n                    // Set error handler.\\n                    rtpReceiver.onerror = function (ev) {\\n                        logger.error('rtpReceiver \\\"error\\\" event, event:');\\n                        logger.error(ev);\\n                    };\\n\\n                    // Fill the info with the stream and rtpReceiver.\\n                    info.stream = stream;\\n                    info.rtpReceiver = rtpReceiver;\\n\\n                    logger.debug('calling rtpReceiver.receive(), parameters:', parameters);\\n\\n                    // Start receiving media.\\n                    try {\\n                        rtpReceiver.receive(parameters);\\n\\n                        // Get the associated MediaStreamTrack.\\n                        var _track3 = info.track;\\n\\n                        // Set custom property with the remote id.\\n                        _track3.jitsiRemoteId = trackRemoteId;\\n\\n                        // Add the track to the stream.\\n                        stream.addTrack(_track3);\\n\\n                        if (!addedRemoteStreams.has(streamRemoteId)) {\\n                            addedRemoteTracks.set(_track3, stream);\\n                        }\\n                    } catch (error) {\\n                        logger.error('rtpReceiver.receive() failed:' + error.message);\\n                        logger.error(error);\\n                    }\\n                }\\n\\n                // Check track removal.\\n            } catch (err) {\\n                _didIteratorError28 = true;\\n                _iteratorError28 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion28 && _iterator28.return) {\\n                        _iterator28.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError28) {\\n                        throw _iteratorError28;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion29 = true;\\n            var _didIteratorError29 = false;\\n            var _iteratorError29 = undefined;\\n\\n            try {\\n                for (var _iterator29 = currentRemoteSsrcs[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {\\n                    var _ssrc = _step29.value;\\n\\n                    if (newRemoteTrackInfos.has(_ssrc)) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    logger.debug('_receiveMedia() remote track removed, ssrc:' + _ssrc);\\n\\n                    var _info3 = this._remoteTrackInfos.get(_ssrc);\\n                    var stream = _info3.stream;\\n                    var track = _info3.track;\\n                    var rtpReceiver = _info3.rtpReceiver;\\n\\n                    try {\\n                        rtpReceiver.stop();\\n                    } catch (error) {\\n                        logger.warn('rtpReceiver.stop() failed:' + error);\\n                    }\\n\\n                    removedRemoteTracks.set(track, stream);\\n                    stream.removeTrack(track);\\n                    this._remoteTrackInfos.delete(_ssrc);\\n                }\\n\\n                // Emit MediaStream 'addtrack' for new tracks in already existing\\n                // streams.\\n            } catch (err) {\\n                _didIteratorError29 = true;\\n                _iteratorError29 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion29 && _iterator29.return) {\\n                        _iterator29.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError29) {\\n                        throw _iteratorError29;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion30 = true;\\n            var _didIteratorError30 = false;\\n            var _iteratorError30 = undefined;\\n\\n            try {\\n                for (var _iterator30 = addedRemoteTracks[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {\\n                    var _ref7 = _step30.value;\\n\\n                    var _ref8 = _slicedToArray(_ref7, 2);\\n\\n                    var track = _ref8[0];\\n                    var stream = _ref8[1];\\n\\n                    var event = new Event('addtrack');\\n\\n                    event.track = track;\\n                    stream.dispatchEvent(event);\\n                }\\n\\n                // Emit MediaStream 'removetrack' for removed tracks.\\n            } catch (err) {\\n                _didIteratorError30 = true;\\n                _iteratorError30 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion30 && _iterator30.return) {\\n                        _iterator30.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError30) {\\n                        throw _iteratorError30;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion31 = true;\\n            var _didIteratorError31 = false;\\n            var _iteratorError31 = undefined;\\n\\n            try {\\n                for (var _iterator31 = removedRemoteTracks[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {\\n                    var _ref9 = _step31.value;\\n\\n                    var _ref10 = _slicedToArray(_ref9, 2);\\n\\n                    var _track2 = _ref10[0];\\n                    var _stream = _ref10[1];\\n\\n                    var event = new Event('removetrack');\\n\\n                    event.track = _track2;\\n                    _stream.dispatchEvent(event);\\n                }\\n\\n                // Emit RTCPeerConnection 'addstream' for new remote streams.\\n            } catch (err) {\\n                _didIteratorError31 = true;\\n                _iteratorError31 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion31 && _iterator31.return) {\\n                        _iterator31.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError31) {\\n                        throw _iteratorError31;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion32 = true;\\n            var _didIteratorError32 = false;\\n            var _iteratorError32 = undefined;\\n\\n            try {\\n                for (var _iterator32 = addedRemoteStreams.values()[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {\\n                    var _stream2 = _step32.value;\\n\\n                    // Check whether at least a track was added, otherwise ignore it.\\n                    if (_stream2.getTracks().length === 0) {\\n                        logger.warn('ignoring new stream for which no track could be added');\\n\\n                        addedRemoteStreams.delete(_stream2.jitsiRemoteId);\\n                        this._remoteStreams.delete(_stream2.jitsiRemoteId);\\n                    } else {\\n                        this._emitAddStream(_stream2);\\n                    }\\n                }\\n\\n                // Emit RTCPeerConnection 'removestream' for removed remote streams.\\n            } catch (err) {\\n                _didIteratorError32 = true;\\n                _iteratorError32 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion32 && _iterator32.return) {\\n                        _iterator32.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError32) {\\n                        throw _iteratorError32;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion33 = true;\\n            var _didIteratorError33 = false;\\n            var _iteratorError33 = undefined;\\n\\n            try {\\n                for (var _iterator33 = this._remoteStreams[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {\\n                    var _ref11 = _step33.value;\\n\\n                    var _ref12 = _slicedToArray(_ref11, 2);\\n\\n                    var streamRemoteId = _ref12[0];\\n                    var _stream3 = _ref12[1];\\n\\n                    if (_stream3.getTracks().length > 0) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    this._remoteStreams.delete(streamRemoteId);\\n                    this._emitRemoveStream(_stream3);\\n                }\\n            } catch (err) {\\n                _didIteratorError33 = true;\\n                _iteratorError33 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion33 && _iterator33.return) {\\n                        _iterator33.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError33) {\\n                        throw _iteratorError33;\\n                    }\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Implementation for removeStream().\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_removeStream',\\n        value: function _removeStream(stream) {\\n            if (this._closed) {\\n                throw new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('RTCPeerConnection closed');\\n            }\\n\\n            // Stop and remove the RTCRtpSender associated to each track.\\n            var _iteratorNormalCompletion34 = true;\\n            var _didIteratorError34 = false;\\n            var _iteratorError34 = undefined;\\n\\n            try {\\n                for (var _iterator34 = stream.getTracks()[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {\\n                    var track = _step34.value;\\n\\n                    // Ignore if track not present.\\n                    if (!this._localTrackInfos.has(track.id)) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    var rtpSender = this._localTrackInfos.get(track.id).rtpSender;\\n\\n                    try {\\n                        rtpSender.stop();\\n                    } catch (error) {\\n                        logger.warn('rtpSender.stop() failed:' + error);\\n                    }\\n\\n                    // Remove from the map.\\n                    this._localTrackInfos.delete(track.id);\\n                }\\n\\n                // It may need to renegotiate.\\n            } catch (err) {\\n                _didIteratorError34 = true;\\n                _iteratorError34 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion34 && _iterator34.return) {\\n                        _iterator34.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError34) {\\n                        throw _iteratorError34;\\n                    }\\n                }\\n            }\\n\\n            this._emitNegotiationNeeded();\\n        }\\n\\n        /**\\n         * Start sending our media to the remote.\\n         */\\n\\n    }, {\\n        key: '_sendMedia',\\n        value: function _sendMedia() {\\n            logger.debug('_sendMedia()');\\n\\n            var _iteratorNormalCompletion35 = true;\\n            var _didIteratorError35 = false;\\n            var _iteratorError35 = undefined;\\n\\n            try {\\n                for (var _iterator35 = this._localTrackInfos.values()[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {\\n                    var info = _step35.value;\\n\\n                    // Ignore if already sending.\\n                    if (info.sending) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    var rtpSender = info.rtpSender;\\n                    var ssrc = info.ssrc;\\n                    var rtxSsrc = info.rtxSsrc;\\n                    var track = rtpSender.track;\\n                    var kind = track.kind;\\n\\n                    var parameters = this._getParametersForRtpSender(kind, {\\n                        ssrc: ssrc,\\n                        rtxSsrc: rtxSsrc\\n                    });\\n\\n                    logger.debug('calling rtpSender.send(), parameters:', parameters);\\n\\n                    // Start sending media.\\n                    try {\\n                        rtpSender.send(parameters);\\n\\n                        // Update sending field.\\n                        info.sending = true;\\n                    } catch (error) {\\n                        logger.error('rtpSender.send() failed:' + error.message);\\n                        logger.error(error);\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError35 = true;\\n                _iteratorError35 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion35 && _iterator35.return) {\\n                        _iterator35.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError35) {\\n                        throw _iteratorError35;\\n                    }\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Creates the RTCDtlsTransport.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_setDtlsTransport',\\n        value: function _setDtlsTransport(iceTransport) {\\n            var _this2 = this;\\n\\n            var dtlsTransport = new RTCDtlsTransport(iceTransport);\\n\\n            // NOTE: Not yet implemented by Edge.\\n            dtlsTransport.onstatechange = function () {\\n                logger.debug('dtlsTransport \\\"statechange\\\" event, ' + ('state:' + dtlsTransport.state));\\n\\n                _this2._emitConnectionStateChange();\\n            };\\n\\n            // NOTE: Not standard, but implemented by Edge.\\n            dtlsTransport.ondtlsstatechange = function () {\\n                logger.debug('dtlsTransport \\\"dtlsstatechange\\\" event, ' + ('state:' + dtlsTransport.state));\\n\\n                _this2._emitConnectionStateChange();\\n            };\\n\\n            dtlsTransport.onerror = function (ev) {\\n                var message = void 0;\\n\\n                if (ev.message) {\\n                    message = ev.message;\\n                } else if (ev.error) {\\n                    message = ev.error.message;\\n                }\\n\\n                logger.error('dtlsTransport \\\"error\\\" event, message:' + message);\\n\\n                // TODO: Edge does not set state to 'failed' on error. We may\\n                // hack it.\\n\\n                _this2._emitConnectionStateChange();\\n            };\\n\\n            this._dtlsTransport = dtlsTransport;\\n        }\\n\\n        /**\\n         * Creates the RTCIceGatherer.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_setIceGatherer',\\n        value: function _setIceGatherer(pcConfig) {\\n            var _this3 = this;\\n\\n            var iceGatherOptions = {\\n                gatherPolicy: pcConfig.iceTransportPolicy || 'all',\\n                iceServers: pcConfig.iceServers || []\\n            };\\n            var iceGatherer = new RTCIceGatherer(iceGatherOptions);\\n\\n            // NOTE: Not yet implemented by Edge.\\n            iceGatherer.onstatechange = function () {\\n                logger.debug('iceGatherer \\\"statechange\\\" event, state:' + iceGatherer.state);\\n\\n                _this3._updateAndEmitIceGatheringStateChange(iceGatherer.state);\\n            };\\n\\n            iceGatherer.onlocalcandidate = function (ev) {\\n                var candidate = ev.candidate;\\n\\n                // NOTE: Not yet implemented by Edge.\\n                var complete = ev.complete;\\n\\n                logger.debug('iceGatherer \\\"localcandidate\\\" event, candidate:', candidate);\\n\\n                // NOTE: Instead of null candidate or complete:true, current Edge\\n                // signals end of gathering with an empty candidate object.\\n                if (complete || !candidate || Object.keys(candidate).length === 0) {\\n\\n                    candidate = null;\\n\\n                    _this3._updateAndEmitIceGatheringStateChange(RTCIceGatheringState.complete);\\n                    _this3._emitIceCandidate(null);\\n                } else {\\n                    _this3._emitIceCandidate(candidate);\\n                }\\n            };\\n\\n            iceGatherer.onerror = function (ev) {\\n                var errorCode = ev.errorCode;\\n                var errorText = ev.errorText;\\n\\n                logger.error('iceGatherer \\\"error\\\" event, errorCode:' + errorCode + ', ' + ('errorText:' + errorText));\\n            };\\n\\n            // NOTE: Not yet implemented by Edge, which starts gathering\\n            // automatically.\\n            try {\\n                iceGatherer.gather();\\n            } catch (error) {\\n                logger.warn('iceGatherer.gather() failed:' + error);\\n            }\\n\\n            this._iceGatherer = iceGatherer;\\n        }\\n\\n        /**\\n         * Creates the RTCIceTransport.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_setIceTransport',\\n        value: function _setIceTransport(iceGatherer) {\\n            var _this4 = this;\\n\\n            var iceTransport = new RTCIceTransport(iceGatherer);\\n\\n            // NOTE: Not yet implemented by Edge.\\n            iceTransport.onstatechange = function () {\\n                logger.debug('iceTransport \\\"statechange\\\" event, ' + ('state:' + iceTransport.state));\\n\\n                _this4._emitIceConnectionStateChange();\\n            };\\n\\n            // NOTE: Not standard, but implemented by Edge.\\n            iceTransport.onicestatechange = function () {\\n                logger.debug('iceTransport \\\"icestatechange\\\" event, ' + ('state:' + iceTransport.state));\\n\\n                if (iceTransport.state === 'completed') {\\n                    logger.debug('nominated candidate pair:', iceTransport.getNominatedCandidatePair());\\n                }\\n\\n                _this4._emitIceConnectionStateChange();\\n            };\\n\\n            iceTransport.oncandidatepairchange = function (ev) {\\n                logger.debug('iceTransport \\\"candidatepairchange\\\" event, ' + ('pair:' + ev.pair));\\n            };\\n\\n            this._iceTransport = iceTransport;\\n        }\\n\\n        /**\\n         * Promise based implementation for setLocalDescription().\\n         * @returns {Promise}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_setLocalDescription',\\n        value: function _setLocalDescription(desc) {\\n            var _this5 = this;\\n\\n            if (this._closed) {\\n                return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('RTCPeerConnection closed'));\\n            }\\n\\n            var localDescription = void 0;\\n\\n            try {\\n                localDescription = new __WEBPACK_IMPORTED_MODULE_2__RTCSessionDescription__[\\\"a\\\" /* default */](desc);\\n            } catch (error) {\\n                return Promise.reject(new TypeError('invalid RTCSessionDescriptionInit: ' + error));\\n            }\\n\\n            switch (desc.type) {\\n                case 'offer':\\n                    {\\n                        if (this.signalingState !== RTCSignalingState.stable) {\\n                            return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('invalid signalingState \\\"' + this.signalingState + '\\\"'));\\n                        }\\n\\n                        // NOTE: P2P mode not yet supported, so createOffer() should never\\n                        // has been called, neither setLocalDescription() with an offer.\\n                        return Promise.reject(new TypeError('setLocalDescription() with type \\\"offer\\\" not supported'));\\n                    }\\n                case 'answer':\\n                    {\\n                        if (this.signalingState !== RTCSignalingState.haveRemoteOffer) {\\n                            return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('invalid signalingState \\\"' + this.signalingState + '\\\"'));\\n                        }\\n\\n                        var isLocalInitialAnswer = Boolean(!this._localDescription);\\n\\n                        return Promise.resolve().then(function () {\\n                            // Different handling for initial answer and re-answer.\\n                            if (isLocalInitialAnswer) {\\n                                return _this5._handleLocalInitialAnswer(localDescription);\\n                            } else {\\n                                // eslint-disable-line no-else-return\\n                                return _this5._handleLocalReAnswer(localDescription);\\n                            }\\n                        }).then(function () {\\n                            logger.debug('setLocalDescription() succeed');\\n\\n                            // Update local description.\\n                            _this5._localDescription = localDescription;\\n\\n                            // Update signaling state.\\n                            _this5._updateAndEmitSignalingStateChange(RTCSignalingState.stable);\\n\\n                            // If initial answer, emit buffered ICE candidates.\\n                            if (isLocalInitialAnswer) {\\n                                _this5._emitBufferedIceCandidates();\\n                            }\\n\\n                            // Send our RTP.\\n                            _this5._sendMedia();\\n\\n                            // Receive remote RTP.\\n                            _this5._receiveMedia();\\n                        }).catch(function (error) {\\n                            logger.error('setLocalDescription() failed: ' + error.message);\\n                            logger.error(error);\\n\\n                            throw error;\\n                        });\\n                    }\\n                default:\\n                    return Promise.reject(new TypeError('unsupported description.type \\\"' + desc.type + '\\\"'));\\n            }\\n        }\\n\\n        /**\\n         * Promise based implementation for setRemoteDescription().\\n         * @returns {Promise}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_setRemoteDescription',\\n        value: function _setRemoteDescription(desc) {\\n            var _this6 = this;\\n\\n            if (this._closed) {\\n                return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('RTCPeerConnection closed'));\\n            }\\n\\n            var remoteDescription = void 0;\\n\\n            try {\\n                remoteDescription = new __WEBPACK_IMPORTED_MODULE_2__RTCSessionDescription__[\\\"a\\\" /* default */](desc);\\n            } catch (error) {\\n                return Promise.reject(new TypeError('invalid RTCSessionDescriptionInit: ' + error));\\n            }\\n\\n            switch (desc.type) {\\n                case 'offer':\\n                    {\\n                        if (this.signalingState !== RTCSignalingState.stable) {\\n                            return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('invalid signalingState \\\"' + this.signalingState + '\\\"'));\\n                        }\\n\\n                        var isRemoteInitialOffer = Boolean(!this._remoteDescription);\\n\\n                        return Promise.resolve().then(function () {\\n                            // Different handling for initial answer and re-answer.\\n                            if (isRemoteInitialOffer) {\\n                                return _this6._handleRemoteInitialOffer(remoteDescription);\\n                            } else {\\n                                // eslint-disable-line no-else-return\\n                                return _this6._handleRemoteReOffer(remoteDescription);\\n                            }\\n                        }).then(function () {\\n                            logger.debug('setRemoteDescription() succeed');\\n\\n                            // Update remote description.\\n                            _this6._remoteDescription = remoteDescription;\\n\\n                            // Update signaling state.\\n                            _this6._updateAndEmitSignalingStateChange(RTCSignalingState.haveRemoteOffer);\\n                        }).catch(function (error) {\\n                            logger.error('setRemoteDescription() failed: ' + error);\\n\\n                            throw error;\\n                        });\\n                    }\\n                case 'answer':\\n                    {\\n                        if (this.signalingState !== RTCSignalingState.haveLocalOffer) {\\n                            return Promise.reject(new __WEBPACK_IMPORTED_MODULE_4__errors__[\\\"a\\\" /* InvalidStateError */]('invalid signalingState \\\"' + this.signalingState + '\\\"'));\\n                        }\\n\\n                        // NOTE: P2P mode not yet supported, so createOffer() should never\\n                        // has been called, neither setRemoteDescription() with an answer.\\n                        return Promise.reject(new TypeError('setRemoteDescription() with type \\\"answer\\\" not supported'));\\n                    }\\n                default:\\n                    return Promise.reject(new TypeError('unsupported description.type \\\"' + desc.type + '\\\"'));\\n            }\\n        }\\n\\n        /**\\n         * Start ICE and DTLS connection procedures.\\n         * @param {RTCSessionDescription} desc - Remote description.\\n         */\\n\\n    }, {\\n        key: '_startIceAndDtls',\\n        value: function _startIceAndDtls(desc) {\\n            var sdpObject = desc.sdpObject;\\n            var remoteIceParameters = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"d\\\" /* extractIceParameters */](sdpObject);\\n            var remoteIceCandidates = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"c\\\" /* extractIceCandidates */](sdpObject);\\n            var remoteDtlsParameters = __WEBPACK_IMPORTED_MODULE_3__utils__[\\\"b\\\" /* extractDtlsParameters */](sdpObject);\\n\\n            // Start the RTCIceTransport.\\n            switch (desc.type) {\\n                case 'offer':\\n                    this._iceTransport.start(this._iceGatherer, remoteIceParameters, 'controlled');\\n                    break;\\n                case 'answer':\\n                    this._iceTransport.start(this._iceGatherer, remoteIceParameters, 'controlling');\\n                    break;\\n            }\\n\\n            // Add remote ICE candidates.\\n            // NOTE: Remove candidates that Edge doesn't like.\\n            var _iteratorNormalCompletion36 = true;\\n            var _didIteratorError36 = false;\\n            var _iteratorError36 = undefined;\\n\\n            try {\\n                for (var _iterator36 = remoteIceCandidates[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {\\n                    var candidate = _step36.value;\\n\\n                    if (candidate.port === 0 || candidate.port === 9) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    this._iceTransport.addRemoteCandidate(candidate);\\n                }\\n\\n                // Also signal a 'complete' candidate as per spec.\\n                // NOTE: It should be {complete: true} but Edge prefers {}.\\n                // NOTE: We know that addCandidate() is never used so we need to signal\\n                // end of candidates (otherwise the RTCIceTransport never enters the\\n                // 'completed' state).\\n            } catch (err) {\\n                _didIteratorError36 = true;\\n                _iteratorError36 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion36 && _iterator36.return) {\\n                        _iterator36.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError36) {\\n                        throw _iteratorError36;\\n                    }\\n                }\\n            }\\n\\n            this._iceTransport.addRemoteCandidate({});\\n\\n            // Set desired remote DTLS role (as we receive the offer).\\n            switch (desc.type) {\\n                case 'offer':\\n                    remoteDtlsParameters.role = 'server';\\n                    break;\\n                case 'answer':\\n                    remoteDtlsParameters.role = 'client';\\n                    break;\\n            }\\n\\n            // Start RTCDtlsTransport.\\n            this._dtlsTransport.start(remoteDtlsParameters);\\n        }\\n\\n        /**\\n         * May update iceGatheringState and emit 'icegatheringstatechange' event.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_updateAndEmitIceGatheringStateChange',\\n        value: function _updateAndEmitIceGatheringStateChange(state) {\\n            if (this._closed || state === this.iceGatheringState) {\\n                return;\\n            }\\n\\n            this._iceGatheringState = state;\\n\\n            logger.debug('emitting \\\"icegatheringstatechange\\\", iceGatheringState:', this.iceGatheringState);\\n\\n            var event = new __WEBPACK_IMPORTED_MODULE_1_yaeti___default.a.Event('icegatheringstatechange');\\n\\n            this.dispatchEvent(event);\\n        }\\n\\n        /**\\n         * May update signalingState and emit 'signalingstatechange' event.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_updateAndEmitSignalingStateChange',\\n        value: function _updateAndEmitSignalingStateChange(state) {\\n            if (state === this.signalingState) {\\n                return;\\n            }\\n\\n            this._signalingState = state;\\n\\n            logger.debug('emitting \\\"signalingstatechange\\\", signalingState:', this.signalingState);\\n\\n            var event = new __WEBPACK_IMPORTED_MODULE_1_yaeti___default.a.Event('signalingstatechange');\\n\\n            this.dispatchEvent(event);\\n        }\\n    }, {\\n        key: 'connectionState',\\n        get: function get() {\\n            return this._dtlsTransport.state;\\n        }\\n\\n        /**\\n         * Current ICE connection state.\\n         * @return {RTCIceConnectionState}\\n         */\\n\\n    }, {\\n        key: 'iceConnectionState',\\n        get: function get() {\\n            return this._iceTransport.state;\\n        }\\n\\n        /**\\n         * Current ICE gathering state.\\n         * @return {RTCIceGatheringState}\\n         */\\n\\n    }, {\\n        key: 'iceGatheringState',\\n        get: function get() {\\n            return this._iceGatheringState;\\n        }\\n\\n        /**\\n         * Gets the local description.\\n         * @return {RTCSessionDescription}\\n         */\\n\\n    }, {\\n        key: 'localDescription',\\n        get: function get() {\\n            return this._localDescription;\\n        }\\n\\n        /**\\n         * Gets the remote description.\\n         * @return {RTCSessionDescription}\\n         */\\n\\n    }, {\\n        key: 'remoteDescription',\\n        get: function get() {\\n            return this._remoteDescription;\\n        }\\n\\n        /**\\n         * Current signaling state.\\n         * @return {RTCSignalingState}\\n         */\\n\\n    }, {\\n        key: 'signalingState',\\n        get: function get() {\\n            return this._signalingState;\\n        }\\n    }]);\\n\\n    return ortcRTCPeerConnection;\\n}(__WEBPACK_IMPORTED_MODULE_1_yaeti___default.a.EventTarget);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (ortcRTCPeerConnection);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/ortc/RTCPeerConnection.js\\\"))\\n\\n/***/ }),\\n/* 122 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nmodule.exports =\\n{\\n\\tEventTarget : __webpack_require__(123),\\n\\tEvent       : __webpack_require__(124)\\n};\\n\\n\\n/***/ }),\\n/* 123 */\\n/***/ (function(module, exports) {\\n\\nfunction yaetiEventTarget()\\n{\\n\\tthis._listeners = {};\\n}\\n\\nObject.defineProperties(yaetiEventTarget.prototype,\\n\\t{\\n\\t\\tlisteners:\\n\\t\\t{\\n\\t\\t\\tget: function()\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn this._listeners;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n\\nyaetiEventTarget.prototype.addEventListener = function(type, newListener)\\n{\\n\\tvar listenersType;\\n\\tvar i;\\n\\tvar listener;\\n\\n\\tif (!type || !newListener)\\n\\t\\treturn;\\n\\n\\tlistenersType = this._listeners[type];\\n\\n\\tif (listenersType === undefined)\\n\\t\\tthis._listeners[type] = listenersType = [];\\n\\n\\tfor (i = 0; !!(listener = listenersType[i]); i++)\\n\\t{\\n\\t\\tif (listener === newListener)\\n\\t\\t\\treturn;\\n\\t}\\n\\n\\tlistenersType.push(newListener);\\n};\\n\\nyaetiEventTarget.prototype.removeEventListener = function(type, oldListener)\\n{\\n\\tvar listenersType;\\n\\tvar i;\\n\\tvar listener;\\n\\n\\tif (!type || !oldListener)\\n\\t\\treturn;\\n\\n\\tlistenersType = this._listeners[type];\\n\\n\\tif (listenersType === undefined)\\n\\t\\treturn;\\n\\n\\tfor (i = 0; !!(listener = listenersType[i]); i++)\\n\\t{\\n\\t\\tif (listener === oldListener)\\n\\t\\t{\\n\\t\\t\\tlistenersType.splice(i, 1);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tif (listenersType.length === 0)\\n\\t\\tdelete this._listeners[type];\\n};\\n\\nyaetiEventTarget.prototype.dispatchEvent = function(event)\\n{\\n\\tvar type;\\n\\tvar listenersType;\\n\\tvar dummyListener;\\n\\tvar stopImmediatePropagation = false;\\n\\tvar i;\\n\\tvar listener;\\n\\n\\tif (!event || typeof event.type !== 'string')\\n\\t\\tthrow new Error('`event` must have a valid `type` property');\\n\\n\\t// Do some stuff to emulate DOM Event behavior (just if this is not a\\n\\t// DOM Event object).\\n\\tif (event._yaeti)\\n\\t{\\n\\t\\tevent.target = this;\\n\\t\\tevent.cancelable = true;\\n\\t}\\n\\n\\t// Attempt to override the stopImmediatePropagation() method.\\n\\ttry\\n\\t{\\n\\t\\tevent.stopImmediatePropagation = function()\\n\\t\\t{\\n\\t\\t\\tstopImmediatePropagation = true;\\n\\t\\t};\\n\\t}\\n\\tcatch (error)\\n\\t{}\\n\\n\\ttype = event.type;\\n\\tlistenersType = (this._listeners[type] || []);\\n\\n\\tdummyListener = this['on' + type];\\n\\n\\tif (typeof dummyListener === 'function')\\n\\t{\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tdummyListener.call(this, event);\\n\\t\\t}\\n\\t\\tcatch (error)\\n\\t\\t{\\n\\t\\t\\tconsole.error(error);\\n\\t\\t}\\n\\t}\\n\\n\\tfor (i = 0; !!(listener = listenersType[i]); i++)\\n\\t{\\n\\t\\tif (stopImmediatePropagation)\\n\\t\\t\\tbreak;\\n\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tlistener.call(this, event);\\n\\t\\t}\\n\\t\\tcatch (error)\\n\\t\\t{\\n\\t\\t\\tconsole.error(error);\\n\\t\\t}\\n\\t}\\n\\n\\treturn !event.defaultPrevented;\\n};\\n\\nmodule.exports = yaetiEventTarget;\\n\\n\\n/***/ }),\\n/* 124 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* WEBPACK VAR INJECTION */(function(global) {/**\\n * In browsers export the native Event interface.\\n */\\n\\nmodule.exports = global.Event;\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\\n\\n/***/ }),\\n/* 125 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sdp_transform__ = __webpack_require__(15);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sdp_transform___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_sdp_transform__);\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n/**\\n * RTCSessionDescription implementation.\\n */\\n\\nvar RTCSessionDescription = function () {\\n    /**\\n     * RTCSessionDescription constructor.\\n     * @param {Object} [data]\\n     * @param {String} [data.type] - 'offer' / 'answer'.\\n     * @param {String} [data.sdp] - SDP string.\\n     * @param {Object} [data._sdpObject] - SDP object generated by the\\n     * sdp-transform library.\\n     */\\n    function RTCSessionDescription(data) {\\n        _classCallCheck(this, RTCSessionDescription);\\n\\n        // @type {String}\\n        this._sdp = null;\\n\\n        // @type {Object}\\n        this._sdpObject = null;\\n\\n        // @type {String}\\n        this._type = null;\\n\\n        switch (data.type) {\\n            case 'offer':\\n                break;\\n            case 'answer':\\n                break;\\n            default:\\n                throw new TypeError('invalid type \\\"' + data.type + '\\\"');\\n        }\\n\\n        this._type = data.type;\\n\\n        if (typeof data.sdp === 'string') {\\n            this._sdp = data.sdp;\\n            try {\\n                this._sdpObject = __WEBPACK_IMPORTED_MODULE_0_sdp_transform___default.a.parse(data.sdp);\\n            } catch (error) {\\n                throw new Error('invalid sdp: ' + error);\\n            }\\n        } else if (_typeof(data._sdpObject) === 'object') {\\n            this._sdpObject = data._sdpObject;\\n            try {\\n                this._sdp = __WEBPACK_IMPORTED_MODULE_0_sdp_transform___default.a.write(data._sdpObject);\\n            } catch (error) {\\n                throw new Error('invalid sdp object: ' + error);\\n            }\\n        } else {\\n            throw new TypeError('invalid sdp or _sdpObject');\\n        }\\n    }\\n\\n    /**\\n     * Get sdp field.\\n     * @return {String}\\n     */\\n\\n\\n    _createClass(RTCSessionDescription, [{\\n        key: 'toJSON',\\n\\n\\n        /**\\n         * Returns an object with type and sdp fields.\\n         * @return {Object}\\n         */\\n        value: function toJSON() {\\n            return {\\n                sdp: this._sdp,\\n                type: this._type\\n            };\\n        }\\n    }, {\\n        key: 'sdp',\\n        get: function get() {\\n            return this._sdp;\\n        }\\n\\n        /**\\n         * Set sdp field.\\n         * NOTE: This is not allowed per spec, but lib-jitsi-meet uses it.\\n         * @param {String} sdp\\n         */\\n        ,\\n        set: function set(sdp) {\\n            try {\\n                this._sdpObject = __WEBPACK_IMPORTED_MODULE_0_sdp_transform___default.a.parse(sdp);\\n            } catch (error) {\\n                throw new Error('invalid sdp: ' + error);\\n            }\\n\\n            this._sdp = sdp;\\n        }\\n\\n        /**\\n         * Gets the internal sdp object.\\n         * @return {Object}\\n         * @private\\n         */\\n\\n    }, {\\n        key: 'sdpObject',\\n        get: function get() {\\n            return this._sdpObject;\\n        }\\n\\n        /**\\n         * Get type field.\\n         * @return {String}\\n         */\\n\\n    }, {\\n        key: 'type',\\n        get: function get() {\\n            return this._type;\\n        }\\n    }]);\\n\\n    return RTCSessionDescription;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (RTCSessionDescription);\\n\\n/***/ }),\\n/* 126 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar toIntIfInt = function (v) {\\n  return String(Number(v)) === v ? Number(v) : v;\\n};\\n\\nvar attachProperties = function (match, location, names, rawName) {\\n  if (rawName && !names) {\\n    location[rawName] = toIntIfInt(match[1]);\\n  }\\n  else {\\n    for (var i = 0; i < names.length; i += 1) {\\n      if (match[i+1] != null) {\\n        location[names[i]] = toIntIfInt(match[i+1]);\\n      }\\n    }\\n  }\\n};\\n\\nvar parseReg = function (obj, location, content) {\\n  var needsBlank = obj.name && obj.names;\\n  if (obj.push && !location[obj.push]) {\\n    location[obj.push] = [];\\n  }\\n  else if (needsBlank && !location[obj.name]) {\\n    location[obj.name] = {};\\n  }\\n  var keyLocation = obj.push ?\\n    {} :  // blank object that will be pushed\\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\\n\\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\\n\\n  if (obj.push) {\\n    location[obj.push].push(keyLocation);\\n  }\\n};\\n\\nvar grammar = __webpack_require__(56);\\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\\n\\nexports.parse = function (sdp) {\\n  var session = {}\\n    , media = []\\n    , location = session; // points at where properties go under (one of the above)\\n\\n  // parse lines we understand\\n  sdp.split(/(\\\\r\\\\n|\\\\r|\\\\n)/).filter(validLine).forEach(function (l) {\\n    var type = l[0];\\n    var content = l.slice(2);\\n    if (type === 'm') {\\n      media.push({rtp: [], fmtp: []});\\n      location = media[media.length-1]; // point at latest media line\\n    }\\n\\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\\n      var obj = grammar[type][j];\\n      if (obj.reg.test(content)) {\\n        return parseReg(obj, location, content);\\n      }\\n    }\\n  });\\n\\n  session.media = media; // link it up\\n  return session;\\n};\\n\\nvar paramReducer = function (acc, expr) {\\n  var s = expr.split(/=(.+)/, 2);\\n  if (s.length === 2) {\\n    acc[s[0]] = toIntIfInt(s[1]);\\n  }\\n  return acc;\\n};\\n\\nexports.parseParams = function (str) {\\n  return str.split(/\\\\;\\\\s?/).reduce(paramReducer, {});\\n};\\n\\n// For backward compatibility - alias will be removed in 3.0.0\\nexports.parseFmtpConfig = exports.parseParams;\\n\\nexports.parsePayloads = function (str) {\\n  return str.split(' ').map(Number);\\n};\\n\\nexports.parseRemoteCandidates = function (str) {\\n  var candidates = [];\\n  var parts = str.split(' ').map(toIntIfInt);\\n  for (var i = 0; i < parts.length; i += 3) {\\n    candidates.push({\\n      component: parts[i],\\n      ip: parts[i + 1],\\n      port: parts[i + 2]\\n    });\\n  }\\n  return candidates;\\n};\\n\\nexports.parseImageAttributes = function (str) {\\n  return str.split(' ').map(function (item) {\\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\\n  });\\n};\\n\\nexports.parseSimulcastStreamList = function (str) {\\n  return str.split(';').map(function (stream) {\\n    return stream.split(',').map(function (format) {\\n      var scid, paused = false;\\n\\n      if (format[0] !== '~') {\\n        scid = toIntIfInt(format);\\n      } else {\\n        scid = toIntIfInt(format.substring(1, format.length));\\n        paused = true;\\n      }\\n\\n      return {\\n        scid: scid,\\n        paused: paused\\n      };\\n    });\\n  });\\n};\\n\\n\\n/***/ }),\\n/* 127 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar grammar = __webpack_require__(56);\\n\\n// customized util.format - discards excess arguments and can void middle ones\\nvar formatRegExp = /%[sdv%]/g;\\nvar format = function (formatStr) {\\n  var i = 1;\\n  var args = arguments;\\n  var len = args.length;\\n  return formatStr.replace(formatRegExp, function (x) {\\n    if (i >= len) {\\n      return x; // missing argument\\n    }\\n    var arg = args[i];\\n    i += 1;\\n    switch (x) {\\n    case '%%':\\n      return '%';\\n    case '%s':\\n      return String(arg);\\n    case '%d':\\n      return Number(arg);\\n    case '%v':\\n      return '';\\n    }\\n  });\\n  // NB: we discard excess arguments - they are typically undefined from makeLine\\n};\\n\\nvar makeLine = function (type, obj, location) {\\n  var str = obj.format instanceof Function ?\\n    (obj.format(obj.push ? location : location[obj.name])) :\\n    obj.format;\\n\\n  var args = [type + '=' + str];\\n  if (obj.names) {\\n    for (var i = 0; i < obj.names.length; i += 1) {\\n      var n = obj.names[i];\\n      if (obj.name) {\\n        args.push(location[obj.name][n]);\\n      }\\n      else { // for mLine and push attributes\\n        args.push(location[obj.names[i]]);\\n      }\\n    }\\n  }\\n  else {\\n    args.push(location[obj.name]);\\n  }\\n  return format.apply(null, args);\\n};\\n\\n// RFC specified order\\n// TODO: extend this with all the rest\\nvar defaultOuterOrder = [\\n  'v', 'o', 's', 'i',\\n  'u', 'e', 'p', 'c',\\n  'b', 't', 'r', 'z', 'a'\\n];\\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\\n\\n\\nmodule.exports = function (session, opts) {\\n  opts = opts || {};\\n  // ensure certain properties exist\\n  if (session.version == null) {\\n    session.version = 0; // 'v=0' must be there (only defined version atm)\\n  }\\n  if (session.name == null) {\\n    session.name = ' '; // 's= ' must be there if no meaningful name set\\n  }\\n  session.media.forEach(function (mLine) {\\n    if (mLine.payloads == null) {\\n      mLine.payloads = '';\\n    }\\n  });\\n\\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\\n  var sdp = [];\\n\\n  // loop through outerOrder for matching properties on session\\n  outerOrder.forEach(function (type) {\\n    grammar[type].forEach(function (obj) {\\n      if (obj.name in session && session[obj.name] != null) {\\n        sdp.push(makeLine(type, obj, session));\\n      }\\n      else if (obj.push in session && session[obj.push] != null) {\\n        session[obj.push].forEach(function (el) {\\n          sdp.push(makeLine(type, obj, el));\\n        });\\n      }\\n    });\\n  });\\n\\n  // then for each media line, follow the innerOrder\\n  session.media.forEach(function (mLine) {\\n    sdp.push(makeLine('m', grammar.m[0], mLine));\\n\\n    innerOrder.forEach(function (type) {\\n      grammar[type].forEach(function (obj) {\\n        if (obj.name in mLine && mLine[obj.name] != null) {\\n          sdp.push(makeLine(type, obj, mLine));\\n        }\\n        else if (obj.push in mLine && mLine[obj.push] != null) {\\n          mLine[obj.push].forEach(function (el) {\\n            sdp.push(makeLine(type, obj, el));\\n          });\\n        }\\n      });\\n    });\\n  });\\n\\n  return sdp.join('\\\\r\\\\n') + '\\\\r\\\\n';\\n};\\n\\n\\n/***/ }),\\n/* 128 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = extractCapabilities;\\n/* harmony export (immutable) */ __webpack_exports__[\\\"b\\\"] = extractDtlsParameters;\\n/* harmony export (immutable) */ __webpack_exports__[\\\"c\\\"] = extractIceCandidates;\\n/* harmony export (immutable) */ __webpack_exports__[\\\"d\\\"] = extractIceParameters;\\n/* harmony export (immutable) */ __webpack_exports__[\\\"e\\\"] = extractMids;\\n/* harmony export (immutable) */ __webpack_exports__[\\\"f\\\"] = extractTrackInfos;\\n/* harmony export (immutable) */ __webpack_exports__[\\\"g\\\"] = getLocalCapabilities;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sdp_transform__ = __webpack_require__(15);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sdp_transform___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_sdp_transform__);\\n/* global RTCRtpReceiver */\\n\\n\\n\\n/**\\n * Extract RTP capabilities from remote description.\\n * @param {Object} sdpObject - Remote SDP object generated by sdp-transform.\\n * @return {RTCRtpCapabilities}\\n */\\nfunction extractCapabilities(sdpObject) {\\n    // Map of RtpCodecParameters indexed by payload type.\\n    var codecsMap = new Map();\\n\\n    // Array of RtpHeaderExtensions.\\n    var headerExtensions = [];\\n\\n    var _iteratorNormalCompletion = true;\\n    var _didIteratorError = false;\\n    var _iteratorError = undefined;\\n\\n    try {\\n        for (var _iterator = sdpObject.media[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n            var m = _step.value;\\n\\n            // Media kind.\\n            var kind = m.type;\\n\\n            if (kind !== 'audio' && kind !== 'video') {\\n                continue; // eslint-disable-line no-continue\\n            }\\n\\n            // Get codecs.\\n            var _iteratorNormalCompletion2 = true;\\n            var _didIteratorError2 = false;\\n            var _iteratorError2 = undefined;\\n\\n            try {\\n                for (var _iterator2 = m.rtp[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                    var rtp = _step2.value;\\n\\n                    var codec = {\\n                        clockRate: rtp.rate,\\n                        kind: kind,\\n                        mimeType: kind + '/' + rtp.codec,\\n                        name: rtp.codec,\\n                        numChannels: rtp.encoding || 1,\\n                        parameters: {},\\n                        preferredPayloadType: rtp.payload,\\n                        rtcpFeedback: []\\n                    };\\n\\n                    codecsMap.set(codec.preferredPayloadType, codec);\\n                }\\n\\n                // Get codec parameters.\\n            } catch (err) {\\n                _didIteratorError2 = true;\\n                _iteratorError2 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                        _iterator2.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError2) {\\n                        throw _iteratorError2;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion3 = true;\\n            var _didIteratorError3 = false;\\n            var _iteratorError3 = undefined;\\n\\n            try {\\n                for (var _iterator3 = (m.fmtp || [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n                    var fmtp = _step3.value;\\n\\n                    var parameters = __WEBPACK_IMPORTED_MODULE_0_sdp_transform___default.a.parseFmtpConfig(fmtp.config);\\n                    var codec = codecsMap.get(fmtp.payload);\\n\\n                    if (!codec) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    codec.parameters = parameters;\\n                }\\n\\n                // Get RTCP feedback for each codec.\\n            } catch (err) {\\n                _didIteratorError3 = true;\\n                _iteratorError3 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                        _iterator3.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError3) {\\n                        throw _iteratorError3;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion4 = true;\\n            var _didIteratorError4 = false;\\n            var _iteratorError4 = undefined;\\n\\n            try {\\n                for (var _iterator4 = (m.rtcpFb || [])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n                    var fb = _step4.value;\\n\\n                    var codec = codecsMap.get(fb.payload);\\n\\n                    if (!codec) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    codec.rtcpFeedback.push({\\n                        parameter: fb.subtype || '',\\n                        type: fb.type\\n                    });\\n                }\\n\\n                // Get RTP header extensions.\\n            } catch (err) {\\n                _didIteratorError4 = true;\\n                _iteratorError4 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n                        _iterator4.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError4) {\\n                        throw _iteratorError4;\\n                    }\\n                }\\n            }\\n\\n            var _loop = function _loop(ext) {\\n                var preferredId = ext.value;\\n                var uri = ext.uri;\\n                var headerExtension = {\\n                    kind: kind,\\n                    uri: uri,\\n                    preferredId: preferredId\\n                };\\n\\n                // Check if already present.\\n                var duplicated = headerExtensions.find(function (savedHeaderExtension) {\\n                    return headerExtension.kind === savedHeaderExtension.kind && headerExtension.uri === savedHeaderExtension.uri;\\n                });\\n\\n                if (!duplicated) {\\n                    headerExtensions.push(headerExtension);\\n                }\\n            };\\n\\n            var _iteratorNormalCompletion5 = true;\\n            var _didIteratorError5 = false;\\n            var _iteratorError5 = undefined;\\n\\n            try {\\n                for (var _iterator5 = (m.ext || [])[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\\n                    var ext = _step5.value;\\n\\n                    _loop(ext);\\n                }\\n            } catch (err) {\\n                _didIteratorError5 = true;\\n                _iteratorError5 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\\n                        _iterator5.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError5) {\\n                        throw _iteratorError5;\\n                    }\\n                }\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError = true;\\n        _iteratorError = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion && _iterator.return) {\\n                _iterator.return();\\n            }\\n        } finally {\\n            if (_didIteratorError) {\\n                throw _iteratorError;\\n            }\\n        }\\n    }\\n\\n    return {\\n        codecs: Array.from(codecsMap.values()),\\n        fecMechanisms: [], // TODO\\n        headerExtensions: headerExtensions\\n    };\\n}\\n\\n/**\\n * Extract DTLS parameters from remote description.\\n * @param {Object} sdpObject - Remote SDP object generated by sdp-transform.\\n * @return {RTCDtlsParameters}\\n */\\nfunction extractDtlsParameters(sdpObject) {\\n    var media = getFirstActiveMediaSection(sdpObject);\\n    var fingerprint = media.fingerprint || sdpObject.fingerprint;\\n    var role = void 0;\\n\\n    switch (media.setup) {\\n        case 'active':\\n            role = 'client';\\n            break;\\n        case 'passive':\\n            role = 'server';\\n            break;\\n        case 'actpass':\\n            role = 'auto';\\n            break;\\n    }\\n\\n    return {\\n        role: role,\\n        fingerprints: [{\\n            algorithm: fingerprint.type,\\n            value: fingerprint.hash\\n        }]\\n    };\\n}\\n\\n/**\\n * Extract ICE candidates from remote description.\\n * NOTE: This implementation assumes a single BUNDLEd transport and rtcp-mux.\\n * @param {Object} sdpObject - Remote SDP object generated by sdp-transform.\\n * @return {sequence<RTCIceCandidate>}\\n */\\nfunction extractIceCandidates(sdpObject) {\\n    var media = getFirstActiveMediaSection(sdpObject);\\n    var candidates = [];\\n\\n    var _iteratorNormalCompletion6 = true;\\n    var _didIteratorError6 = false;\\n    var _iteratorError6 = undefined;\\n\\n    try {\\n        for (var _iterator6 = media.candidates[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\\n            var c = _step6.value;\\n\\n            // Ignore RTCP candidates (we assume rtcp-mux).\\n            if (c.component !== 1) {\\n                continue; // eslint-disable-line no-continue\\n            }\\n\\n            var candidate = {\\n                foundation: c.foundation,\\n                ip: c.ip,\\n                port: c.port,\\n                priority: c.priority,\\n                protocol: c.transport.toLowerCase(),\\n                type: c.type\\n            };\\n\\n            candidates.push(candidate);\\n        }\\n    } catch (err) {\\n        _didIteratorError6 = true;\\n        _iteratorError6 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\\n                _iterator6.return();\\n            }\\n        } finally {\\n            if (_didIteratorError6) {\\n                throw _iteratorError6;\\n            }\\n        }\\n    }\\n\\n    return candidates;\\n}\\n\\n/**\\n * Extract ICE parameters from remote description.\\n * NOTE: This implementation assumes a single BUNDLEd transport.\\n * @param {Object} sdpObject - Remote SDP object generated by sdp-transform.\\n * @return {RTCIceParameters}\\n */\\nfunction extractIceParameters(sdpObject) {\\n    var media = getFirstActiveMediaSection(sdpObject);\\n    var usernameFragment = media.iceUfrag;\\n    var password = media.icePwd;\\n    var icelite = sdpObject.icelite === 'ice-lite';\\n\\n    return {\\n        icelite: icelite,\\n        password: password,\\n        usernameFragment: usernameFragment\\n    };\\n}\\n\\n/**\\n * Extract MID values from remote description.\\n * @param {Object} sdpObject - Remote SDP object generated by sdp-transform.\\n * @return {map<String, String>} Ordered Map with MID as key and kind as value.\\n */\\nfunction extractMids(sdpObject) {\\n    var midToKind = new Map();\\n\\n    // Ignore disabled media sections.\\n    var _iteratorNormalCompletion7 = true;\\n    var _didIteratorError7 = false;\\n    var _iteratorError7 = undefined;\\n\\n    try {\\n        for (var _iterator7 = sdpObject.media[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\\n            var m = _step7.value;\\n\\n            midToKind.set(m.mid, m.type);\\n        }\\n    } catch (err) {\\n        _didIteratorError7 = true;\\n        _iteratorError7 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\\n                _iterator7.return();\\n            }\\n        } finally {\\n            if (_didIteratorError7) {\\n                throw _iteratorError7;\\n            }\\n        }\\n    }\\n\\n    return midToKind;\\n}\\n\\n/**\\n * Extract tracks information.\\n * @param {Object} sdpObject - Remote SDP object generated by sdp-transform.\\n * @return {Map}\\n */\\nfunction extractTrackInfos(sdpObject) {\\n    // Map with info about receiving media.\\n    // - index: Media SSRC\\n    // - value: Object\\n    //   - kind: 'audio' / 'video'\\n    //   - ssrc: Media SSRC\\n    //   - rtxSsrc: RTX SSRC (may be unset)\\n    //   - streamId: MediaStream.jitsiRemoteId\\n    //   - trackId: MediaStreamTrack.jitsiRemoteId\\n    //   - cname: CNAME\\n    // @type {map<Number, Object>}\\n    var infos = new Map();\\n\\n    // Map with stream SSRC as index and associated RTX SSRC as value.\\n    // @type {map<Number, Number>}\\n    var rtxMap = new Map();\\n\\n    // Set of RTX SSRC values.\\n    var rtxSet = new Set();\\n\\n    var _iteratorNormalCompletion8 = true;\\n    var _didIteratorError8 = false;\\n    var _iteratorError8 = undefined;\\n\\n    try {\\n        for (var _iterator8 = sdpObject.media[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\\n            var m = _step8.value;\\n\\n            var kind = m.type;\\n\\n            if (kind !== 'audio' && kind !== 'video') {\\n                continue; // eslint-disable-line no-continue\\n            }\\n\\n            // Get RTX information.\\n            var _iteratorNormalCompletion9 = true;\\n            var _didIteratorError9 = false;\\n            var _iteratorError9 = undefined;\\n\\n            try {\\n                for (var _iterator9 = (m.ssrcGroups || [])[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\\n                    var ssrcGroup = _step9.value;\\n\\n                    // Just consider FID.\\n                    if (ssrcGroup.semantics !== 'FID') {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    var ssrcs = ssrcGroup.ssrcs.split(' ').map(function (ssrc) {\\n                        return Number(ssrc);\\n                    });\\n                    var ssrc = ssrcs[0];\\n                    var rtxSsrc = ssrcs[1];\\n\\n                    rtxMap.set(ssrc, rtxSsrc);\\n                    rtxSet.add(rtxSsrc);\\n                }\\n            } catch (err) {\\n                _didIteratorError9 = true;\\n                _iteratorError9 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion9 && _iterator9.return) {\\n                        _iterator9.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError9) {\\n                        throw _iteratorError9;\\n                    }\\n                }\\n            }\\n\\n            var _iteratorNormalCompletion10 = true;\\n            var _didIteratorError10 = false;\\n            var _iteratorError10 = undefined;\\n\\n            try {\\n                for (var _iterator10 = (m.ssrcs || [])[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\\n                    var ssrcObject = _step10.value;\\n\\n                    var ssrc = ssrcObject.id;\\n\\n                    // Ignore RTX.\\n                    if (rtxSet.has(ssrc)) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    var info = infos.get(ssrc);\\n\\n                    if (!info) {\\n                        info = {\\n                            kind: kind,\\n                            rtxSsrc: rtxMap.get(ssrc),\\n                            ssrc: ssrc\\n                        };\\n\\n                        infos.set(ssrc, info);\\n                    }\\n\\n                    switch (ssrcObject.attribute) {\\n                        case 'cname':\\n                            {\\n                                info.cname = ssrcObject.value;\\n                                break;\\n                            }\\n                        case 'msid':\\n                            {\\n                                var values = ssrcObject.value.split(' ');\\n                                var streamId = values[0];\\n                                var trackId = values[1];\\n\\n                                info.streamId = streamId;\\n                                info.trackId = trackId;\\n                                break;\\n                            }\\n                        case 'mslabel':\\n                            {\\n                                var _streamId = ssrcObject.value;\\n\\n                                info.streamId = _streamId;\\n                                break;\\n                            }\\n                        case 'label':\\n                            {\\n                                var _trackId = ssrcObject.value;\\n\\n                                info.trackId = _trackId;\\n                                break;\\n                            }\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError10 = true;\\n                _iteratorError10 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion10 && _iterator10.return) {\\n                        _iterator10.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError10) {\\n                        throw _iteratorError10;\\n                    }\\n                }\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError8 = true;\\n        _iteratorError8 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion8 && _iterator8.return) {\\n                _iterator8.return();\\n            }\\n        } finally {\\n            if (_didIteratorError8) {\\n                throw _iteratorError8;\\n            }\\n        }\\n    }\\n\\n    return infos;\\n}\\n\\n/**\\n * Get local ORTC RTP capabilities filtered and adapted to the given remote RTP\\n * capabilities.\\n * @param {RTCRtpCapabilities} filterWithCapabilities - RTP capabilities to\\n * filter with.\\n * @return {RTCRtpCapabilities}\\n */\\nfunction getLocalCapabilities(filterWithCapabilities) {\\n    var localFullCapabilities = RTCRtpReceiver.getCapabilities();\\n    var localCapabilities = {\\n        codecs: [],\\n        fecMechanisms: [],\\n        headerExtensions: []\\n    };\\n\\n    // Map of RTX and codec payloads.\\n    // - index: Codec payloadType\\n    // - value: Associated RTX payloadType\\n    // @type {map<Number, Number>}\\n    var remoteRtxMap = new Map();\\n\\n    // Set codecs.\\n\\n    var _loop2 = function _loop2(remoteCodec) {\\n        var remoteCodecName = remoteCodec.name.toLowerCase();\\n\\n        if (remoteCodecName === 'rtx') {\\n            remoteRtxMap.set(remoteCodec.parameters.apt, remoteCodec.preferredPayloadType);\\n\\n            return 'continue'; // eslint-disable-line no-continue\\n        }\\n\\n        var localCodec = localFullCapabilities.codecs.find(function (codec) {\\n            return codec.name.toLowerCase() === remoteCodecName && codec.kind === remoteCodec.kind && codec.clockRate === remoteCodec.clockRate;\\n        });\\n\\n        if (!localCodec) {\\n            return 'continue'; // eslint-disable-line no-continue\\n        }\\n\\n        var codec = {\\n            clockRate: localCodec.clockRate,\\n            kind: localCodec.kind,\\n            mimeType: localCodec.kind + '/' + localCodec.name,\\n            name: localCodec.name,\\n            numChannels: localCodec.numChannels || 1,\\n            parameters: {},\\n            preferredPayloadType: remoteCodec.preferredPayloadType,\\n            rtcpFeedback: []\\n        };\\n\\n        var _iteratorNormalCompletion15 = true;\\n        var _didIteratorError15 = false;\\n        var _iteratorError15 = undefined;\\n\\n        try {\\n            for (var _iterator15 = Object.keys(remoteCodec.parameters)[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\\n                var remoteParamName = _step15.value;\\n\\n                var remoteParamValue = remoteCodec.parameters[remoteParamName];\\n\\n                var _iteratorNormalCompletion17 = true;\\n                var _didIteratorError17 = false;\\n                var _iteratorError17 = undefined;\\n\\n                try {\\n                    for (var _iterator17 = Object.keys(localCodec.parameters)[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\\n                        var localParamName = _step17.value;\\n\\n                        var localParamValue = localCodec.parameters[localParamName];\\n\\n                        if (localParamName !== remoteParamName) {\\n                            continue; // eslint-disable-line no-continue\\n                        }\\n\\n                        // TODO: We should consider much more cases here, but Edge\\n                        // does not support many codec parameters.\\n                        if (localParamValue === remoteParamValue) {\\n                            // Use this RTP parameter.\\n                            codec.parameters[localParamName] = localParamValue;\\n                            break;\\n                        }\\n                    }\\n                } catch (err) {\\n                    _didIteratorError17 = true;\\n                    _iteratorError17 = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion17 && _iterator17.return) {\\n                            _iterator17.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError17) {\\n                            throw _iteratorError17;\\n                        }\\n                    }\\n                }\\n            }\\n        } catch (err) {\\n            _didIteratorError15 = true;\\n            _iteratorError15 = err;\\n        } finally {\\n            try {\\n                if (!_iteratorNormalCompletion15 && _iterator15.return) {\\n                    _iterator15.return();\\n                }\\n            } finally {\\n                if (_didIteratorError15) {\\n                    throw _iteratorError15;\\n                }\\n            }\\n        }\\n\\n        var _loop5 = function _loop5(remoteFb) {\\n            var localFb = localCodec.rtcpFeedback.find(function (fb) {\\n                return fb.type === remoteFb.type && fb.parameter === remoteFb.parameter;\\n            });\\n\\n            if (localFb) {\\n                // Use this RTCP feedback.\\n                codec.rtcpFeedback.push(localFb);\\n            }\\n        };\\n\\n        var _iteratorNormalCompletion16 = true;\\n        var _didIteratorError16 = false;\\n        var _iteratorError16 = undefined;\\n\\n        try {\\n            for (var _iterator16 = remoteCodec.rtcpFeedback[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\\n                var remoteFb = _step16.value;\\n\\n                _loop5(remoteFb);\\n            }\\n\\n            // Use this codec.\\n        } catch (err) {\\n            _didIteratorError16 = true;\\n            _iteratorError16 = err;\\n        } finally {\\n            try {\\n                if (!_iteratorNormalCompletion16 && _iterator16.return) {\\n                    _iterator16.return();\\n                }\\n            } finally {\\n                if (_didIteratorError16) {\\n                    throw _iteratorError16;\\n                }\\n            }\\n        }\\n\\n        localCapabilities.codecs.push(codec);\\n    };\\n\\n    var _iteratorNormalCompletion11 = true;\\n    var _didIteratorError11 = false;\\n    var _iteratorError11 = undefined;\\n\\n    try {\\n        for (var _iterator11 = filterWithCapabilities.codecs[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\\n            var remoteCodec = _step11.value;\\n\\n            var _ret2 = _loop2(remoteCodec);\\n\\n            if (_ret2 === 'continue') continue;\\n        }\\n\\n        // Add RTX for video codecs.\\n    } catch (err) {\\n        _didIteratorError11 = true;\\n        _iteratorError11 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion11 && _iterator11.return) {\\n                _iterator11.return();\\n            }\\n        } finally {\\n            if (_didIteratorError11) {\\n                throw _iteratorError11;\\n            }\\n        }\\n    }\\n\\n    var _iteratorNormalCompletion12 = true;\\n    var _didIteratorError12 = false;\\n    var _iteratorError12 = undefined;\\n\\n    try {\\n        for (var _iterator12 = localCapabilities.codecs[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\\n            var _codec = _step12.value;\\n\\n            var payloadType = _codec.preferredPayloadType;\\n\\n            if (!remoteRtxMap.has(payloadType)) {\\n                continue; // eslint-disable-line no-continue\\n            }\\n\\n            var rtxCodec = {\\n                clockRate: _codec.clockRate,\\n                kind: _codec.kind,\\n                mimeType: _codec.kind + '/rtx',\\n                name: 'rtx',\\n                parameters: {\\n                    apt: payloadType\\n                },\\n                preferredPayloadType: remoteRtxMap.get(payloadType),\\n                rtcpFeedback: []\\n            };\\n\\n            // Add RTX codec.\\n            localCapabilities.codecs.push(rtxCodec);\\n        }\\n\\n        // Add RTP header extensions.\\n    } catch (err) {\\n        _didIteratorError12 = true;\\n        _iteratorError12 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion12 && _iterator12.return) {\\n                _iterator12.return();\\n            }\\n        } finally {\\n            if (_didIteratorError12) {\\n                throw _iteratorError12;\\n            }\\n        }\\n    }\\n\\n    var _loop3 = function _loop3(remoteExtension) {\\n        var localExtension = localFullCapabilities.headerExtensions.find(function (extension) {\\n            return extension.kind === remoteExtension.kind && extension.uri === remoteExtension.uri;\\n        });\\n\\n        if (localExtension) {\\n            var extension = {\\n                kind: localExtension.kind,\\n                preferredEncrypt: Boolean(remoteExtension.preferredEncrypt),\\n                preferredId: remoteExtension.preferredId,\\n                uri: localExtension.uri\\n            };\\n\\n            // Use this RTP header extension.\\n            localCapabilities.headerExtensions.push(extension);\\n        }\\n    };\\n\\n    var _iteratorNormalCompletion13 = true;\\n    var _didIteratorError13 = false;\\n    var _iteratorError13 = undefined;\\n\\n    try {\\n        for (var _iterator13 = filterWithCapabilities.headerExtensions[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\\n            var remoteExtension = _step13.value;\\n\\n            _loop3(remoteExtension);\\n        }\\n\\n        // Add FEC mechanisms.\\n        // NOTE: We don't support FEC yet and, in fact, neither does Edge.\\n    } catch (err) {\\n        _didIteratorError13 = true;\\n        _iteratorError13 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion13 && _iterator13.return) {\\n                _iterator13.return();\\n            }\\n        } finally {\\n            if (_didIteratorError13) {\\n                throw _iteratorError13;\\n            }\\n        }\\n    }\\n\\n    var _loop4 = function _loop4(remoteFecMechanism) {\\n        var localFecMechanism = localFullCapabilities.fecMechanisms.find(function (fec) {\\n            return fec === remoteFecMechanism;\\n        });\\n\\n        if (localFecMechanism) {\\n            // Use this FEC mechanism.\\n            localCapabilities.fecMechanisms.push(localFecMechanism);\\n        }\\n    };\\n\\n    var _iteratorNormalCompletion14 = true;\\n    var _didIteratorError14 = false;\\n    var _iteratorError14 = undefined;\\n\\n    try {\\n        for (var _iterator14 = filterWithCapabilities.fecMechanisms[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\\n            var remoteFecMechanism = _step14.value;\\n\\n            _loop4(remoteFecMechanism);\\n        }\\n    } catch (err) {\\n        _didIteratorError14 = true;\\n        _iteratorError14 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion14 && _iterator14.return) {\\n                _iterator14.return();\\n            }\\n        } finally {\\n            if (_didIteratorError14) {\\n                throw _iteratorError14;\\n            }\\n        }\\n    }\\n\\n    return localCapabilities;\\n}\\n\\n/**\\n * Get the first acive media section.\\n * @param {Object} sdpObject - SDP object generated by sdp-transform.\\n * @return {Object} SDP media section as parsed by sdp-transform.\\n */\\nfunction getFirstActiveMediaSection(sdpObject) {\\n    return sdpObject.media.find(function (m) {\\n        return m.iceUfrag && m.port !== 0;\\n    });\\n}\\n\\n/***/ }),\\n/* 129 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return InvalidStateError; });\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n/**\\n * Create a class inheriting from Error.\\n */\\nfunction createErrorClass(name) {\\n    var klass = function (_Error) {\\n        _inherits(klass, _Error);\\n\\n        /**\\n         * Custom error class constructor.\\n         * @param {string} message\\n         */\\n        function klass(message) {\\n            _classCallCheck(this, klass);\\n\\n            // Override `name` property value and make it non enumerable.\\n            var _this = _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).call(this, message));\\n\\n            Object.defineProperty(_this, 'name', { value: name });\\n            return _this;\\n        }\\n\\n        return klass;\\n    }(Error);\\n\\n    return klass;\\n}\\n\\nvar InvalidStateError = createErrorClass('InvalidStateError');\\n\\n/***/ }),\\n/* 130 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__ = __webpack_require__(12);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__ = __webpack_require__(17);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__ = __webpack_require__(1);\\n/* global chrome, $, alert */\\n\\n\\n\\n\\n\\nvar logger = __webpack_require__(0).getLogger(__filename);\\nvar GlobalOnErrorHandler = __webpack_require__(3);\\n\\n/**\\n * Indicates whether the Chrome desktop sharing extension is installed.\\n * @type {boolean}\\n */\\nvar chromeExtInstalled = false;\\n\\n/**\\n * Indicates whether an update of the Chrome desktop sharing extension is\\n * required.\\n * @type {boolean}\\n */\\nvar chromeExtUpdateRequired = false;\\n\\n/**\\n * Whether the jidesha extension for firefox is installed for the domain on\\n * which we are running. Null designates an unknown value.\\n * @type {null}\\n */\\nvar firefoxExtInstalled = null;\\n\\n/**\\n * If set to true, detection of an installed firefox extension will be started\\n * again the next time obtainScreenOnFirefox is called (e.g. next time the\\n * user tries to enable screen sharing).\\n */\\nvar reDetectFirefoxExtension = false;\\n\\nvar gumFunction = null;\\n\\n/**\\n * The error returned by chrome when trying to start inline installation from\\n * popup.\\n */\\nvar CHROME_EXTENSION_POPUP_ERROR = 'Inline installs can not be initiated from pop-up windows.';\\n\\n/**\\n * The error returned by chrome when trying to start inline installation from\\n * iframe.\\n */\\nvar CHROME_EXTENSION_IFRAME_ERROR = 'Chrome Web Store installations can only be started by the top frame.';\\n\\n/**\\n * The error returned by chrome when trying to start inline installation\\n * not from the \\\"main\\\" whitelisted site.\\n * @type {string}\\n */\\nvar CHROME_EXTENSION_INLINE_ERROR = 'Installs can only be initiated by one of' + ' the Chrome Web Store item\\\\'s verified sites.';\\n\\n/**\\n * The error returned by chrome when trying to start inline installation\\n * with extension that doesn't support inline installation.\\n *\\n * @type {string}\\n */\\nvar CHROME_EXTENSION_INLINE_NOT_SUPPORTED_ERROR = 'Inline installation is not supported for this item. ' + 'The user will be redirected to the Chrome Web Store.';\\n\\n/**\\n * The error message returned by chrome when the extension is installed.\\n */\\nvar CHROME_NO_EXTENSION_ERROR_MSG // eslint-disable-line no-unused-vars\\n= 'Could not establish connection. Receiving end does not exist.';\\n\\n/**\\n * The error message returned by chrome when the extension install action needs\\n * to be initiated by a user gesture.\\n * @type {string}\\n */\\nvar CHROME_USER_GESTURE_REQ_ERROR = 'Chrome Web Store installations can only be initated by a user gesture.';\\n\\n/**\\n * Handles obtaining a stream from a screen capture on different browsers.\\n */\\nvar ScreenObtainer = {\\n    /**\\n     * If not <tt>null</tt> it means that the initialization process is still in\\n     * progress. It is used to make desktop stream request wait and continue\\n     * after it's done.\\n     * {@type Promise|null}\\n     */\\n    intChromeExtPromise: null,\\n\\n    obtainStream: null,\\n\\n    /**\\n     * Initializes the function used to obtain a screen capture\\n     * (this.obtainStream).\\n     *\\n     * @param {object} options\\n     * @param {boolean} [options.disableDesktopSharing]\\n     * @param {boolean} [options.desktopSharingChromeDisabled]\\n     * @param {boolean} [options.desktopSharingChromeExtId]\\n     * @param {boolean} [options.desktopSharingFirefoxDisabled]\\n     * @param {boolean} [options.desktopSharingFirefoxExtId] (deprecated)\\n     * @param {Function} gum GUM method\\n     */\\n    init: function init() {\\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\\n            disableDesktopSharing: false,\\n            desktopSharingChromeDisabled: false,\\n            desktopSharingChromeExtId: null,\\n            desktopSharingFirefoxDisabled: false,\\n            desktopSharingFirefoxExtId: null\\n        };\\n        var gum = arguments[1];\\n\\n        // eslint-disable-next-line no-param-reassign\\n        this.options = options = options || {};\\n        gumFunction = gum;\\n\\n        this.obtainStream = this.options.disableDesktopSharing ? null : this._createObtainStreamMethod(options);\\n\\n        if (!this.obtainStream) {\\n            logger.info('Desktop sharing disabled');\\n        }\\n    },\\n\\n\\n    /**\\n     * Returns a method which will be used to obtain the screen sharing stream\\n     * (based on the browser type).\\n     *\\n     * @param {object} options passed from {@link init} - check description\\n     * there\\n     * @returns {Function}\\n     * @private\\n     */\\n    _createObtainStreamMethod: function _createObtainStreamMethod(options) {\\n        var _this = this;\\n\\n        if (__WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].isNWJS()) {\\n            return function (_, onSuccess, onFailure) {\\n                window.JitsiMeetNW.obtainDesktopStream(onSuccess, function (error, constraints) {\\n                    var jitsiError = void 0;\\n\\n                    // FIXME:\\n                    // This is very very dirty fix for recognising that the\\n                    // user have clicked the cancel button from the Desktop\\n                    // sharing pick window. The proper solution would be to\\n                    // detect this in the NWJS application by checking the\\n                    // streamId === \\\"\\\". Even better solution would be to\\n                    // stop calling GUM from the NWJS app and just pass the\\n                    // streamId to lib-jitsi-meet. This way the desktop\\n                    // sharing implementation for NWJS and chrome extension\\n                    // will be the same and lib-jitsi-meet will be able to\\n                    // control the constraints, check the streamId, etc.\\n                    //\\n                    // I cannot find documentation about \\\"InvalidStateError\\\"\\n                    // but this is what we are receiving from GUM when the\\n                    // streamId for the desktop sharing is \\\"\\\".\\n\\n                    if (error && error.name === 'InvalidStateError') {\\n                        jitsiError = new __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__[\\\"CHROME_EXTENSION_USER_CANCELED\\\"]);\\n                    } else {\\n                        jitsiError = new __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__[\\\"a\\\" /* default */](error, constraints, ['desktop']);\\n                    }\\n                    typeof onFailure === 'function' && onFailure(jitsiError);\\n                });\\n            };\\n        } else if (__WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].isElectron()) {\\n            return this.obtainScreenOnElectron;\\n        } else if (__WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed()) {\\n            // XXX Don't require Temasys unless it's to be used because it\\n            // doesn't run on React Native, for example.\\n            var plugin = __webpack_require__(37).WebRTCPlugin.plugin;\\n\\n            if (!plugin.HasScreensharingFeature) {\\n                logger.warn('Screensharing not supported by this plugin version');\\n\\n                return null;\\n            } else if (!plugin.isScreensharingAvailable) {\\n                logger.warn('Screensharing not available with Temasys plugin on' + ' this site');\\n\\n                return null;\\n            }\\n\\n            logger.info('Using Temasys plugin for desktop sharing');\\n\\n            return obtainWebRTCScreen;\\n        } else if (__WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].isChrome() || __WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].isOpera()) {\\n            if ((__WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].getChromeVersion() || __WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].getOperaVersion()) < 34) {\\n                logger.info('Chrome extension not supported until ver 34');\\n\\n                return null;\\n            } else if (options.desktopSharingChromeDisabled || options.desktopSharingChromeMethod === false || !options.desktopSharingChromeExtId) {\\n\\n                // TODO: desktopSharingChromeMethod is deprecated, remove.\\n                return null;\\n            }\\n\\n            logger.info('Using Chrome extension for desktop sharing');\\n            this.intChromeExtPromise = initChromeExtension(options).then(function () {\\n                _this.intChromeExtPromise = null;\\n            });\\n\\n            return this.obtainScreenFromExtension;\\n        } else if (__WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox()) {\\n            if (options.desktopSharingFirefoxDisabled) {\\n                return null;\\n            } else if (window.location.protocol === 'http:') {\\n                logger.log('Screen sharing is not supported over HTTP. ' + 'Use of HTTPS is required.');\\n\\n                return null;\\n            }\\n\\n            initFirefoxExtensionDetection(options);\\n\\n            return this.obtainScreenOnFirefox;\\n        }\\n\\n        logger.log('Screen sharing not supported by the current browser: ', __WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].getBrowserType(), __WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].getBrowserName());\\n\\n        return null;\\n    },\\n\\n\\n    /**\\n     * Checks whether obtaining a screen capture is supported in the current\\n     * environment.\\n     * @returns {boolean}\\n     */\\n    isSupported: function isSupported() {\\n        return this.obtainStream !== null;\\n    },\\n\\n\\n    /**\\n     * Obtains a screen capture stream on Firefox.\\n     * @param callback\\n     * @param errorCallback\\n     */\\n    obtainScreenOnFirefox: function obtainScreenOnFirefox(options, callback, errorCallback) {\\n        var _this2 = this;\\n\\n        var extensionRequired = false;\\n        var desktopSharingFirefoxMaxVersionExtRequired = this.options.desktopSharingFirefoxMaxVersionExtRequired;\\n\\n\\n        if (desktopSharingFirefoxMaxVersionExtRequired === -1 || desktopSharingFirefoxMaxVersionExtRequired >= 0 && __WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].getFirefoxVersion() <= desktopSharingFirefoxMaxVersionExtRequired) {\\n            extensionRequired = true;\\n            logger.log('Jidesha extension required on firefox version ' + __WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].getFirefoxVersion());\\n        }\\n\\n        if (!extensionRequired || firefoxExtInstalled === true) {\\n            obtainWebRTCScreen(options, callback, errorCallback);\\n\\n            return;\\n        }\\n\\n        if (reDetectFirefoxExtension) {\\n            reDetectFirefoxExtension = false;\\n            initFirefoxExtensionDetection(this.options);\\n        }\\n\\n        // Give it some (more) time to initialize, and assume lack of\\n        // extension if it hasn't.\\n        if (firefoxExtInstalled === null) {\\n            window.setTimeout(function () {\\n                if (firefoxExtInstalled === null) {\\n                    firefoxExtInstalled = false;\\n                }\\n                _this2.obtainScreenOnFirefox(callback, errorCallback);\\n            }, 300);\\n            logger.log('Waiting for detection of jidesha on firefox to finish.');\\n\\n            return;\\n        }\\n\\n        // We need an extension and it isn't installed.\\n\\n        // Make sure we check for the extension when the user clicks again.\\n        firefoxExtInstalled = null;\\n        reDetectFirefoxExtension = true;\\n\\n        // Make sure desktopsharing knows that we failed, so that it doesn't get\\n        // stuck in 'switching' mode.\\n        errorCallback(new __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__[\\\"FIREFOX_EXTENSION_NEEDED\\\"]));\\n    },\\n\\n\\n    /**\\n     * Obtains a screen capture stream on Electron.\\n     *\\n     * @param {Object} [options] - Screen sharing options.\\n     * @param {Array<string>} [options.desktopSharingSources] - Array with the\\n     * sources that have to be displayed in the desktop picker window ('screen',\\n     * 'window', etc.).\\n     * @param onSuccess - Success callback.\\n     * @param onFailure - Failure callback.\\n     */\\n    obtainScreenOnElectron: function obtainScreenOnElectron() {\\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n        var onSuccess = arguments[1];\\n        var onFailure = arguments[2];\\n\\n        if (window.JitsiMeetScreenObtainer && window.JitsiMeetScreenObtainer.openDesktopPicker) {\\n            window.JitsiMeetScreenObtainer.openDesktopPicker({\\n                desktopSharingSources: options.desktopSharingSources || this.options.desktopSharingChromeSources\\n            }, function (streamId, streamType) {\\n                return onGetStreamResponse({\\n                    streamId: streamId,\\n                    streamType: streamType\\n                }, onSuccess, onFailure);\\n            }, function (err) {\\n                return onFailure(new __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__[\\\"ELECTRON_DESKTOP_PICKER_ERROR\\\"], err));\\n            });\\n        } else {\\n            onFailure(new __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__[\\\"ELECTRON_DESKTOP_PICKER_NOT_FOUND\\\"]));\\n        }\\n    },\\n\\n\\n    /**\\n     * Asks Chrome extension to call chooseDesktopMedia and gets chrome\\n     * 'desktop' stream for returned stream token.\\n     */\\n    obtainScreenFromExtension: function obtainScreenFromExtension(options, streamCallback, failCallback) {\\n        var _this3 = this;\\n\\n        if (this.intChromeExtPromise !== null) {\\n            this.intChromeExtPromise.then(function () {\\n                _this3.obtainScreenFromExtension(options, streamCallback, failCallback);\\n            });\\n\\n            return;\\n        }\\n\\n        var _options = this.options,\\n            desktopSharingChromeExtId = _options.desktopSharingChromeExtId,\\n            desktopSharingChromeSources = _options.desktopSharingChromeSources;\\n\\n\\n        var gumOptions = {\\n            desktopSharingChromeExtId: desktopSharingChromeExtId,\\n            desktopSharingChromeSources: options.desktopSharingSources || desktopSharingChromeSources\\n        };\\n\\n        if (chromeExtInstalled) {\\n            doGetStreamFromExtension(gumOptions, streamCallback, failCallback);\\n        } else {\\n            if (chromeExtUpdateRequired) {\\n                /* eslint-disable no-alert */\\n                alert('Jitsi Desktop Streamer requires update. ' + 'Changes will take effect after next Chrome restart.');\\n\\n                /* eslint-enable no-alert */\\n            }\\n\\n            // for opera there is no inline install\\n            // extension \\\"Download Chrome Extension\\\" allows us to open\\n            // the chrome webstore and install from there and then activate our\\n            // extension\\n            if (__WEBPACK_IMPORTED_MODULE_2__RTCBrowserType__[\\\"a\\\" /* default */].isOpera()) {\\n                this.handleExternalInstall(options, streamCallback, failCallback);\\n\\n                return;\\n            }\\n\\n            try {\\n                chrome.webstore.install(getWebStoreInstallUrl(this.options), function (arg) {\\n                    logger.log('Extension installed successfully', arg);\\n                    chromeExtInstalled = true;\\n\\n                    // We need to give a moment to the endpoint to become\\n                    // available.\\n                    waitForExtensionAfterInstall(_this3.options, 200, 10).then(function () {\\n                        doGetStreamFromExtension(gumOptions, streamCallback, failCallback);\\n                    }).catch(function () {\\n                        _this3.handleExtensionInstallationError(options, streamCallback, failCallback);\\n                    });\\n                }, this.handleExtensionInstallationError.bind(this, options, streamCallback, failCallback));\\n            } catch (e) {\\n                this.handleExtensionInstallationError(options, streamCallback, failCallback, e);\\n            }\\n        }\\n    },\\n\\n\\n    /* eslint-disable max-params */\\n\\n    handleExternalInstall: function handleExternalInstall(options, streamCallback, failCallback, e) {\\n        var webStoreInstallUrl = getWebStoreInstallUrl(this.options);\\n\\n        options.listener('waitingForExtension', webStoreInstallUrl);\\n        this.checkForChromeExtensionOnInterval(options, streamCallback, failCallback, e);\\n    },\\n    handleExtensionInstallationError: function handleExtensionInstallationError(options, streamCallback, failCallback, e) {\\n        var webStoreInstallUrl = getWebStoreInstallUrl(this.options);\\n\\n        if ((CHROME_EXTENSION_POPUP_ERROR === e || CHROME_EXTENSION_IFRAME_ERROR === e || CHROME_EXTENSION_INLINE_ERROR === e || CHROME_EXTENSION_INLINE_NOT_SUPPORTED_ERROR === e) && options.interval > 0 && typeof options.checkAgain === 'function' && typeof options.listener === 'function') {\\n            this.handleExternalInstall(options, streamCallback, failCallback, e);\\n\\n            return;\\n        }\\n\\n        var msg = 'Failed to install the extension from ' + webStoreInstallUrl;\\n\\n        logger.log(msg, e);\\n\\n        var error = e === CHROME_USER_GESTURE_REQ_ERROR ? __WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__[\\\"CHROME_EXTENSION_USER_GESTURE_REQUIRED\\\"] : __WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__[\\\"CHROME_EXTENSION_INSTALLATION_ERROR\\\"];\\n\\n        failCallback(new __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__[\\\"a\\\" /* default */](error, msg));\\n    },\\n\\n\\n    /* eslint-enable max-params */\\n\\n    checkForChromeExtensionOnInterval: function checkForChromeExtensionOnInterval(options, streamCallback, failCallback) {\\n        var _this4 = this;\\n\\n        if (options.checkAgain() === false) {\\n            failCallback(new __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__[\\\"CHROME_EXTENSION_INSTALLATION_ERROR\\\"]));\\n\\n            return;\\n        }\\n        waitForExtensionAfterInstall(this.options, options.interval, 1).then(function () {\\n            chromeExtInstalled = true;\\n            options.listener('extensionFound');\\n            _this4.obtainScreenFromExtension(options, streamCallback, failCallback);\\n        }).catch(function () {\\n            _this4.checkForChromeExtensionOnInterval(options, streamCallback, failCallback);\\n        });\\n    }\\n};\\n\\n/**\\n * Obtains a desktop stream using getUserMedia.\\n * For this to work on Chrome, the\\n * 'chrome://flags/#enable-usermedia-screen-capture' flag must be enabled.\\n *\\n * On firefox, the document's domain must be white-listed in the\\n * 'media.getusermedia.screensharing.allowed_domains' preference in\\n * 'about:config'.\\n */\\nfunction obtainWebRTCScreen(options, streamCallback, failCallback) {\\n    gumFunction(['screen'], function (stream) {\\n        return streamCallback({ stream: stream });\\n    }, failCallback);\\n}\\n\\n/**\\n * Constructs inline install URL for Chrome desktop streaming extension.\\n * The 'chromeExtensionId' must be defined in options parameter.\\n * @param options supports \\\"desktopSharingChromeExtId\\\"\\n * @returns {string}\\n */\\nfunction getWebStoreInstallUrl(options) {\\n    return 'https://chrome.google.com/webstore/detail/' + options.desktopSharingChromeExtId;\\n}\\n\\n/**\\n * Checks whether an update of the Chrome extension is required.\\n * @param minVersion minimal required version\\n * @param extVersion current extension version\\n * @returns {boolean}\\n */\\nfunction isUpdateRequired(minVersion, extVersion) {\\n    try {\\n        var s1 = minVersion.split('.');\\n        var s2 = extVersion.split('.');\\n\\n        var len = Math.max(s1.length, s2.length);\\n\\n        for (var i = 0; i < len; i++) {\\n            var n1 = 0,\\n                n2 = 0;\\n\\n            if (i < s1.length) {\\n                n1 = parseInt(s1[i], 10);\\n            }\\n            if (i < s2.length) {\\n                n2 = parseInt(s2[i], 10);\\n            }\\n\\n            if (isNaN(n1) || isNaN(n2)) {\\n                return true;\\n            } else if (n1 !== n2) {\\n                return n1 > n2;\\n            }\\n        }\\n\\n        // will happen if both versions have identical numbers in\\n        // their components (even if one of them is longer, has more components)\\n        return false;\\n    } catch (e) {\\n        GlobalOnErrorHandler.callErrorHandler(e);\\n        logger.error('Failed to parse extension version', e);\\n\\n        return true;\\n    }\\n}\\n\\n/**\\n *\\n * @param callback\\n * @param options\\n */\\nfunction checkChromeExtInstalled(callback, options) {\\n    if (typeof chrome === 'undefined' || !chrome || !chrome.runtime) {\\n        // No API, so no extension for sure\\n        callback(false, false);\\n\\n        return;\\n    }\\n    chrome.runtime.sendMessage(options.desktopSharingChromeExtId, { getVersion: true }, function (response) {\\n        if (!response || !response.version) {\\n            // Communication failure - assume that no endpoint exists\\n            logger.warn('Extension not installed?: ', chrome.runtime.lastError);\\n            callback(false, false);\\n\\n            return;\\n        }\\n\\n        // Check installed extension version\\n        var extVersion = response.version;\\n\\n        logger.log('Extension version is: ' + extVersion);\\n        var updateRequired = isUpdateRequired(options.desktopSharingChromeMinExtVersion, extVersion);\\n\\n        callback(!updateRequired, updateRequired);\\n    });\\n}\\n\\n/**\\n *\\n * @param options\\n * @param streamCallback\\n * @param failCallback\\n */\\nfunction doGetStreamFromExtension(options, streamCallback, failCallback) {\\n    // Sends 'getStream' msg to the extension.\\n    // Extension id must be defined in the config.\\n    chrome.runtime.sendMessage(options.desktopSharingChromeExtId, {\\n        getStream: true,\\n        sources: options.desktopSharingChromeSources\\n    }, function (response) {\\n        if (!response) {\\n            // possibly re-wraping error message to make code consistent\\n            var lastError = chrome.runtime.lastError;\\n\\n            failCallback(lastError instanceof Error ? lastError : new __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__[\\\"CHROME_EXTENSION_GENERIC_ERROR\\\"], lastError));\\n\\n            return;\\n        }\\n        logger.log('Response from extension: ', response);\\n        onGetStreamResponse(response, streamCallback, failCallback);\\n    });\\n}\\n\\n/**\\n * Initializes <link rel=chrome-webstore-item /> with extension id set in\\n * config.js to support inline installs. Host site must be selected as main\\n * website of published extension.\\n * @param options supports \\\"desktopSharingChromeExtId\\\"\\n */\\nfunction initInlineInstalls(options) {\\n    if ($('link[rel=chrome-webstore-item]').length === 0) {\\n        $('head').append('<link rel=\\\"chrome-webstore-item\\\">');\\n    }\\n    $('link[rel=chrome-webstore-item]').attr('href', getWebStoreInstallUrl(options));\\n}\\n\\n/**\\n *\\n * @param options\\n *\\n * @return {Promise} - a Promise resolved once the initialization process is\\n * finished.\\n */\\nfunction initChromeExtension(options) {\\n    // Initialize Chrome extension inline installs\\n    initInlineInstalls(options);\\n\\n    return new Promise(function (resolve) {\\n        // Check if extension is installed\\n        checkChromeExtInstalled(function (installed, updateRequired) {\\n            chromeExtInstalled = installed;\\n            chromeExtUpdateRequired = updateRequired;\\n            logger.info('Chrome extension installed: ' + chromeExtInstalled + ' updateRequired: ' + chromeExtUpdateRequired);\\n            resolve();\\n        }, options);\\n    });\\n}\\n\\n/**\\n * Checks \\\"retries\\\" times on every \\\"waitInterval\\\"ms whether the ext is alive.\\n * @param {Object} options the options passed to ScreanObtainer.obtainStream\\n * @param {int} waitInterval the number of ms between retries\\n * @param {int} retries the number of retries\\n * @returns {Promise} returns promise that will be resolved when the extension\\n * is alive and rejected if the extension is not alive even after \\\"retries\\\"\\n * checks\\n */\\nfunction waitForExtensionAfterInstall(options, waitInterval, retries) {\\n    if (retries === 0) {\\n        return Promise.reject();\\n    }\\n\\n    return new Promise(function (resolve, reject) {\\n        var currentRetries = retries;\\n        var interval = window.setInterval(function () {\\n            checkChromeExtInstalled(function (installed) {\\n                if (installed) {\\n                    window.clearInterval(interval);\\n                    resolve();\\n                } else {\\n                    currentRetries--;\\n                    if (currentRetries === 0) {\\n                        reject();\\n                        window.clearInterval(interval);\\n                    }\\n                }\\n            }, options);\\n        }, waitInterval);\\n    });\\n}\\n\\n/**\\n * Handles response from external application / extension and calls GUM to\\n * receive the desktop streams or reports error.\\n * @param {object} response\\n * @param {string} response.streamId - the streamId for the desktop stream\\n * @param {string} response.error - error to be reported.\\n * @param {Function} onSuccess - callback for success.\\n * @param {Function} onFailure - callback for failure.\\n */\\nfunction onGetStreamResponse(_ref, onSuccess, onFailure) {\\n    var streamId = _ref.streamId,\\n        streamType = _ref.streamType,\\n        error = _ref.error;\\n\\n    if (streamId) {\\n        gumFunction(['desktop'], function (stream) {\\n            return onSuccess({\\n                stream: stream,\\n                sourceId: streamId,\\n                sourceType: streamType\\n            });\\n        }, onFailure, { desktopStream: streamId });\\n    } else {\\n        // As noted in Chrome Desktop Capture API:\\n        // If user didn't select any source (i.e. canceled the prompt)\\n        // then the callback is called with an empty streamId.\\n        if (streamId === '') {\\n            onFailure(new __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__[\\\"CHROME_EXTENSION_USER_CANCELED\\\"]));\\n\\n            return;\\n        }\\n\\n        onFailure(new __WEBPACK_IMPORTED_MODULE_0__JitsiTrackError__[\\\"a\\\" /* default */](__WEBPACK_IMPORTED_MODULE_1__JitsiTrackErrors__[\\\"CHROME_EXTENSION_GENERIC_ERROR\\\"], error));\\n    }\\n}\\n\\n/**\\n * Starts the detection of an installed jidesha extension for firefox.\\n * @param options supports \\\"desktopSharingFirefoxDisabled\\\",\\n * \\\"desktopSharingFirefoxExtId\\\"\\n */\\nfunction initFirefoxExtensionDetection(options) {\\n    if (options.desktopSharingFirefoxDisabled) {\\n        return;\\n    }\\n    if (firefoxExtInstalled === false || firefoxExtInstalled === true) {\\n        return;\\n    }\\n    if (!options.desktopSharingFirefoxExtId) {\\n        firefoxExtInstalled = false;\\n\\n        return;\\n    }\\n\\n    var img = document.createElement('img');\\n\\n    img.onload = function () {\\n        logger.log('Detected firefox screen sharing extension.');\\n        firefoxExtInstalled = true;\\n    };\\n    img.onerror = function () {\\n        logger.log('Detected lack of firefox screen sharing extension.');\\n        firefoxExtInstalled = false;\\n    };\\n\\n    // The jidesha extension exposes an empty image file under the url:\\n    // \\\"chrome://EXT_ID/content/DOMAIN.png\\\"\\n    // Where EXT_ID is the ID of the extension with \\\"@\\\" replaced by \\\".\\\", and\\n    // DOMAIN is a domain whitelisted by the extension.\\n    var extId = options.desktopSharingFirefoxExtId.replace('@', '.');\\n    var domain = document.location.hostname;\\n    var src = 'chrome://' + extId + '/content/' + domain + '.png';\\n\\n    img.setAttribute('src', src);\\n}\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (ScreenObtainer);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/ScreenObtainer.js\\\"))\\n\\n/***/ }),\\n/* 131 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(global) {/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n\\n\\nvar adapterFactory = __webpack_require__(132);\\nmodule.exports = adapterFactory({window: global.window});\\n\\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\\n\\n/***/ }),\\n/* 132 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n\\n\\nvar utils = __webpack_require__(11);\\n// Shimming starts here.\\nmodule.exports = function(dependencies, opts) {\\n  var window = dependencies && dependencies.window;\\n\\n  var options = {\\n    shimChrome: true,\\n    shimFirefox: true,\\n    shimEdge: true,\\n    shimSafari: true,\\n  };\\n\\n  for (var key in opts) {\\n    if (hasOwnProperty.call(opts, key)) {\\n      options[key] = opts[key];\\n    }\\n  }\\n\\n  // Utils.\\n  var logging = utils.log;\\n  var browserDetails = utils.detectBrowser(window);\\n\\n  // Export to the adapter global object visible in the browser.\\n  var adapter = {\\n    browserDetails: browserDetails,\\n    extractVersion: utils.extractVersion,\\n    disableLog: utils.disableLog,\\n    disableWarnings: utils.disableWarnings\\n  };\\n\\n  // Uncomment the line below if you want logging to occur, including logging\\n  // for the switch statement below. Can also be turned on in the browser via\\n  // adapter.disableLog(false), but then logging from the switch statement below\\n  // will not appear.\\n  // require('./utils').disableLog(false);\\n\\n  // Browser shims.\\n  var chromeShim = __webpack_require__(133) || null;\\n  var edgeShim = __webpack_require__(135) || null;\\n  var firefoxShim = __webpack_require__(138) || null;\\n  var safariShim = __webpack_require__(140) || null;\\n  var commonShim = __webpack_require__(141) || null;\\n\\n  // Shim browser if found.\\n  switch (browserDetails.browser) {\\n    case 'chrome':\\n      if (!chromeShim || !chromeShim.shimPeerConnection ||\\n          !options.shimChrome) {\\n        logging('Chrome shim is not included in this adapter release.');\\n        return adapter;\\n      }\\n      logging('adapter.js shimming chrome.');\\n      // Export to the adapter global object visible in the browser.\\n      adapter.browserShim = chromeShim;\\n      commonShim.shimCreateObjectURL(window);\\n\\n      chromeShim.shimGetUserMedia(window);\\n      chromeShim.shimMediaStream(window);\\n      chromeShim.shimSourceObject(window);\\n      chromeShim.shimPeerConnection(window);\\n      chromeShim.shimOnTrack(window);\\n      chromeShim.shimAddTrackRemoveTrack(window);\\n      chromeShim.shimGetSendersWithDtmf(window);\\n\\n      commonShim.shimRTCIceCandidate(window);\\n      break;\\n    case 'firefox':\\n      if (!firefoxShim || !firefoxShim.shimPeerConnection ||\\n          !options.shimFirefox) {\\n        logging('Firefox shim is not included in this adapter release.');\\n        return adapter;\\n      }\\n      logging('adapter.js shimming firefox.');\\n      // Export to the adapter global object visible in the browser.\\n      adapter.browserShim = firefoxShim;\\n      commonShim.shimCreateObjectURL(window);\\n\\n      firefoxShim.shimGetUserMedia(window);\\n      firefoxShim.shimSourceObject(window);\\n      firefoxShim.shimPeerConnection(window);\\n      firefoxShim.shimOnTrack(window);\\n\\n      commonShim.shimRTCIceCandidate(window);\\n      break;\\n    case 'edge':\\n      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {\\n        logging('MS edge shim is not included in this adapter release.');\\n        return adapter;\\n      }\\n      logging('adapter.js shimming edge.');\\n      // Export to the adapter global object visible in the browser.\\n      adapter.browserShim = edgeShim;\\n      commonShim.shimCreateObjectURL(window);\\n\\n      edgeShim.shimGetUserMedia(window);\\n      edgeShim.shimPeerConnection(window);\\n      edgeShim.shimReplaceTrack(window);\\n\\n      // the edge shim implements the full RTCIceCandidate object.\\n      break;\\n    case 'safari':\\n      if (!safariShim || !options.shimSafari) {\\n        logging('Safari shim is not included in this adapter release.');\\n        return adapter;\\n      }\\n      logging('adapter.js shimming safari.');\\n      // Export to the adapter global object visible in the browser.\\n      adapter.browserShim = safariShim;\\n      commonShim.shimCreateObjectURL(window);\\n\\n      safariShim.shimRTCIceServerUrls(window);\\n      safariShim.shimCallbacksAPI(window);\\n      safariShim.shimLocalStreamsAPI(window);\\n      safariShim.shimRemoteStreamsAPI(window);\\n      safariShim.shimTrackEventTransceiver(window);\\n      safariShim.shimGetUserMedia(window);\\n      safariShim.shimCreateOfferLegacy(window);\\n\\n      commonShim.shimRTCIceCandidate(window);\\n      break;\\n    default:\\n      logging('Unsupported browser!');\\n      break;\\n  }\\n\\n  return adapter;\\n};\\n\\n\\n/***/ }),\\n/* 133 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\nvar utils = __webpack_require__(11);\\nvar logging = utils.log;\\n\\nvar chromeShim = {\\n  shimMediaStream: function(window) {\\n    window.MediaStream = window.MediaStream || window.webkitMediaStream;\\n  },\\n\\n  shimOnTrack: function(window) {\\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\\n        window.RTCPeerConnection.prototype)) {\\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\\n        get: function() {\\n          return this._ontrack;\\n        },\\n        set: function(f) {\\n          if (this._ontrack) {\\n            this.removeEventListener('track', this._ontrack);\\n          }\\n          this.addEventListener('track', this._ontrack = f);\\n        }\\n      });\\n      var origSetRemoteDescription =\\n          window.RTCPeerConnection.prototype.setRemoteDescription;\\n      window.RTCPeerConnection.prototype.setRemoteDescription = function() {\\n        var pc = this;\\n        if (!pc._ontrackpoly) {\\n          pc._ontrackpoly = function(e) {\\n            // onaddstream does not fire when a track is added to an existing\\n            // stream. But stream.onaddtrack is implemented so we use that.\\n            e.stream.addEventListener('addtrack', function(te) {\\n              var receiver;\\n              if (window.RTCPeerConnection.prototype.getReceivers) {\\n                receiver = pc.getReceivers().find(function(r) {\\n                  return r.track && r.track.id === te.track.id;\\n                });\\n              } else {\\n                receiver = {track: te.track};\\n              }\\n\\n              var event = new Event('track');\\n              event.track = te.track;\\n              event.receiver = receiver;\\n              event.transceiver = {receiver: receiver};\\n              event.streams = [e.stream];\\n              pc.dispatchEvent(event);\\n            });\\n            e.stream.getTracks().forEach(function(track) {\\n              var receiver;\\n              if (window.RTCPeerConnection.prototype.getReceivers) {\\n                receiver = pc.getReceivers().find(function(r) {\\n                  return r.track && r.track.id === track.id;\\n                });\\n              } else {\\n                receiver = {track: track};\\n              }\\n              var event = new Event('track');\\n              event.track = track;\\n              event.receiver = receiver;\\n              event.transceiver = {receiver: receiver};\\n              event.streams = [e.stream];\\n              pc.dispatchEvent(event);\\n            });\\n          };\\n          pc.addEventListener('addstream', pc._ontrackpoly);\\n        }\\n        return origSetRemoteDescription.apply(pc, arguments);\\n      };\\n    }\\n  },\\n\\n  shimGetSendersWithDtmf: function(window) {\\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\\n    if (typeof window === 'object' && window.RTCPeerConnection &&\\n        !('getSenders' in window.RTCPeerConnection.prototype) &&\\n        'createDTMFSender' in window.RTCPeerConnection.prototype) {\\n      var shimSenderWithDtmf = function(pc, track) {\\n        return {\\n          track: track,\\n          get dtmf() {\\n            if (this._dtmf === undefined) {\\n              if (track.kind === 'audio') {\\n                this._dtmf = pc.createDTMFSender(track);\\n              } else {\\n                this._dtmf = null;\\n              }\\n            }\\n            return this._dtmf;\\n          },\\n          _pc: pc\\n        };\\n      };\\n\\n      // augment addTrack when getSenders is not available.\\n      if (!window.RTCPeerConnection.prototype.getSenders) {\\n        window.RTCPeerConnection.prototype.getSenders = function() {\\n          this._senders = this._senders || [];\\n          return this._senders.slice(); // return a copy of the internal state.\\n        };\\n        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\\n        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\\n          var pc = this;\\n          var sender = origAddTrack.apply(pc, arguments);\\n          if (!sender) {\\n            sender = shimSenderWithDtmf(pc, track);\\n            pc._senders.push(sender);\\n          }\\n          return sender;\\n        };\\n\\n        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\\n        window.RTCPeerConnection.prototype.removeTrack = function(sender) {\\n          var pc = this;\\n          origRemoveTrack.apply(pc, arguments);\\n          var idx = pc._senders.indexOf(sender);\\n          if (idx !== -1) {\\n            pc._senders.splice(idx, 1);\\n          }\\n        };\\n      }\\n      var origAddStream = window.RTCPeerConnection.prototype.addStream;\\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\\n        var pc = this;\\n        pc._senders = pc._senders || [];\\n        origAddStream.apply(pc, [stream]);\\n        stream.getTracks().forEach(function(track) {\\n          pc._senders.push(shimSenderWithDtmf(pc, track));\\n        });\\n      };\\n\\n      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\\n        var pc = this;\\n        pc._senders = pc._senders || [];\\n        origRemoveStream.apply(pc, [stream]);\\n\\n        stream.getTracks().forEach(function(track) {\\n          var sender = pc._senders.find(function(s) {\\n            return s.track === track;\\n          });\\n          if (sender) {\\n            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender\\n          }\\n        });\\n      };\\n    } else if (typeof window === 'object' && window.RTCPeerConnection &&\\n               'getSenders' in window.RTCPeerConnection.prototype &&\\n               'createDTMFSender' in window.RTCPeerConnection.prototype &&\\n               window.RTCRtpSender &&\\n               !('dtmf' in window.RTCRtpSender.prototype)) {\\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\\n      window.RTCPeerConnection.prototype.getSenders = function() {\\n        var pc = this;\\n        var senders = origGetSenders.apply(pc, []);\\n        senders.forEach(function(sender) {\\n          sender._pc = pc;\\n        });\\n        return senders;\\n      };\\n\\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\\n        get: function() {\\n          if (this._dtmf === undefined) {\\n            if (this.track.kind === 'audio') {\\n              this._dtmf = this._pc.createDTMFSender(this.track);\\n            } else {\\n              this._dtmf = null;\\n            }\\n          }\\n          return this._dtmf;\\n        }\\n      });\\n    }\\n  },\\n\\n  shimSourceObject: function(window) {\\n    var URL = window && window.URL;\\n\\n    if (typeof window === 'object') {\\n      if (window.HTMLMediaElement &&\\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\\n          get: function() {\\n            return this._srcObject;\\n          },\\n          set: function(stream) {\\n            var self = this;\\n            // Use _srcObject as a private property for this shim\\n            this._srcObject = stream;\\n            if (this.src) {\\n              URL.revokeObjectURL(this.src);\\n            }\\n\\n            if (!stream) {\\n              this.src = '';\\n              return undefined;\\n            }\\n            this.src = URL.createObjectURL(stream);\\n            // We need to recreate the blob url when a track is added or\\n            // removed. Doing it manually since we want to avoid a recursion.\\n            stream.addEventListener('addtrack', function() {\\n              if (self.src) {\\n                URL.revokeObjectURL(self.src);\\n              }\\n              self.src = URL.createObjectURL(stream);\\n            });\\n            stream.addEventListener('removetrack', function() {\\n              if (self.src) {\\n                URL.revokeObjectURL(self.src);\\n              }\\n              self.src = URL.createObjectURL(stream);\\n            });\\n          }\\n        });\\n      }\\n    }\\n  },\\n\\n  shimAddTrackRemoveTrack: function(window) {\\n    var browserDetails = utils.detectBrowser(window);\\n    // shim addTrack and removeTrack.\\n    if (window.RTCPeerConnection.prototype.addTrack &&\\n        browserDetails.version >= 63) {\\n      return;\\n    }\\n\\n    // also shim pc.getLocalStreams when addTrack is shimmed\\n    // to return the original streams.\\n    var origGetLocalStreams = window.RTCPeerConnection.prototype\\n        .getLocalStreams;\\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\\n      var self = this;\\n      var nativeStreams = origGetLocalStreams.apply(this);\\n      self._reverseStreams = self._reverseStreams || {};\\n      return nativeStreams.map(function(stream) {\\n        return self._reverseStreams[stream.id];\\n      });\\n    };\\n\\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\\n      var pc = this;\\n      pc._streams = pc._streams || {};\\n      pc._reverseStreams = pc._reverseStreams || {};\\n\\n      stream.getTracks().forEach(function(track) {\\n        var alreadyExists = pc.getSenders().find(function(s) {\\n          return s.track === track;\\n        });\\n        if (alreadyExists) {\\n          throw new DOMException('Track already exists.',\\n              'InvalidAccessError');\\n        }\\n      });\\n      // Add identity mapping for consistency with addTrack.\\n      // Unless this is being used with a stream from addTrack.\\n      if (!pc._reverseStreams[stream.id]) {\\n        var newStream = new window.MediaStream(stream.getTracks());\\n        pc._streams[stream.id] = newStream;\\n        pc._reverseStreams[newStream.id] = stream;\\n        stream = newStream;\\n      }\\n      origAddStream.apply(pc, [stream]);\\n    };\\n\\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\\n      var pc = this;\\n      pc._streams = pc._streams || {};\\n      pc._reverseStreams = pc._reverseStreams || {};\\n\\n      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);\\n      delete pc._reverseStreams[(pc._streams[stream.id] ?\\n          pc._streams[stream.id].id : stream.id)];\\n      delete pc._streams[stream.id];\\n    };\\n\\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\\n      var pc = this;\\n      if (pc.signalingState === 'closed') {\\n        throw new DOMException(\\n          'The RTCPeerConnection\\\\'s signalingState is \\\\'closed\\\\'.',\\n          'InvalidStateError');\\n      }\\n      var streams = [].slice.call(arguments, 1);\\n      if (streams.length !== 1 ||\\n          !streams[0].getTracks().find(function(t) {\\n            return t === track;\\n          })) {\\n        // this is not fully correct but all we can manage without\\n        // [[associated MediaStreams]] internal slot.\\n        throw new DOMException(\\n          'The adapter.js addTrack polyfill only supports a single ' +\\n          ' stream which is associated with the specified track.',\\n          'NotSupportedError');\\n      }\\n\\n      var alreadyExists = pc.getSenders().find(function(s) {\\n        return s.track === track;\\n      });\\n      if (alreadyExists) {\\n        throw new DOMException('Track already exists.',\\n            'InvalidAccessError');\\n      }\\n\\n      pc._streams = pc._streams || {};\\n      pc._reverseStreams = pc._reverseStreams || {};\\n      var oldStream = pc._streams[stream.id];\\n      if (oldStream) {\\n        // this is using odd Chrome behaviour, use with caution:\\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\\n        // Note: we rely on the high-level addTrack/dtmf shim to\\n        // create the sender with a dtmf sender.\\n        oldStream.addTrack(track);\\n\\n        // Trigger ONN async.\\n        Promise.resolve().then(function() {\\n          pc.dispatchEvent(new Event('negotiationneeded'));\\n        });\\n      } else {\\n        var newStream = new window.MediaStream([track]);\\n        pc._streams[stream.id] = newStream;\\n        pc._reverseStreams[newStream.id] = stream;\\n        pc.addStream(newStream);\\n      }\\n      return pc.getSenders().find(function(s) {\\n        return s.track === track;\\n      });\\n    };\\n\\n    // replace the internal stream id with the external one and\\n    // vice versa.\\n    function replaceInternalStreamId(pc, description) {\\n      var sdp = description.sdp;\\n      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {\\n        var externalStream = pc._reverseStreams[internalId];\\n        var internalStream = pc._streams[externalStream.id];\\n        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\\n            externalStream.id);\\n      });\\n      return new RTCSessionDescription({\\n        type: description.type,\\n        sdp: sdp\\n      });\\n    }\\n    function replaceExternalStreamId(pc, description) {\\n      var sdp = description.sdp;\\n      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {\\n        var externalStream = pc._reverseStreams[internalId];\\n        var internalStream = pc._streams[externalStream.id];\\n        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\\n            internalStream.id);\\n      });\\n      return new RTCSessionDescription({\\n        type: description.type,\\n        sdp: sdp\\n      });\\n    }\\n    ['createOffer', 'createAnswer'].forEach(function(method) {\\n      var nativeMethod = window.RTCPeerConnection.prototype[method];\\n      window.RTCPeerConnection.prototype[method] = function() {\\n        var pc = this;\\n        var args = arguments;\\n        var isLegacyCall = arguments.length &&\\n            typeof arguments[0] === 'function';\\n        if (isLegacyCall) {\\n          return nativeMethod.apply(pc, [\\n            function(description) {\\n              var desc = replaceInternalStreamId(pc, description);\\n              args[0].apply(null, [desc]);\\n            },\\n            function(err) {\\n              if (args[1]) {\\n                args[1].apply(null, err);\\n              }\\n            }, arguments[2]\\n          ]);\\n        }\\n        return nativeMethod.apply(pc, arguments)\\n        .then(function(description) {\\n          return replaceInternalStreamId(pc, description);\\n        });\\n      };\\n    });\\n\\n    var origSetLocalDescription =\\n        window.RTCPeerConnection.prototype.setLocalDescription;\\n    window.RTCPeerConnection.prototype.setLocalDescription = function() {\\n      var pc = this;\\n      if (!arguments.length || !arguments[0].type) {\\n        return origSetLocalDescription.apply(pc, arguments);\\n      }\\n      arguments[0] = replaceExternalStreamId(pc, arguments[0]);\\n      return origSetLocalDescription.apply(pc, arguments);\\n    };\\n\\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\\n\\n    var origLocalDescription = Object.getOwnPropertyDescriptor(\\n        window.RTCPeerConnection.prototype, 'localDescription');\\n    Object.defineProperty(window.RTCPeerConnection.prototype,\\n        'localDescription', {\\n          get: function() {\\n            var pc = this;\\n            var description = origLocalDescription.get.apply(this);\\n            if (description.type === '') {\\n              return description;\\n            }\\n            return replaceInternalStreamId(pc, description);\\n          }\\n        });\\n\\n    window.RTCPeerConnection.prototype.removeTrack = function(sender) {\\n      var pc = this;\\n      if (pc.signalingState === 'closed') {\\n        throw new DOMException(\\n          'The RTCPeerConnection\\\\'s signalingState is \\\\'closed\\\\'.',\\n          'InvalidStateError');\\n      }\\n      // We can not yet check for sender instanceof RTCRtpSender\\n      // since we shim RTPSender. So we check if sender._pc is set.\\n      if (!sender._pc) {\\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\\n            'does not implement interface RTCRtpSender.', 'TypeError');\\n      }\\n      var isLocal = sender._pc === pc;\\n      if (!isLocal) {\\n        throw new DOMException('Sender was not created by this connection.',\\n            'InvalidAccessError');\\n      }\\n\\n      // Search for the native stream the senders track belongs to.\\n      pc._streams = pc._streams || {};\\n      var stream;\\n      Object.keys(pc._streams).forEach(function(streamid) {\\n        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {\\n          return sender.track === track;\\n        });\\n        if (hasTrack) {\\n          stream = pc._streams[streamid];\\n        }\\n      });\\n\\n      if (stream) {\\n        if (stream.getTracks().length === 1) {\\n          // if this is the last track of the stream, remove the stream. This\\n          // takes care of any shimmed _senders.\\n          pc.removeStream(pc._reverseStreams[stream.id]);\\n        } else {\\n          // relying on the same odd chrome behaviour as above.\\n          stream.removeTrack(sender.track);\\n        }\\n        pc.dispatchEvent(new Event('negotiationneeded'));\\n      }\\n    };\\n  },\\n\\n  shimPeerConnection: function(window) {\\n    var browserDetails = utils.detectBrowser(window);\\n\\n    // The RTCPeerConnection object.\\n    if (!window.RTCPeerConnection) {\\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\\n        // Translate iceTransportPolicy to iceTransports,\\n        // see https://code.google.com/p/webrtc/issues/detail?id=4869\\n        // this was fixed in M56 along with unprefixing RTCPeerConnection.\\n        logging('PeerConnection');\\n        if (pcConfig && pcConfig.iceTransportPolicy) {\\n          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\\n        }\\n\\n        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);\\n      };\\n      window.RTCPeerConnection.prototype =\\n          window.webkitRTCPeerConnection.prototype;\\n      // wrap static methods. Currently just generateCertificate.\\n      if (window.webkitRTCPeerConnection.generateCertificate) {\\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\\n          get: function() {\\n            return window.webkitRTCPeerConnection.generateCertificate;\\n          }\\n        });\\n      }\\n    } else {\\n      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\\n      var OrigPeerConnection = window.RTCPeerConnection;\\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\\n        if (pcConfig && pcConfig.iceServers) {\\n          var newIceServers = [];\\n          for (var i = 0; i < pcConfig.iceServers.length; i++) {\\n            var server = pcConfig.iceServers[i];\\n            if (!server.hasOwnProperty('urls') &&\\n                server.hasOwnProperty('url')) {\\n              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\\n              server = JSON.parse(JSON.stringify(server));\\n              server.urls = server.url;\\n              newIceServers.push(server);\\n            } else {\\n              newIceServers.push(pcConfig.iceServers[i]);\\n            }\\n          }\\n          pcConfig.iceServers = newIceServers;\\n        }\\n        return new OrigPeerConnection(pcConfig, pcConstraints);\\n      };\\n      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\\n      // wrap static methods. Currently just generateCertificate.\\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\\n        get: function() {\\n          return OrigPeerConnection.generateCertificate;\\n        }\\n      });\\n    }\\n\\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\\n    window.RTCPeerConnection.prototype.getStats = function(selector,\\n        successCallback, errorCallback) {\\n      var self = this;\\n      var args = arguments;\\n\\n      // If selector is a function then we are in the old style stats so just\\n      // pass back the original getStats format to avoid breaking old users.\\n      if (arguments.length > 0 && typeof selector === 'function') {\\n        return origGetStats.apply(this, arguments);\\n      }\\n\\n      // When spec-style getStats is supported, return those when called with\\n      // either no arguments or the selector argument is null.\\n      if (origGetStats.length === 0 && (arguments.length === 0 ||\\n          typeof arguments[0] !== 'function')) {\\n        return origGetStats.apply(this, []);\\n      }\\n\\n      var fixChromeStats_ = function(response) {\\n        var standardReport = {};\\n        var reports = response.result();\\n        reports.forEach(function(report) {\\n          var standardStats = {\\n            id: report.id,\\n            timestamp: report.timestamp,\\n            type: {\\n              localcandidate: 'local-candidate',\\n              remotecandidate: 'remote-candidate'\\n            }[report.type] || report.type\\n          };\\n          report.names().forEach(function(name) {\\n            standardStats[name] = report.stat(name);\\n          });\\n          standardReport[standardStats.id] = standardStats;\\n        });\\n\\n        return standardReport;\\n      };\\n\\n      // shim getStats with maplike support\\n      var makeMapStats = function(stats) {\\n        return new Map(Object.keys(stats).map(function(key) {\\n          return [key, stats[key]];\\n        }));\\n      };\\n\\n      if (arguments.length >= 2) {\\n        var successCallbackWrapper_ = function(response) {\\n          args[1](makeMapStats(fixChromeStats_(response)));\\n        };\\n\\n        return origGetStats.apply(this, [successCallbackWrapper_,\\n          arguments[0]]);\\n      }\\n\\n      // promise-support\\n      return new Promise(function(resolve, reject) {\\n        origGetStats.apply(self, [\\n          function(response) {\\n            resolve(makeMapStats(fixChromeStats_(response)));\\n          }, reject]);\\n      }).then(successCallback, errorCallback);\\n    };\\n\\n    // add promise support -- natively available in Chrome 51\\n    if (browserDetails.version < 51) {\\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\\n          .forEach(function(method) {\\n            var nativeMethod = window.RTCPeerConnection.prototype[method];\\n            window.RTCPeerConnection.prototype[method] = function() {\\n              var args = arguments;\\n              var self = this;\\n              var promise = new Promise(function(resolve, reject) {\\n                nativeMethod.apply(self, [args[0], resolve, reject]);\\n              });\\n              if (args.length < 2) {\\n                return promise;\\n              }\\n              return promise.then(function() {\\n                args[1].apply(null, []);\\n              },\\n              function(err) {\\n                if (args.length >= 3) {\\n                  args[2].apply(null, [err]);\\n                }\\n              });\\n            };\\n          });\\n    }\\n\\n    // promise support for createOffer and createAnswer. Available (without\\n    // bugs) since M52: crbug/619289\\n    if (browserDetails.version < 52) {\\n      ['createOffer', 'createAnswer'].forEach(function(method) {\\n        var nativeMethod = window.RTCPeerConnection.prototype[method];\\n        window.RTCPeerConnection.prototype[method] = function() {\\n          var self = this;\\n          if (arguments.length < 1 || (arguments.length === 1 &&\\n              typeof arguments[0] === 'object')) {\\n            var opts = arguments.length === 1 ? arguments[0] : undefined;\\n            return new Promise(function(resolve, reject) {\\n              nativeMethod.apply(self, [resolve, reject, opts]);\\n            });\\n          }\\n          return nativeMethod.apply(this, arguments);\\n        };\\n      });\\n    }\\n\\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\\n        .forEach(function(method) {\\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\\n          window.RTCPeerConnection.prototype[method] = function() {\\n            arguments[0] = new ((method === 'addIceCandidate') ?\\n                window.RTCIceCandidate :\\n                window.RTCSessionDescription)(arguments[0]);\\n            return nativeMethod.apply(this, arguments);\\n          };\\n        });\\n\\n    // support for addIceCandidate(null or undefined)\\n    var nativeAddIceCandidate =\\n        window.RTCPeerConnection.prototype.addIceCandidate;\\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\\n      if (!arguments[0]) {\\n        if (arguments[1]) {\\n          arguments[1].apply(null);\\n        }\\n        return Promise.resolve();\\n      }\\n      return nativeAddIceCandidate.apply(this, arguments);\\n    };\\n  }\\n};\\n\\n\\n// Expose public methods.\\nmodule.exports = {\\n  shimMediaStream: chromeShim.shimMediaStream,\\n  shimOnTrack: chromeShim.shimOnTrack,\\n  shimAddTrackRemoveTrack: chromeShim.shimAddTrackRemoveTrack,\\n  shimGetSendersWithDtmf: chromeShim.shimGetSendersWithDtmf,\\n  shimSourceObject: chromeShim.shimSourceObject,\\n  shimPeerConnection: chromeShim.shimPeerConnection,\\n  shimGetUserMedia: __webpack_require__(134)\\n};\\n\\n\\n/***/ }),\\n/* 134 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\nvar utils = __webpack_require__(11);\\nvar logging = utils.log;\\n\\n// Expose public methods.\\nmodule.exports = function(window) {\\n  var browserDetails = utils.detectBrowser(window);\\n  var navigator = window && window.navigator;\\n\\n  var constraintsToChrome_ = function(c) {\\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\\n      return c;\\n    }\\n    var cc = {};\\n    Object.keys(c).forEach(function(key) {\\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\\n        return;\\n      }\\n      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\\n      if (r.exact !== undefined && typeof r.exact === 'number') {\\n        r.min = r.max = r.exact;\\n      }\\n      var oldname_ = function(prefix, name) {\\n        if (prefix) {\\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\\n        }\\n        return (name === 'deviceId') ? 'sourceId' : name;\\n      };\\n      if (r.ideal !== undefined) {\\n        cc.optional = cc.optional || [];\\n        var oc = {};\\n        if (typeof r.ideal === 'number') {\\n          oc[oldname_('min', key)] = r.ideal;\\n          cc.optional.push(oc);\\n          oc = {};\\n          oc[oldname_('max', key)] = r.ideal;\\n          cc.optional.push(oc);\\n        } else {\\n          oc[oldname_('', key)] = r.ideal;\\n          cc.optional.push(oc);\\n        }\\n      }\\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\\n        cc.mandatory = cc.mandatory || {};\\n        cc.mandatory[oldname_('', key)] = r.exact;\\n      } else {\\n        ['min', 'max'].forEach(function(mix) {\\n          if (r[mix] !== undefined) {\\n            cc.mandatory = cc.mandatory || {};\\n            cc.mandatory[oldname_(mix, key)] = r[mix];\\n          }\\n        });\\n      }\\n    });\\n    if (c.advanced) {\\n      cc.optional = (cc.optional || []).concat(c.advanced);\\n    }\\n    return cc;\\n  };\\n\\n  var shimConstraints_ = function(constraints, func) {\\n    if (browserDetails.version >= 61) {\\n      return func(constraints);\\n    }\\n    constraints = JSON.parse(JSON.stringify(constraints));\\n    if (constraints && typeof constraints.audio === 'object') {\\n      var remap = function(obj, a, b) {\\n        if (a in obj && !(b in obj)) {\\n          obj[b] = obj[a];\\n          delete obj[a];\\n        }\\n      };\\n      constraints = JSON.parse(JSON.stringify(constraints));\\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\\n      constraints.audio = constraintsToChrome_(constraints.audio);\\n    }\\n    if (constraints && typeof constraints.video === 'object') {\\n      // Shim facingMode for mobile & surface pro.\\n      var face = constraints.video.facingMode;\\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\\n      var getSupportedFacingModeLies = browserDetails.version < 66;\\n\\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\\n          !(navigator.mediaDevices.getSupportedConstraints &&\\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\\n            !getSupportedFacingModeLies)) {\\n        delete constraints.video.facingMode;\\n        var matches;\\n        if (face.exact === 'environment' || face.ideal === 'environment') {\\n          matches = ['back', 'rear'];\\n        } else if (face.exact === 'user' || face.ideal === 'user') {\\n          matches = ['front'];\\n        }\\n        if (matches) {\\n          // Look for matches in label, or use last cam for back (typical).\\n          return navigator.mediaDevices.enumerateDevices()\\n          .then(function(devices) {\\n            devices = devices.filter(function(d) {\\n              return d.kind === 'videoinput';\\n            });\\n            var dev = devices.find(function(d) {\\n              return matches.some(function(match) {\\n                return d.label.toLowerCase().indexOf(match) !== -1;\\n              });\\n            });\\n            if (!dev && devices.length && matches.indexOf('back') !== -1) {\\n              dev = devices[devices.length - 1]; // more likely the back cam\\n            }\\n            if (dev) {\\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\\n                                                        {ideal: dev.deviceId};\\n            }\\n            constraints.video = constraintsToChrome_(constraints.video);\\n            logging('chrome: ' + JSON.stringify(constraints));\\n            return func(constraints);\\n          });\\n        }\\n      }\\n      constraints.video = constraintsToChrome_(constraints.video);\\n    }\\n    logging('chrome: ' + JSON.stringify(constraints));\\n    return func(constraints);\\n  };\\n\\n  var shimError_ = function(e) {\\n    return {\\n      name: {\\n        PermissionDeniedError: 'NotAllowedError',\\n        InvalidStateError: 'NotReadableError',\\n        DevicesNotFoundError: 'NotFoundError',\\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\\n        TrackStartError: 'NotReadableError',\\n        MediaDeviceFailedDueToShutdown: 'NotReadableError',\\n        MediaDeviceKillSwitchOn: 'NotReadableError'\\n      }[e.name] || e.name,\\n      message: e.message,\\n      constraint: e.constraintName,\\n      toString: function() {\\n        return this.name + (this.message && ': ') + this.message;\\n      }\\n    };\\n  };\\n\\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\\n    shimConstraints_(constraints, function(c) {\\n      navigator.webkitGetUserMedia(c, onSuccess, function(e) {\\n        if (onError) {\\n          onError(shimError_(e));\\n        }\\n      });\\n    });\\n  };\\n\\n  navigator.getUserMedia = getUserMedia_;\\n\\n  // Returns the result of getUserMedia as a Promise.\\n  var getUserMediaPromise_ = function(constraints) {\\n    return new Promise(function(resolve, reject) {\\n      navigator.getUserMedia(constraints, resolve, reject);\\n    });\\n  };\\n\\n  if (!navigator.mediaDevices) {\\n    navigator.mediaDevices = {\\n      getUserMedia: getUserMediaPromise_,\\n      enumerateDevices: function() {\\n        return new Promise(function(resolve) {\\n          var kinds = {audio: 'audioinput', video: 'videoinput'};\\n          return window.MediaStreamTrack.getSources(function(devices) {\\n            resolve(devices.map(function(device) {\\n              return {label: device.label,\\n                kind: kinds[device.kind],\\n                deviceId: device.id,\\n                groupId: ''};\\n            }));\\n          });\\n        });\\n      },\\n      getSupportedConstraints: function() {\\n        return {\\n          deviceId: true, echoCancellation: true, facingMode: true,\\n          frameRate: true, height: true, width: true\\n        };\\n      }\\n    };\\n  }\\n\\n  // A shim for getUserMedia method on the mediaDevices object.\\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\\n  if (!navigator.mediaDevices.getUserMedia) {\\n    navigator.mediaDevices.getUserMedia = function(constraints) {\\n      return getUserMediaPromise_(constraints);\\n    };\\n  } else {\\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\\n    // function which returns a Promise, it does not accept spec-style\\n    // constraints.\\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\\n        bind(navigator.mediaDevices);\\n    navigator.mediaDevices.getUserMedia = function(cs) {\\n      return shimConstraints_(cs, function(c) {\\n        return origGetUserMedia(c).then(function(stream) {\\n          if (c.audio && !stream.getAudioTracks().length ||\\n              c.video && !stream.getVideoTracks().length) {\\n            stream.getTracks().forEach(function(track) {\\n              track.stop();\\n            });\\n            throw new DOMException('', 'NotFoundError');\\n          }\\n          return stream;\\n        }, function(e) {\\n          return Promise.reject(shimError_(e));\\n        });\\n      });\\n    };\\n  }\\n\\n  // Dummy devicechange event methods.\\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\\n  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\\n    navigator.mediaDevices.addEventListener = function() {\\n      logging('Dummy mediaDevices.addEventListener called.');\\n    };\\n  }\\n  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\\n    navigator.mediaDevices.removeEventListener = function() {\\n      logging('Dummy mediaDevices.removeEventListener called.');\\n    };\\n  }\\n};\\n\\n\\n/***/ }),\\n/* 135 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n\\nvar utils = __webpack_require__(11);\\nvar shimRTCPeerConnection = __webpack_require__(136);\\n\\nmodule.exports = {\\n  shimGetUserMedia: __webpack_require__(137),\\n  shimPeerConnection: function(window) {\\n    var browserDetails = utils.detectBrowser(window);\\n\\n    if (window.RTCIceGatherer) {\\n      // ORTC defines an RTCIceCandidate object but no constructor.\\n      // Not implemented in Edge.\\n      if (!window.RTCIceCandidate) {\\n        window.RTCIceCandidate = function(args) {\\n          return args;\\n        };\\n      }\\n      // ORTC does not have a session description object but\\n      // other browsers (i.e. Chrome) that will support both PC and ORTC\\n      // in the future might have this defined already.\\n      if (!window.RTCSessionDescription) {\\n        window.RTCSessionDescription = function(args) {\\n          return args;\\n        };\\n      }\\n      // this adds an additional event listener to MediaStrackTrack that signals\\n      // when a tracks enabled property was changed. Workaround for a bug in\\n      // addStream, see below. No longer required in 15025+\\n      if (browserDetails.version < 15025) {\\n        var origMSTEnabled = Object.getOwnPropertyDescriptor(\\n            window.MediaStreamTrack.prototype, 'enabled');\\n        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\\n          set: function(value) {\\n            origMSTEnabled.set.call(this, value);\\n            var ev = new Event('enabled');\\n            ev.enabled = value;\\n            this.dispatchEvent(ev);\\n          }\\n        });\\n      }\\n    }\\n\\n    // ORTC defines the DTMF sender a bit different.\\n    // https://github.com/w3c/ortc/issues/714\\n    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\\n        get: function() {\\n          if (this._dtmf === undefined) {\\n            if (this.track.kind === 'audio') {\\n              this._dtmf = new window.RTCDtmfSender(this);\\n            } else if (this.track.kind === 'video') {\\n              this._dtmf = null;\\n            }\\n          }\\n          return this._dtmf;\\n        }\\n      });\\n    }\\n\\n    window.RTCPeerConnection =\\n        shimRTCPeerConnection(window, browserDetails.version);\\n  },\\n  shimReplaceTrack: function(window) {\\n    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\\n    if (window.RTCRtpSender &&\\n        !('replaceTrack' in window.RTCRtpSender.prototype)) {\\n      window.RTCRtpSender.prototype.replaceTrack =\\n          window.RTCRtpSender.prototype.setTrack;\\n    }\\n  }\\n};\\n\\n\\n/***/ }),\\n/* 136 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*\\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n\\nvar SDPUtils = __webpack_require__(57);\\n\\nfunction writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\\n\\n  // Map ICE parameters (ufrag, pwd) to SDP.\\n  sdp += SDPUtils.writeIceParameters(\\n      transceiver.iceGatherer.getLocalParameters());\\n\\n  // Map DTLS parameters to SDP.\\n  sdp += SDPUtils.writeDtlsParameters(\\n      transceiver.dtlsTransport.getLocalParameters(),\\n      type === 'offer' ? 'actpass' : dtlsRole || 'active');\\n\\n  sdp += 'a=mid:' + transceiver.mid + '\\\\r\\\\n';\\n\\n  if (transceiver.rtpSender && transceiver.rtpReceiver) {\\n    sdp += 'a=sendrecv\\\\r\\\\n';\\n  } else if (transceiver.rtpSender) {\\n    sdp += 'a=sendonly\\\\r\\\\n';\\n  } else if (transceiver.rtpReceiver) {\\n    sdp += 'a=recvonly\\\\r\\\\n';\\n  } else {\\n    sdp += 'a=inactive\\\\r\\\\n';\\n  }\\n\\n  if (transceiver.rtpSender) {\\n    // spec.\\n    var msid = 'msid:' + stream.id + ' ' +\\n        transceiver.rtpSender.track.id + '\\\\r\\\\n';\\n    sdp += 'a=' + msid;\\n\\n    // for Chrome.\\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\\n        ' ' + msid;\\n    if (transceiver.sendEncodingParameters[0].rtx) {\\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\\n          ' ' + msid;\\n      sdp += 'a=ssrc-group:FID ' +\\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\\n          '\\\\r\\\\n';\\n    }\\n  }\\n  // FIXME: this should be written by writeRtpDescription.\\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\\n      ' cname:' + SDPUtils.localCName + '\\\\r\\\\n';\\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\\n        ' cname:' + SDPUtils.localCName + '\\\\r\\\\n';\\n  }\\n  return sdp;\\n}\\n\\n// Edge does not like\\n// 1) stun: filtered after 14393 unless ?transport=udp is present\\n// 2) turn: that does not have all of turn:host:port?transport=udp\\n// 3) turn: with ipv6 addresses\\n// 4) turn: occurring muliple times\\nfunction filterIceServers(iceServers, edgeVersion) {\\n  var hasTurn = false;\\n  iceServers = JSON.parse(JSON.stringify(iceServers));\\n  return iceServers.filter(function(server) {\\n    if (server && (server.urls || server.url)) {\\n      var urls = server.urls || server.url;\\n      if (server.url && !server.urls) {\\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\\n      }\\n      var isString = typeof urls === 'string';\\n      if (isString) {\\n        urls = [urls];\\n      }\\n      urls = urls.filter(function(url) {\\n        var validTurn = url.indexOf('turn:') === 0 &&\\n            url.indexOf('transport=udp') !== -1 &&\\n            url.indexOf('turn:[') === -1 &&\\n            !hasTurn;\\n\\n        if (validTurn) {\\n          hasTurn = true;\\n          return true;\\n        }\\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\\n            url.indexOf('?transport=udp') === -1;\\n      });\\n\\n      delete server.url;\\n      server.urls = isString ? urls[0] : urls;\\n      return !!urls.length;\\n    }\\n  });\\n}\\n\\n// Determines the intersection of local and remote capabilities.\\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\\n  var commonCapabilities = {\\n    codecs: [],\\n    headerExtensions: [],\\n    fecMechanisms: []\\n  };\\n\\n  var findCodecByPayloadType = function(pt, codecs) {\\n    pt = parseInt(pt, 10);\\n    for (var i = 0; i < codecs.length; i++) {\\n      if (codecs[i].payloadType === pt ||\\n          codecs[i].preferredPayloadType === pt) {\\n        return codecs[i];\\n      }\\n    }\\n  };\\n\\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\\n    return lCodec && rCodec &&\\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\\n  };\\n\\n  localCapabilities.codecs.forEach(function(lCodec) {\\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\\n      var rCodec = remoteCapabilities.codecs[i];\\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\\n          lCodec.clockRate === rCodec.clockRate) {\\n        if (lCodec.name.toLowerCase() === 'rtx' &&\\n            lCodec.parameters && rCodec.parameters.apt) {\\n          // for RTX we need to find the local rtx that has a apt\\n          // which points to the same local codec as the remote one.\\n          if (!rtxCapabilityMatches(lCodec, rCodec,\\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\\n            continue;\\n          }\\n        }\\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\\n        // number of channels is the highest common number of channels\\n        rCodec.numChannels = Math.min(lCodec.numChannels,\\n            rCodec.numChannels);\\n        // push rCodec so we reply with offerer payload type\\n        commonCapabilities.codecs.push(rCodec);\\n\\n        // determine common feedback mechanisms\\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\\n              return true;\\n            }\\n          }\\n          return false;\\n        });\\n        // FIXME: also need to determine .parameters\\n        //  see https://github.com/openpeer/ortc/issues/569\\n        break;\\n      }\\n    }\\n  });\\n\\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\\n         i++) {\\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\\n        break;\\n      }\\n    }\\n  });\\n\\n  // FIXME: fecMechanisms\\n  return commonCapabilities;\\n}\\n\\n// is action=setLocalDescription with type allowed in signalingState\\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\\n  return {\\n    offer: {\\n      setLocalDescription: ['stable', 'have-local-offer'],\\n      setRemoteDescription: ['stable', 'have-remote-offer']\\n    },\\n    answer: {\\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\\n    }\\n  }[type][action].indexOf(signalingState) !== -1;\\n}\\n\\nfunction maybeAddCandidate(iceTransport, candidate) {\\n  // Edge's internal representation adds some fields therefore\\n  // not all fieldѕ are taken into account.\\n  var alreadyAdded = iceTransport.getRemoteCandidates()\\n      .find(function(remoteCandidate) {\\n        return candidate.foundation === remoteCandidate.foundation &&\\n            candidate.ip === remoteCandidate.ip &&\\n            candidate.port === remoteCandidate.port &&\\n            candidate.priority === remoteCandidate.priority &&\\n            candidate.protocol === remoteCandidate.protocol &&\\n            candidate.type === remoteCandidate.type;\\n      });\\n  if (!alreadyAdded) {\\n    iceTransport.addRemoteCandidate(candidate);\\n  }\\n  return !alreadyAdded;\\n}\\n\\n\\n// https://w3c.github.io/mediacapture-main/#mediastream\\n// Helper function to add the track to the stream and\\n// dispatch the event ourselves.\\nfunction addTrackToStreamAndFireEvent(track, stream) {\\n  stream.addTrack(track);\\n  var e = new Event('addtrack'); // TODO: MediaStreamTrackEvent\\n  e.track = track;\\n  stream.dispatchEvent(e);\\n}\\n\\nfunction removeTrackFromStreamAndFireEvent(track, stream) {\\n  stream.removeTrack(track);\\n  var e = new Event('removetrack'); // TODO: MediaStreamTrackEvent\\n  e.track = track;\\n  stream.dispatchEvent(e);\\n}\\n\\nfunction fireAddTrack(pc, track, receiver, streams) {\\n  var trackEvent = new Event('track');\\n  trackEvent.track = track;\\n  trackEvent.receiver = receiver;\\n  trackEvent.transceiver = {receiver: receiver};\\n  trackEvent.streams = streams;\\n  window.setTimeout(function() {\\n    pc._dispatchEvent('track', trackEvent);\\n  });\\n}\\n\\nfunction makeError(name, description) {\\n  var e = new Error(description);\\n  e.name = name;\\n  return e;\\n}\\n\\nmodule.exports = function(window, edgeVersion) {\\n  var RTCPeerConnection = function(config) {\\n    var pc = this;\\n\\n    var _eventTarget = document.createDocumentFragment();\\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\\n        .forEach(function(method) {\\n          pc[method] = _eventTarget[method].bind(_eventTarget);\\n        });\\n\\n    this.canTrickleIceCandidates = null;\\n\\n    this.needNegotiation = false;\\n\\n    this.localStreams = [];\\n    this.remoteStreams = [];\\n\\n    this.localDescription = null;\\n    this.remoteDescription = null;\\n\\n    this.signalingState = 'stable';\\n    this.iceConnectionState = 'new';\\n    this.iceGatheringState = 'new';\\n\\n    config = JSON.parse(JSON.stringify(config || {}));\\n\\n    this.usingBundle = config.bundlePolicy === 'max-bundle';\\n    if (config.rtcpMuxPolicy === 'negotiate') {\\n      throw(makeError('NotSupportedError',\\n          'rtcpMuxPolicy \\\\'negotiate\\\\' is not supported'));\\n    } else if (!config.rtcpMuxPolicy) {\\n      config.rtcpMuxPolicy = 'require';\\n    }\\n\\n    switch (config.iceTransportPolicy) {\\n      case 'all':\\n      case 'relay':\\n        break;\\n      default:\\n        config.iceTransportPolicy = 'all';\\n        break;\\n    }\\n\\n    switch (config.bundlePolicy) {\\n      case 'balanced':\\n      case 'max-compat':\\n      case 'max-bundle':\\n        break;\\n      default:\\n        config.bundlePolicy = 'balanced';\\n        break;\\n    }\\n\\n    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);\\n\\n    this._iceGatherers = [];\\n    if (config.iceCandidatePoolSize) {\\n      for (var i = config.iceCandidatePoolSize; i > 0; i--) {\\n        this._iceGatherers = new window.RTCIceGatherer({\\n          iceServers: config.iceServers,\\n          gatherPolicy: config.iceTransportPolicy\\n        });\\n      }\\n    } else {\\n      config.iceCandidatePoolSize = 0;\\n    }\\n\\n    this._config = config;\\n\\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\\n    // everything that is needed to describe a SDP m-line.\\n    this.transceivers = [];\\n\\n    this._sdpSessionId = SDPUtils.generateSessionId();\\n    this._sdpSessionVersion = 0;\\n\\n    this._dtlsRole = undefined; // role for a=setup to use in answers.\\n\\n    this._isClosed = false;\\n  };\\n\\n  // set up event handlers on prototype\\n  RTCPeerConnection.prototype.onicecandidate = null;\\n  RTCPeerConnection.prototype.onaddstream = null;\\n  RTCPeerConnection.prototype.ontrack = null;\\n  RTCPeerConnection.prototype.onremovestream = null;\\n  RTCPeerConnection.prototype.onsignalingstatechange = null;\\n  RTCPeerConnection.prototype.oniceconnectionstatechange = null;\\n  RTCPeerConnection.prototype.onicegatheringstatechange = null;\\n  RTCPeerConnection.prototype.onnegotiationneeded = null;\\n  RTCPeerConnection.prototype.ondatachannel = null;\\n\\n  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {\\n    if (this._isClosed) {\\n      return;\\n    }\\n    this.dispatchEvent(event);\\n    if (typeof this['on' + name] === 'function') {\\n      this['on' + name](event);\\n    }\\n  };\\n\\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\\n    var event = new Event('icegatheringstatechange');\\n    this._dispatchEvent('icegatheringstatechange', event);\\n  };\\n\\n  RTCPeerConnection.prototype.getConfiguration = function() {\\n    return this._config;\\n  };\\n\\n  RTCPeerConnection.prototype.getLocalStreams = function() {\\n    return this.localStreams;\\n  };\\n\\n  RTCPeerConnection.prototype.getRemoteStreams = function() {\\n    return this.remoteStreams;\\n  };\\n\\n  // internal helper to create a transceiver object.\\n  // (whih is not yet the same as the WebRTC 1.0 transceiver)\\n  RTCPeerConnection.prototype._createTransceiver = function(kind) {\\n    var hasBundleTransport = this.transceivers.length > 0;\\n    var transceiver = {\\n      track: null,\\n      iceGatherer: null,\\n      iceTransport: null,\\n      dtlsTransport: null,\\n      localCapabilities: null,\\n      remoteCapabilities: null,\\n      rtpSender: null,\\n      rtpReceiver: null,\\n      kind: kind,\\n      mid: null,\\n      sendEncodingParameters: null,\\n      recvEncodingParameters: null,\\n      stream: null,\\n      associatedRemoteMediaStreams: [],\\n      wantReceive: true\\n    };\\n    if (this.usingBundle && hasBundleTransport) {\\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\\n    } else {\\n      var transports = this._createIceAndDtlsTransports();\\n      transceiver.iceTransport = transports.iceTransport;\\n      transceiver.dtlsTransport = transports.dtlsTransport;\\n    }\\n    this.transceivers.push(transceiver);\\n    return transceiver;\\n  };\\n\\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\\n    var alreadyExists = this.transceivers.find(function(s) {\\n      return s.track === track;\\n    });\\n\\n    if (alreadyExists) {\\n      throw makeError('InvalidAccessError', 'Track already exists.');\\n    }\\n\\n    if (this.signalingState === 'closed') {\\n      throw makeError('InvalidStateError',\\n          'Attempted to call addTrack on a closed peerconnection.');\\n    }\\n\\n    var transceiver;\\n    for (var i = 0; i < this.transceivers.length; i++) {\\n      if (!this.transceivers[i].track &&\\n          this.transceivers[i].kind === track.kind) {\\n        transceiver = this.transceivers[i];\\n      }\\n    }\\n    if (!transceiver) {\\n      transceiver = this._createTransceiver(track.kind);\\n    }\\n\\n    this._maybeFireNegotiationNeeded();\\n\\n    if (this.localStreams.indexOf(stream) === -1) {\\n      this.localStreams.push(stream);\\n    }\\n\\n    transceiver.track = track;\\n    transceiver.stream = stream;\\n    transceiver.rtpSender = new window.RTCRtpSender(track,\\n        transceiver.dtlsTransport);\\n    return transceiver.rtpSender;\\n  };\\n\\n  RTCPeerConnection.prototype.addStream = function(stream) {\\n    var pc = this;\\n    if (edgeVersion >= 15025) {\\n      stream.getTracks().forEach(function(track) {\\n        pc.addTrack(track, stream);\\n      });\\n    } else {\\n      // Clone is necessary for local demos mostly, attaching directly\\n      // to two different senders does not work (build 10547).\\n      // Fixed in 15025 (or earlier)\\n      var clonedStream = stream.clone();\\n      stream.getTracks().forEach(function(track, idx) {\\n        var clonedTrack = clonedStream.getTracks()[idx];\\n        track.addEventListener('enabled', function(event) {\\n          clonedTrack.enabled = event.enabled;\\n        });\\n      });\\n      clonedStream.getTracks().forEach(function(track) {\\n        pc.addTrack(track, clonedStream);\\n      });\\n    }\\n  };\\n\\n  RTCPeerConnection.prototype.removeTrack = function(sender) {\\n    if (!(sender instanceof window.RTCRtpSender)) {\\n      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +\\n          'does not implement interface RTCRtpSender.');\\n    }\\n\\n    var transceiver = this.transceivers.find(function(t) {\\n      return t.rtpSender === sender;\\n    });\\n\\n    if (!transceiver) {\\n      throw makeError('InvalidAccessError',\\n          'Sender was not created by this connection.');\\n    }\\n    var stream = transceiver.stream;\\n\\n    transceiver.rtpSender.stop();\\n    transceiver.rtpSender = null;\\n    transceiver.track = null;\\n    transceiver.stream = null;\\n\\n    // remove the stream from the set of local streams\\n    var localStreams = this.transceivers.map(function(t) {\\n      return t.stream;\\n    });\\n    if (localStreams.indexOf(stream) === -1 &&\\n        this.localStreams.indexOf(stream) > -1) {\\n      this.localStreams.splice(this.localStreams.indexOf(stream), 1);\\n    }\\n\\n    this._maybeFireNegotiationNeeded();\\n  };\\n\\n  RTCPeerConnection.prototype.removeStream = function(stream) {\\n    var pc = this;\\n    stream.getTracks().forEach(function(track) {\\n      var sender = pc.getSenders().find(function(s) {\\n        return s.track === track;\\n      });\\n      if (sender) {\\n        pc.removeTrack(sender);\\n      }\\n    });\\n  };\\n\\n  RTCPeerConnection.prototype.getSenders = function() {\\n    return this.transceivers.filter(function(transceiver) {\\n      return !!transceiver.rtpSender;\\n    })\\n    .map(function(transceiver) {\\n      return transceiver.rtpSender;\\n    });\\n  };\\n\\n  RTCPeerConnection.prototype.getReceivers = function() {\\n    return this.transceivers.filter(function(transceiver) {\\n      return !!transceiver.rtpReceiver;\\n    })\\n    .map(function(transceiver) {\\n      return transceiver.rtpReceiver;\\n    });\\n  };\\n\\n\\n  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,\\n      usingBundle) {\\n    var pc = this;\\n    if (usingBundle && sdpMLineIndex > 0) {\\n      return this.transceivers[0].iceGatherer;\\n    } else if (this._iceGatherers.length) {\\n      return this._iceGatherers.shift();\\n    }\\n    var iceGatherer = new window.RTCIceGatherer({\\n      iceServers: this._config.iceServers,\\n      gatherPolicy: this._config.iceTransportPolicy\\n    });\\n    Object.defineProperty(iceGatherer, 'state',\\n        {value: 'new', writable: true}\\n    );\\n\\n    this.transceivers[sdpMLineIndex].candidates = [];\\n    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {\\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\\n      // polyfill since RTCIceGatherer.state is not implemented in\\n      // Edge 10547 yet.\\n      iceGatherer.state = end ? 'completed' : 'gathering';\\n      if (pc.transceivers[sdpMLineIndex].candidates !== null) {\\n        pc.transceivers[sdpMLineIndex].candidates.push(event.candidate);\\n      }\\n    };\\n    iceGatherer.addEventListener('localcandidate',\\n      this.transceivers[sdpMLineIndex].bufferCandidates);\\n    return iceGatherer;\\n  };\\n\\n  // start gathering from an RTCIceGatherer.\\n  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {\\n    var pc = this;\\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\\n    if (iceGatherer.onlocalcandidate) {\\n      return;\\n    }\\n    var candidates = this.transceivers[sdpMLineIndex].candidates;\\n    this.transceivers[sdpMLineIndex].candidates = null;\\n    iceGatherer.removeEventListener('localcandidate',\\n      this.transceivers[sdpMLineIndex].bufferCandidates);\\n    iceGatherer.onlocalcandidate = function(evt) {\\n      if (pc.usingBundle && sdpMLineIndex > 0) {\\n        // if we know that we use bundle we can drop candidates with\\n        // ѕdpMLineIndex > 0. If we don't do this then our state gets\\n        // confused since we dispose the extra ice gatherer.\\n        return;\\n      }\\n      var event = new Event('icecandidate');\\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\\n\\n      var cand = evt.candidate;\\n      // Edge emits an empty object for RTCIceCandidateComplete‥\\n      var end = !cand || Object.keys(cand).length === 0;\\n      if (end) {\\n        // polyfill since RTCIceGatherer.state is not implemented in\\n        // Edge 10547 yet.\\n        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {\\n          iceGatherer.state = 'completed';\\n        }\\n      } else {\\n        if (iceGatherer.state === 'new') {\\n          iceGatherer.state = 'gathering';\\n        }\\n        // RTCIceCandidate doesn't have a component, needs to be added\\n        cand.component = 1;\\n        event.candidate.candidate = SDPUtils.writeCandidate(cand);\\n      }\\n\\n      // update local description.\\n      var sections = SDPUtils.splitSections(pc.localDescription.sdp);\\n      if (!end) {\\n        sections[event.candidate.sdpMLineIndex + 1] +=\\n            'a=' + event.candidate.candidate + '\\\\r\\\\n';\\n      } else {\\n        sections[event.candidate.sdpMLineIndex + 1] +=\\n            'a=end-of-candidates\\\\r\\\\n';\\n      }\\n      pc.localDescription.sdp = sections.join('');\\n      var complete = pc.transceivers.every(function(transceiver) {\\n        return transceiver.iceGatherer &&\\n            transceiver.iceGatherer.state === 'completed';\\n      });\\n\\n      if (pc.iceGatheringState !== 'gathering') {\\n        pc.iceGatheringState = 'gathering';\\n        pc._emitGatheringStateChange();\\n      }\\n\\n      // Emit candidate. Also emit null candidate when all gatherers are\\n      // complete.\\n      if (!end) {\\n        pc._dispatchEvent('icecandidate', event);\\n      }\\n      if (complete) {\\n        pc._dispatchEvent('icecandidate', new Event('icecandidate'));\\n        pc.iceGatheringState = 'complete';\\n        pc._emitGatheringStateChange();\\n      }\\n    };\\n\\n    // emit already gathered candidates.\\n    window.setTimeout(function() {\\n      candidates.forEach(function(candidate) {\\n        var e = new Event('RTCIceGatherEvent');\\n        e.candidate = candidate;\\n        iceGatherer.onlocalcandidate(e);\\n      });\\n    }, 0);\\n  };\\n\\n  // Create ICE transport and DTLS transport.\\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\\n    var pc = this;\\n    var iceTransport = new window.RTCIceTransport(null);\\n    iceTransport.onicestatechange = function() {\\n      pc._updateConnectionState();\\n    };\\n\\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\\n    dtlsTransport.ondtlsstatechange = function() {\\n      pc._updateConnectionState();\\n    };\\n    dtlsTransport.onerror = function() {\\n      // onerror does not set state to failed by itpc.\\n      Object.defineProperty(dtlsTransport, 'state',\\n          {value: 'failed', writable: true});\\n      pc._updateConnectionState();\\n    };\\n\\n    return {\\n      iceTransport: iceTransport,\\n      dtlsTransport: dtlsTransport\\n    };\\n  };\\n\\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\\n  // Without triggering the callbacks.\\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\\n      sdpMLineIndex) {\\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\\n    if (iceGatherer) {\\n      delete iceGatherer.onlocalcandidate;\\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\\n    }\\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\\n    if (iceTransport) {\\n      delete iceTransport.onicestatechange;\\n      delete this.transceivers[sdpMLineIndex].iceTransport;\\n    }\\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\\n    if (dtlsTransport) {\\n      delete dtlsTransport.ondtlsstatechange;\\n      delete dtlsTransport.onerror;\\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\\n    }\\n  };\\n\\n  // Start the RTP Sender and Receiver for a transceiver.\\n  RTCPeerConnection.prototype._transceive = function(transceiver,\\n      send, recv) {\\n    var params = getCommonCapabilities(transceiver.localCapabilities,\\n        transceiver.remoteCapabilities);\\n    if (send && transceiver.rtpSender) {\\n      params.encodings = transceiver.sendEncodingParameters;\\n      params.rtcp = {\\n        cname: SDPUtils.localCName,\\n        compound: transceiver.rtcpParameters.compound\\n      };\\n      if (transceiver.recvEncodingParameters.length) {\\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\\n      }\\n      transceiver.rtpSender.send(params);\\n    }\\n    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {\\n      // remove RTX field in Edge 14942\\n      if (transceiver.kind === 'video'\\n          && transceiver.recvEncodingParameters\\n          && edgeVersion < 15019) {\\n        transceiver.recvEncodingParameters.forEach(function(p) {\\n          delete p.rtx;\\n        });\\n      }\\n      if (transceiver.recvEncodingParameters.length) {\\n        params.encodings = transceiver.recvEncodingParameters;\\n      }\\n      params.rtcp = {\\n        compound: transceiver.rtcpParameters.compound\\n      };\\n      if (transceiver.rtcpParameters.cname) {\\n        params.rtcp.cname = transceiver.rtcpParameters.cname;\\n      }\\n      if (transceiver.sendEncodingParameters.length) {\\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\\n      }\\n      transceiver.rtpReceiver.receive(params);\\n    }\\n  };\\n\\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\\n    var pc = this;\\n\\n    if (!isActionAllowedInSignalingState('setLocalDescription',\\n        description.type, this.signalingState) || this._isClosed) {\\n      return Promise.reject(makeError('InvalidStateError',\\n          'Can not set local ' + description.type +\\n          ' in state ' + pc.signalingState));\\n    }\\n\\n    var sections;\\n    var sessionpart;\\n    if (description.type === 'offer') {\\n      // VERY limited support for SDP munging. Limited to:\\n      // * changing the order of codecs\\n      sections = SDPUtils.splitSections(description.sdp);\\n      sessionpart = sections.shift();\\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\\n        var caps = SDPUtils.parseRtpParameters(mediaSection);\\n        pc.transceivers[sdpMLineIndex].localCapabilities = caps;\\n      });\\n\\n      this.transceivers.forEach(function(transceiver, sdpMLineIndex) {\\n        pc._gather(transceiver.mid, sdpMLineIndex);\\n      });\\n    } else if (description.type === 'answer') {\\n      sections = SDPUtils.splitSections(pc.remoteDescription.sdp);\\n      sessionpart = sections.shift();\\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\\n          'a=ice-lite').length > 0;\\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\\n        var transceiver = pc.transceivers[sdpMLineIndex];\\n        var iceGatherer = transceiver.iceGatherer;\\n        var iceTransport = transceiver.iceTransport;\\n        var dtlsTransport = transceiver.dtlsTransport;\\n        var localCapabilities = transceiver.localCapabilities;\\n        var remoteCapabilities = transceiver.remoteCapabilities;\\n\\n        // treat bundle-only as not-rejected.\\n        var rejected = SDPUtils.isRejected(mediaSection) &&\\n            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\\n\\n        if (!rejected && !transceiver.isDatachannel) {\\n          var remoteIceParameters = SDPUtils.getIceParameters(\\n              mediaSection, sessionpart);\\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\\n              mediaSection, sessionpart);\\n          if (isIceLite) {\\n            remoteDtlsParameters.role = 'server';\\n          }\\n\\n          if (!pc.usingBundle || sdpMLineIndex === 0) {\\n            pc._gather(transceiver.mid, sdpMLineIndex);\\n            if (iceTransport.state === 'new') {\\n              iceTransport.start(iceGatherer, remoteIceParameters,\\n                  isIceLite ? 'controlling' : 'controlled');\\n            }\\n            if (dtlsTransport.state === 'new') {\\n              dtlsTransport.start(remoteDtlsParameters);\\n            }\\n          }\\n\\n          // Calculate intersection of capabilities.\\n          var params = getCommonCapabilities(localCapabilities,\\n              remoteCapabilities);\\n\\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\\n          // transceiver has already been started in setRemoteDescription.\\n          pc._transceive(transceiver,\\n              params.codecs.length > 0,\\n              false);\\n        }\\n      });\\n    }\\n\\n    this.localDescription = {\\n      type: description.type,\\n      sdp: description.sdp\\n    };\\n    switch (description.type) {\\n      case 'offer':\\n        this._updateSignalingState('have-local-offer');\\n        break;\\n      case 'answer':\\n        this._updateSignalingState('stable');\\n        break;\\n      default:\\n        throw new TypeError('unsupported type \\\"' + description.type +\\n            '\\\"');\\n    }\\n\\n    return Promise.resolve();\\n  };\\n\\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\\n    var pc = this;\\n\\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\\n        description.type, this.signalingState) || this._isClosed) {\\n      return Promise.reject(makeError('InvalidStateError',\\n          'Can not set remote ' + description.type +\\n          ' in state ' + pc.signalingState));\\n    }\\n\\n    var streams = {};\\n    this.remoteStreams.forEach(function(stream) {\\n      streams[stream.id] = stream;\\n    });\\n    var receiverList = [];\\n    var sections = SDPUtils.splitSections(description.sdp);\\n    var sessionpart = sections.shift();\\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\\n        'a=ice-lite').length > 0;\\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\\n        'a=group:BUNDLE ').length > 0;\\n    this.usingBundle = usingBundle;\\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\\n        'a=ice-options:')[0];\\n    if (iceOptions) {\\n      this.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\\n          .indexOf('trickle') >= 0;\\n    } else {\\n      this.canTrickleIceCandidates = false;\\n    }\\n\\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\\n      var lines = SDPUtils.splitLines(mediaSection);\\n      var kind = SDPUtils.getKind(mediaSection);\\n      // treat bundle-only as not-rejected.\\n      var rejected = SDPUtils.isRejected(mediaSection) &&\\n          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\\n      var protocol = lines[0].substr(2).split(' ')[2];\\n\\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\\n\\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\\n\\n      // Reject datachannels which are not implemented yet.\\n      if (kind === 'application' && protocol === 'DTLS/SCTP') {\\n        pc.transceivers[sdpMLineIndex] = {\\n          mid: mid,\\n          isDatachannel: true\\n        };\\n        return;\\n      }\\n\\n      var transceiver;\\n      var iceGatherer;\\n      var iceTransport;\\n      var dtlsTransport;\\n      var rtpReceiver;\\n      var sendEncodingParameters;\\n      var recvEncodingParameters;\\n      var localCapabilities;\\n\\n      var track;\\n      // FIXME: ensure the mediaSection has rtcp-mux set.\\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\\n      var remoteIceParameters;\\n      var remoteDtlsParameters;\\n      if (!rejected) {\\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\\n            sessionpart);\\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\\n            sessionpart);\\n        remoteDtlsParameters.role = 'client';\\n      }\\n      recvEncodingParameters =\\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\\n\\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\\n\\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\\n          'a=end-of-candidates', sessionpart).length > 0;\\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\\n          .map(function(cand) {\\n            return SDPUtils.parseCandidate(cand);\\n          })\\n          .filter(function(cand) {\\n            return cand.component === 1;\\n          });\\n\\n      // Check if we can use BUNDLE and dispose transports.\\n      if ((description.type === 'offer' || description.type === 'answer') &&\\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\\n          pc.transceivers[sdpMLineIndex]) {\\n        pc._disposeIceAndDtlsTransports(sdpMLineIndex);\\n        pc.transceivers[sdpMLineIndex].iceGatherer =\\n            pc.transceivers[0].iceGatherer;\\n        pc.transceivers[sdpMLineIndex].iceTransport =\\n            pc.transceivers[0].iceTransport;\\n        pc.transceivers[sdpMLineIndex].dtlsTransport =\\n            pc.transceivers[0].dtlsTransport;\\n        if (pc.transceivers[sdpMLineIndex].rtpSender) {\\n          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(\\n              pc.transceivers[0].dtlsTransport);\\n        }\\n        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {\\n          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\\n              pc.transceivers[0].dtlsTransport);\\n        }\\n      }\\n      if (description.type === 'offer' && !rejected) {\\n        transceiver = pc.transceivers[sdpMLineIndex] ||\\n            pc._createTransceiver(kind);\\n        transceiver.mid = mid;\\n\\n        if (!transceiver.iceGatherer) {\\n          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\\n              usingBundle);\\n        }\\n\\n        if (cands.length && transceiver.iceTransport.state === 'new') {\\n          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {\\n            transceiver.iceTransport.setRemoteCandidates(cands);\\n          } else {\\n            cands.forEach(function(candidate) {\\n              maybeAddCandidate(transceiver.iceTransport, candidate);\\n            });\\n          }\\n        }\\n\\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\\n\\n        // filter RTX until additional stuff needed for RTX is implemented\\n        // in adapter.js\\n        if (edgeVersion < 15019) {\\n          localCapabilities.codecs = localCapabilities.codecs.filter(\\n              function(codec) {\\n                return codec.name !== 'rtx';\\n              });\\n        }\\n\\n        sendEncodingParameters = transceiver.sendEncodingParameters || [{\\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\\n        }];\\n\\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\\n        var isNewTrack = false;\\n        if (direction === 'sendrecv' || direction === 'sendonly') {\\n          isNewTrack = !transceiver.rtpReceiver;\\n          rtpReceiver = transceiver.rtpReceiver ||\\n              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\\n\\n          if (isNewTrack) {\\n            var stream;\\n            track = rtpReceiver.track;\\n            // FIXME: does not work with Plan B.\\n            if (remoteMsid && remoteMsid.stream === '-') {\\n              // no-op. a stream id of '-' means: no associated stream.\\n            } else if (remoteMsid) {\\n              if (!streams[remoteMsid.stream]) {\\n                streams[remoteMsid.stream] = new window.MediaStream();\\n                Object.defineProperty(streams[remoteMsid.stream], 'id', {\\n                  get: function() {\\n                    return remoteMsid.stream;\\n                  }\\n                });\\n              }\\n              Object.defineProperty(track, 'id', {\\n                get: function() {\\n                  return remoteMsid.track;\\n                }\\n              });\\n              stream = streams[remoteMsid.stream];\\n            } else {\\n              if (!streams.default) {\\n                streams.default = new window.MediaStream();\\n              }\\n              stream = streams.default;\\n            }\\n            if (stream) {\\n              addTrackToStreamAndFireEvent(track, stream);\\n              transceiver.associatedRemoteMediaStreams.push(stream);\\n            }\\n            receiverList.push([track, rtpReceiver, stream]);\\n          }\\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {\\n          transceiver.associatedRemoteMediaStreams.forEach(function(s) {\\n            var nativeTrack = s.getTracks().find(function(t) {\\n              return t.id === transceiver.rtpReceiver.track.id;\\n            });\\n            if (nativeTrack) {\\n              removeTrackFromStreamAndFireEvent(nativeTrack, s);\\n            }\\n          });\\n          transceiver.associatedRemoteMediaStreams = [];\\n        }\\n\\n        transceiver.localCapabilities = localCapabilities;\\n        transceiver.remoteCapabilities = remoteCapabilities;\\n        transceiver.rtpReceiver = rtpReceiver;\\n        transceiver.rtcpParameters = rtcpParameters;\\n        transceiver.sendEncodingParameters = sendEncodingParameters;\\n        transceiver.recvEncodingParameters = recvEncodingParameters;\\n\\n        // Start the RTCRtpReceiver now. The RTPSender is started in\\n        // setLocalDescription.\\n        pc._transceive(pc.transceivers[sdpMLineIndex],\\n            false,\\n            isNewTrack);\\n      } else if (description.type === 'answer' && !rejected) {\\n        transceiver = pc.transceivers[sdpMLineIndex];\\n        iceGatherer = transceiver.iceGatherer;\\n        iceTransport = transceiver.iceTransport;\\n        dtlsTransport = transceiver.dtlsTransport;\\n        rtpReceiver = transceiver.rtpReceiver;\\n        sendEncodingParameters = transceiver.sendEncodingParameters;\\n        localCapabilities = transceiver.localCapabilities;\\n\\n        pc.transceivers[sdpMLineIndex].recvEncodingParameters =\\n            recvEncodingParameters;\\n        pc.transceivers[sdpMLineIndex].remoteCapabilities =\\n            remoteCapabilities;\\n        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\\n\\n        if (cands.length && iceTransport.state === 'new') {\\n          if ((isIceLite || isComplete) &&\\n              (!usingBundle || sdpMLineIndex === 0)) {\\n            iceTransport.setRemoteCandidates(cands);\\n          } else {\\n            cands.forEach(function(candidate) {\\n              maybeAddCandidate(transceiver.iceTransport, candidate);\\n            });\\n          }\\n        }\\n\\n        if (!usingBundle || sdpMLineIndex === 0) {\\n          if (iceTransport.state === 'new') {\\n            iceTransport.start(iceGatherer, remoteIceParameters,\\n                'controlling');\\n          }\\n          if (dtlsTransport.state === 'new') {\\n            dtlsTransport.start(remoteDtlsParameters);\\n          }\\n        }\\n\\n        pc._transceive(transceiver,\\n            direction === 'sendrecv' || direction === 'recvonly',\\n            direction === 'sendrecv' || direction === 'sendonly');\\n\\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\\n        if (rtpReceiver &&\\n            (direction === 'sendrecv' || direction === 'sendonly')) {\\n          track = rtpReceiver.track;\\n          if (remoteMsid) {\\n            if (!streams[remoteMsid.stream]) {\\n              streams[remoteMsid.stream] = new window.MediaStream();\\n            }\\n            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);\\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\\n          } else {\\n            if (!streams.default) {\\n              streams.default = new window.MediaStream();\\n            }\\n            addTrackToStreamAndFireEvent(track, streams.default);\\n            receiverList.push([track, rtpReceiver, streams.default]);\\n          }\\n        } else {\\n          // FIXME: actually the receiver should be created later.\\n          delete transceiver.rtpReceiver;\\n        }\\n      }\\n    });\\n\\n    if (this._dtlsRole === undefined) {\\n      this._dtlsRole = description.type === 'offer' ? 'active' : 'passive';\\n    }\\n\\n    this.remoteDescription = {\\n      type: description.type,\\n      sdp: description.sdp\\n    };\\n    switch (description.type) {\\n      case 'offer':\\n        this._updateSignalingState('have-remote-offer');\\n        break;\\n      case 'answer':\\n        this._updateSignalingState('stable');\\n        break;\\n      default:\\n        throw new TypeError('unsupported type \\\"' + description.type +\\n            '\\\"');\\n    }\\n    Object.keys(streams).forEach(function(sid) {\\n      var stream = streams[sid];\\n      if (stream.getTracks().length) {\\n        if (pc.remoteStreams.indexOf(stream) === -1) {\\n          pc.remoteStreams.push(stream);\\n          var event = new Event('addstream');\\n          event.stream = stream;\\n          window.setTimeout(function() {\\n            pc._dispatchEvent('addstream', event);\\n          });\\n        }\\n\\n        receiverList.forEach(function(item) {\\n          var track = item[0];\\n          var receiver = item[1];\\n          if (stream.id !== item[2].id) {\\n            return;\\n          }\\n          fireAddTrack(pc, track, receiver, [stream]);\\n        });\\n      }\\n    });\\n    receiverList.forEach(function(item) {\\n      if (item[2]) {\\n        return;\\n      }\\n      fireAddTrack(pc, item[0], item[1], []);\\n    });\\n\\n    // check whether addIceCandidate({}) was called within four seconds after\\n    // setRemoteDescription.\\n    window.setTimeout(function() {\\n      if (!(pc && pc.transceivers)) {\\n        return;\\n      }\\n      pc.transceivers.forEach(function(transceiver) {\\n        if (transceiver.iceTransport &&\\n            transceiver.iceTransport.state === 'new' &&\\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\\n              'an end-of-candidates notification');\\n          transceiver.iceTransport.addRemoteCandidate({});\\n        }\\n      });\\n    }, 4000);\\n\\n    return Promise.resolve();\\n  };\\n\\n  RTCPeerConnection.prototype.close = function() {\\n    this.transceivers.forEach(function(transceiver) {\\n      /* not yet\\n      if (transceiver.iceGatherer) {\\n        transceiver.iceGatherer.close();\\n      }\\n      */\\n      if (transceiver.iceTransport) {\\n        transceiver.iceTransport.stop();\\n      }\\n      if (transceiver.dtlsTransport) {\\n        transceiver.dtlsTransport.stop();\\n      }\\n      if (transceiver.rtpSender) {\\n        transceiver.rtpSender.stop();\\n      }\\n      if (transceiver.rtpReceiver) {\\n        transceiver.rtpReceiver.stop();\\n      }\\n    });\\n    // FIXME: clean up tracks, local streams, remote streams, etc\\n    this._isClosed = true;\\n    this._updateSignalingState('closed');\\n  };\\n\\n  // Update the signaling state.\\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\\n    this.signalingState = newState;\\n    var event = new Event('signalingstatechange');\\n    this._dispatchEvent('signalingstatechange', event);\\n  };\\n\\n  // Determine whether to fire the negotiationneeded event.\\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\\n    var pc = this;\\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\\n      return;\\n    }\\n    this.needNegotiation = true;\\n    window.setTimeout(function() {\\n      if (pc.needNegotiation === false) {\\n        return;\\n      }\\n      pc.needNegotiation = false;\\n      var event = new Event('negotiationneeded');\\n      pc._dispatchEvent('negotiationneeded', event);\\n    }, 0);\\n  };\\n\\n  // Update the connection state.\\n  RTCPeerConnection.prototype._updateConnectionState = function() {\\n    var newState;\\n    var states = {\\n      'new': 0,\\n      closed: 0,\\n      connecting: 0,\\n      checking: 0,\\n      connected: 0,\\n      completed: 0,\\n      disconnected: 0,\\n      failed: 0\\n    };\\n    this.transceivers.forEach(function(transceiver) {\\n      states[transceiver.iceTransport.state]++;\\n      states[transceiver.dtlsTransport.state]++;\\n    });\\n    // ICETransport.completed and connected are the same for this purpose.\\n    states.connected += states.completed;\\n\\n    newState = 'new';\\n    if (states.failed > 0) {\\n      newState = 'failed';\\n    } else if (states.connecting > 0 || states.checking > 0) {\\n      newState = 'connecting';\\n    } else if (states.disconnected > 0) {\\n      newState = 'disconnected';\\n    } else if (states.new > 0) {\\n      newState = 'new';\\n    } else if (states.connected > 0 || states.completed > 0) {\\n      newState = 'connected';\\n    }\\n\\n    if (newState !== this.iceConnectionState) {\\n      this.iceConnectionState = newState;\\n      var event = new Event('iceconnectionstatechange');\\n      this._dispatchEvent('iceconnectionstatechange', event);\\n    }\\n  };\\n\\n  RTCPeerConnection.prototype.createOffer = function() {\\n    var pc = this;\\n\\n    if (this._isClosed) {\\n      return Promise.reject(makeError('InvalidStateError',\\n          'Can not call createOffer after close'));\\n    }\\n\\n    var numAudioTracks = this.transceivers.filter(function(t) {\\n      return t.kind === 'audio';\\n    }).length;\\n    var numVideoTracks = this.transceivers.filter(function(t) {\\n      return t.kind === 'video';\\n    }).length;\\n\\n    // Determine number of audio and video tracks we need to send/recv.\\n    var offerOptions = arguments[0];\\n    if (offerOptions) {\\n      // Reject Chrome legacy constraints.\\n      if (offerOptions.mandatory || offerOptions.optional) {\\n        throw new TypeError(\\n            'Legacy mandatory/optional constraints not supported.');\\n      }\\n      if (offerOptions.offerToReceiveAudio !== undefined) {\\n        if (offerOptions.offerToReceiveAudio === true) {\\n          numAudioTracks = 1;\\n        } else if (offerOptions.offerToReceiveAudio === false) {\\n          numAudioTracks = 0;\\n        } else {\\n          numAudioTracks = offerOptions.offerToReceiveAudio;\\n        }\\n      }\\n      if (offerOptions.offerToReceiveVideo !== undefined) {\\n        if (offerOptions.offerToReceiveVideo === true) {\\n          numVideoTracks = 1;\\n        } else if (offerOptions.offerToReceiveVideo === false) {\\n          numVideoTracks = 0;\\n        } else {\\n          numVideoTracks = offerOptions.offerToReceiveVideo;\\n        }\\n      }\\n    }\\n\\n    this.transceivers.forEach(function(transceiver) {\\n      if (transceiver.kind === 'audio') {\\n        numAudioTracks--;\\n        if (numAudioTracks < 0) {\\n          transceiver.wantReceive = false;\\n        }\\n      } else if (transceiver.kind === 'video') {\\n        numVideoTracks--;\\n        if (numVideoTracks < 0) {\\n          transceiver.wantReceive = false;\\n        }\\n      }\\n    });\\n\\n    // Create M-lines for recvonly streams.\\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\\n      if (numAudioTracks > 0) {\\n        this._createTransceiver('audio');\\n        numAudioTracks--;\\n      }\\n      if (numVideoTracks > 0) {\\n        this._createTransceiver('video');\\n        numVideoTracks--;\\n      }\\n    }\\n\\n    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId,\\n        this._sdpSessionVersion++);\\n    this.transceivers.forEach(function(transceiver, sdpMLineIndex) {\\n      // For each track, create an ice gatherer, ice transport,\\n      // dtls transport, potentially rtpsender and rtpreceiver.\\n      var track = transceiver.track;\\n      var kind = transceiver.kind;\\n      var mid = SDPUtils.generateIdentifier();\\n      transceiver.mid = mid;\\n\\n      if (!transceiver.iceGatherer) {\\n        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\\n            pc.usingBundle);\\n      }\\n\\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\\n      // filter RTX until additional stuff needed for RTX is implemented\\n      // in adapter.js\\n      if (edgeVersion < 15019) {\\n        localCapabilities.codecs = localCapabilities.codecs.filter(\\n            function(codec) {\\n              return codec.name !== 'rtx';\\n            });\\n      }\\n      localCapabilities.codecs.forEach(function(codec) {\\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\\n        // by adding level-asymmetry-allowed=1\\n        if (codec.name === 'H264' &&\\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\\n          codec.parameters['level-asymmetry-allowed'] = '1';\\n        }\\n      });\\n\\n      // generate an ssrc now, to be used later in rtpSender.send\\n      var sendEncodingParameters = transceiver.sendEncodingParameters || [{\\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\\n      }];\\n      if (track) {\\n        // add RTX\\n        if (edgeVersion >= 15019 && kind === 'video' &&\\n            !sendEncodingParameters[0].rtx) {\\n          sendEncodingParameters[0].rtx = {\\n            ssrc: sendEncodingParameters[0].ssrc + 1\\n          };\\n        }\\n      }\\n\\n      if (transceiver.wantReceive) {\\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\\n            transceiver.dtlsTransport, kind);\\n      }\\n\\n      transceiver.localCapabilities = localCapabilities;\\n      transceiver.sendEncodingParameters = sendEncodingParameters;\\n    });\\n\\n    // always offer BUNDLE and dispose on return if not supported.\\n    if (this._config.bundlePolicy !== 'max-compat') {\\n      sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {\\n        return t.mid;\\n      }).join(' ') + '\\\\r\\\\n';\\n    }\\n    sdp += 'a=ice-options:trickle\\\\r\\\\n';\\n\\n    this.transceivers.forEach(function(transceiver, sdpMLineIndex) {\\n      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,\\n          'offer', transceiver.stream, pc._dtlsRole);\\n      sdp += 'a=rtcp-rsize\\\\r\\\\n';\\n\\n      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&\\n          (sdpMLineIndex === 0 || !pc.usingBundle)) {\\n        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {\\n          cand.component = 1;\\n          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\\\\r\\\\n';\\n        });\\n\\n        if (transceiver.iceGatherer.state === 'completed') {\\n          sdp += 'a=end-of-candidates\\\\r\\\\n';\\n        }\\n      }\\n    });\\n\\n    var desc = new window.RTCSessionDescription({\\n      type: 'offer',\\n      sdp: sdp\\n    });\\n    return Promise.resolve(desc);\\n  };\\n\\n  RTCPeerConnection.prototype.createAnswer = function() {\\n    var pc = this;\\n\\n    if (this._isClosed) {\\n      return Promise.reject(makeError('InvalidStateError',\\n          'Can not call createAnswer after close'));\\n    }\\n\\n    var sdp = SDPUtils.writeSessionBoilerplate(this._sdpSessionId,\\n        this._sdpSessionVersion++);\\n    if (this.usingBundle) {\\n      sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {\\n        return t.mid;\\n      }).join(' ') + '\\\\r\\\\n';\\n    }\\n    var mediaSectionsInOffer = SDPUtils.splitSections(\\n        this.remoteDescription.sdp).length - 1;\\n    this.transceivers.forEach(function(transceiver, sdpMLineIndex) {\\n      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {\\n        return;\\n      }\\n      if (transceiver.isDatachannel) {\\n        sdp += 'm=application 0 DTLS/SCTP 5000\\\\r\\\\n' +\\n            'c=IN IP4 0.0.0.0\\\\r\\\\n' +\\n            'a=mid:' + transceiver.mid + '\\\\r\\\\n';\\n        return;\\n      }\\n\\n      // FIXME: look at direction.\\n      if (transceiver.stream) {\\n        var localTrack;\\n        if (transceiver.kind === 'audio') {\\n          localTrack = transceiver.stream.getAudioTracks()[0];\\n        } else if (transceiver.kind === 'video') {\\n          localTrack = transceiver.stream.getVideoTracks()[0];\\n        }\\n        if (localTrack) {\\n          // add RTX\\n          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&\\n              !transceiver.sendEncodingParameters[0].rtx) {\\n            transceiver.sendEncodingParameters[0].rtx = {\\n              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\\n            };\\n          }\\n        }\\n      }\\n\\n      // Calculate intersection of capabilities.\\n      var commonCapabilities = getCommonCapabilities(\\n          transceiver.localCapabilities,\\n          transceiver.remoteCapabilities);\\n\\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\\n        return c.name.toLowerCase() === 'rtx';\\n      }).length;\\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\\n        delete transceiver.sendEncodingParameters[0].rtx;\\n      }\\n\\n      sdp += writeMediaSection(transceiver, commonCapabilities,\\n          'answer', transceiver.stream, pc._dtlsRole);\\n      if (transceiver.rtcpParameters &&\\n          transceiver.rtcpParameters.reducedSize) {\\n        sdp += 'a=rtcp-rsize\\\\r\\\\n';\\n      }\\n    });\\n\\n    var desc = new window.RTCSessionDescription({\\n      type: 'answer',\\n      sdp: sdp\\n    });\\n    return Promise.resolve(desc);\\n  };\\n\\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\\n    var sections;\\n    if (!candidate || candidate.candidate === '') {\\n      for (var j = 0; j < this.transceivers.length; j++) {\\n        if (this.transceivers[j].isDatachannel) {\\n          continue;\\n        }\\n        this.transceivers[j].iceTransport.addRemoteCandidate({});\\n        sections = SDPUtils.splitSections(this.remoteDescription.sdp);\\n        sections[j + 1] += 'a=end-of-candidates\\\\r\\\\n';\\n        this.remoteDescription.sdp = sections.join('');\\n        if (this.usingBundle) {\\n          break;\\n        }\\n      }\\n    } else if (!(candidate.sdpMLineIndex !== undefined || candidate.sdpMid)) {\\n      throw new TypeError('sdpMLineIndex or sdpMid required');\\n    } else if (!this.remoteDescription) {\\n      return Promise.reject(makeError('InvalidStateError',\\n          'Can not add ICE candidate without a remote description'));\\n    } else {\\n      var sdpMLineIndex = candidate.sdpMLineIndex;\\n      if (candidate.sdpMid) {\\n        for (var i = 0; i < this.transceivers.length; i++) {\\n          if (this.transceivers[i].mid === candidate.sdpMid) {\\n            sdpMLineIndex = i;\\n            break;\\n          }\\n        }\\n      }\\n      var transceiver = this.transceivers[sdpMLineIndex];\\n      if (transceiver) {\\n        if (transceiver.isDatachannel) {\\n          return Promise.resolve();\\n        }\\n        var cand = Object.keys(candidate.candidate).length > 0 ?\\n            SDPUtils.parseCandidate(candidate.candidate) : {};\\n        // Ignore Chrome's invalid candidates since Edge does not like them.\\n        if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\\n          return Promise.resolve();\\n        }\\n        // Ignore RTCP candidates, we assume RTCP-MUX.\\n        if (cand.component && cand.component !== 1) {\\n          return Promise.resolve();\\n        }\\n        // when using bundle, avoid adding candidates to the wrong\\n        // ice transport. And avoid adding candidates added in the SDP.\\n        if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&\\n            transceiver.iceTransport !== this.transceivers[0].iceTransport)) {\\n          if (!maybeAddCandidate(transceiver.iceTransport, cand)) {\\n            return Promise.reject(makeError('OperationError',\\n                'Can not add ICE candidate'));\\n          }\\n        }\\n\\n        // update the remoteDescription.\\n        var candidateString = candidate.candidate.trim();\\n        if (candidateString.indexOf('a=') === 0) {\\n          candidateString = candidateString.substr(2);\\n        }\\n        sections = SDPUtils.splitSections(this.remoteDescription.sdp);\\n        sections[sdpMLineIndex + 1] += 'a=' +\\n            (cand.type ? candidateString : 'end-of-candidates')\\n            + '\\\\r\\\\n';\\n        this.remoteDescription.sdp = sections.join('');\\n      } else {\\n        return Promise.reject(makeError('OperationError',\\n            'Can not add ICE candidate'));\\n      }\\n    }\\n    return Promise.resolve();\\n  };\\n\\n  RTCPeerConnection.prototype.getStats = function() {\\n    var promises = [];\\n    this.transceivers.forEach(function(transceiver) {\\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\\n          'dtlsTransport'].forEach(function(method) {\\n            if (transceiver[method]) {\\n              promises.push(transceiver[method].getStats());\\n            }\\n          });\\n    });\\n    var fixStatsType = function(stat) {\\n      return {\\n        inboundrtp: 'inbound-rtp',\\n        outboundrtp: 'outbound-rtp',\\n        candidatepair: 'candidate-pair',\\n        localcandidate: 'local-candidate',\\n        remotecandidate: 'remote-candidate'\\n      }[stat.type] || stat.type;\\n    };\\n    return new Promise(function(resolve) {\\n      // shim getStats with maplike support\\n      var results = new Map();\\n      Promise.all(promises).then(function(res) {\\n        res.forEach(function(result) {\\n          Object.keys(result).forEach(function(id) {\\n            result[id].type = fixStatsType(result[id]);\\n            results.set(id, result[id]);\\n          });\\n        });\\n        resolve(results);\\n      });\\n    });\\n  };\\n\\n  // legacy callback shims. Should be moved to adapter.js some days.\\n  var methods = ['createOffer', 'createAnswer'];\\n  methods.forEach(function(method) {\\n    var nativeMethod = RTCPeerConnection.prototype[method];\\n    RTCPeerConnection.prototype[method] = function() {\\n      var args = arguments;\\n      if (typeof args[0] === 'function' ||\\n          typeof args[1] === 'function') { // legacy\\n        return nativeMethod.apply(this, [arguments[2]])\\n        .then(function(description) {\\n          if (typeof args[0] === 'function') {\\n            args[0].apply(null, [description]);\\n          }\\n        }, function(error) {\\n          if (typeof args[1] === 'function') {\\n            args[1].apply(null, [error]);\\n          }\\n        });\\n      }\\n      return nativeMethod.apply(this, arguments);\\n    };\\n  });\\n\\n  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];\\n  methods.forEach(function(method) {\\n    var nativeMethod = RTCPeerConnection.prototype[method];\\n    RTCPeerConnection.prototype[method] = function() {\\n      var args = arguments;\\n      if (typeof args[1] === 'function' ||\\n          typeof args[2] === 'function') { // legacy\\n        return nativeMethod.apply(this, arguments)\\n        .then(function() {\\n          if (typeof args[1] === 'function') {\\n            args[1].apply(null);\\n          }\\n        }, function(error) {\\n          if (typeof args[2] === 'function') {\\n            args[2].apply(null, [error]);\\n          }\\n        });\\n      }\\n      return nativeMethod.apply(this, arguments);\\n    };\\n  });\\n\\n  // getStats is special. It doesn't have a spec legacy method yet we support\\n  // getStats(something, cb) without error callbacks.\\n  ['getStats'].forEach(function(method) {\\n    var nativeMethod = RTCPeerConnection.prototype[method];\\n    RTCPeerConnection.prototype[method] = function() {\\n      var args = arguments;\\n      if (typeof args[1] === 'function') {\\n        return nativeMethod.apply(this, arguments)\\n        .then(function() {\\n          if (typeof args[1] === 'function') {\\n            args[1].apply(null);\\n          }\\n        });\\n      }\\n      return nativeMethod.apply(this, arguments);\\n    };\\n  });\\n\\n  return RTCPeerConnection;\\n};\\n\\n\\n/***/ }),\\n/* 137 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n\\n// Expose public methods.\\nmodule.exports = function(window) {\\n  var navigator = window && window.navigator;\\n\\n  var shimError_ = function(e) {\\n    return {\\n      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\\n      message: e.message,\\n      constraint: e.constraint,\\n      toString: function() {\\n        return this.name;\\n      }\\n    };\\n  };\\n\\n  // getUserMedia error shim.\\n  var origGetUserMedia = navigator.mediaDevices.getUserMedia.\\n      bind(navigator.mediaDevices);\\n  navigator.mediaDevices.getUserMedia = function(c) {\\n    return origGetUserMedia(c).catch(function(e) {\\n      return Promise.reject(shimError_(e));\\n    });\\n  };\\n};\\n\\n\\n/***/ }),\\n/* 138 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n\\nvar utils = __webpack_require__(11);\\n\\nvar firefoxShim = {\\n  shimOnTrack: function(window) {\\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\\n        window.RTCPeerConnection.prototype)) {\\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\\n        get: function() {\\n          return this._ontrack;\\n        },\\n        set: function(f) {\\n          if (this._ontrack) {\\n            this.removeEventListener('track', this._ontrack);\\n            this.removeEventListener('addstream', this._ontrackpoly);\\n          }\\n          this.addEventListener('track', this._ontrack = f);\\n          this.addEventListener('addstream', this._ontrackpoly = function(e) {\\n            e.stream.getTracks().forEach(function(track) {\\n              var event = new Event('track');\\n              event.track = track;\\n              event.receiver = {track: track};\\n              event.transceiver = {receiver: event.receiver};\\n              event.streams = [e.stream];\\n              this.dispatchEvent(event);\\n            }.bind(this));\\n          }.bind(this));\\n        }\\n      });\\n    }\\n    if (typeof window === 'object' && window.RTCTrackEvent &&\\n        ('receiver' in window.RTCTrackEvent.prototype) &&\\n        !('transceiver' in window.RTCTrackEvent.prototype)) {\\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\\n        get: function() {\\n          return {receiver: this.receiver};\\n        }\\n      });\\n    }\\n  },\\n\\n  shimSourceObject: function(window) {\\n    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\\n    if (typeof window === 'object') {\\n      if (window.HTMLMediaElement &&\\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\\n          get: function() {\\n            return this.mozSrcObject;\\n          },\\n          set: function(stream) {\\n            this.mozSrcObject = stream;\\n          }\\n        });\\n      }\\n    }\\n  },\\n\\n  shimPeerConnection: function(window) {\\n    var browserDetails = utils.detectBrowser(window);\\n\\n    if (typeof window !== 'object' || !(window.RTCPeerConnection ||\\n        window.mozRTCPeerConnection)) {\\n      return; // probably media.peerconnection.enabled=false in about:config\\n    }\\n    // The RTCPeerConnection object.\\n    if (!window.RTCPeerConnection) {\\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\\n        if (browserDetails.version < 38) {\\n          // .urls is not supported in FF < 38.\\n          // create RTCIceServers with a single url.\\n          if (pcConfig && pcConfig.iceServers) {\\n            var newIceServers = [];\\n            for (var i = 0; i < pcConfig.iceServers.length; i++) {\\n              var server = pcConfig.iceServers[i];\\n              if (server.hasOwnProperty('urls')) {\\n                for (var j = 0; j < server.urls.length; j++) {\\n                  var newServer = {\\n                    url: server.urls[j]\\n                  };\\n                  if (server.urls[j].indexOf('turn') === 0) {\\n                    newServer.username = server.username;\\n                    newServer.credential = server.credential;\\n                  }\\n                  newIceServers.push(newServer);\\n                }\\n              } else {\\n                newIceServers.push(pcConfig.iceServers[i]);\\n              }\\n            }\\n            pcConfig.iceServers = newIceServers;\\n          }\\n        }\\n        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);\\n      };\\n      window.RTCPeerConnection.prototype =\\n          window.mozRTCPeerConnection.prototype;\\n\\n      // wrap static methods. Currently just generateCertificate.\\n      if (window.mozRTCPeerConnection.generateCertificate) {\\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\\n          get: function() {\\n            return window.mozRTCPeerConnection.generateCertificate;\\n          }\\n        });\\n      }\\n\\n      window.RTCSessionDescription = window.mozRTCSessionDescription;\\n      window.RTCIceCandidate = window.mozRTCIceCandidate;\\n    }\\n\\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\\n        .forEach(function(method) {\\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\\n          window.RTCPeerConnection.prototype[method] = function() {\\n            arguments[0] = new ((method === 'addIceCandidate') ?\\n                window.RTCIceCandidate :\\n                window.RTCSessionDescription)(arguments[0]);\\n            return nativeMethod.apply(this, arguments);\\n          };\\n        });\\n\\n    // support for addIceCandidate(null or undefined)\\n    var nativeAddIceCandidate =\\n        window.RTCPeerConnection.prototype.addIceCandidate;\\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\\n      if (!arguments[0]) {\\n        if (arguments[1]) {\\n          arguments[1].apply(null);\\n        }\\n        return Promise.resolve();\\n      }\\n      return nativeAddIceCandidate.apply(this, arguments);\\n    };\\n\\n    // shim getStats with maplike support\\n    var makeMapStats = function(stats) {\\n      var map = new Map();\\n      Object.keys(stats).forEach(function(key) {\\n        map.set(key, stats[key]);\\n        map[key] = stats[key];\\n      });\\n      return map;\\n    };\\n\\n    var modernStatsTypes = {\\n      inboundrtp: 'inbound-rtp',\\n      outboundrtp: 'outbound-rtp',\\n      candidatepair: 'candidate-pair',\\n      localcandidate: 'local-candidate',\\n      remotecandidate: 'remote-candidate'\\n    };\\n\\n    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;\\n    window.RTCPeerConnection.prototype.getStats = function(\\n      selector,\\n      onSucc,\\n      onErr\\n    ) {\\n      return nativeGetStats.apply(this, [selector || null])\\n        .then(function(stats) {\\n          if (browserDetails.version < 48) {\\n            stats = makeMapStats(stats);\\n          }\\n          if (browserDetails.version < 53 && !onSucc) {\\n            // Shim only promise getStats with spec-hyphens in type names\\n            // Leave callback version alone; misc old uses of forEach before Map\\n            try {\\n              stats.forEach(function(stat) {\\n                stat.type = modernStatsTypes[stat.type] || stat.type;\\n              });\\n            } catch (e) {\\n              if (e.name !== 'TypeError') {\\n                throw e;\\n              }\\n              // Avoid TypeError: \\\"type\\\" is read-only, in old versions. 34-43ish\\n              stats.forEach(function(stat, i) {\\n                stats.set(i, Object.assign({}, stat, {\\n                  type: modernStatsTypes[stat.type] || stat.type\\n                }));\\n              });\\n            }\\n          }\\n          return stats;\\n        })\\n        .then(onSucc, onErr);\\n    };\\n  }\\n};\\n\\n// Expose public methods.\\nmodule.exports = {\\n  shimOnTrack: firefoxShim.shimOnTrack,\\n  shimSourceObject: firefoxShim.shimSourceObject,\\n  shimPeerConnection: firefoxShim.shimPeerConnection,\\n  shimGetUserMedia: __webpack_require__(139)\\n};\\n\\n\\n/***/ }),\\n/* 139 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n\\nvar utils = __webpack_require__(11);\\nvar logging = utils.log;\\n\\n// Expose public methods.\\nmodule.exports = function(window) {\\n  var browserDetails = utils.detectBrowser(window);\\n  var navigator = window && window.navigator;\\n  var MediaStreamTrack = window && window.MediaStreamTrack;\\n\\n  var shimError_ = function(e) {\\n    return {\\n      name: {\\n        InternalError: 'NotReadableError',\\n        NotSupportedError: 'TypeError',\\n        PermissionDeniedError: 'NotAllowedError',\\n        SecurityError: 'NotAllowedError'\\n      }[e.name] || e.name,\\n      message: {\\n        'The operation is insecure.': 'The request is not allowed by the ' +\\n        'user agent or the platform in the current context.'\\n      }[e.message] || e.message,\\n      constraint: e.constraint,\\n      toString: function() {\\n        return this.name + (this.message && ': ') + this.message;\\n      }\\n    };\\n  };\\n\\n  // getUserMedia constraints shim.\\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\\n    var constraintsToFF37_ = function(c) {\\n      if (typeof c !== 'object' || c.require) {\\n        return c;\\n      }\\n      var require = [];\\n      Object.keys(c).forEach(function(key) {\\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\\n          return;\\n        }\\n        var r = c[key] = (typeof c[key] === 'object') ?\\n            c[key] : {ideal: c[key]};\\n        if (r.min !== undefined ||\\n            r.max !== undefined || r.exact !== undefined) {\\n          require.push(key);\\n        }\\n        if (r.exact !== undefined) {\\n          if (typeof r.exact === 'number') {\\n            r. min = r.max = r.exact;\\n          } else {\\n            c[key] = r.exact;\\n          }\\n          delete r.exact;\\n        }\\n        if (r.ideal !== undefined) {\\n          c.advanced = c.advanced || [];\\n          var oc = {};\\n          if (typeof r.ideal === 'number') {\\n            oc[key] = {min: r.ideal, max: r.ideal};\\n          } else {\\n            oc[key] = r.ideal;\\n          }\\n          c.advanced.push(oc);\\n          delete r.ideal;\\n          if (!Object.keys(r).length) {\\n            delete c[key];\\n          }\\n        }\\n      });\\n      if (require.length) {\\n        c.require = require;\\n      }\\n      return c;\\n    };\\n    constraints = JSON.parse(JSON.stringify(constraints));\\n    if (browserDetails.version < 38) {\\n      logging('spec: ' + JSON.stringify(constraints));\\n      if (constraints.audio) {\\n        constraints.audio = constraintsToFF37_(constraints.audio);\\n      }\\n      if (constraints.video) {\\n        constraints.video = constraintsToFF37_(constraints.video);\\n      }\\n      logging('ff37: ' + JSON.stringify(constraints));\\n    }\\n    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {\\n      onError(shimError_(e));\\n    });\\n  };\\n\\n  // Returns the result of getUserMedia as a Promise.\\n  var getUserMediaPromise_ = function(constraints) {\\n    return new Promise(function(resolve, reject) {\\n      getUserMedia_(constraints, resolve, reject);\\n    });\\n  };\\n\\n  // Shim for mediaDevices on older versions.\\n  if (!navigator.mediaDevices) {\\n    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,\\n      addEventListener: function() { },\\n      removeEventListener: function() { }\\n    };\\n  }\\n  navigator.mediaDevices.enumerateDevices =\\n      navigator.mediaDevices.enumerateDevices || function() {\\n        return new Promise(function(resolve) {\\n          var infos = [\\n            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},\\n            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}\\n          ];\\n          resolve(infos);\\n        });\\n      };\\n\\n  if (browserDetails.version < 41) {\\n    // Work around http://bugzil.la/1169665\\n    var orgEnumerateDevices =\\n        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\\n    navigator.mediaDevices.enumerateDevices = function() {\\n      return orgEnumerateDevices().then(undefined, function(e) {\\n        if (e.name === 'NotFoundError') {\\n          return [];\\n        }\\n        throw e;\\n      });\\n    };\\n  }\\n  if (browserDetails.version < 49) {\\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\\n        bind(navigator.mediaDevices);\\n    navigator.mediaDevices.getUserMedia = function(c) {\\n      return origGetUserMedia(c).then(function(stream) {\\n        // Work around https://bugzil.la/802326\\n        if (c.audio && !stream.getAudioTracks().length ||\\n            c.video && !stream.getVideoTracks().length) {\\n          stream.getTracks().forEach(function(track) {\\n            track.stop();\\n          });\\n          throw new DOMException('The object can not be found here.',\\n                                 'NotFoundError');\\n        }\\n        return stream;\\n      }, function(e) {\\n        return Promise.reject(shimError_(e));\\n      });\\n    };\\n  }\\n  if (!(browserDetails.version > 55 &&\\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\\n    var remap = function(obj, a, b) {\\n      if (a in obj && !(b in obj)) {\\n        obj[b] = obj[a];\\n        delete obj[a];\\n      }\\n    };\\n\\n    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\\n        bind(navigator.mediaDevices);\\n    navigator.mediaDevices.getUserMedia = function(c) {\\n      if (typeof c === 'object' && typeof c.audio === 'object') {\\n        c = JSON.parse(JSON.stringify(c));\\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\\n      }\\n      return nativeGetUserMedia(c);\\n    };\\n\\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\\n      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;\\n      MediaStreamTrack.prototype.getSettings = function() {\\n        var obj = nativeGetSettings.apply(this, arguments);\\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\\n        return obj;\\n      };\\n    }\\n\\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\\n      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\\n        if (this.kind === 'audio' && typeof c === 'object') {\\n          c = JSON.parse(JSON.stringify(c));\\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\\n        }\\n        return nativeApplyConstraints.apply(this, [c]);\\n      };\\n    }\\n  }\\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\\n    if (browserDetails.version < 44) {\\n      return getUserMedia_(constraints, onSuccess, onError);\\n    }\\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\\n    utils.deprecated('navigator.getUserMedia',\\n        'navigator.mediaDevices.getUserMedia');\\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\\n  };\\n};\\n\\n\\n/***/ }),\\n/* 140 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*\\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n\\nvar utils = __webpack_require__(11);\\n\\nvar safariShim = {\\n  // TODO: DrAlex, should be here, double check against LayoutTests\\n\\n  // TODO: once the back-end for the mac port is done, add.\\n  // TODO: check for webkitGTK+\\n  // shimPeerConnection: function() { },\\n\\n  shimLocalStreamsAPI: function(window) {\\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\\n      return;\\n    }\\n    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\\n      window.RTCPeerConnection.prototype.getLocalStreams = function() {\\n        if (!this._localStreams) {\\n          this._localStreams = [];\\n        }\\n        return this._localStreams;\\n      };\\n    }\\n    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {\\n      window.RTCPeerConnection.prototype.getStreamById = function(id) {\\n        var result = null;\\n        if (this._localStreams) {\\n          this._localStreams.forEach(function(stream) {\\n            if (stream.id === id) {\\n              result = stream;\\n            }\\n          });\\n        }\\n        if (this._remoteStreams) {\\n          this._remoteStreams.forEach(function(stream) {\\n            if (stream.id === id) {\\n              result = stream;\\n            }\\n          });\\n        }\\n        return result;\\n      };\\n    }\\n    if (!('addStream' in window.RTCPeerConnection.prototype)) {\\n      var _addTrack = window.RTCPeerConnection.prototype.addTrack;\\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\\n        if (!this._localStreams) {\\n          this._localStreams = [];\\n        }\\n        if (this._localStreams.indexOf(stream) === -1) {\\n          this._localStreams.push(stream);\\n        }\\n        var self = this;\\n        stream.getTracks().forEach(function(track) {\\n          _addTrack.call(self, track, stream);\\n        });\\n      };\\n\\n      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\\n        if (stream) {\\n          if (!this._localStreams) {\\n            this._localStreams = [stream];\\n          } else if (this._localStreams.indexOf(stream) === -1) {\\n            this._localStreams.push(stream);\\n          }\\n        }\\n        _addTrack.call(this, track, stream);\\n      };\\n    }\\n    if (!('removeStream' in window.RTCPeerConnection.prototype)) {\\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\\n        if (!this._localStreams) {\\n          this._localStreams = [];\\n        }\\n        var index = this._localStreams.indexOf(stream);\\n        if (index === -1) {\\n          return;\\n        }\\n        this._localStreams.splice(index, 1);\\n        var self = this;\\n        var tracks = stream.getTracks();\\n        this.getSenders().forEach(function(sender) {\\n          if (tracks.indexOf(sender.track) !== -1) {\\n            self.removeTrack(sender);\\n          }\\n        });\\n      };\\n    }\\n  },\\n  shimRemoteStreamsAPI: function(window) {\\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\\n      return;\\n    }\\n    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\\n      window.RTCPeerConnection.prototype.getRemoteStreams = function() {\\n        return this._remoteStreams ? this._remoteStreams : [];\\n      };\\n    }\\n    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\\n        get: function() {\\n          return this._onaddstream;\\n        },\\n        set: function(f) {\\n          if (this._onaddstream) {\\n            this.removeEventListener('addstream', this._onaddstream);\\n            this.removeEventListener('track', this._onaddstreampoly);\\n          }\\n          this.addEventListener('addstream', this._onaddstream = f);\\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\\n            var stream = e.streams[0];\\n            if (!this._remoteStreams) {\\n              this._remoteStreams = [];\\n            }\\n            if (this._remoteStreams.indexOf(stream) >= 0) {\\n              return;\\n            }\\n            this._remoteStreams.push(stream);\\n            var event = new Event('addstream');\\n            event.stream = e.streams[0];\\n            this.dispatchEvent(event);\\n          }.bind(this));\\n        }\\n      });\\n    }\\n  },\\n  shimCallbacksAPI: function(window) {\\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\\n      return;\\n    }\\n    var prototype = window.RTCPeerConnection.prototype;\\n    var createOffer = prototype.createOffer;\\n    var createAnswer = prototype.createAnswer;\\n    var setLocalDescription = prototype.setLocalDescription;\\n    var setRemoteDescription = prototype.setRemoteDescription;\\n    var addIceCandidate = prototype.addIceCandidate;\\n\\n    prototype.createOffer = function(successCallback, failureCallback) {\\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\\n      var promise = createOffer.apply(this, [options]);\\n      if (!failureCallback) {\\n        return promise;\\n      }\\n      promise.then(successCallback, failureCallback);\\n      return Promise.resolve();\\n    };\\n\\n    prototype.createAnswer = function(successCallback, failureCallback) {\\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\\n      var promise = createAnswer.apply(this, [options]);\\n      if (!failureCallback) {\\n        return promise;\\n      }\\n      promise.then(successCallback, failureCallback);\\n      return Promise.resolve();\\n    };\\n\\n    var withCallback = function(description, successCallback, failureCallback) {\\n      var promise = setLocalDescription.apply(this, [description]);\\n      if (!failureCallback) {\\n        return promise;\\n      }\\n      promise.then(successCallback, failureCallback);\\n      return Promise.resolve();\\n    };\\n    prototype.setLocalDescription = withCallback;\\n\\n    withCallback = function(description, successCallback, failureCallback) {\\n      var promise = setRemoteDescription.apply(this, [description]);\\n      if (!failureCallback) {\\n        return promise;\\n      }\\n      promise.then(successCallback, failureCallback);\\n      return Promise.resolve();\\n    };\\n    prototype.setRemoteDescription = withCallback;\\n\\n    withCallback = function(candidate, successCallback, failureCallback) {\\n      var promise = addIceCandidate.apply(this, [candidate]);\\n      if (!failureCallback) {\\n        return promise;\\n      }\\n      promise.then(successCallback, failureCallback);\\n      return Promise.resolve();\\n    };\\n    prototype.addIceCandidate = withCallback;\\n  },\\n  shimGetUserMedia: function(window) {\\n    var navigator = window && window.navigator;\\n\\n    if (!navigator.getUserMedia) {\\n      if (navigator.webkitGetUserMedia) {\\n        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\\n      } else if (navigator.mediaDevices &&\\n          navigator.mediaDevices.getUserMedia) {\\n        navigator.getUserMedia = function(constraints, cb, errcb) {\\n          navigator.mediaDevices.getUserMedia(constraints)\\n          .then(cb, errcb);\\n        }.bind(navigator);\\n      }\\n    }\\n  },\\n  shimRTCIceServerUrls: function(window) {\\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\\n    var OrigPeerConnection = window.RTCPeerConnection;\\n    window.RTCPeerConnection = function(pcConfig, pcConstraints) {\\n      if (pcConfig && pcConfig.iceServers) {\\n        var newIceServers = [];\\n        for (var i = 0; i < pcConfig.iceServers.length; i++) {\\n          var server = pcConfig.iceServers[i];\\n          if (!server.hasOwnProperty('urls') &&\\n              server.hasOwnProperty('url')) {\\n            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\\n            server = JSON.parse(JSON.stringify(server));\\n            server.urls = server.url;\\n            delete server.url;\\n            newIceServers.push(server);\\n          } else {\\n            newIceServers.push(pcConfig.iceServers[i]);\\n          }\\n        }\\n        pcConfig.iceServers = newIceServers;\\n      }\\n      return new OrigPeerConnection(pcConfig, pcConstraints);\\n    };\\n    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\\n    // wrap static methods. Currently just generateCertificate.\\n    if ('generateCertificate' in window.RTCPeerConnection) {\\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\\n        get: function() {\\n          return OrigPeerConnection.generateCertificate;\\n        }\\n      });\\n    }\\n  },\\n  shimTrackEventTransceiver: function(window) {\\n    // Add event.transceiver member over deprecated event.receiver\\n    if (typeof window === 'object' && window.RTCPeerConnection &&\\n        ('receiver' in window.RTCTrackEvent.prototype) &&\\n        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is\\n        // defined for some reason even when window.RTCTransceiver is not.\\n        !window.RTCTransceiver) {\\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\\n        get: function() {\\n          return {receiver: this.receiver};\\n        }\\n      });\\n    }\\n  },\\n\\n  shimCreateOfferLegacy: function(window) {\\n    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\\n    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {\\n      var pc = this;\\n      if (offerOptions) {\\n        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {\\n          return transceiver.sender.track &&\\n              transceiver.sender.track.kind === 'audio';\\n        });\\n        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\\n          if (audioTransceiver.direction === 'sendrecv') {\\n            audioTransceiver.setDirection('sendonly');\\n          } else if (audioTransceiver.direction === 'recvonly') {\\n            audioTransceiver.setDirection('inactive');\\n          }\\n        } else if (offerOptions.offerToReceiveAudio === true &&\\n            !audioTransceiver) {\\n          pc.addTransceiver('audio');\\n        }\\n\\n        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {\\n          return transceiver.sender.track &&\\n              transceiver.sender.track.kind === 'video';\\n        });\\n        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\\n          if (videoTransceiver.direction === 'sendrecv') {\\n            videoTransceiver.setDirection('sendonly');\\n          } else if (videoTransceiver.direction === 'recvonly') {\\n            videoTransceiver.setDirection('inactive');\\n          }\\n        } else if (offerOptions.offerToReceiveVideo === true &&\\n            !videoTransceiver) {\\n          pc.addTransceiver('video');\\n        }\\n      }\\n      return origCreateOffer.apply(pc, arguments);\\n    };\\n  }\\n};\\n\\n// Expose public methods.\\nmodule.exports = {\\n  shimCallbacksAPI: safariShim.shimCallbacksAPI,\\n  shimLocalStreamsAPI: safariShim.shimLocalStreamsAPI,\\n  shimRemoteStreamsAPI: safariShim.shimRemoteStreamsAPI,\\n  shimGetUserMedia: safariShim.shimGetUserMedia,\\n  shimRTCIceServerUrls: safariShim.shimRTCIceServerUrls,\\n  shimTrackEventTransceiver: safariShim.shimTrackEventTransceiver,\\n  shimCreateOfferLegacy: safariShim.shimCreateOfferLegacy\\n  // TODO\\n  // shimPeerConnection: safariShim.shimPeerConnection\\n};\\n\\n\\n/***/ }),\\n/* 141 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/*\\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\\n *\\n *  Use of this source code is governed by a BSD-style license\\n *  that can be found in the LICENSE file in the root of the source\\n *  tree.\\n */\\n /* eslint-env node */\\n\\n\\nvar SDPUtils = __webpack_require__(57);\\nvar utils = __webpack_require__(11);\\n\\n// Wraps the peerconnection event eventNameToWrap in a function\\n// which returns the modified event object.\\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\\n  if (!window.RTCPeerConnection) {\\n    return;\\n  }\\n  var proto = window.RTCPeerConnection.prototype;\\n  var nativeAddEventListener = proto.addEventListener;\\n  proto.addEventListener = function(nativeEventName, cb) {\\n    if (nativeEventName !== eventNameToWrap) {\\n      return nativeAddEventListener.apply(this, arguments);\\n    }\\n    var wrappedCallback = function(e) {\\n      cb(wrapper(e));\\n    };\\n    this._eventMap = this._eventMap || {};\\n    this._eventMap[cb] = wrappedCallback;\\n    return nativeAddEventListener.apply(this, [nativeEventName,\\n      wrappedCallback]);\\n  };\\n\\n  var nativeRemoveEventListener = proto.removeEventListener;\\n  proto.removeEventListener = function(nativeEventName, cb) {\\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\\n        || !this._eventMap[cb]) {\\n      return nativeRemoveEventListener.apply(this, arguments);\\n    }\\n    var unwrappedCb = this._eventMap[cb];\\n    delete this._eventMap[cb];\\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\\n      unwrappedCb]);\\n  };\\n\\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\\n    get: function() {\\n      return this['_on' + eventNameToWrap];\\n    },\\n    set: function(cb) {\\n      if (this['_on' + eventNameToWrap]) {\\n        this.removeEventListener(eventNameToWrap,\\n            this['_on' + eventNameToWrap]);\\n        delete this['_on' + eventNameToWrap];\\n      }\\n      if (cb) {\\n        this.addEventListener(eventNameToWrap,\\n            this['_on' + eventNameToWrap] = cb);\\n      }\\n    }\\n  });\\n}\\n\\nmodule.exports = {\\n  shimRTCIceCandidate: function(window) {\\n    // foundation is arbitrarily chosen as an indicator for full support for\\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\\n    if (window.RTCIceCandidate && 'foundation' in\\n        window.RTCIceCandidate.prototype) {\\n      return;\\n    }\\n\\n    var NativeRTCIceCandidate = window.RTCIceCandidate;\\n    window.RTCIceCandidate = function(args) {\\n      // Remove the a= which shouldn't be part of the candidate string.\\n      if (typeof args === 'object' && args.candidate &&\\n          args.candidate.indexOf('a=') === 0) {\\n        args = JSON.parse(JSON.stringify(args));\\n        args.candidate = args.candidate.substr(2);\\n      }\\n\\n      // Augment the native candidate with the parsed fields.\\n      var nativeCandidate = new NativeRTCIceCandidate(args);\\n      var parsedCandidate = SDPUtils.parseCandidate(args.candidate);\\n      var augmentedCandidate = Object.assign(nativeCandidate,\\n          parsedCandidate);\\n\\n      // Add a serializer that does not serialize the extra attributes.\\n      augmentedCandidate.toJSON = function() {\\n        return {\\n          candidate: augmentedCandidate.candidate,\\n          sdpMid: augmentedCandidate.sdpMid,\\n          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\\n          usernameFragment: augmentedCandidate.usernameFragment,\\n        };\\n      };\\n      return augmentedCandidate;\\n    };\\n\\n    // Hook up the augmented candidate in onicecandidate and\\n    // addEventListener('icecandidate', ...)\\n    wrapPeerConnectionEvent(window, 'icecandidate', function(e) {\\n      if (e.candidate) {\\n        Object.defineProperty(e, 'candidate', {\\n          value: new window.RTCIceCandidate(e.candidate),\\n          writable: 'false'\\n        });\\n      }\\n      return e;\\n    });\\n  },\\n\\n  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.\\n\\n  shimCreateObjectURL: function(window) {\\n    var URL = window && window.URL;\\n\\n    if (!(typeof window === 'object' && window.HTMLMediaElement &&\\n          'srcObject' in window.HTMLMediaElement.prototype &&\\n        URL.createObjectURL && URL.revokeObjectURL)) {\\n      // Only shim CreateObjectURL using srcObject if srcObject exists.\\n      return undefined;\\n    }\\n\\n    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);\\n    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);\\n    var streams = new Map(), newId = 0;\\n\\n    URL.createObjectURL = function(stream) {\\n      if ('getTracks' in stream) {\\n        var url = 'polyblob:' + (++newId);\\n        streams.set(url, stream);\\n        utils.deprecated('URL.createObjectURL(stream)',\\n            'elem.srcObject = stream');\\n        return url;\\n      }\\n      return nativeCreateObjectURL(stream);\\n    };\\n    URL.revokeObjectURL = function(url) {\\n      nativeRevokeObjectURL(url);\\n      streams.delete(url);\\n    };\\n\\n    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,\\n                                              'src');\\n    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {\\n      get: function() {\\n        return dsc.get.apply(this);\\n      },\\n      set: function(url) {\\n        this.srcObject = streams.get(url) || null;\\n        return dsc.set.apply(this, [url]);\\n      }\\n    });\\n\\n    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;\\n    window.HTMLMediaElement.prototype.setAttribute = function() {\\n      if (arguments.length === 2 &&\\n          ('' + arguments[0]).toLowerCase() === 'src') {\\n        this.srcObject = streams.get(arguments[1]) || null;\\n      }\\n      return nativeSetAttribute.apply(this, arguments);\\n    };\\n  }\\n};\\n\\n\\n/***/ }),\\n/* 142 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony export (immutable) */ __webpack_exports__[\\\"a\\\"] = TraceablePeerConnection;\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sdp_transform__ = __webpack_require__(15);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_sdp_transform__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__ = __webpack_require__(3);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__JitsiRemoteTrack__ = __webpack_require__(143);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__LocalSdpMunger__ = __webpack_require__(144);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__RTC__ = __webpack_require__(27);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__RTCUtils__ = __webpack_require__(28);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__xmpp_RtxModifier__ = __webpack_require__(145);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__xmpp_SDP__ = __webpack_require__(52);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__xmpp_SdpConsistency__ = __webpack_require__(146);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__xmpp_SdpTransformUtil__ = __webpack_require__(29);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__ = __webpack_require__(14);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__service_RTC_SignalingEvents__ = __webpack_require__(53);\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\n/* global __filename, RTCSessionDescription */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// FIXME SDP tools should end up in some kind of util module\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\nvar SIMULCAST_LAYERS = 3;\\nvar SIM_LAYER_1_RID = '1';\\nvar SIM_LAYER_2_RID = '2';\\nvar SIM_LAYER_3_RID = '3';\\nvar SIM_LAYER_RIDS = [SIM_LAYER_1_RID, SIM_LAYER_2_RID, SIM_LAYER_3_RID];\\n\\n/* eslint-disable max-params */\\n\\n/**\\n * Creates new instance of 'TraceablePeerConnection'.\\n *\\n * @param {RTC} rtc the instance of <tt>RTC</tt> service\\n * @param {number} id the peer connection id assigned by the parent RTC module.\\n * @param {SignalingLayer} signalingLayer the signaling layer instance\\n * @param {object} iceConfig WebRTC 'PeerConnection' ICE config\\n * @param {object} constraints WebRTC 'PeerConnection' constraints\\n * @param {boolean} isP2P indicates whether or not the new instance will be used\\n * in a peer to peer connection\\n * @param {object} options <tt>TracablePeerConnection</tt> config options.\\n * @param {boolean} options.disableSimulcast if set to 'true' will disable\\n * the simulcast.\\n * @param {boolean} options.disableRtx if set to 'true' will disable the RTX\\n * @param {boolean} options.enableFirefoxSimulcast if set to 'true' will enable\\n * experimental simulcast support on Firefox.\\n * @param {boolean} options.disableH264 If set to 'true' H264 will be\\n *      disabled by removing it from the SDP.\\n * @param {boolean} options.preferH264 if set to 'true' H264 will be preferred\\n * over other video codecs.\\n *\\n * FIXME: initially the purpose of TraceablePeerConnection was to be able to\\n * debug the peer connection. Since many other responsibilities have been added\\n * it would make sense to extract a separate class from it and come up with\\n * a more suitable name.\\n *\\n * @constructor\\n */\\nfunction TraceablePeerConnection(rtc, id, signalingLayer, iceConfig, constraints, isP2P, options) {\\n    var _this = this;\\n\\n    /**\\n     * Indicates whether or not this peer connection instance is actively\\n     * sending/receiving audio media. When set to <tt>false</tt> the SDP audio\\n     * media direction will be adjusted to 'inactive' in order to suspend\\n     * the transmission.\\n     * @type {boolean}\\n     * @private\\n     */\\n    this.audioTransferActive = true;\\n\\n    /**\\n     * Indicates whether or not this peer connection instance is actively\\n     * sending/receiving video media. When set to <tt>false</tt> the SDP video\\n     * media direction will be adjusted to 'inactive' in order to suspend\\n     * the transmission.\\n     * @type {boolean}\\n     * @private\\n     */\\n    this.videoTransferActive = true;\\n\\n    /**\\n     * The parent instance of RTC service which created this\\n     * <tt>TracablePeerConnection</tt>.\\n     * @type {RTC}\\n     */\\n    this.rtc = rtc;\\n\\n    /**\\n     * The peer connection identifier assigned by the RTC module.\\n     * @type {number}\\n     */\\n    this.id = id;\\n\\n    /**\\n     * Indicates whether or not this instance is used in a peer to peer\\n     * connection.\\n     * @type {boolean}\\n     */\\n    this.isP2P = isP2P;\\n\\n    // FIXME: We should support multiple streams per jid.\\n    /**\\n     * The map holds remote tracks associated with this peer connection.\\n     * It maps user's JID to media type and remote track\\n     * (one track per media type per user's JID).\\n     * @type {Map<string, Map<MediaType, JitsiRemoteTrack>>}\\n     */\\n    this.remoteTracks = new Map();\\n\\n    /**\\n     * A map which stores local tracks mapped by {@link JitsiLocalTrack.rtcId}\\n     * @type {Map<number, JitsiLocalTrack>}\\n     */\\n    this.localTracks = new Map();\\n\\n    /**\\n     * Keeps tracks of the WebRTC <tt>MediaStream</tt>s that have been added to\\n     * the underlying WebRTC PeerConnection. An Array is used to avoid errors in\\n     * IE11 with adding temasys MediaStream objects into other data structures.\\n     * @type {Array}\\n     * @private\\n     */\\n    this._addedStreams = [];\\n\\n    /**\\n     * @typedef {Object} TPCGroupInfo\\n     * @property {string} semantics the SSRC groups semantics\\n     * @property {Array<number>} ssrcs group's SSRCs in order where the first\\n     * one is group's primary SSRC, the second one is secondary (RTX) and so\\n     * on...\\n     */\\n    /**\\n     * @typedef {Object} TPCSSRCInfo\\n     * @property {Array<number>} ssrcs an array which holds all track's SSRCs\\n     * @property {Array<TPCGroupInfo>} groups an array stores all track's SSRC\\n     * groups\\n     */\\n    /**\\n     * Holds the info about local track's SSRCs mapped per their\\n     * {@link JitsiLocalTrack.rtcId}\\n     * @type {Map<number, TPCSSRCInfo>}\\n     */\\n    this.localSSRCs = new Map();\\n\\n    /**\\n     * The local ICE username fragment for this session.\\n     */\\n    this.localUfrag = null;\\n\\n    /**\\n     * The remote ICE username fragment for this session.\\n     */\\n    this.remoteUfrag = null;\\n\\n    /**\\n     * The signaling layer which operates this peer connection.\\n     * @type {SignalingLayer}\\n     */\\n    this.signalingLayer = signalingLayer;\\n\\n    // SignalingLayer listeners\\n    this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this);\\n    this.signalingLayer.on(__WEBPACK_IMPORTED_MODULE_15__service_RTC_SignalingEvents__[\\\"b\\\" /* PEER_VIDEO_TYPE_CHANGED */], this._peerVideoTypeChanged);\\n\\n    this._peerMutedChanged = this._peerMutedChanged.bind(this);\\n    this.signalingLayer.on(__WEBPACK_IMPORTED_MODULE_15__service_RTC_SignalingEvents__[\\\"a\\\" /* PEER_MUTED_CHANGED */], this._peerMutedChanged);\\n    this.options = options;\\n\\n    this.peerconnection = new __WEBPACK_IMPORTED_MODULE_7__RTCUtils__[\\\"a\\\" /* default */].RTCPeerConnectionType(iceConfig, constraints);\\n    this.updateLog = [];\\n    this.stats = {};\\n    this.statsinterval = null;\\n\\n    /**\\n     * @type {number}\\n     */\\n    this.maxstats = 0;\\n    var Interop = __webpack_require__(147).Interop;\\n\\n    this.interop = new Interop();\\n    var Simulcast = __webpack_require__(151);\\n\\n    this.simulcast = new Simulcast({ numOfLayers: SIMULCAST_LAYERS,\\n        explodeRemoteSimulcast: false });\\n    this.sdpConsistency = new __WEBPACK_IMPORTED_MODULE_12__xmpp_SdpConsistency__[\\\"a\\\" /* default */](this.toString());\\n\\n    /**\\n     * Munges local SDP provided to the Jingle Session in order to prevent from\\n     * sending SSRC updates on attach/detach and mute/unmute (for video).\\n     * @type {LocalSdpMunger}\\n     */\\n    this.localSdpMunger = new __WEBPACK_IMPORTED_MODULE_5__LocalSdpMunger__[\\\"a\\\" /* default */](this);\\n\\n    /**\\n     * TracablePeerConnection uses RTC's eventEmitter\\n     * @type {EventEmitter}\\n     */\\n    this.eventEmitter = rtc.eventEmitter;\\n    this.rtxModifier = new __WEBPACK_IMPORTED_MODULE_10__xmpp_RtxModifier__[\\\"a\\\" /* default */]();\\n\\n    // override as desired\\n    this.trace = function (what, info) {\\n        /* logger.warn('WTRACE', what, info);\\n        if (info && RTCBrowserType.isIExplorer()) {\\n            if (info.length > 1024) {\\n                logger.warn('WTRACE', what, info.substr(1024));\\n            }\\n            if (info.length > 2048) {\\n                logger.warn('WTRACE', what, info.substr(2048));\\n            }\\n        }*/\\n        _this.updateLog.push({\\n            time: new Date(),\\n            type: what,\\n            value: info || ''\\n        });\\n    };\\n    this.onicecandidate = null;\\n    this.peerconnection.onicecandidate = function (event) {\\n        // FIXME: this causes stack overflow with Temasys Plugin\\n        if (!__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed()) {\\n            _this.trace('onicecandidate', JSON.stringify(event.candidate, null, ' '));\\n        }\\n\\n        if (_this.onicecandidate !== null) {\\n            _this.onicecandidate(event);\\n        }\\n    };\\n    this.peerconnection.onaddstream = function (event) {\\n        return _this._remoteStreamAdded(event.stream);\\n    };\\n    this.peerconnection.onremovestream = function (event) {\\n        return _this._remoteStreamRemoved(event.stream);\\n    };\\n    this.onsignalingstatechange = null;\\n    this.peerconnection.onsignalingstatechange = function (event) {\\n        _this.trace('onsignalingstatechange', _this.signalingState);\\n        if (_this.onsignalingstatechange !== null) {\\n            _this.onsignalingstatechange(event);\\n        }\\n    };\\n    this.oniceconnectionstatechange = null;\\n    this.peerconnection.oniceconnectionstatechange = function (event) {\\n        _this.trace('oniceconnectionstatechange', _this.iceConnectionState);\\n        if (_this.oniceconnectionstatechange !== null) {\\n            _this.oniceconnectionstatechange(event);\\n        }\\n    };\\n    this.onnegotiationneeded = null;\\n    this.peerconnection.onnegotiationneeded = function (event) {\\n        _this.trace('onnegotiationneeded');\\n        if (_this.onnegotiationneeded !== null) {\\n            _this.onnegotiationneeded(event);\\n        }\\n    };\\n    this.ondatachannel = null;\\n    this.peerconnection.ondatachannel = function (event) {\\n        _this.trace('ondatachannel', event);\\n        if (_this.ondatachannel !== null) {\\n            _this.ondatachannel(event);\\n        }\\n    };\\n\\n    // XXX: do all non-firefox browsers which we support also support this?\\n    if (!__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox() && this.maxstats) {\\n        this.statsinterval = window.setInterval(function () {\\n            _this.peerconnection.getStats(function (stats) {\\n                var results = stats.result();\\n                var now = new Date();\\n\\n                var _loop = function _loop(i) {\\n                    results[i].names().forEach(function (name) {\\n                        // eslint-disable-next-line no-shadow\\n                        var id = results[i].id + '-' + name;\\n                        var s = _this.stats[id];\\n\\n                        if (!s) {\\n                            _this.stats[id] = s = {\\n                                startTime: now,\\n                                endTime: now,\\n                                values: [],\\n                                times: []\\n                            };\\n                        }\\n                        s.values.push(results[i].stat(name));\\n                        s.times.push(now.getTime());\\n                        if (s.values.length > _this.maxstats) {\\n                            s.values.shift();\\n                            s.times.shift();\\n                        }\\n                        s.endTime = now;\\n                    });\\n                };\\n\\n                for (var i = 0; i < results.length; ++i) {\\n                    _loop(i);\\n                }\\n            });\\n        }, 1000);\\n    }\\n\\n    logger.info('Create new ' + this);\\n}\\n\\n/* eslint-enable max-params */\\n\\n/**\\n * Returns a string representation of a SessionDescription object.\\n */\\nvar dumpSDP = function dumpSDP(description) {\\n    if (typeof description === 'undefined' || description === null) {\\n        return '';\\n    }\\n\\n    return 'type: ' + description.type + '\\\\r\\\\n' + description.sdp;\\n};\\n\\n/**\\n * Forwards the {@link peerconnection.iceConnectionState} state except that it\\n * will convert \\\"completed\\\" into \\\"connected\\\" where both mean that the ICE has\\n * succeeded and is up and running. We never see \\\"completed\\\" state for\\n * the JVB connection, but it started appearing for the P2P one. This method\\n * allows to adapt old logic to this new situation.\\n * @return {string}\\n */\\nTraceablePeerConnection.prototype.getConnectionState = function () {\\n    var state = this.peerconnection.iceConnectionState;\\n\\n    if (state === 'completed') {\\n        return 'connected';\\n    }\\n\\n    return state;\\n};\\n\\n/**\\n * Obtains the media direction for given {@link MediaType}. The method takes\\n * into account whether or not there are any local tracks for media and\\n * the {@link audioTransferActive} and {@link videoTransferActive} flags.\\n * @param {MediaType} mediaType\\n * @return {string} one of the SDP direction constants ('sendrecv, 'recvonly'\\n * etc.) which should be used when setting local description on the peer\\n * connection.\\n * @private\\n */\\nTraceablePeerConnection.prototype._getDesiredMediaDirection = function (mediaType) {\\n    var mediaTransferActive = true;\\n\\n    if (mediaType === __WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]) {\\n        mediaTransferActive = this.audioTransferActive;\\n    } else if (mediaType === __WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]) {\\n        mediaTransferActive = this.videoTransferActive;\\n    }\\n    if (mediaTransferActive) {\\n        return this.hasAnyTracksOfType(mediaType) ? 'sendrecv' : 'recvonly';\\n    }\\n\\n    return 'inactive';\\n};\\n\\n/**\\n * Tells whether or not this TPC instance is using Simulcast.\\n * @return {boolean} <tt>true</tt> if simulcast is enabled and active or\\n * <tt>false</tt> if it's turned off.\\n */\\nTraceablePeerConnection.prototype.isSimulcastOn = function () {\\n    return !this.options.disableSimulcast && __WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].supportsSimulcast()\\n\\n    // Firefox has been added as supporting simulcast, but it is\\n    // experimental so we only want to do it for firefox if the config\\n    // option is set.  Unfortunately, RTCBrowserType::supportsSimulcast()\\n    // doesn't have a reference to the config options, so we have\\n    // to do it here\\n    && (!__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox() || this.options.enableFirefoxSimulcast);\\n};\\n\\n/**\\n * Handles {@link SignalingEvents.PEER_VIDEO_TYPE_CHANGED}\\n * @param {string} endpointId the video owner's ID (MUC nickname)\\n * @param {VideoType} videoType the new value\\n * @private\\n */\\nTraceablePeerConnection.prototype._peerVideoTypeChanged = function (endpointId, videoType) {\\n    // Check if endpointId has a value to avoid action on random track\\n    if (!endpointId) {\\n        logger.error('No endpointID on peerVideoTypeChanged ' + this);\\n\\n        return;\\n    }\\n    var videoTrack = this.getRemoteTracks(endpointId, __WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]);\\n\\n    if (videoTrack.length) {\\n        // NOTE 1 track per media type is assumed\\n        videoTrack[0]._setVideoType(videoType);\\n    }\\n};\\n\\n/**\\n * Handles remote track mute / unmute events.\\n * @param {string} endpointId the track owner's identifier (MUC nickname)\\n * @param {MediaType} mediaType \\\"audio\\\" or \\\"video\\\"\\n * @param {boolean} isMuted the new mute state\\n * @private\\n */\\nTraceablePeerConnection.prototype._peerMutedChanged = function (endpointId, mediaType, isMuted) {\\n    // Check if endpointId is a value to avoid doing action on all remote tracks\\n    if (!endpointId) {\\n        logger.error('On peerMuteChanged - no endpoint ID');\\n\\n        return;\\n    }\\n    var track = this.getRemoteTracks(endpointId, mediaType);\\n\\n    if (track.length) {\\n        // NOTE 1 track per media type is assumed\\n        track[0].setMute(isMuted);\\n    }\\n};\\n\\n/**\\n * Obtains local tracks for given {@link MediaType}. If the <tt>mediaType</tt>\\n * argument is omitted the list of all local tracks will be returned.\\n * @param {MediaType} [mediaType]\\n * @return {Array<JitsiLocalTrack>}\\n */\\nTraceablePeerConnection.prototype.getLocalTracks = function (mediaType) {\\n    var tracks = Array.from(this.localTracks.values());\\n\\n    if (mediaType !== undefined) {\\n        tracks = tracks.filter(function (track) {\\n            return track.getType() === mediaType;\\n        });\\n    }\\n\\n    return tracks;\\n};\\n\\n/**\\n * Checks whether or not this {@link TraceablePeerConnection} instance contains\\n * any local tracks for given <tt>mediaType</tt>.\\n * @param {MediaType} mediaType\\n * @return {boolean}\\n */\\nTraceablePeerConnection.prototype.hasAnyTracksOfType = function (mediaType) {\\n    if (!mediaType) {\\n        throw new Error('\\\"mediaType\\\" is required');\\n    }\\n\\n    return this.getLocalTracks(mediaType).length > 0;\\n};\\n\\n/**\\n * Obtains all remote tracks currently known to this PeerConnection instance.\\n * @param {string} [endpointId] the track owner's identifier (MUC nickname)\\n * @param {MediaType} [mediaType] the remote tracks will be filtered\\n * by their media type if this argument is specified.\\n * @return {Array<JitsiRemoteTrack>}\\n */\\nTraceablePeerConnection.prototype.getRemoteTracks = function (endpointId, mediaType) {\\n    var remoteTracks = [];\\n    var endpoints = endpointId ? [endpointId] : this.remoteTracks.keys();\\n\\n    var _iteratorNormalCompletion = true;\\n    var _didIteratorError = false;\\n    var _iteratorError = undefined;\\n\\n    try {\\n        for (var _iterator = endpoints[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n            var endpoint = _step.value;\\n\\n            var endpointTrackMap = this.remoteTracks.get(endpoint);\\n\\n            if (!endpointTrackMap) {\\n\\n                // Otherwise an empty Map() would have to be allocated above\\n                // eslint-disable-next-line no-continue\\n                continue;\\n            }\\n\\n            var _iteratorNormalCompletion2 = true;\\n            var _didIteratorError2 = false;\\n            var _iteratorError2 = undefined;\\n\\n            try {\\n                for (var _iterator2 = endpointTrackMap.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                    var trackMediaType = _step2.value;\\n\\n                    // per media type filtering\\n                    if (!mediaType || mediaType === trackMediaType) {\\n                        var mediaTrack = endpointTrackMap.get(trackMediaType);\\n\\n                        if (mediaTrack) {\\n                            remoteTracks.push(mediaTrack);\\n                        }\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError2 = true;\\n                _iteratorError2 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                        _iterator2.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError2) {\\n                        throw _iteratorError2;\\n                    }\\n                }\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError = true;\\n        _iteratorError = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion && _iterator.return) {\\n                _iterator.return();\\n            }\\n        } finally {\\n            if (_didIteratorError) {\\n                throw _iteratorError;\\n            }\\n        }\\n    }\\n\\n    return remoteTracks;\\n};\\n\\n/**\\n * Tries to find {@link JitsiTrack} for given SSRC number. It will search both\\n * local and remote tracks bound to this instance.\\n * @param {number} ssrc\\n * @return {JitsiTrack|null}\\n */\\nTraceablePeerConnection.prototype.getTrackBySSRC = function (ssrc) {\\n    if (typeof ssrc !== 'number') {\\n        throw new Error('SSRC ' + ssrc + ' is not a number');\\n    }\\n    var _iteratorNormalCompletion3 = true;\\n    var _didIteratorError3 = false;\\n    var _iteratorError3 = undefined;\\n\\n    try {\\n        for (var _iterator3 = this.localTracks.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n            var localTrack = _step3.value;\\n\\n            if (this.getLocalSSRC(localTrack) === ssrc) {\\n                return localTrack;\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError3 = true;\\n        _iteratorError3 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n                _iterator3.return();\\n            }\\n        } finally {\\n            if (_didIteratorError3) {\\n                throw _iteratorError3;\\n            }\\n        }\\n    }\\n\\n    var _iteratorNormalCompletion4 = true;\\n    var _didIteratorError4 = false;\\n    var _iteratorError4 = undefined;\\n\\n    try {\\n        for (var _iterator4 = this.getRemoteTracks()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n            var remoteTrack = _step4.value;\\n\\n            if (remoteTrack.getSSRC() === ssrc) {\\n                return remoteTrack;\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError4 = true;\\n        _iteratorError4 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n                _iterator4.return();\\n            }\\n        } finally {\\n            if (_didIteratorError4) {\\n                throw _iteratorError4;\\n            }\\n        }\\n    }\\n\\n    return null;\\n};\\n\\n/**\\n * Called when new remote MediaStream is added to the PeerConnection.\\n * @param {MediaStream} stream the WebRTC MediaStream for remote participant\\n */\\nTraceablePeerConnection.prototype._remoteStreamAdded = function (stream) {\\n    var _this2 = this;\\n\\n    var streamId = __WEBPACK_IMPORTED_MODULE_6__RTC__[\\\"a\\\" /* default */].getStreamID(stream);\\n\\n    if (!__WEBPACK_IMPORTED_MODULE_6__RTC__[\\\"a\\\" /* default */].isUserStreamById(streamId)) {\\n        logger.info(this + ' ignored remote \\\\'stream added\\\\' event for non-user stream' + ('id: ' + streamId));\\n\\n        return;\\n    }\\n\\n    // Bind 'addtrack'/'removetrack' event handlers\\n    if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isChrome() || __WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isNWJS() || __WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isElectron() || __WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isEdge()) {\\n        stream.onaddtrack = function (event) {\\n            _this2._remoteTrackAdded(stream, event.track);\\n        };\\n        stream.onremovetrack = function (event) {\\n            _this2._remoteTrackRemoved(stream, event.track);\\n        };\\n    }\\n\\n    // Call remoteTrackAdded for each track in the stream\\n    var streamAudioTracks = stream.getAudioTracks();\\n\\n    var _iteratorNormalCompletion5 = true;\\n    var _didIteratorError5 = false;\\n    var _iteratorError5 = undefined;\\n\\n    try {\\n        for (var _iterator5 = streamAudioTracks[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\\n            var audioTrack = _step5.value;\\n\\n            this._remoteTrackAdded(stream, audioTrack);\\n        }\\n    } catch (err) {\\n        _didIteratorError5 = true;\\n        _iteratorError5 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\\n                _iterator5.return();\\n            }\\n        } finally {\\n            if (_didIteratorError5) {\\n                throw _iteratorError5;\\n            }\\n        }\\n    }\\n\\n    var streamVideoTracks = stream.getVideoTracks();\\n\\n    var _iteratorNormalCompletion6 = true;\\n    var _didIteratorError6 = false;\\n    var _iteratorError6 = undefined;\\n\\n    try {\\n        for (var _iterator6 = streamVideoTracks[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\\n            var videoTrack = _step6.value;\\n\\n            this._remoteTrackAdded(stream, videoTrack);\\n        }\\n    } catch (err) {\\n        _didIteratorError6 = true;\\n        _iteratorError6 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\\n                _iterator6.return();\\n            }\\n        } finally {\\n            if (_didIteratorError6) {\\n                throw _iteratorError6;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Called on \\\"track added\\\" and \\\"stream added\\\" PeerConnection events (because we\\n * handle streams on per track basis). Finds the owner and the SSRC for\\n * the track and passes that to ChatRoom for further processing.\\n * @param {MediaStream} stream the WebRTC MediaStream instance which is\\n * the parent of the track\\n * @param {MediaStreamTrack} track the WebRTC MediaStreamTrack added for remote\\n * participant\\n */\\nTraceablePeerConnection.prototype._remoteTrackAdded = function (stream, track) {\\n    var streamId = __WEBPACK_IMPORTED_MODULE_6__RTC__[\\\"a\\\" /* default */].getStreamID(stream);\\n    var mediaType = track.kind;\\n\\n    logger.info(this + ' remote track added:', streamId, mediaType);\\n\\n    // look up an associated JID for a stream id\\n    if (!mediaType) {\\n        __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__[\\\"callErrorHandler\\\"](new Error('MediaType undefined for remote track, stream id: ' + streamId));\\n\\n        // Abort\\n        return;\\n    }\\n\\n    var remoteSDP = new __WEBPACK_IMPORTED_MODULE_11__xmpp_SDP__[\\\"a\\\" /* default */](this.remoteDescription.sdp);\\n    var mediaLines = remoteSDP.media.filter(function (mls) {\\n        return mls.startsWith('m=' + mediaType);\\n    });\\n\\n    if (!mediaLines.length) {\\n        __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__[\\\"callErrorHandler\\\"](new Error('No media lines for type ' + mediaType + ' found in remote SDP for remote track: ' + streamId));\\n\\n        // Abort\\n        return;\\n    }\\n\\n    var ssrcLines = __WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].findLines(mediaLines[0], 'a=ssrc:');\\n\\n    ssrcLines = ssrcLines.filter(function (line) {\\n        var msid = __WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed() ? 'mslabel' : 'msid';\\n\\n        return line.indexOf(msid + ':' + streamId) !== -1;\\n    });\\n    if (!ssrcLines.length) {\\n        __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__[\\\"callErrorHandler\\\"](new Error('No SSRC lines for streamId ' + streamId + ' for remote track, media type: ' + mediaType));\\n\\n        // Abort\\n        return;\\n    }\\n\\n    // FIXME the length of ssrcLines[0] not verified, but it will fail\\n    // with global error handler anyway\\n    var ssrcStr = ssrcLines[0].substring(7).split(' ')[0];\\n    var trackSsrc = Number(ssrcStr);\\n    var ownerEndpointId = this.signalingLayer.getSSRCOwner(trackSsrc);\\n\\n    if (isNaN(trackSsrc) || trackSsrc < 0) {\\n        __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__[\\\"callErrorHandler\\\"](new Error('Invalid SSRC: ' + ssrcStr + ' for remote track, msid: ' + streamId + ' media type: ' + mediaType));\\n\\n        // Abort\\n        return;\\n    } else if (!ownerEndpointId) {\\n        __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__[\\\"callErrorHandler\\\"](new Error('No SSRC owner known for: ' + trackSsrc + ' for remote track, msid: ' + streamId + ' media type: ' + mediaType));\\n\\n        // Abort\\n        return;\\n    }\\n\\n    logger.log(this + ' associated ssrc', ownerEndpointId, trackSsrc);\\n\\n    var peerMediaInfo = this.signalingLayer.getPeerMediaInfo(ownerEndpointId, mediaType);\\n\\n    if (!peerMediaInfo) {\\n        __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__[\\\"callErrorHandler\\\"](new Error(this + ': no peer media info available for ' + ownerEndpointId));\\n\\n        return;\\n    }\\n\\n    var muted = peerMediaInfo.muted;\\n    var videoType = peerMediaInfo.videoType; // can be undefined\\n\\n    this._createRemoteTrack(ownerEndpointId, stream, track, mediaType, videoType, trackSsrc, muted);\\n};\\n\\n// FIXME cleanup params\\n/* eslint-disable max-params */\\n\\n/**\\n * Initializes a new JitsiRemoteTrack instance with the data provided by\\n * the signaling layer and SDP.\\n *\\n * @param {string} ownerEndpointId the owner's endpoint ID (MUC nickname)\\n * @param {MediaStream} stream the WebRTC stream instance\\n * @param {MediaStreamTrack} track the WebRTC track instance\\n * @param {MediaType} mediaType the track's type of the media\\n * @param {VideoType} [videoType] the track's type of the video (if applicable)\\n * @param {number} ssrc the track's main SSRC number\\n * @param {boolean} muted the initial muted status\\n */\\nTraceablePeerConnection.prototype._createRemoteTrack = function (ownerEndpointId, stream, track, mediaType, videoType, ssrc, muted) {\\n    var remoteTrack = new __WEBPACK_IMPORTED_MODULE_3__JitsiRemoteTrack__[\\\"a\\\" /* default */](this.rtc, this.rtc.conference, ownerEndpointId, stream, track, mediaType, videoType, ssrc, muted, this.isP2P);\\n    var remoteTracksMap = this.remoteTracks.get(ownerEndpointId);\\n\\n    if (!remoteTracksMap) {\\n        remoteTracksMap = new Map();\\n        this.remoteTracks.set(ownerEndpointId, remoteTracksMap);\\n    }\\n\\n    if (remoteTracksMap.has(mediaType)) {\\n        logger.error(this + ' overwriting remote track! ' + remoteTrack, ownerEndpointId, mediaType);\\n    }\\n    remoteTracksMap.set(mediaType, remoteTrack);\\n\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.REMOTE_TRACK_ADDED, remoteTrack);\\n};\\n\\n/* eslint-enable max-params */\\n\\n/**\\n * Handles remote stream removal.\\n * @param stream the WebRTC MediaStream object which is being removed from the\\n * PeerConnection\\n */\\nTraceablePeerConnection.prototype._remoteStreamRemoved = function (stream) {\\n    if (!__WEBPACK_IMPORTED_MODULE_6__RTC__[\\\"a\\\" /* default */].isUserStream(stream)) {\\n        var id = __WEBPACK_IMPORTED_MODULE_6__RTC__[\\\"a\\\" /* default */].getStreamID(stream);\\n\\n        logger.info('Ignored remote \\\\'stream removed\\\\' event for non-user stream ' + id);\\n\\n        return;\\n    }\\n\\n    // Call remoteTrackRemoved for each track in the stream\\n    var streamVideoTracks = stream.getVideoTracks();\\n\\n    var _iteratorNormalCompletion7 = true;\\n    var _didIteratorError7 = false;\\n    var _iteratorError7 = undefined;\\n\\n    try {\\n        for (var _iterator7 = streamVideoTracks[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\\n            var videoTrack = _step7.value;\\n\\n            this._remoteTrackRemoved(stream, videoTrack);\\n        }\\n    } catch (err) {\\n        _didIteratorError7 = true;\\n        _iteratorError7 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\\n                _iterator7.return();\\n            }\\n        } finally {\\n            if (_didIteratorError7) {\\n                throw _iteratorError7;\\n            }\\n        }\\n    }\\n\\n    var streamAudioTracks = stream.getAudioTracks();\\n\\n    var _iteratorNormalCompletion8 = true;\\n    var _didIteratorError8 = false;\\n    var _iteratorError8 = undefined;\\n\\n    try {\\n        for (var _iterator8 = streamAudioTracks[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\\n            var audioTrack = _step8.value;\\n\\n            this._remoteTrackRemoved(stream, audioTrack);\\n        }\\n    } catch (err) {\\n        _didIteratorError8 = true;\\n        _iteratorError8 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion8 && _iterator8.return) {\\n                _iterator8.return();\\n            }\\n        } finally {\\n            if (_didIteratorError8) {\\n                throw _iteratorError8;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Handles remote media track removal.\\n * @param {MediaStream} stream WebRTC MediaStream instance which is the parent\\n * of the track.\\n * @param {MediaStreamTrack} track the WebRTC MediaStreamTrack which has been\\n * removed from the PeerConnection.\\n */\\nTraceablePeerConnection.prototype._remoteTrackRemoved = function (stream, track) {\\n    var streamId = __WEBPACK_IMPORTED_MODULE_6__RTC__[\\\"a\\\" /* default */].getStreamID(stream);\\n    var trackId = track && __WEBPACK_IMPORTED_MODULE_6__RTC__[\\\"a\\\" /* default */].getTrackID(track);\\n\\n    logger.info(this + ' - remote track removed: ' + streamId + ', ' + trackId);\\n\\n    if (!streamId) {\\n        __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__[\\\"callErrorHandler\\\"](new Error(this + ' remote track removal failed - no stream ID'));\\n\\n        return;\\n    }\\n\\n    if (!trackId) {\\n        __WEBPACK_IMPORTED_MODULE_2__util_GlobalOnErrorHandler__[\\\"callErrorHandler\\\"](new Error(this + ' remote track removal failed - no track ID'));\\n\\n        return;\\n    }\\n\\n    if (!this._removeRemoteTrackById(streamId, trackId)) {\\n        // NOTE this warning is always printed when user leaves the room,\\n        // because we remove remote tracks manually on MUC member left event,\\n        // before the SSRCs are removed by Jicofo. In most cases it is fine to\\n        // ignore this warning, but still it's better to keep it printed for\\n        // debugging purposes.\\n        //\\n        // We could change the behaviour to emit track removed only from here,\\n        // but the order of the events will change and consuming apps could\\n        // behave unexpectedly (the \\\"user left\\\" event would come before \\\"track\\n        // removed\\\" events).\\n        logger.warn(this + ' Removed track not found for msid: ' + streamId + ',\\\\n             track id: ' + trackId);\\n    }\\n};\\n\\n/**\\n * Finds remote track by it's stream and track ids.\\n * @param {string} streamId the media stream id as defined by the WebRTC\\n * @param {string} trackId the media track id as defined by the WebRTC\\n * @return {JitsiRemoteTrack|undefined} the track's instance or\\n * <tt>undefined</tt> if not found.\\n * @private\\n */\\nTraceablePeerConnection.prototype._getRemoteTrackById = function (streamId, trackId) {\\n    // .find will break the loop once the first match is found\\n    var _iteratorNormalCompletion9 = true;\\n    var _didIteratorError9 = false;\\n    var _iteratorError9 = undefined;\\n\\n    try {\\n        for (var _iterator9 = this.remoteTracks.values()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\\n            var endpointTrackMap = _step9.value;\\n            var _iteratorNormalCompletion10 = true;\\n            var _didIteratorError10 = false;\\n            var _iteratorError10 = undefined;\\n\\n            try {\\n                for (var _iterator10 = endpointTrackMap.values()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\\n                    var mediaTrack = _step10.value;\\n\\n                    // FIXME verify and try to use ===\\n                    /* eslint-disable eqeqeq */\\n                    if (mediaTrack.getStreamId() == streamId && mediaTrack.getTrackId() == trackId) {\\n                        return mediaTrack;\\n                    }\\n\\n                    /* eslint-enable eqeqeq */\\n                }\\n            } catch (err) {\\n                _didIteratorError10 = true;\\n                _iteratorError10 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion10 && _iterator10.return) {\\n                        _iterator10.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError10) {\\n                        throw _iteratorError10;\\n                    }\\n                }\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError9 = true;\\n        _iteratorError9 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion9 && _iterator9.return) {\\n                _iterator9.return();\\n            }\\n        } finally {\\n            if (_didIteratorError9) {\\n                throw _iteratorError9;\\n            }\\n        }\\n    }\\n\\n    return undefined;\\n};\\n\\n/**\\n * Removes all JitsiRemoteTracks associated with given MUC nickname\\n * (resource part of the JID). Returns array of removed tracks.\\n *\\n * @param {string} owner - The resource part of the MUC JID.\\n * @returns {JitsiRemoteTrack[]}\\n */\\nTraceablePeerConnection.prototype.removeRemoteTracks = function (owner) {\\n    var removedTracks = [];\\n    var remoteTracksMap = this.remoteTracks.get(owner);\\n\\n    if (remoteTracksMap) {\\n        var removedAudioTrack = remoteTracksMap.get(__WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]);\\n        var removedVideoTrack = remoteTracksMap.get(__WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]);\\n\\n        removedAudioTrack && removedTracks.push(removedAudioTrack);\\n        removedVideoTrack && removedTracks.push(removedVideoTrack);\\n\\n        this.remoteTracks.delete(owner);\\n    }\\n\\n    logger.debug(this + ' removed remote tracks for ' + owner + ' count: ' + removedTracks.length);\\n\\n    return removedTracks;\\n};\\n\\n/**\\n * Removes and disposes given <tt>JitsiRemoteTrack</tt> instance. Emits\\n * {@link RTCEvents.REMOTE_TRACK_REMOVED}.\\n * @param {JitsiRemoteTrack} toBeRemoved\\n */\\nTraceablePeerConnection.prototype._removeRemoteTrack = function (toBeRemoved) {\\n    toBeRemoved.dispose();\\n    var participantId = toBeRemoved.getParticipantId();\\n    var remoteTracksMap = this.remoteTracks.get(participantId);\\n\\n    if (!remoteTracksMap) {\\n        logger.error('removeRemoteTrack: no remote tracks map for ' + participantId);\\n    } else if (!remoteTracksMap.delete(toBeRemoved.getType())) {\\n        logger.error('Failed to remove ' + toBeRemoved + ' - type mapping messed up ?');\\n    }\\n    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.REMOTE_TRACK_REMOVED, toBeRemoved);\\n};\\n\\n/**\\n * Removes and disposes <tt>JitsiRemoteTrack</tt> identified by given stream and\\n * track ids.\\n *\\n * @param {string} streamId the media stream id as defined by the WebRTC\\n * @param {string} trackId the media track id as defined by the WebRTC\\n * @returns {JitsiRemoteTrack|undefined} the track which has been removed or\\n * <tt>undefined</tt> if no track matching given stream and track ids was\\n * found.\\n */\\nTraceablePeerConnection.prototype._removeRemoteTrackById = function (streamId, trackId) {\\n    var toBeRemoved = this._getRemoteTrackById(streamId, trackId);\\n\\n    if (toBeRemoved) {\\n        this._removeRemoteTrack(toBeRemoved);\\n    }\\n\\n    return toBeRemoved;\\n};\\n\\n/**\\n * @typedef {Object} SSRCGroupInfo\\n * @property {Array<number>} ssrcs group's SSRCs\\n * @property {string} semantics\\n */\\n/**\\n * @typedef {Object} TrackSSRCInfo\\n * @property {Array<number>} ssrcs track's SSRCs\\n * @property {Array<SSRCGroupInfo>} groups track's SSRC groups\\n */\\n/**\\n * Returns map with keys msid and <tt>TrackSSRCInfo</tt> values.\\n * @param {Object} desc the WebRTC SDP instance.\\n * @return {Map<string,TrackSSRCInfo>}\\n */\\nfunction extractSSRCMap(desc) {\\n    /**\\n     * Track SSRC infos mapped by stream ID (msid)\\n     * @type {Map<string,TrackSSRCInfo>}\\n     */\\n    var ssrcMap = new Map();\\n\\n    /**\\n     * Groups mapped by primary SSRC number\\n     * @type {Map<number,Array<SSRCGroupInfo>>}\\n     */\\n    var groupsMap = new Map();\\n\\n    if ((typeof desc === 'undefined' ? 'undefined' : _typeof(desc)) !== 'object' || desc === null || typeof desc.sdp !== 'string') {\\n        logger.warn('An empty description was passed as an argument.');\\n\\n        return ssrcMap;\\n    }\\n\\n    var session = __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.parse(desc.sdp);\\n\\n    if (!Array.isArray(session.media)) {\\n        return ssrcMap;\\n    }\\n\\n    var _iteratorNormalCompletion11 = true;\\n    var _didIteratorError11 = false;\\n    var _iteratorError11 = undefined;\\n\\n    try {\\n        for (var _iterator11 = session.media[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\\n            var mLine = _step11.value;\\n\\n            if (!Array.isArray(mLine.ssrcs)) {\\n                continue; // eslint-disable-line no-continue\\n            }\\n\\n            if (Array.isArray(mLine.ssrcGroups)) {\\n                var _iteratorNormalCompletion12 = true;\\n                var _didIteratorError12 = false;\\n                var _iteratorError12 = undefined;\\n\\n                try {\\n                    for (var _iterator12 = mLine.ssrcGroups[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\\n                        var group = _step12.value;\\n\\n                        if (typeof group.semantics !== 'undefined' && typeof group.ssrcs !== 'undefined') {\\n                            // Parse SSRCs and store as numbers\\n                            var groupSSRCs = group.ssrcs.split(' ').map(function (ssrcStr) {\\n                                return parseInt(ssrcStr, 10);\\n                            });\\n                            var primarySSRC = groupSSRCs[0];\\n\\n                            // Note that group.semantics is already present\\n\\n                            group.ssrcs = groupSSRCs;\\n\\n                            // eslint-disable-next-line max-depth\\n                            if (!groupsMap.has(primarySSRC)) {\\n                                groupsMap.set(primarySSRC, []);\\n                            }\\n                            groupsMap.get(primarySSRC).push(group);\\n                        }\\n                    }\\n                } catch (err) {\\n                    _didIteratorError12 = true;\\n                    _iteratorError12 = err;\\n                } finally {\\n                    try {\\n                        if (!_iteratorNormalCompletion12 && _iterator12.return) {\\n                            _iterator12.return();\\n                        }\\n                    } finally {\\n                        if (_didIteratorError12) {\\n                            throw _iteratorError12;\\n                        }\\n                    }\\n                }\\n            }\\n            var _iteratorNormalCompletion13 = true;\\n            var _didIteratorError13 = false;\\n            var _iteratorError13 = undefined;\\n\\n            try {\\n                for (var _iterator13 = mLine.ssrcs[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\\n                    var ssrc = _step13.value;\\n\\n                    if (ssrc.attribute !== 'msid') {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    var msid = ssrc.value;\\n                    var ssrcInfo = ssrcMap.get(msid);\\n\\n                    if (!ssrcInfo) {\\n                        ssrcInfo = {\\n                            ssrcs: [],\\n                            groups: [],\\n                            msid: msid\\n                        };\\n                        ssrcMap.set(msid, ssrcInfo);\\n                    }\\n\\n                    var ssrcNumber = ssrc.id;\\n\\n                    ssrcInfo.ssrcs.push(ssrcNumber);\\n\\n                    if (groupsMap.has(ssrcNumber)) {\\n                        var ssrcGroups = groupsMap.get(ssrcNumber);\\n\\n                        var _iteratorNormalCompletion14 = true;\\n                        var _didIteratorError14 = false;\\n                        var _iteratorError14 = undefined;\\n\\n                        try {\\n                            for (var _iterator14 = ssrcGroups[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\\n                                var _group = _step14.value;\\n\\n                                ssrcInfo.groups.push(_group);\\n                            }\\n                        } catch (err) {\\n                            _didIteratorError14 = true;\\n                            _iteratorError14 = err;\\n                        } finally {\\n                            try {\\n                                if (!_iteratorNormalCompletion14 && _iterator14.return) {\\n                                    _iterator14.return();\\n                                }\\n                            } finally {\\n                                if (_didIteratorError14) {\\n                                    throw _iteratorError14;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError13 = true;\\n                _iteratorError13 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion13 && _iterator13.return) {\\n                        _iterator13.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError13) {\\n                        throw _iteratorError13;\\n                    }\\n                }\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError11 = true;\\n        _iteratorError11 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion11 && _iterator11.return) {\\n                _iterator11.return();\\n            }\\n        } finally {\\n            if (_didIteratorError11) {\\n                throw _iteratorError11;\\n            }\\n        }\\n    }\\n\\n    return ssrcMap;\\n}\\n\\n/**\\n * Takes a SessionDescription object and returns a \\\"normalized\\\" version.\\n * Currently it only takes care of ordering the a=ssrc lines.\\n */\\nvar normalizePlanB = function normalizePlanB(desc) {\\n    if ((typeof desc === 'undefined' ? 'undefined' : _typeof(desc)) !== 'object' || desc === null || typeof desc.sdp !== 'string') {\\n        logger.warn('An empty description was passed as an argument.');\\n\\n        return desc;\\n    }\\n\\n    // eslint-disable-next-line no-shadow\\n    var transform = __webpack_require__(15);\\n    var session = transform.parse(desc.sdp);\\n\\n    if (typeof session !== 'undefined' && typeof session.media !== 'undefined' && Array.isArray(session.media)) {\\n        session.media.forEach(function (mLine) {\\n\\n            // Chrome appears to be picky about the order in which a=ssrc lines\\n            // are listed in an m-line when rtx is enabled (and thus there are\\n            // a=ssrc-group lines with FID semantics). Specifically if we have\\n            // \\\"a=ssrc-group:FID S1 S2\\\" and the \\\"a=ssrc:S2\\\" lines appear before\\n            // the \\\"a=ssrc:S1\\\" lines, SRD fails.\\n            // So, put SSRC which appear as the first SSRC in an FID ssrc-group\\n            // first.\\n            var firstSsrcs = [];\\n            var newSsrcLines = [];\\n\\n            if (typeof mLine.ssrcGroups !== 'undefined' && Array.isArray(mLine.ssrcGroups)) {\\n                mLine.ssrcGroups.forEach(function (group) {\\n                    if (typeof group.semantics !== 'undefined' && group.semantics === 'FID') {\\n                        if (typeof group.ssrcs !== 'undefined') {\\n                            firstSsrcs.push(Number(group.ssrcs.split(' ')[0]));\\n                        }\\n                    }\\n                });\\n            }\\n\\n            if (Array.isArray(mLine.ssrcs)) {\\n                var i = void 0;\\n\\n                for (i = 0; i < mLine.ssrcs.length; i++) {\\n                    if (_typeof(mLine.ssrcs[i]) === 'object' && typeof mLine.ssrcs[i].id !== 'undefined' && firstSsrcs.indexOf(mLine.ssrcs[i].id) >= 0) {\\n                        newSsrcLines.push(mLine.ssrcs[i]);\\n                        delete mLine.ssrcs[i];\\n                    }\\n                }\\n\\n                for (i = 0; i < mLine.ssrcs.length; i++) {\\n                    if (typeof mLine.ssrcs[i] !== 'undefined') {\\n                        newSsrcLines.push(mLine.ssrcs[i]);\\n                    }\\n                }\\n\\n                mLine.ssrcs = newSsrcLines;\\n            }\\n        });\\n    }\\n\\n    var resStr = transform.write(session);\\n\\n    return new RTCSessionDescription({\\n        type: desc.type,\\n        sdp: resStr\\n    });\\n};\\n\\n/**\\n * Makes sure that both audio and video directions are configured as 'sendrecv'.\\n * @param {Object} localDescription the SDP object as defined by WebRTC.\\n */\\nvar enforceSendRecv = function enforceSendRecv(localDescription) {\\n    if (!localDescription) {\\n        throw new Error('No local description passed in.');\\n    }\\n\\n    var transformer = new __WEBPACK_IMPORTED_MODULE_13__xmpp_SdpTransformUtil__[\\\"a\\\" /* SdpTransformWrap */](localDescription.sdp);\\n    var audioMedia = transformer.selectMedia('audio');\\n    var changed = false;\\n\\n    if (audioMedia && audioMedia.direction !== 'sendrecv') {\\n        audioMedia.direction = 'sendrecv';\\n        changed = true;\\n    }\\n\\n    var videoMedia = transformer.selectMedia('video');\\n\\n    if (videoMedia && videoMedia.direction !== 'sendrecv') {\\n        videoMedia.direction = 'sendrecv';\\n        changed = true;\\n    }\\n\\n    if (changed) {\\n        return new RTCSessionDescription({\\n            type: localDescription.type,\\n            sdp: transformer.toRawSDP()\\n        });\\n    }\\n\\n    return localDescription;\\n};\\n\\n/**\\n *\\n * @param {JitsiLocalTrack} localTrack\\n */\\nTraceablePeerConnection.prototype.getLocalSSRC = function (localTrack) {\\n    var ssrcInfo = this._getSSRC(localTrack.rtcId);\\n\\n    return ssrcInfo && ssrcInfo.ssrcs[0];\\n};\\n\\n/**\\n * When doing unified plan simulcast, we'll have a set of ssrcs with the\\n * same msid but no ssrc-group, since unified plan signals the simulcast\\n * group via the a=simulcast line.  Unfortunately, Jicofo will complain\\n * if it sees ssrcs with matching msids but no ssrc-group, so we'll inject\\n * an ssrc-group line to make Jicofo happy.\\n * NOTE: unlike plan B simulcast, the ssrcs in this inject ssrc-group will\\n * NOT necessarily be in order of quality (low to high) because:\\n * a) when translating between unified plan and plan b the order of the ssrcs\\n * is not preserved and\\n * b) it isn't guaranteed that firefox will give them to us in order to begin\\n * with\\n * @param desc A session description object (with 'type' and 'sdp' fields)\\n * @return A session description object with its sdp field modified to\\n * contain an inject ssrc-group for simulcast\\n */\\nTraceablePeerConnection.prototype._injectSsrcGroupForUnifiedSimulcast = function (desc) {\\n    var sdp = __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.parse(desc.sdp);\\n    var video = sdp.media.find(function (mline) {\\n        return mline.type === 'video';\\n    });\\n\\n    if (video.simulcast_03) {\\n        var ssrcs = [];\\n\\n        video.ssrcs.forEach(function (ssrc) {\\n            if (ssrc.attribute === 'msid') {\\n                ssrcs.push(ssrc.id);\\n            }\\n        });\\n        video.ssrcGroups = video.ssrcGroups || [];\\n        if (video.ssrcGroups.find(function (group) {\\n            return group.semantics === 'SIM';\\n        })) {\\n            // Group already exists, no need to do anything\\n            return desc;\\n        }\\n        video.ssrcGroups.push({\\n            semantics: 'SIM',\\n            ssrcs: ssrcs.join(' ')\\n        });\\n    }\\n\\n    return new RTCSessionDescription({\\n        type: desc.type,\\n        sdp: __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.write(sdp)\\n    });\\n};\\n\\n/* eslint-disable-next-line vars-on-top */\\nvar getters = {\\n    signalingState: function signalingState() {\\n        return this.peerconnection.signalingState;\\n    },\\n    iceConnectionState: function iceConnectionState() {\\n        return this.peerconnection.iceConnectionState;\\n    },\\n    localDescription: function localDescription() {\\n        var desc = this.peerconnection.localDescription;\\n\\n        if (!desc) {\\n            logger.debug('getLocalDescription no localDescription found');\\n\\n            return {};\\n        }\\n\\n        this.trace('getLocalDescription::preTransform', dumpSDP(desc));\\n\\n        // if we're running on FF, transform to Plan B first.\\n        if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].usesUnifiedPlan()) {\\n            desc = this.interop.toPlanB(desc);\\n            this.trace('getLocalDescription::postTransform (Plan B)', dumpSDP(desc));\\n\\n            desc = this._injectSsrcGroupForUnifiedSimulcast(desc);\\n            this.trace('getLocalDescription::postTransform (inject ssrc group)', dumpSDP(desc));\\n        }\\n\\n        if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].doesVideoMuteByStreamRemove()) {\\n            desc = this.localSdpMunger.maybeAddMutedLocalVideoTracksToSDP(desc);\\n            logger.debug('getLocalDescription::postTransform (munge local SDP)', desc);\\n        }\\n\\n        // What comes out of this getter will be signalled over Jingle to\\n        // the other peer, so we need to make sure the media direction is\\n        // 'sendrecv' because we won't change the direction later and don't want\\n        // the other peer to think we can't send or receive.\\n        //\\n        // Note that the description we set in chrome does have the accurate\\n        // direction (e.g. 'recvonly'), since that is technically what is\\n        // happening (check setLocalDescription impl).\\n        desc = enforceSendRecv(desc);\\n\\n        return desc;\\n    },\\n    remoteDescription: function remoteDescription() {\\n        var desc = this.peerconnection.remoteDescription;\\n\\n        this.trace('getRemoteDescription::preTransform', dumpSDP(desc));\\n\\n        // if we're running on FF, transform to Plan B first.\\n        if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].usesUnifiedPlan()) {\\n            desc = this.interop.toPlanB(desc);\\n            this.trace('getRemoteDescription::postTransform (Plan B)', dumpSDP(desc));\\n        }\\n\\n        return desc || {};\\n    }\\n};\\n\\nObject.keys(getters).forEach(function (prop) {\\n    Object.defineProperty(TraceablePeerConnection.prototype, prop, {\\n        get: getters[prop]\\n    });\\n});\\n\\nTraceablePeerConnection.prototype._getSSRC = function (rtcId) {\\n    return this.localSSRCs.get(rtcId);\\n};\\n\\n/**\\n * Add {@link JitsiLocalTrack} to this TPC.\\n * @param {JitsiLocalTrack} track\\n */\\nTraceablePeerConnection.prototype.addTrack = function (track) {\\n    var rtcId = track.rtcId;\\n\\n    logger.info('add ' + track + ' to: ' + this);\\n\\n    if (this.localTracks.has(rtcId)) {\\n        logger.error(track + ' is already in ' + this);\\n\\n        return;\\n    }\\n\\n    this.localTracks.set(rtcId, track);\\n\\n    var webrtcStream = track.getOriginalStream();\\n\\n    if (webrtcStream) {\\n        this._addStream(webrtcStream);\\n\\n        // It's not ok for a track to not have a WebRTC stream if:\\n    } else if (!__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].doesVideoMuteByStreamRemove() || track.isAudioTrack() || track.isVideoTrack() && !track.isMuted()) {\\n        logger.error(this + ' no WebRTC stream for: ' + track);\\n    }\\n\\n    // Muted video tracks do not have WebRTC stream\\n    if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].doesVideoMuteByStreamRemove() && track.isVideoTrack() && track.isMuted()) {\\n        var ssrcInfo = this.generateNewStreamSSRCInfo(track);\\n\\n        this.sdpConsistency.setPrimarySsrc(ssrcInfo.ssrcs[0]);\\n        var simGroup = ssrcInfo.groups.find(function (groupInfo) {\\n            return groupInfo.semantics === 'SIM';\\n        });\\n\\n        if (simGroup) {\\n            this.simulcast.setSsrcCache(simGroup.ssrcs);\\n        }\\n        var fidGroups = ssrcInfo.groups.filter(function (groupInfo) {\\n            return groupInfo.semantics === 'FID';\\n        });\\n\\n        if (fidGroups) {\\n            var rtxSsrcMapping = new Map();\\n\\n            fidGroups.forEach(function (fidGroup) {\\n                var primarySsrc = fidGroup.ssrcs[0];\\n                var rtxSsrc = fidGroup.ssrcs[1];\\n\\n                rtxSsrcMapping.set(primarySsrc, rtxSsrc);\\n            });\\n            this.rtxModifier.setSsrcCache(rtxSsrcMapping);\\n        }\\n    }\\n};\\n\\n/**\\n * Adds local track as part of the unmute operation.\\n * @param {JitsiLocalTrack} track the track to be added as part of the unmute\\n * operation\\n * @return {boolean} <tt>true</tt> if the state of underlying PC has changed and\\n * the renegotiation is required or <tt>false</tt> otherwise.\\n */\\nTraceablePeerConnection.prototype.addTrackUnmute = function (track) {\\n    if (!this._assertTrackBelongs('addTrackUnmute', track)) {\\n        // Abort\\n        return false;\\n    }\\n\\n    logger.info('Adding ' + track + ' as unmute to ' + this);\\n    var webRtcStream = track.getOriginalStream();\\n\\n    if (!webRtcStream) {\\n        logger.error('Unable to add ' + track + ' as unmute to ' + this + ' - no WebRTC stream');\\n\\n        return false;\\n    }\\n    this._addStream(webRtcStream);\\n\\n    return true;\\n};\\n\\n/**\\n * Adds WebRTC media stream to the underlying PeerConnection\\n * @param {MediaStream} mediaStream\\n * @private\\n */\\nTraceablePeerConnection.prototype._addStream = function (mediaStream) {\\n    this.peerconnection.addStream(mediaStream);\\n    this._addedStreams.push(mediaStream);\\n};\\n\\n/**\\n * Removes WebRTC media stream from the underlying PeerConection\\n * @param {MediaStream} mediaStream\\n */\\nTraceablePeerConnection.prototype._removeStream = function (mediaStream) {\\n    if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox()) {\\n        this._handleFirefoxRemoveStream(mediaStream);\\n    } else {\\n        this.peerconnection.removeStream(mediaStream);\\n    }\\n    this._addedStreams = this._addedStreams.filter(function (stream) {\\n        return stream !== mediaStream;\\n    });\\n};\\n\\n/**\\n * This method when called will check if given <tt>localTrack</tt> belongs to\\n * this TPC (that it has been previously added using {@link addTrack}). If the\\n * track does not belong an error message will be logged.\\n * @param {string} methodName the method name that will be logged in an error\\n * message\\n * @param {JitsiLocalTrack} localTrack\\n * @return {boolean} <tt>true</tt> if given local track belongs to this TPC or\\n * <tt>false</tt> otherwise.\\n * @private\\n */\\nTraceablePeerConnection.prototype._assertTrackBelongs = function (methodName, localTrack) {\\n    var doesBelong = this.localTracks.has(localTrack.rtcId);\\n\\n    if (!doesBelong) {\\n        logger.error(methodName + ': ' + localTrack + ' does not belong to ' + this);\\n    }\\n\\n    return doesBelong;\\n};\\n\\n/**\\n * Tells if the given WebRTC <tt>MediaStream</tt> has been added to\\n * the underlying WebRTC PeerConnection.\\n * @param {MediaStream} mediaStream\\n * @returns {boolean}\\n */\\nTraceablePeerConnection.prototype.isMediaStreamInPc = function (mediaStream) {\\n    return this._addedStreams.indexOf(mediaStream) > -1;\\n};\\n\\n/**\\n * Remove local track from this TPC.\\n * @param {JitsiLocalTrack} localTrack the track to be removed from this TPC.\\n *\\n * FIXME It should probably remove a boolean just like {@link removeTrackMute}\\n *       The same applies to addTrack.\\n */\\nTraceablePeerConnection.prototype.removeTrack = function (localTrack) {\\n    var webRtcStream = localTrack.getOriginalStream();\\n\\n    this.trace('removeStream', localTrack.rtcId, webRtcStream ? webRtcStream.id : undefined);\\n\\n    if (!this._assertTrackBelongs('removeStream', localTrack)) {\\n        // Abort - nothing to be done here\\n        return;\\n    }\\n    this.localTracks.delete(localTrack.rtcId);\\n    this.localSSRCs.delete(localTrack.rtcId);\\n\\n    if (webRtcStream) {\\n        if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox()) {\\n            this._handleFirefoxRemoveStream(webRtcStream);\\n        } else {\\n            this.peerconnection.removeStream(webRtcStream);\\n        }\\n    }\\n};\\n\\n/**\\n * Removes local track as part of the mute operation.\\n * @param {JitsiLocalTrack} localTrack the local track to be remove as part of\\n * the mute operation.\\n * @return {boolean} <tt>true</tt> if the underlying PeerConnection's state has\\n * changed and the renegotiation is required or <tt>false</tt> otherwise.\\n */\\nTraceablePeerConnection.prototype.removeTrackMute = function (localTrack) {\\n    var webRtcStream = localTrack.getOriginalStream();\\n\\n    this.trace('removeStreamMute', localTrack.rtcId, webRtcStream ? webRtcStream.id : null);\\n\\n    if (!this._assertTrackBelongs('removeStreamMute', localTrack)) {\\n        // Abort - nothing to be done here\\n        return false;\\n    }\\n\\n    if (webRtcStream) {\\n        logger.info('Removing ' + localTrack + ' as mute from ' + this);\\n        this._removeStream(webRtcStream);\\n\\n        return true;\\n    }\\n\\n    logger.error('removeStreamMute - no WebRTC stream for ' + localTrack);\\n\\n    return false;\\n};\\n\\n/**\\n * Remove stream handling for firefox\\n * @param stream: webrtc media stream\\n */\\nTraceablePeerConnection.prototype._handleFirefoxRemoveStream = function (stream) {\\n    if (!stream) {\\n        // There is nothing to be changed\\n        return;\\n    }\\n    var sender = null;\\n\\n    // On Firefox we don't replace MediaStreams as this messes up the\\n    // m-lines (which can't be removed in Plan Unified) and brings a lot\\n    // of complications. Instead, we use the RTPSender and remove just\\n    // the track.\\n    var track = null;\\n\\n    if (stream.getAudioTracks() && stream.getAudioTracks().length) {\\n        track = stream.getAudioTracks()[0];\\n    } else if (stream.getVideoTracks() && stream.getVideoTracks().length) {\\n        track = stream.getVideoTracks()[0];\\n    }\\n\\n    if (!track) {\\n        logger.error('Cannot remove tracks: no tracks.');\\n\\n        return;\\n    }\\n\\n    // Find the right sender (for audio or video)\\n    this.peerconnection.getSenders().some(function (s) {\\n        if (s.track === track) {\\n            sender = s;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    });\\n\\n    if (sender) {\\n        this.peerconnection.removeTrack(sender);\\n    } else {\\n        logger.log('Cannot remove tracks: no RTPSender.');\\n    }\\n};\\n\\nTraceablePeerConnection.prototype.createDataChannel = function (label, opts) {\\n    this.trace('createDataChannel', label, opts);\\n\\n    return this.peerconnection.createDataChannel(label, opts);\\n};\\n\\n/**\\n * Ensures that the simulcast ssrc-group appears after any other ssrc-groups\\n * in the SDP so that simulcast is properly activated.\\n *\\n * @param {Object} localSdp the WebRTC session description instance for\\n * the local description.\\n * @private\\n */\\nTraceablePeerConnection.prototype._ensureSimulcastGroupIsLast = function (localSdp) {\\n    var sdpStr = localSdp.sdp;\\n\\n    var videoStartIndex = sdpStr.indexOf('m=video');\\n    var simStartIndex = sdpStr.indexOf('a=ssrc-group:SIM', videoStartIndex);\\n    var otherStartIndex = sdpStr.lastIndexOf('a=ssrc-group');\\n\\n    if (simStartIndex === -1 || otherStartIndex === -1 || otherStartIndex === simStartIndex) {\\n        return localSdp;\\n    }\\n\\n    var simEndIndex = sdpStr.indexOf('\\\\r\\\\n', simStartIndex);\\n    var simStr = sdpStr.substring(simStartIndex, simEndIndex + 2);\\n\\n    sdpStr = sdpStr.replace(simStr, '');\\n    otherStartIndex = sdpStr.lastIndexOf('a=ssrc-group');\\n    var otherEndIndex = sdpStr.indexOf('\\\\r\\\\n', otherStartIndex);\\n    var sdpHead = sdpStr.slice(0, otherEndIndex);\\n    var simStrTrimmed = simStr.trim();\\n    var sdpTail = sdpStr.slice(otherEndIndex);\\n\\n    sdpStr = sdpHead + '\\\\r\\\\n' + simStrTrimmed + sdpTail;\\n\\n    return new RTCSessionDescription({\\n        type: localSdp.type,\\n        sdp: sdpStr\\n    });\\n};\\n\\n/**\\n * Will adjust audio and video media direction in the given SDP object to\\n * reflect the current status of the {@link audioTransferActive} and\\n * {@link videoTransferActive} flags.\\n * @param {Object} localDescription the WebRTC session description instance for\\n * the local description.\\n * @private\\n */\\nTraceablePeerConnection.prototype._adjustLocalMediaDirection = function (localDescription) {\\n    var transformer = new __WEBPACK_IMPORTED_MODULE_13__xmpp_SdpTransformUtil__[\\\"a\\\" /* SdpTransformWrap */](localDescription.sdp);\\n    var modifiedDirection = false;\\n    var audioMedia = transformer.selectMedia('audio');\\n\\n    if (audioMedia) {\\n        var desiredAudioDirection = this._getDesiredMediaDirection(__WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]);\\n\\n        if (audioMedia.direction !== desiredAudioDirection) {\\n            audioMedia.direction = desiredAudioDirection;\\n            logger.info('Adjusted local audio direction to ' + desiredAudioDirection);\\n            modifiedDirection = true;\\n        }\\n    } else {\\n        logger.warn('No \\\"audio\\\" media found int the local description');\\n    }\\n\\n    var videoMedia = transformer.selectMedia('video');\\n\\n    if (videoMedia) {\\n        var desiredVideoDirection = this._getDesiredMediaDirection(__WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]);\\n\\n        if (videoMedia.direction !== desiredVideoDirection) {\\n            videoMedia.direction = desiredVideoDirection;\\n            logger.info('Adjusted local video direction to ' + desiredVideoDirection);\\n            modifiedDirection = true;\\n        }\\n    } else {\\n        logger.warn('No \\\"video\\\" media found in the local description');\\n    }\\n\\n    if (modifiedDirection) {\\n        return new RTCSessionDescription({\\n            type: localDescription.type,\\n            sdp: transformer.toRawSDP()\\n        });\\n    }\\n\\n    return localDescription;\\n};\\n\\nTraceablePeerConnection.prototype.setLocalDescription = function (description, successCallback, failureCallback) {\\n    var _this3 = this;\\n\\n    var localSdp = description;\\n\\n    this.trace('setLocalDescription::preTransform', dumpSDP(localSdp));\\n\\n    if (this.options.disableH264 || this.options.preferH264) {\\n        var parsedSdp = __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.parse(localSdp.sdp);\\n        var videoMLine = parsedSdp.media.find(function (m) {\\n            return m.type === 'video';\\n        });\\n\\n        if (this.options.disableH264) {\\n            __WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].stripVideoCodec(videoMLine, 'h264');\\n        } else {\\n            __WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].preferVideoCodec(videoMLine, 'h264');\\n        }\\n\\n        localSdp = new RTCSessionDescription({\\n            type: localSdp.type,\\n            sdp: __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.write(parsedSdp)\\n        });\\n\\n        this.trace('setLocalDescription::postTransform (H264)', dumpSDP(localSdp));\\n    }\\n\\n    localSdp = this._adjustLocalMediaDirection(localSdp);\\n\\n    localSdp = this._ensureSimulcastGroupIsLast(localSdp);\\n\\n    // if we're using unified plan, transform to it first.\\n    if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].usesUnifiedPlan()) {\\n        localSdp = this.interop.toUnifiedPlan(localSdp);\\n        this.trace('setLocalDescription::postTransform (Unified Plan)', dumpSDP(localSdp));\\n    }\\n\\n    this.peerconnection.setLocalDescription(localSdp, function () {\\n        _this3.trace('setLocalDescriptionOnSuccess');\\n        var localUfrag = __WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].getUfrag(localSdp.sdp);\\n\\n        if (localUfrag !== _this3.localUfrag) {\\n            _this3.localUfrag = localUfrag;\\n            _this3.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.LOCAL_UFRAG_CHANGED, _this3, localUfrag);\\n        }\\n        successCallback();\\n    }, function (err) {\\n        _this3.trace('setLocalDescriptionOnFailure', err);\\n        _this3.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.SET_LOCAL_DESCRIPTION_FAILED, err, _this3);\\n        failureCallback(err);\\n    });\\n};\\n\\n/**\\n * Enables/disables audio media transmission on this peer connection. When\\n * disabled the SDP audio media direction in the local SDP will be adjusted to\\n * 'inactive' which means that no data will be sent nor accepted, but\\n * the connection should be kept alive.\\n * @param {boolean} active <tt>true</tt> to enable video media transmission or\\n * <tt>false</tt> to disable. If the value is not a boolean the call will have\\n * no effect.\\n * @return {boolean} <tt>true</tt> if the value has changed and sRD/sLD cycle\\n * needs to be executed in order for the changes to take effect or\\n * <tt>false</tt> if the given value was the same as the previous one.\\n * @public\\n */\\nTraceablePeerConnection.prototype.setAudioTransferActive = function (active) {\\n    logger.debug(this + ' audio transfer active: ' + active);\\n    var changed = this.audioTransferActive !== active;\\n\\n    this.audioTransferActive = active;\\n\\n    return changed;\\n};\\n\\n/**\\n * Takes in a *unified plan* offer and inserts the appropriate\\n * parameters for adding simulcast receive support.\\n * @param {Object} desc - A session description object\\n * @param {String} desc.type - the type (offer/answer)\\n * @param {String} desc.sdp - the sdp content\\n *\\n * @return {Object} A session description (same format as above) object\\n * with its sdp field modified to advertise simulcast receive support\\n */\\nTraceablePeerConnection.prototype._insertUnifiedPlanSimulcastReceive = function (desc) {\\n    var sdp = __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.parse(desc.sdp);\\n    var video = sdp.media.find(function (mline) {\\n        return mline.type === 'video';\\n    });\\n\\n    // In order of lowest to highest spatial quality\\n    video.rids = [{\\n        id: SIM_LAYER_1_RID,\\n        direction: 'recv'\\n    }, {\\n        id: SIM_LAYER_2_RID,\\n        direction: 'recv'\\n    }, {\\n        id: SIM_LAYER_3_RID,\\n        direction: 'recv'\\n    }];\\n    // eslint-disable-next-line camelcase\\n    video.simulcast_03 = {\\n        value: 'recv rid=' + SIM_LAYER_RIDS.join(';')\\n    };\\n\\n    return new RTCSessionDescription({\\n        type: desc.type,\\n        sdp: __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.write(sdp)\\n    });\\n};\\n\\nTraceablePeerConnection.prototype.setRemoteDescription = function (description, successCallback, failureCallback) {\\n    var _this4 = this;\\n\\n    this.trace('setRemoteDescription::preTransform', dumpSDP(description));\\n\\n    // TODO the focus should squeze or explode the remote simulcast\\n    // eslint-disable-next-line no-param-reassign\\n    description = this.simulcast.mungeRemoteDescription(description);\\n    this.trace('setRemoteDescription::postTransform (simulcast)', dumpSDP(description));\\n\\n    if (this.options.preferH264) {\\n        var parsedSdp = __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.parse(description.sdp);\\n        var videoMLine = parsedSdp.media.find(function (m) {\\n            return m.type === 'video';\\n        });\\n\\n        __WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].preferVideoCodec(videoMLine, 'h264');\\n\\n        // eslint-disable-next-line no-param-reassign\\n        description = new RTCSessionDescription({\\n            type: description.type,\\n            sdp: __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.write(parsedSdp)\\n        });\\n    }\\n\\n    // If the browser uses unified plan, transform to it first\\n    if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].usesUnifiedPlan()) {\\n        // eslint-disable-next-line no-param-reassign\\n        description = new RTCSessionDescription({\\n            type: description.type,\\n            sdp: this.rtxModifier.stripRtx(description.sdp)\\n        });\\n\\n        this.trace('setRemoteDescription::postTransform (stripRtx)', dumpSDP(description));\\n\\n        // eslint-disable-next-line no-param-reassign\\n        description = this.interop.toUnifiedPlan(description);\\n        this.trace('setRemoteDescription::postTransform (Plan A)', dumpSDP(description));\\n\\n        if (this.isSimulcastOn()) {\\n            // eslint-disable-next-line no-param-reassign\\n            description = this._insertUnifiedPlanSimulcastReceive(description);\\n            this.trace('setRemoteDescription::postTransform (sim receive)', dumpSDP(description));\\n        }\\n    } else {\\n        // Plan B\\n        // eslint-disable-next-line no-param-reassign\\n        description = normalizePlanB(description);\\n    }\\n\\n    // Safari WebRTC errors when no supported video codec is found in the offer.\\n    // To prevent the error, inject H264 into the video mLine.\\n    if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isSafariWithWebrtc()) {\\n        logger.debug('Maybe injecting H264 into the remote description');\\n\\n        // eslint-disable-next-line no-param-reassign\\n        description = this._injectH264IfNotPresent(description);\\n    }\\n\\n    this.peerconnection.setRemoteDescription(description, function () {\\n        _this4.trace('setRemoteDescriptionOnSuccess');\\n        var remoteUfrag = __WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].getUfrag(description.sdp);\\n\\n        if (remoteUfrag !== _this4.remoteUfrag) {\\n            _this4.remoteUfrag = remoteUfrag;\\n            _this4.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.REMOTE_UFRAG_CHANGED, _this4, remoteUfrag);\\n        }\\n        successCallback();\\n    }, function (err) {\\n        _this4.trace('setRemoteDescriptionOnFailure', err);\\n        _this4.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.SET_REMOTE_DESCRIPTION_FAILED, err, _this4);\\n        failureCallback(err);\\n    });\\n};\\n\\n/**\\n * Inserts an H264 payload into the description if not already present. This is\\n * need for Safari WebRTC, which errors when no supported video codec is found\\n * in the offer. Related bug reports:\\n * https://bugs.webkit.org/show_bug.cgi?id=173141\\n * https://bugs.chromium.org/p/webrtc/issues/detail?id=4957\\n *\\n * @param {RTCSessionDescription} description - An RTCSessionDescription\\n * to inject with an H264 payload.\\n * @private\\n * @returns {RTCSessionDescription}\\n */\\nTraceablePeerConnection.prototype._injectH264IfNotPresent = function (description) {\\n    var parsedSdp = __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.parse(description.sdp);\\n    var videoMLine = parsedSdp.media.find(function (m) {\\n        return m.type === 'video';\\n    });\\n\\n    if (!videoMLine) {\\n        logger.debug('No videoMLine found, no need to inject H264.');\\n\\n        return description;\\n    }\\n\\n    if (videoMLine.rtp.some(function (rtp) {\\n        return rtp.codec.toLowerCase() === 'h264';\\n    })) {\\n        logger.debug('H264 codec found in video mLine, no need to inject.');\\n\\n        return description;\\n    }\\n\\n    var fmtp = videoMLine.fmtp,\\n        payloads = videoMLine.payloads,\\n        rtp = videoMLine.rtp;\\n\\n    var payloadsArray = payloads.toString().split(' ');\\n    var dummyPayloadType = void 0;\\n\\n    for (var i = 127; i >= 96; i--) {\\n        if (!payloadsArray.includes(i)) {\\n            dummyPayloadType = i;\\n            payloadsArray.push(i);\\n            videoMLine.payloads = payloadsArray.join(' ');\\n            break;\\n        }\\n    }\\n\\n    if (typeof dummyPayloadType === 'undefined') {\\n        logger.error('Could not find valid payload type to inject.');\\n\\n        return description;\\n    }\\n\\n    rtp.push({\\n        codec: 'H264',\\n        payload: dummyPayloadType,\\n        rate: 90000\\n    });\\n\\n    fmtp.push({\\n        config: 'level-asymmetry-allowed=1;' + 'packetization-mode=1;' + 'profile-level-id=42e01f',\\n        payload: dummyPayloadType\\n    });\\n\\n    logger.debug('Injecting H264 payload type ' + dummyPayloadType + ' into video mLine.');\\n\\n    return new RTCSessionDescription({\\n        type: description.type,\\n        sdp: __WEBPACK_IMPORTED_MODULE_1_sdp_transform___default.a.write(parsedSdp)\\n    });\\n};\\n\\n/**\\n * Enables/disables video media transmission on this peer connection. When\\n * disabled the SDP video media direction in the local SDP will be adjusted to\\n * 'inactive' which means that no data will be sent nor accepted, but\\n * the connection should be kept alive.\\n * @param {boolean} active <tt>true</tt> to enable video media transmission or\\n * <tt>false</tt> to disable. If the value is not a boolean the call will have\\n * no effect.\\n * @return {boolean} <tt>true</tt> if the value has changed and sRD/sLD cycle\\n * needs to be executed in order for the changes to take effect or\\n * <tt>false</tt> if the given value was the same as the previous one.\\n * @public\\n */\\nTraceablePeerConnection.prototype.setVideoTransferActive = function (active) {\\n    logger.debug(this + ' video transfer active: ' + active);\\n    var changed = this.videoTransferActive !== active;\\n\\n    this.videoTransferActive = active;\\n\\n    return changed;\\n};\\n\\n/**\\n * Makes the underlying TraceablePeerConnection generate new SSRC for\\n * the recvonly video stream.\\n */\\nTraceablePeerConnection.prototype.generateRecvonlySsrc = function () {\\n    var newSSRC = __WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].generateSsrc();\\n\\n    logger.info(this + ' generated new recvonly SSRC: ' + newSSRC);\\n    this.sdpConsistency.setPrimarySsrc(newSSRC);\\n};\\n\\n/**\\n * Makes the underlying TraceablePeerConnection forget the current primary video\\n * SSRC.\\n */\\nTraceablePeerConnection.prototype.clearRecvonlySsrc = function () {\\n    logger.info('Clearing primary video SSRC!');\\n    this.sdpConsistency.clearVideoSsrcCache();\\n};\\n\\n/**\\n * Closes underlying WebRTC PeerConnection instance and removes all remote\\n * tracks by emitting {@link RTCEvents.REMOTE_TRACK_REMOVED} for each one of\\n * them.\\n */\\nTraceablePeerConnection.prototype.close = function () {\\n    this.trace('stop');\\n\\n    // Off SignalingEvents\\n    this.signalingLayer.off(__WEBPACK_IMPORTED_MODULE_15__service_RTC_SignalingEvents__[\\\"a\\\" /* PEER_MUTED_CHANGED */], this._peerMutedChanged);\\n    this.signalingLayer.off(__WEBPACK_IMPORTED_MODULE_15__service_RTC_SignalingEvents__[\\\"b\\\" /* PEER_VIDEO_TYPE_CHANGED */], this._peerVideoTypeChanged);\\n\\n    var _iteratorNormalCompletion15 = true;\\n    var _didIteratorError15 = false;\\n    var _iteratorError15 = undefined;\\n\\n    try {\\n        for (var _iterator15 = this.remoteTracks.values()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\\n            var peerTracks = _step15.value;\\n            var _iteratorNormalCompletion16 = true;\\n            var _didIteratorError16 = false;\\n            var _iteratorError16 = undefined;\\n\\n            try {\\n                for (var _iterator16 = peerTracks.values()[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\\n                    var remoteTrack = _step16.value;\\n\\n                    this._removeRemoteTrack(remoteTrack);\\n                }\\n            } catch (err) {\\n                _didIteratorError16 = true;\\n                _iteratorError16 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion16 && _iterator16.return) {\\n                        _iterator16.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError16) {\\n                        throw _iteratorError16;\\n                    }\\n                }\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError15 = true;\\n        _iteratorError15 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion15 && _iterator15.return) {\\n                _iterator15.return();\\n            }\\n        } finally {\\n            if (_didIteratorError15) {\\n                throw _iteratorError15;\\n            }\\n        }\\n    }\\n\\n    this.remoteTracks.clear();\\n\\n    this._addedStreams = [];\\n\\n    if (!this.rtc._removePeerConnection(this)) {\\n        logger.error('RTC._removePeerConnection returned false');\\n    }\\n    if (this.statsinterval !== null) {\\n        window.clearInterval(this.statsinterval);\\n        this.statsinterval = null;\\n    }\\n    logger.info('Closing ' + this + '...');\\n    this.peerconnection.close();\\n};\\n\\n/**\\n * Modifies the values of the setup attributes (defined by\\n * {@link http://tools.ietf.org/html/rfc4145#section-4}) of a specific SDP\\n * answer in order to overcome a delay of 1 second in the connection\\n * establishment between Chrome and Videobridge.\\n *\\n * @param {SDP} offer - the SDP offer to which the specified SDP answer is\\n * being prepared to respond\\n * @param {SDP} answer - the SDP to modify\\n * @private\\n */\\nvar _fixAnswerRFC4145Setup = function _fixAnswerRFC4145Setup(offer, answer) {\\n    if (!__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isChrome()) {\\n        // It looks like Firefox doesn't agree with the fix (at least in its\\n        // current implementation) because it effectively remains active even\\n        // after we tell it to become passive. Apart from Firefox which I tested\\n        // after the fix was deployed, I tested Chrome only. In order to prevent\\n        // issues with other browsers, limit the fix to Chrome for the time\\n        // being.\\n        return;\\n    }\\n\\n    // XXX Videobridge is the (SDP) offerer and WebRTC (e.g. Chrome) is the\\n    // answerer (as orchestrated by Jicofo). In accord with\\n    // http://tools.ietf.org/html/rfc5245#section-5.2 and because both peers\\n    // are ICE FULL agents, Videobridge will take on the controlling role and\\n    // WebRTC will take on the controlled role. In accord with\\n    // https://tools.ietf.org/html/rfc5763#section-5, Videobridge will use the\\n    // setup attribute value of setup:actpass and WebRTC will be allowed to\\n    // choose either the setup attribute value of setup:active or\\n    // setup:passive. Chrome will by default choose setup:active because it is\\n    // RECOMMENDED by the respective RFC since setup:passive adds additional\\n    // latency. The case of setup:active allows WebRTC to send a DTLS\\n    // ClientHello as soon as an ICE connectivity check of its succeeds.\\n    // Unfortunately, Videobridge will be unable to respond immediately because\\n    // may not have WebRTC's answer or may have not completed the ICE\\n    // connectivity establishment. Even more unfortunate is that in the\\n    // described scenario Chrome's DTLS implementation will insist on\\n    // retransmitting its ClientHello after a second (the time is in accord\\n    // with the respective RFC) and will thus cause the whole connection\\n    // establishment to exceed at least 1 second. To work around Chrome's\\n    // idiosyncracy, don't allow it to send a ClientHello i.e. change its\\n    // default choice of setup:active to setup:passive.\\n    if (offer && answer && offer.media && answer.media && offer.media.length === answer.media.length) {\\n        answer.media.forEach(function (a, i) {\\n            if (__WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].findLine(offer.media[i], 'a=setup:actpass', offer.session)) {\\n                answer.media[i] = a.replace(/a=setup:active/g, 'a=setup:passive');\\n            }\\n        });\\n        answer.raw = answer.session + answer.media.join('');\\n    }\\n};\\n\\nTraceablePeerConnection.prototype.createAnswer = function (successCallback, failureCallback, constraints) {\\n    if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].supportsRtpSender() && this.isSimulcastOn()) {\\n        var videoSender = this.peerconnection.getSenders().find(function (sender) {\\n            return sender.track.kind === 'video';\\n        });\\n        var simParams = {\\n            encodings: [{\\n                rid: SIM_LAYER_1_RID,\\n                scaleResolutionDownBy: 4\\n            }, {\\n                rid: SIM_LAYER_2_RID,\\n                scaleResolutionDownBy: 2\\n            }, {\\n                rid: SIM_LAYER_3_RID\\n            }]\\n        };\\n\\n        videoSender.setParameters(simParams);\\n    }\\n    this._createOfferOrAnswer(false /* answer */, successCallback, failureCallback, constraints);\\n};\\n\\nTraceablePeerConnection.prototype.createOffer = function (successCallback, failureCallback, constraints) {\\n    this._createOfferOrAnswer(true /* offer */, successCallback, failureCallback, constraints);\\n};\\n\\n/* eslint-disable max-params */\\n\\nTraceablePeerConnection.prototype._createOfferOrAnswer = function (isOffer, successCallback, failureCallback, constraints) {\\n    var _this5 = this;\\n\\n    var logName = isOffer ? 'Offer' : 'Answer';\\n\\n    this.trace('create' + logName, JSON.stringify(constraints, null, ' '));\\n\\n    var _successCallback = function _successCallback(resultSdp) {\\n        try {\\n            _this5.trace('create' + logName + 'OnSuccess::preTransform', dumpSDP(resultSdp));\\n\\n            // if we're using unified plan, transform to Plan B.\\n            if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].usesUnifiedPlan()) {\\n                // eslint-disable-next-line no-param-reassign\\n                resultSdp = _this5.interop.toPlanB(resultSdp);\\n                _this5.trace('create' + logName + 'OnSuccess::postTransform (Plan B)', dumpSDP(resultSdp));\\n                if (_this5.isSimulcastOn()) {\\n                    // eslint-disable-next-line no-param-reassign\\n                    resultSdp = _this5._injectSsrcGroupForUnifiedSimulcast(resultSdp);\\n                    _this5.trace('create' + logName + 'OnSuccess::postTransform' + '(inject ssrc group)', dumpSDP(resultSdp));\\n                }\\n            }\\n\\n            /**\\n             * We don't keep ssrcs consitent for Firefox because rewriting\\n             *  the ssrcs between createAnswer and setLocalDescription breaks\\n             *  the caching in sdp-interop (sdp-interop must know about all\\n             *  ssrcs, and it updates its cache in toPlanB so if we rewrite them\\n             *  after that, when we try and go back to unified plan it will\\n             *  complain about unmapped ssrcs)\\n             */\\n            if (!__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox()) {\\n                // If there are no local video tracks, then a \\\"recvonly\\\"\\n                // SSRC needs to be generated\\n                if (!_this5.hasAnyTracksOfType(__WEBPACK_IMPORTED_MODULE_4__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]) && !_this5.sdpConsistency.hasPrimarySsrcCached()) {\\n                    _this5.generateRecvonlySsrc();\\n                }\\n\\n                // eslint-disable-next-line no-param-reassign\\n                resultSdp = new RTCSessionDescription({\\n                    type: resultSdp.type,\\n                    sdp: _this5.sdpConsistency.makeVideoPrimarySsrcsConsistent(resultSdp.sdp)\\n                });\\n\\n                _this5.trace('create' + logName + 'OnSuccess::postTransform ' + '(make primary audio/video ssrcs consistent)', dumpSDP(resultSdp));\\n            }\\n\\n            // Add simulcast streams if simulcast is enabled\\n            if (_this5.isSimulcastOn()) {\\n\\n                // eslint-disable-next-line no-param-reassign\\n                resultSdp = _this5.simulcast.mungeLocalDescription(resultSdp);\\n                _this5.trace('create' + logName + 'OnSuccess::postTransform (simulcast)', dumpSDP(resultSdp));\\n            }\\n\\n            if (!_this5.options.disableRtx && __WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].supportsRtx()) {\\n                // eslint-disable-next-line no-param-reassign\\n                resultSdp = new RTCSessionDescription({\\n                    type: resultSdp.type,\\n                    sdp: _this5.rtxModifier.modifyRtxSsrcs(resultSdp.sdp)\\n                });\\n\\n                _this5.trace('create' + logName + 'OnSuccess::postTransform (rtx modifier)', dumpSDP(resultSdp));\\n            }\\n\\n            // Fix the setup attribute (see _fixAnswerRFC4145Setup for\\n            //  details)\\n            if (!isOffer) {\\n                var remoteDescription = new __WEBPACK_IMPORTED_MODULE_11__xmpp_SDP__[\\\"a\\\" /* default */](_this5.remoteDescription.sdp);\\n                var localDescription = new __WEBPACK_IMPORTED_MODULE_11__xmpp_SDP__[\\\"a\\\" /* default */](resultSdp.sdp);\\n\\n                _fixAnswerRFC4145Setup(remoteDescription, localDescription);\\n\\n                // eslint-disable-next-line no-param-reassign\\n                resultSdp = new RTCSessionDescription({\\n                    type: resultSdp.type,\\n                    sdp: localDescription.raw\\n                });\\n            }\\n\\n            var ssrcMap = extractSSRCMap(resultSdp);\\n\\n            logger.debug('Got local SSRCs MAP: ', ssrcMap);\\n            _this5._processLocalSSRCsMap(ssrcMap);\\n\\n            successCallback(resultSdp);\\n        } catch (e) {\\n            _this5.trace('create' + logName + 'OnError', e);\\n            _this5.trace('create' + logName + 'OnError', dumpSDP(resultSdp));\\n            logger.error('create' + logName + 'OnError', e, dumpSDP(resultSdp));\\n            failureCallback(e);\\n        }\\n    };\\n\\n    var _errorCallback = function _errorCallback(err) {\\n        _this5.trace('create' + logName + 'OnFailure', err);\\n        var eventType = isOffer ? __WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.CREATE_OFFER_FAILED : __WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.CREATE_ANSWER_FAILED;\\n\\n        _this5.eventEmitter.emit(eventType, err, _this5);\\n        failureCallback(err);\\n    };\\n\\n    // NOTE Temasys plugin does not support \\\"bind\\\" on peerconnection methods\\n    if (isOffer) {\\n        this.peerconnection.createOffer(_successCallback, _errorCallback, constraints);\\n    } else {\\n        this.peerconnection.createAnswer(_successCallback, _errorCallback, constraints);\\n    }\\n};\\n\\n/* eslint-enable max-params */\\n\\n/**\\n * Extract primary SSRC from given {@link TrackSSRCInfo} object.\\n * @param {TrackSSRCInfo} ssrcObj\\n * @return {number|null} the primary SSRC or <tt>null</tt>\\n */\\nfunction extractPrimarySSRC(ssrcObj) {\\n    if (ssrcObj && ssrcObj.groups && ssrcObj.groups.length) {\\n        return ssrcObj.groups[0].ssrcs[0];\\n    } else if (ssrcObj && ssrcObj.ssrcs && ssrcObj.ssrcs.length) {\\n        return ssrcObj.ssrcs[0];\\n    }\\n\\n    return null;\\n}\\n\\n/**\\n * Goes over the SSRC map extracted from the latest local description and tries\\n * to match them with the local tracks (by MSID). Will update the values\\n * currently stored in the {@link TraceablePeerConnection.localSSRCs} map.\\n * @param {Map<string,TrackSSRCInfo>} ssrcMap\\n * @private\\n */\\nTraceablePeerConnection.prototype._processLocalSSRCsMap = function (ssrcMap) {\\n    var _iteratorNormalCompletion17 = true;\\n    var _didIteratorError17 = false;\\n    var _iteratorError17 = undefined;\\n\\n    try {\\n        for (var _iterator17 = this.localTracks.values()[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\\n            var track = _step17.value;\\n\\n            var trackMSID = track.getMSID();\\n\\n            if (ssrcMap.has(trackMSID)) {\\n                var newSSRC = ssrcMap.get(trackMSID);\\n\\n                if (!newSSRC) {\\n                    logger.error('No SSRC found for: ' + trackMSID + ' in ' + this);\\n\\n                    return;\\n                }\\n                var oldSSRC = this.localSSRCs.get(track.rtcId);\\n                var newSSRCNum = extractPrimarySSRC(newSSRC);\\n                var oldSSRCNum = extractPrimarySSRC(oldSSRC);\\n\\n                // eslint-disable-next-line no-negated-condition\\n                if (newSSRCNum !== oldSSRCNum) {\\n                    if (oldSSRCNum === null) {\\n                        logger.info('Storing new local SSRC for ' + track + ' in ' + this, newSSRC);\\n                    } else {\\n                        logger.error('Overwriting SSRC for ' + track + ' ' + trackMSID + ' in ' + this + ' with: ', newSSRC);\\n                    }\\n                    this.localSSRCs.set(track.rtcId, newSSRC);\\n\\n                    this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_9__service_RTC_RTCEvents___default.a.LOCAL_TRACK_SSRC_UPDATED, track, newSSRCNum);\\n                } else {\\n                    logger.debug('The local SSRC(' + newSSRCNum + ') for ' + track + ' ' + trackMSID + ('is still up to date in ' + this));\\n                }\\n            } else {\\n                logger.warn('No local track matched with: ' + trackMSID + ' in ' + this);\\n            }\\n        }\\n    } catch (err) {\\n        _didIteratorError17 = true;\\n        _iteratorError17 = err;\\n    } finally {\\n        try {\\n            if (!_iteratorNormalCompletion17 && _iterator17.return) {\\n                _iterator17.return();\\n            }\\n        } finally {\\n            if (_didIteratorError17) {\\n                throw _iteratorError17;\\n            }\\n        }\\n    }\\n};\\n\\nTraceablePeerConnection.prototype.addIceCandidate = function (candidate, successCallback, failureCallback) {\\n    // var self = this;\\n    this.trace('addIceCandidate', JSON.stringify(candidate, null, ' '));\\n    this.peerconnection.addIceCandidate(candidate, successCallback, failureCallback);\\n\\n    /* maybe later\\n     this.peerconnection.addIceCandidate(candidate,\\n     function () {\\n     self.trace('addIceCandidateOnSuccess');\\n     successCallback();\\n     },\\n     function (err) {\\n     self.trace('addIceCandidateOnFailure', err);\\n     failureCallback(err);\\n     }\\n     );\\n     */\\n};\\n\\n/**\\n * Obtains call-related stats from the peer connection.\\n *\\n * @param {Function} callback - The function to invoke after successfully\\n * obtaining stats.\\n * @param {Function} errback - The function to invoke after failing to obtain\\n * stats.\\n * @returns {void}\\n */\\nTraceablePeerConnection.prototype.getStats = function (callback, errback) {\\n    // TODO: Is this the correct way to handle Opera, Temasys?\\n    // TODO (brian): After moving all browsers to adapter, check if adapter is\\n    // accounting for different getStats apis, making the browser-checking-if\\n    // unnecessary.\\n    if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isFirefox() || __WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed() || __WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isReactNative()) {\\n        this.peerconnection.getStats(null, callback, errback || function () {\\n\\n            // Making sure that getStats won't fail if error callback is\\n            // not passed.\\n        });\\n    } else if (__WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].isSafariWithWebrtc()) {\\n        // FIXME: Safari's native stats implementation is not compatibile with\\n        // existing stats processing logic. Skip implementing stats for now to\\n        // at least get native webrtc Safari available for use.\\n    } else {\\n        this.peerconnection.getStats(callback);\\n    }\\n};\\n\\n/**\\n * Generates and stores new SSRC info object for given local track.\\n * The method should be called only for a video track being added to this TPC\\n * in the muted state (given that the current browser uses this strategy).\\n * @param {JitsiLocalTrack} track\\n * @return {TPCSSRCInfo}\\n */\\nTraceablePeerConnection.prototype.generateNewStreamSSRCInfo = function (track) {\\n    var rtcId = track.rtcId;\\n    var ssrcInfo = this._getSSRC(rtcId);\\n\\n    if (ssrcInfo) {\\n        logger.error('Will overwrite local SSRCs for track ID: ' + rtcId);\\n    }\\n    if (this.isSimulcastOn()) {\\n        ssrcInfo = {\\n            ssrcs: [],\\n            groups: []\\n        };\\n        for (var i = 0; i < SIMULCAST_LAYERS; i++) {\\n            ssrcInfo.ssrcs.push(__WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].generateSsrc());\\n        }\\n        ssrcInfo.groups.push({\\n            ssrcs: ssrcInfo.ssrcs.slice(),\\n            semantics: 'SIM'\\n        });\\n    } else {\\n        ssrcInfo = {\\n            ssrcs: [__WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].generateSsrc()],\\n            groups: []\\n        };\\n    }\\n    if (!this.options.disableRtx && __WEBPACK_IMPORTED_MODULE_8__RTCBrowserType__[\\\"a\\\" /* default */].supportsRtx()) {\\n        // Specifically use a for loop here because we'll\\n        //  be adding to the list we're iterating over, so we\\n        //  only want to iterate through the items originally\\n        //  on the list\\n        var currNumSsrcs = ssrcInfo.ssrcs.length;\\n\\n        for (var _i = 0; _i < currNumSsrcs; ++_i) {\\n            var primarySsrc = ssrcInfo.ssrcs[_i];\\n            var rtxSsrc = __WEBPACK_IMPORTED_MODULE_14__xmpp_SDPUtil__[\\\"a\\\" /* default */].generateSsrc();\\n\\n            ssrcInfo.ssrcs.push(rtxSsrc);\\n            ssrcInfo.groups.push({\\n                ssrcs: [primarySsrc, rtxSsrc],\\n                semantics: 'FID'\\n            });\\n        }\\n    }\\n    ssrcInfo.msid = track.storedMSID;\\n    this.localSSRCs.set(rtcId, ssrcInfo);\\n\\n    return ssrcInfo;\\n};\\n\\n/**\\n * Creates a text representation of this <tt>TraceablePeerConnection</tt>\\n * instance.\\n * @return {string}\\n */\\nTraceablePeerConnection.prototype.toString = function () {\\n    return 'TPC[' + this.id + ',p2p:' + this.isP2P + ']';\\n};\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/TraceablePeerConnection.js\\\"))\\n\\n/***/ }),\\n/* 143 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__ = __webpack_require__(7);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JitsiTrack__ = __webpack_require__(54);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__JitsiTrackEvents__ = __webpack_require__(18);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__statistics_statistics__ = __webpack_require__(5);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\nvar logger = __webpack_require__(0).getLogger(__filename);\\nvar RTCEvents = __webpack_require__(9);\\n\\nvar ttfmTrackerAudioAttached = false;\\nvar ttfmTrackerVideoAttached = false;\\n\\n/* eslint-disable max-params */\\n\\n/**\\n * Represents a single media track (either audio or video).\\n */\\n\\nvar JitsiRemoteTrack = function (_JitsiTrack) {\\n    _inherits(JitsiRemoteTrack, _JitsiTrack);\\n\\n    /**\\n     * Creates new JitsiRemoteTrack instance.\\n     * @param {RTC} rtc the RTC service instance.\\n     * @param {JitsiConference} conference the conference to which this track\\n     *        belongs to\\n     * @param {string} ownerEndpointId the endpoint ID of the track owner\\n     * @param {MediaStream} stream WebRTC MediaStream, parent of the track\\n     * @param {MediaStreamTrack} track underlying WebRTC MediaStreamTrack for\\n     *        the new JitsiRemoteTrack\\n     * @param {MediaType} mediaType the type of the media\\n     * @param {VideoType} videoType the type of the video if applicable\\n     * @param {number} ssrc the SSRC number of the Media Stream\\n     * @param {boolean} muted the initial muted state\\n     * @param {boolean} isP2P indicates whether or not this track belongs to a\\n     * P2P session\\n     * @throws {TypeError} if <tt>ssrc</tt> is not a number.\\n     * @constructor\\n     */\\n    function JitsiRemoteTrack(rtc, conference, ownerEndpointId, stream, track, mediaType, videoType, ssrc, muted, isP2P) {\\n        _classCallCheck(this, JitsiRemoteTrack);\\n\\n        var _this = _possibleConstructorReturn(this, (JitsiRemoteTrack.__proto__ || Object.getPrototypeOf(JitsiRemoteTrack)).call(this, conference, stream, track, function () {\\n            // Nothing to do if the track is inactive.\\n        }, mediaType, videoType));\\n\\n        _this.rtc = rtc;\\n\\n        // Prevent from mixing up type of SSRC which should be a number\\n        if (typeof ssrc !== 'number') {\\n            throw new TypeError('SSRC ' + ssrc + ' is not a number');\\n        }\\n        _this.ssrc = ssrc;\\n        _this.ownerEndpointId = ownerEndpointId;\\n        _this.muted = muted;\\n        _this.isP2P = isP2P;\\n\\n        // we want to mark whether the track has been ever muted\\n        // to detect ttfm events for startmuted conferences, as it can\\n        // significantly increase ttfm values\\n        _this.hasBeenMuted = muted;\\n\\n        // Bind 'onmute' and 'onunmute' event handlers\\n        if (_this.rtc && _this.track) {\\n            _this._bindMuteHandlers();\\n        }\\n        return _this;\\n    }\\n\\n    /* eslint-enable max-params */\\n    /**\\n     * Attaches the track muted handlers.\\n     *\\n     * @returns {void}\\n     */\\n\\n\\n    _createClass(JitsiRemoteTrack, [{\\n        key: '_bindMuteHandlers',\\n        value: function _bindMuteHandlers() {\\n            var _this2 = this;\\n\\n            // Use feature detection for finding what event handling function is\\n            // supported. On Internet Explorer, which uses uses temasys/firebreath,\\n            // the track will have attachEvent instead of addEventListener.\\n            //\\n            // FIXME it would be better to use recently added '_setHandler' method,\\n            // but:\\n            // 1. It does not allow to set more than one handler to the event\\n            // 2. It does mix MediaStream('inactive') with MediaStreamTrack events\\n            // 3. Allowing to bind more than one event handler requires too much\\n            //    refactoring around camera issues detection.\\n            if (this.track.addEventListener) {\\n                this.track.addEventListener('mute', function () {\\n                    return _this2._onTrackMute();\\n                });\\n                this.track.addEventListener('unmute', function () {\\n                    return _this2._onTrackUnmute();\\n                });\\n            } else if (this.track.attachEvent) {\\n                // FIXME Internet Explorer is not emitting out mute/unmute events.\\n                this.track.attachEvent('onmute', function () {\\n                    return _this2._onTrackMute();\\n                });\\n                this.track.attachEvent('onunmute', function () {\\n                    return _this2._onTrackUnmute();\\n                });\\n            }\\n        }\\n\\n        /**\\n         * Callback invoked when the track is muted. Emits an event notifying\\n         * listeners of the mute event.\\n         *\\n         * @private\\n         * @returns {void}\\n         */\\n\\n    }, {\\n        key: '_onTrackMute',\\n        value: function _onTrackMute() {\\n            logger.debug('\\\"onmute\\\" event(' + Date.now() + '): ', this.getParticipantId(), this.getType(), this.getSSRC());\\n\\n            this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_MUTE, this);\\n        }\\n\\n        /**\\n         * Callback invoked when the track is unmuted. Emits an event notifying\\n         * listeners of the mute event.\\n         *\\n         * @private\\n         * @returns {void}\\n         */\\n\\n    }, {\\n        key: '_onTrackUnmute',\\n        value: function _onTrackUnmute() {\\n            logger.debug('\\\"onunmute\\\" event(' + Date.now() + '): ', this.getParticipantId(), this.getType(), this.getSSRC());\\n\\n            this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_UNMUTE, this);\\n        }\\n\\n        /**\\n         * Sets current muted status and fires an events for the change.\\n         * @param value the muted status.\\n         */\\n\\n    }, {\\n        key: 'setMute',\\n        value: function setMute(value) {\\n            if (this.muted === value) {\\n                return;\\n            }\\n\\n            if (value) {\\n                this.hasBeenMuted = true;\\n            }\\n\\n            // we can have a fake video stream\\n            if (this.stream) {\\n                this.stream.muted = value;\\n            }\\n\\n            this.muted = value;\\n            this.emit(__WEBPACK_IMPORTED_MODULE_2__JitsiTrackEvents__[\\\"TRACK_MUTE_CHANGED\\\"], this);\\n        }\\n\\n        /**\\n         * Returns the current muted status of the track.\\n         * @returns {boolean|*|JitsiRemoteTrack.muted} <tt>true</tt> if the track is\\n         * muted and <tt>false</tt> otherwise.\\n         */\\n\\n    }, {\\n        key: 'isMuted',\\n        value: function isMuted() {\\n            return this.muted;\\n        }\\n\\n        /**\\n         * Returns the participant id which owns the track.\\n         *\\n         * @returns {string} the id of the participants. It corresponds to the\\n         * Colibri endpoint id/MUC nickname in case of Jitsi-meet.\\n         */\\n\\n    }, {\\n        key: 'getParticipantId',\\n        value: function getParticipantId() {\\n            return this.ownerEndpointId;\\n        }\\n\\n        /**\\n         * Return false;\\n         */\\n\\n    }, {\\n        key: 'isLocal',\\n        value: function isLocal() {\\n            return false;\\n        }\\n\\n        /**\\n         * Returns the synchronization source identifier (SSRC) of this remote\\n         * track.\\n         *\\n         * @returns {number} the SSRC of this remote track.\\n         */\\n\\n    }, {\\n        key: 'getSSRC',\\n        value: function getSSRC() {\\n            return this.ssrc;\\n        }\\n\\n        /**\\n         * Changes the video type of the track.\\n         *\\n         * @param {string} type - The new video type(\\\"camera\\\", \\\"desktop\\\").\\n         */\\n\\n    }, {\\n        key: '_setVideoType',\\n        value: function _setVideoType(type) {\\n            if (this.videoType === type) {\\n                return;\\n            }\\n            this.videoType = type;\\n            this.emit(__WEBPACK_IMPORTED_MODULE_2__JitsiTrackEvents__[\\\"TRACK_VIDEOTYPE_CHANGED\\\"], type);\\n        }\\n\\n        /**\\n         * Handles track play events.\\n         */\\n\\n    }, {\\n        key: '_playCallback',\\n        value: function _playCallback() {\\n            var type = this.isVideoTrack() ? 'video' : 'audio';\\n\\n            var now = window.performance.now();\\n\\n            console.log('(TIME) Render ' + type + ':\\\\t', now);\\n            this.conference.getConnectionTimes()[type + '.render'] = now;\\n\\n            // The conference can be started without calling GUM\\n            // FIXME if there would be a module for connection times this kind\\n            // of logic (gumDuration or ttfm) should end up there\\n            var gumStart = window.connectionTimes['obtainPermissions.start'];\\n            var gumEnd = window.connectionTimes['obtainPermissions.end'];\\n            var gumDuration = !isNaN(gumEnd) && !isNaN(gumStart) ? gumEnd - gumStart : 0;\\n\\n            var ttfm = now - (this.conference.getConnectionTimes()['session.initiate'] - this.conference.getConnectionTimes()['muc.joined']) - gumDuration;\\n\\n            this.conference.getConnectionTimes()[type + '.ttfm'] = ttfm;\\n            console.log('(TIME) TTFM ' + type + ':\\\\t', ttfm);\\n            var eventName = type + '.' + __WEBPACK_IMPORTED_MODULE_0__service_statistics_AnalyticsEvents__[\\\"J\\\" /* _TTFM_ */];\\n\\n            if (this.hasBeenMuted) {\\n                eventName += '.muted';\\n            }\\n            __WEBPACK_IMPORTED_MODULE_4__statistics_statistics__[\\\"a\\\" /* default */].analytics.sendEvent(eventName, { value: ttfm });\\n        }\\n\\n        /**\\n         * Attach time to first media tracker only if there is conference and only\\n         * for the first element.\\n         * @param container the HTML container which can be 'video' or 'audio'\\n         * element. It can also be 'object' element if Temasys plugin is in use and\\n         * this method has been called previously on video or audio HTML element.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_attachTTFMTracker',\\n        value: function _attachTTFMTracker(container) {\\n            if (ttfmTrackerAudioAttached && this.isAudioTrack() || ttfmTrackerVideoAttached && this.isVideoTrack()) {\\n                return;\\n            }\\n\\n            if (this.isAudioTrack()) {\\n                ttfmTrackerAudioAttached = true;\\n            }\\n            if (this.isVideoTrack()) {\\n                ttfmTrackerVideoAttached = true;\\n            }\\n\\n            if (__WEBPACK_IMPORTED_MODULE_3__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed()) {\\n                // XXX Don't require Temasys unless it's to be used because it\\n                // doesn't run on React Native, for example.\\n                var AdapterJS = __webpack_require__(37);\\n\\n                // FIXME: this is not working for IE11\\n                AdapterJS.addEvent(container, 'play', this._playCallback.bind(this));\\n            } else {\\n                container.addEventListener('canplay', this._playCallback.bind(this));\\n            }\\n        }\\n\\n        /**\\n         * Creates a text representation of this remote track instance.\\n         * @return {string}\\n         */\\n\\n    }, {\\n        key: 'toString',\\n        value: function toString() {\\n            return 'RemoteTrack[' + this.ownerEndpointId + ', ' + this.getType() + ', p2p: ' + this.isP2P + ']';\\n        }\\n    }]);\\n\\n    return JitsiRemoteTrack;\\n}(__WEBPACK_IMPORTED_MODULE_1__JitsiTrack__[\\\"a\\\" /* default */]);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (JitsiRemoteTrack);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/JitsiRemoteTrack.js\\\"))\\n\\n/***/ }),\\n/* 144 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__xmpp_SdpTransformUtil__ = __webpack_require__(29);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/* global __filename */\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Fakes local SDP exposed to {@link JingleSessionPC} through the local\\n * description getter. Modifies the SDP, so that it will contain muted local\\n * video tracks description, even though their underlying {MediaStreamTrack}s\\n * are no longer in the WebRTC peerconnection. That prevents from SSRC updates\\n * being sent to Jicofo/remote peer and prevents sRD/sLD cycle on the remote\\n * side.\\n */\\n\\nvar LocalSdpMunger = function () {\\n\\n    /**\\n     * Creates new <tt>LocalSdpMunger</tt> instance.\\n     *\\n     * @param {TraceablePeerConnection} tpc\\n     */\\n    function LocalSdpMunger(tpc) {\\n        _classCallCheck(this, LocalSdpMunger);\\n\\n        this.tpc = tpc;\\n    }\\n\\n    /**\\n     * Makes sure that muted local video tracks associated with the parent\\n     * {@link TraceablePeerConnection} are described in the local SDP. It's done\\n     * in order to prevent from sending 'source-remove'/'source-add' Jingle\\n     * notifications when local video track is muted (<tt>MediaStream</tt> is\\n     * removed from the peerconnection).\\n     *\\n     * NOTE 1 video track is assumed\\n     *\\n     * @param {SdpTransformWrap} transformer the transformer instance which will\\n     * be used to process the SDP.\\n     * @return {boolean} <tt>true</tt> if there were any modifications to\\n     * the SDP wrapped by <tt>transformer</tt>.\\n     * @private\\n     */\\n\\n\\n    _createClass(LocalSdpMunger, [{\\n        key: '_addMutedLocalVideoTracksToSDP',\\n        value: function _addMutedLocalVideoTracksToSDP(transformer) {\\n            // Go over each video tracks and check if the SDP has to be changed\\n            var localVideos = this.tpc.getLocalTracks(__WEBPACK_IMPORTED_MODULE_1__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]);\\n\\n            if (!localVideos.length) {\\n                return false;\\n            } else if (localVideos.length !== 1) {\\n                logger.error(this.tpc + ' there is more than 1 video track ! ' + 'Strange things may happen !', localVideos);\\n            }\\n\\n            var videoMLine = transformer.selectMedia('video');\\n\\n            if (!videoMLine) {\\n                logger.debug(this.tpc + ' unable to hack local video track SDP' + '- no \\\"video\\\" media');\\n\\n                return false;\\n            }\\n\\n            var modified = false;\\n\\n            var _iteratorNormalCompletion = true;\\n            var _didIteratorError = false;\\n            var _iteratorError = undefined;\\n\\n            try {\\n                for (var _iterator = localVideos[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                    var videoTrack = _step.value;\\n\\n                    var muted = videoTrack.isMuted();\\n                    var mediaStream = videoTrack.getOriginalStream();\\n\\n                    // During the mute/unmute operation there are periods of time when\\n                    // the track's underlying MediaStream is not added yet to\\n                    // the PeerConnection. The SDP needs to be munged in such case.\\n                    var isInPeerConnection = mediaStream && this.tpc.isMediaStreamInPc(mediaStream);\\n                    var shouldFakeSdp = muted || !isInPeerConnection;\\n\\n                    logger.debug(this.tpc + ' ' + videoTrack + ' muted: ' + muted + ', is in PeerConnection: ' + isInPeerConnection + ' => should fake sdp ? : ' + shouldFakeSdp);\\n\\n                    if (!shouldFakeSdp) {\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    // Inject removed SSRCs\\n                    var requiredSSRCs = this.tpc.isSimulcastOn() ? this.tpc.simulcast.ssrcCache : [this.tpc.sdpConsistency.cachedPrimarySsrc];\\n\\n                    if (!requiredSSRCs.length) {\\n                        logger.error('No SSRCs stored for: ' + videoTrack + ' in ' + this.tpc);\\n\\n                        continue; // eslint-disable-line no-continue\\n                    }\\n\\n                    modified = true;\\n\\n                    // We need to fake sendrecv.\\n                    // NOTE the SDP produced here goes only to Jicofo and is never set\\n                    // as localDescription. That's why\\n                    // TraceablePeerConnection.mediaTransferActive is ignored here.\\n                    videoMLine.direction = 'sendrecv';\\n\\n                    // Check if the recvonly has MSID\\n                    var primarySSRC = requiredSSRCs[0];\\n\\n                    // FIXME The cname could come from the stream, but may turn out to\\n                    // be too complex. It is fine to come up with any value, as long as\\n                    // we only care about the actual SSRC values when deciding whether\\n                    // or not an update should be sent.\\n                    var primaryCname = 'injected-' + primarySSRC;\\n\\n                    var _iteratorNormalCompletion2 = true;\\n                    var _didIteratorError2 = false;\\n                    var _iteratorError2 = undefined;\\n\\n                    try {\\n                        for (var _iterator2 = requiredSSRCs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                            var ssrcNum = _step2.value;\\n\\n                            // Remove old attributes\\n                            videoMLine.removeSSRC(ssrcNum);\\n\\n                            // Inject\\n                            logger.debug(this.tpc + ' injecting video SSRC: ' + ssrcNum + ' for ' + videoTrack);\\n                            videoMLine.addSSRCAttribute({\\n                                id: ssrcNum,\\n                                attribute: 'cname',\\n                                value: primaryCname\\n                            });\\n                            videoMLine.addSSRCAttribute({\\n                                id: ssrcNum,\\n                                attribute: 'msid',\\n                                value: videoTrack.storedMSID\\n                            });\\n                        }\\n                    } catch (err) {\\n                        _didIteratorError2 = true;\\n                        _iteratorError2 = err;\\n                    } finally {\\n                        try {\\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                                _iterator2.return();\\n                            }\\n                        } finally {\\n                            if (_didIteratorError2) {\\n                                throw _iteratorError2;\\n                            }\\n                        }\\n                    }\\n\\n                    if (requiredSSRCs.length > 1) {\\n                        var group = {\\n                            ssrcs: requiredSSRCs.join(' '),\\n                            semantics: 'SIM'\\n                        };\\n\\n                        if (!videoMLine.findGroup(group.semantics, group.ssrcs)) {\\n                            // Inject the group\\n                            logger.debug(this.tpc + ' injecting SIM group for ' + videoTrack, group);\\n                            videoMLine.addSSRCGroup(group);\\n                        }\\n                    }\\n\\n                    // Insert RTX\\n                    // FIXME in P2P RTX is used by Chrome regardless of config option\\n                    // status. Because of that 'source-remove'/'source-add'\\n                    // notifications are still sent to remove/add RTX SSRC and FID group\\n                    if (!this.tpc.options.disableRtx) {\\n                        this.tpc.rtxModifier.modifyRtxSsrcs2(videoMLine);\\n                    }\\n                }\\n            } catch (err) {\\n                _didIteratorError = true;\\n                _iteratorError = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion && _iterator.return) {\\n                        _iterator.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError) {\\n                        throw _iteratorError;\\n                    }\\n                }\\n            }\\n\\n            return modified;\\n        }\\n\\n        /**\\n         * Maybe modifies local description to fake local video tracks SDP when\\n         * those are muted.\\n         *\\n         * @param {object} desc the WebRTC SDP object instance for the local\\n         * description.\\n         * @returns {RTCSessionDescription}\\n         */\\n\\n    }, {\\n        key: 'maybeAddMutedLocalVideoTracksToSDP',\\n        value: function maybeAddMutedLocalVideoTracksToSDP(desc) {\\n            if (!desc) {\\n                throw new Error('No local description passed in.');\\n            }\\n\\n            var transformer = new __WEBPACK_IMPORTED_MODULE_2__xmpp_SdpTransformUtil__[\\\"a\\\" /* SdpTransformWrap */](desc.sdp);\\n\\n            if (this._addMutedLocalVideoTracksToSDP(transformer)) {\\n                return new RTCSessionDescription({\\n                    type: desc.type,\\n                    sdp: transformer.toRawSDP()\\n                });\\n            }\\n\\n            return desc;\\n        }\\n    }]);\\n\\n    return LocalSdpMunger;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (LocalSdpMunger);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/LocalSdpMunger.js\\\"))\\n\\n/***/ }),\\n/* 145 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SdpTransformUtil__ = __webpack_require__(29);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__SDPUtil__ = __webpack_require__(14);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/* global __filename */\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Begin helper functions\\n */\\n/**\\n * Updates or inserts the appropriate rtx information for primarySsrc with\\n *  the given rtxSsrc.  If no rtx ssrc for primarySsrc currently exists, it will\\n *  add the appropriate ssrc and ssrc group lines.  If primarySsrc already has\\n *  an rtx ssrc, the appropriate ssrc and group lines will be updated\\n * @param {MLineWrap} mLine\\n * @param {object} primarySsrcInfo the info (ssrc, msid & cname) for the\\n *  primary ssrc\\n * @param {number} rtxSsrc the rtx ssrc to associate with the primary ssrc\\n */\\nfunction updateAssociatedRtxStream(mLine, primarySsrcInfo, rtxSsrc) {\\n    logger.debug('Updating mline to associate ' + rtxSsrc + ('rtx ssrc with primary stream, ' + primarySsrcInfo.id));\\n    var primarySsrc = primarySsrcInfo.id;\\n    var primarySsrcMsid = primarySsrcInfo.msid;\\n    var primarySsrcCname = primarySsrcInfo.cname;\\n\\n    var previousRtxSSRC = mLine.getRtxSSRC(primarySsrc);\\n\\n    if (previousRtxSSRC === rtxSsrc) {\\n        logger.debug(rtxSsrc + ' was already associated with ' + primarySsrc);\\n\\n        return;\\n    }\\n    if (previousRtxSSRC) {\\n        logger.debug(primarySsrc + ' was previously associated with rtx' + (previousRtxSSRC + ', removing all references to it'));\\n\\n        // Stream already had an rtx ssrc that is different than the one given,\\n        //  remove all trace of the old one\\n        mLine.removeSSRC(previousRtxSSRC);\\n\\n        logger.debug('groups before filtering for ' + previousRtxSSRC);\\n        logger.debug(mLine.dumpSSRCGroups());\\n\\n        mLine.removeGroupsWithSSRC(previousRtxSSRC);\\n    }\\n    mLine.addSSRCAttribute({\\n        id: rtxSsrc,\\n        attribute: 'cname',\\n        value: primarySsrcCname\\n    });\\n    mLine.addSSRCAttribute({\\n        id: rtxSsrc,\\n        attribute: 'msid',\\n        value: primarySsrcMsid\\n    });\\n    mLine.addSSRCGroup({\\n        semantics: 'FID',\\n        ssrcs: primarySsrc + ' ' + rtxSsrc\\n    });\\n}\\n\\n/**\\n * End helper functions\\n */\\n\\n/**\\n * Adds any missing RTX streams for video streams\\n *  and makes sure that they remain consistent\\n */\\n\\nvar RtxModifier = function () {\\n    /**\\n     * Constructor\\n     */\\n    function RtxModifier() {\\n        _classCallCheck(this, RtxModifier);\\n\\n        /**\\n         * Map of video ssrc to corresponding RTX\\n         *  ssrc\\n         */\\n        this.correspondingRtxSsrcs = new Map();\\n    }\\n\\n    /**\\n     * Clear the cached map of primary video ssrcs to\\n     *  their corresponding rtx ssrcs so that they will\\n     *  not be used for the next call to modifyRtxSsrcs\\n     */\\n\\n\\n    _createClass(RtxModifier, [{\\n        key: 'clearSsrcCache',\\n        value: function clearSsrcCache() {\\n            this.correspondingRtxSsrcs.clear();\\n        }\\n\\n        /**\\n         * Explicitly set the primary video ssrc -> rtx ssrc\\n         *  mapping to be used in modifyRtxSsrcs\\n         * @param {Map} ssrcMapping a mapping of primary video\\n         *  ssrcs to their corresponding rtx ssrcs\\n         */\\n\\n    }, {\\n        key: 'setSsrcCache',\\n        value: function setSsrcCache(ssrcMapping) {\\n            logger.debug('Setting ssrc cache to ', ssrcMapping);\\n            this.correspondingRtxSsrcs = ssrcMapping;\\n        }\\n\\n        /**\\n         * Adds RTX ssrcs for any video ssrcs that don't\\n         *  already have them.  If the video ssrc has been\\n         *  seen before, and already had an RTX ssrc generated,\\n         *  the same RTX ssrc will be used again.\\n         * @param {string} sdpStr sdp in raw string format\\n         */\\n\\n    }, {\\n        key: 'modifyRtxSsrcs',\\n        value: function modifyRtxSsrcs(sdpStr) {\\n            var sdpTransformer = new __WEBPACK_IMPORTED_MODULE_1__SdpTransformUtil__[\\\"a\\\" /* SdpTransformWrap */](sdpStr);\\n            var videoMLine = sdpTransformer.selectMedia('video');\\n\\n            if (!videoMLine) {\\n                logger.debug('No \\\\'video\\\\' media found in the sdp: ' + sdpStr);\\n\\n                return sdpStr;\\n            }\\n\\n            return this.modifyRtxSsrcs2(videoMLine) ? sdpTransformer.toRawSDP() : sdpStr;\\n        }\\n\\n        /**\\n         * Does the same thing as {@link modifyRtxSsrcs}, but takes the\\n         *  {@link MLineWrap} instance wrapping video media as an argument.\\n         * @param {MLineWrap} videoMLine\\n         * @return {boolean} <tt>true</tt> if the SDP wrapped by\\n         *  {@link SdpTransformWrap} has been modified or <tt>false</tt> otherwise.\\n         */\\n\\n    }, {\\n        key: 'modifyRtxSsrcs2',\\n        value: function modifyRtxSsrcs2(videoMLine) {\\n            if (videoMLine.direction === 'recvonly') {\\n                logger.debug('RtxModifier doing nothing, video m line is recvonly');\\n\\n                return false;\\n            }\\n            if (videoMLine.getSSRCCount() < 1) {\\n                logger.debug('RtxModifier doing nothing, no video ssrcs present');\\n\\n                return false;\\n            }\\n            logger.debug('Current ssrc mapping: ', this.correspondingRtxSsrcs);\\n            var primaryVideoSsrcs = videoMLine.getPrimaryVideoSSRCs();\\n\\n            logger.debug('Parsed primary video ssrcs ', primaryVideoSsrcs, ' making sure all have rtx streams');\\n            var _iteratorNormalCompletion = true;\\n            var _didIteratorError = false;\\n            var _iteratorError = undefined;\\n\\n            try {\\n                for (var _iterator = primaryVideoSsrcs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                    var ssrc = _step.value;\\n\\n                    var msid = videoMLine.getSSRCAttrValue(ssrc, 'msid');\\n                    var cname = videoMLine.getSSRCAttrValue(ssrc, 'cname');\\n                    var correspondingRtxSsrc = this.correspondingRtxSsrcs.get(ssrc);\\n\\n                    if (correspondingRtxSsrc) {\\n                        logger.debug('Already have an associated rtx ssrc for' + ('video ssrc ' + ssrc + ': ' + correspondingRtxSsrc));\\n                    } else {\\n                        logger.debug('No previously associated rtx ssrc for video ssrc ' + ssrc);\\n\\n                        // If there's one in the sdp already for it, we'll just set\\n                        //  that as the corresponding one\\n                        var previousAssociatedRtxStream = videoMLine.getRtxSSRC(ssrc);\\n\\n                        if (previousAssociatedRtxStream) {\\n                            logger.debug('Rtx stream ' + previousAssociatedRtxStream + ' ' + 'already existed in the sdp as an rtx stream for ' + ('' + ssrc));\\n                            correspondingRtxSsrc = previousAssociatedRtxStream;\\n                        } else {\\n                            correspondingRtxSsrc = __WEBPACK_IMPORTED_MODULE_2__SDPUtil__[\\\"a\\\" /* default */].generateSsrc();\\n                            logger.debug('Generated rtx ssrc ' + correspondingRtxSsrc + ' ' + ('for ssrc ' + ssrc));\\n                        }\\n                        logger.debug('Caching rtx ssrc ' + correspondingRtxSsrc + ' ' + ('for video ssrc ' + ssrc));\\n                        this.correspondingRtxSsrcs.set(ssrc, correspondingRtxSsrc);\\n                    }\\n                    updateAssociatedRtxStream(videoMLine, {\\n                        id: ssrc,\\n                        cname: cname,\\n                        msid: msid\\n                    }, correspondingRtxSsrc);\\n                }\\n\\n                // FIXME we're not looking into much details whether the SDP has been\\n                // modified or not once the precondition requirements are met.\\n            } catch (err) {\\n                _didIteratorError = true;\\n                _iteratorError = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion && _iterator.return) {\\n                        _iterator.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError) {\\n                        throw _iteratorError;\\n                    }\\n                }\\n            }\\n\\n            return true;\\n        }\\n\\n        /**\\n         * Strip all rtx streams from the given sdp\\n         * @param {string} sdpStr sdp in raw string format\\n         * @returns {string} sdp string with all rtx streams stripped\\n         */\\n\\n    }, {\\n        key: 'stripRtx',\\n        value: function stripRtx(sdpStr) {\\n            var sdpTransformer = new __WEBPACK_IMPORTED_MODULE_1__SdpTransformUtil__[\\\"a\\\" /* SdpTransformWrap */](sdpStr);\\n            var videoMLine = sdpTransformer.selectMedia('video');\\n\\n            if (!videoMLine) {\\n                logger.debug('No \\\\'video\\\\' media found in the sdp: ' + sdpStr);\\n\\n                return sdpStr;\\n            }\\n            if (videoMLine.direction === 'recvonly') {\\n                logger.debug('RtxModifier doing nothing, video m line is recvonly');\\n\\n                return sdpStr;\\n            }\\n            if (videoMLine.getSSRCCount() < 1) {\\n                logger.debug('RtxModifier doing nothing, no video ssrcs present');\\n\\n                return sdpStr;\\n            }\\n            if (!videoMLine.containsAnySSRCGroups()) {\\n                logger.debug('RtxModifier doing nothing, ' + 'no video ssrcGroups present');\\n\\n                return sdpStr;\\n            }\\n            var fidGroups = videoMLine.findGroups('FID');\\n\\n            // Remove the fid groups from the mline\\n\\n            videoMLine.removeGroupsBySemantics('FID');\\n\\n            // Get the rtx ssrcs and remove them from the mline\\n            var _iteratorNormalCompletion2 = true;\\n            var _didIteratorError2 = false;\\n            var _iteratorError2 = undefined;\\n\\n            try {\\n                for (var _iterator2 = fidGroups[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                    var fidGroup = _step2.value;\\n\\n                    var rtxSsrc = Object(__WEBPACK_IMPORTED_MODULE_1__SdpTransformUtil__[\\\"c\\\" /* parseSecondarySSRC */])(fidGroup);\\n\\n                    videoMLine.removeSSRC(rtxSsrc);\\n                }\\n            } catch (err) {\\n                _didIteratorError2 = true;\\n                _iteratorError2 = err;\\n            } finally {\\n                try {\\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                        _iterator2.return();\\n                    }\\n                } finally {\\n                    if (_didIteratorError2) {\\n                        throw _iteratorError2;\\n                    }\\n                }\\n            }\\n\\n            return sdpTransformer.toRawSDP();\\n        }\\n    }]);\\n\\n    return RtxModifier;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (RtxModifier);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/RtxModifier.js\\\"))\\n\\n/***/ }),\\n/* 146 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SdpTransformUtil__ = __webpack_require__(29);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/* global __filename */\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * Handles the work of keeping video ssrcs consistent across multiple\\n * o/a cycles, making it such that all stream operations can be\\n * kept local and do not need to be signaled.\\n * NOTE: This only keeps the 'primary' video ssrc consistent: meaning\\n * the primary video stream\\n */\\n\\nvar SdpConsistency = function () {\\n    /**\\n     * Constructor\\n     * @param {string} logPrefix the log prefix appended to every logged\\n     * message, currently used to distinguish for which\\n     * <tt>TraceablePeerConnection</tt> the instance works.\\n     */\\n    function SdpConsistency(logPrefix) {\\n        _classCallCheck(this, SdpConsistency);\\n\\n        this.clearVideoSsrcCache();\\n        this.logPrefix = logPrefix;\\n    }\\n\\n    /**\\n     * Clear the cached video primary and primary rtx ssrcs so that\\n     *  they will not be used for the next call to\\n     *  makeVideoPrimarySsrcsConsistent\\n     */\\n\\n\\n    _createClass(SdpConsistency, [{\\n        key: 'clearVideoSsrcCache',\\n        value: function clearVideoSsrcCache() {\\n            this.cachedPrimarySsrc = null;\\n            this.injectRecvOnly = false;\\n        }\\n\\n        /**\\n         * Explicitly set the primary ssrc to be used in\\n         *  makeVideoPrimarySsrcsConsistent\\n         * @param {number} primarySsrc the primarySsrc to be used\\n         *  in future calls to makeVideoPrimarySsrcsConsistent\\n         * @throws Error if <tt>primarySsrc</tt> is not a number\\n         */\\n\\n    }, {\\n        key: 'setPrimarySsrc',\\n        value: function setPrimarySsrc(primarySsrc) {\\n            if (typeof primarySsrc !== 'number') {\\n                throw new Error('Primary SSRC must be a number!');\\n            }\\n            this.cachedPrimarySsrc = primarySsrc;\\n        }\\n\\n        /**\\n         * Checks whether or not there is a primary video SSRC cached already.\\n         * @return {boolean}\\n         */\\n\\n    }, {\\n        key: 'hasPrimarySsrcCached',\\n        value: function hasPrimarySsrcCached() {\\n            return Boolean(this.cachedPrimarySsrc);\\n        }\\n\\n        /**\\n         * Given an sdp string, either:\\n         *  1) record the primary video and primary rtx ssrcs to be\\n         *   used in future calls to makeVideoPrimarySsrcsConsistent or\\n         *  2) change the primary and primary rtx ssrcs in the given sdp\\n         *   to match the ones previously cached\\n         * @param {string} sdpStr the sdp string to (potentially)\\n         *  change to make the video ssrcs consistent\\n         * @returns {string} a (potentially) modified sdp string\\n         *  with ssrcs consistent with this class' cache\\n         */\\n\\n    }, {\\n        key: 'makeVideoPrimarySsrcsConsistent',\\n        value: function makeVideoPrimarySsrcsConsistent(sdpStr) {\\n            var sdpTransformer = new __WEBPACK_IMPORTED_MODULE_1__SdpTransformUtil__[\\\"a\\\" /* SdpTransformWrap */](sdpStr);\\n            var videoMLine = sdpTransformer.selectMedia('video');\\n\\n            if (!videoMLine) {\\n                logger.debug(this.logPrefix + ' no \\\\'video\\\\' media found in the sdp: ' + ('' + sdpStr));\\n\\n                return sdpStr;\\n            }\\n\\n            if (videoMLine.direction === 'recvonly') {\\n                // If the mline is recvonly, we'll add the primary\\n                //  ssrc as a recvonly ssrc\\n                if (this.cachedPrimarySsrc && this.injectRecvOnly) {\\n                    videoMLine.addSSRCAttribute({\\n                        id: this.cachedPrimarySsrc,\\n                        attribute: 'cname',\\n                        value: 'recvonly-' + this.cachedPrimarySsrc\\n                    });\\n                } else {\\n                    logger.info(this.logPrefix + ' no SSRC found for the recvonly video' + 'stream!');\\n                }\\n            } else {\\n                var newPrimarySsrc = videoMLine.getPrimaryVideoSsrc();\\n\\n                if (!newPrimarySsrc) {\\n                    logger.info(this.logPrefix + ' sdp-consistency couldn\\\\'t' + ' parse new primary ssrc');\\n\\n                    return sdpStr;\\n                }\\n                if (this.cachedPrimarySsrc) {\\n                    logger.info(this.logPrefix + ' sdp-consistency replacing new ssrc' + (newPrimarySsrc + ' with cached ') + ('' + this.cachedPrimarySsrc));\\n                    videoMLine.replaceSSRC(newPrimarySsrc, this.cachedPrimarySsrc);\\n                    var _iteratorNormalCompletion = true;\\n                    var _didIteratorError = false;\\n                    var _iteratorError = undefined;\\n\\n                    try {\\n                        for (var _iterator = videoMLine.ssrcGroups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n                            var group = _step.value;\\n\\n                            if (group.semantics === 'FID') {\\n                                var primarySsrc = Object(__WEBPACK_IMPORTED_MODULE_1__SdpTransformUtil__[\\\"b\\\" /* parsePrimarySSRC */])(group);\\n                                var rtxSsrc = Object(__WEBPACK_IMPORTED_MODULE_1__SdpTransformUtil__[\\\"c\\\" /* parseSecondarySSRC */])(group);\\n\\n                                // eslint-disable-next-line max-depth\\n                                if (primarySsrc === newPrimarySsrc) {\\n                                    group.ssrcs = this.cachedPrimarySsrc + ' ' + rtxSsrc;\\n                                }\\n                            }\\n                        }\\n                    } catch (err) {\\n                        _didIteratorError = true;\\n                        _iteratorError = err;\\n                    } finally {\\n                        try {\\n                            if (!_iteratorNormalCompletion && _iterator.return) {\\n                                _iterator.return();\\n                            }\\n                        } finally {\\n                            if (_didIteratorError) {\\n                                throw _iteratorError;\\n                            }\\n                        }\\n                    }\\n                } else {\\n                    this.cachedPrimarySsrc = newPrimarySsrc;\\n                    logger.info(this.logPrefix + ' sdp-consistency caching primary ssrc' + ('' + this.cachedPrimarySsrc));\\n                }\\n\\n                this.injectRecvOnly = true;\\n            }\\n\\n            return sdpTransformer.toRawSDP();\\n        }\\n    }]);\\n\\n    return SdpConsistency;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (SdpConsistency);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/xmpp/SdpConsistency.js\\\"))\\n\\n/***/ }),\\n/* 147 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* Copyright @ 2015 Atlassian Pty Ltd\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\nexports.Interop = __webpack_require__(148);\\n\\n\\n/***/ }),\\n/* 148 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* Copyright @ 2015 Atlassian Pty Ltd\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n/* global RTCSessionDescription */\\n/* global RTCIceCandidate */\\n/* jshint -W097 */\\n\\n\\nvar transform = __webpack_require__(149);\\nvar arrayEquals = __webpack_require__(150);\\n\\nfunction Interop() {\\n\\n    /**\\n     * This map holds the most recent Unified Plan offer/answer SDP that was\\n     * converted to Plan B, with the SDP type ('offer' or 'answer') as keys and\\n     * the SDP string as values.\\n     *\\n     * @type {{}}\\n     */\\n    this.cache = {\\n        mlB2UMap : {},\\n        mlU2BMap : {}\\n    };\\n}\\n\\nmodule.exports = Interop;\\n\\n/**\\n * Changes the candidate args to match with the related Unified Plan\\n */\\nInterop.prototype.candidateToUnifiedPlan = function(candidate) {\\n    var cand = new RTCIceCandidate(candidate);\\n\\n    cand.sdpMLineIndex = this.cache.mlB2UMap[cand.sdpMLineIndex];\\n    /* TODO: change sdpMid to (audio|video)-SSRC */\\n\\n    return cand;\\n};\\n\\n/**\\n * Changes the candidate args to match with the related Plan B\\n */\\nInterop.prototype.candidateToPlanB = function(candidate) {\\n    var cand = new RTCIceCandidate(candidate);\\n\\n    if (cand.sdpMid.indexOf('audio') === 0) {\\n      cand.sdpMid = 'audio';\\n    } else if (cand.sdpMid.indexOf('video') === 0) {\\n      cand.sdpMid = 'video';\\n    } else {\\n      throw new Error('candidate with ' + cand.sdpMid + ' not allowed');\\n    }\\n\\n    cand.sdpMLineIndex = this.cache.mlU2BMap[cand.sdpMLineIndex];\\n\\n    return cand;\\n};\\n\\n/**\\n * Returns the index of the first m-line with the given media type and with a\\n * direction which allows sending, in the last Unified Plan description with\\n * type \\\"answer\\\" converted to Plan B. Returns {null} if there is no saved\\n * answer, or if none of its m-lines with the given type allow sending.\\n * @param type the media type (\\\"audio\\\" or \\\"video\\\").\\n * @returns {*}\\n */\\nInterop.prototype.getFirstSendingIndexFromAnswer = function(type) {\\n    if (!this.cache.answer) {\\n        return null;\\n    }\\n\\n    var session = transform.parse(this.cache.answer);\\n    if (session && session.media && Array.isArray(session.media)){\\n        for (var i = 0; i < session.media.length; i++) {\\n            if (session.media[i].type == type &&\\n                (!session.media[i].direction /* default to sendrecv */ ||\\n                    session.media[i].direction === 'sendrecv' ||\\n                    session.media[i].direction === 'sendonly')){\\n                return i;\\n            }\\n        }\\n    }\\n\\n    return null;\\n};\\n\\n/**\\n * This method transforms a Unified Plan SDP to an equivalent Plan B SDP. A\\n * PeerConnection wrapper transforms the SDP to Plan B before passing it to the\\n * application.\\n *\\n * @param desc\\n * @returns {*}\\n */\\nInterop.prototype.toPlanB = function(desc) {\\n    var self = this;\\n    //#region Preliminary input validation.\\n\\n    if (typeof desc !== 'object' || desc === null ||\\n        typeof desc.sdp !== 'string') {\\n        console.warn('An empty description was passed as an argument.');\\n        return desc;\\n    }\\n\\n    // Objectify the SDP for easier manipulation.\\n    var session = transform.parse(desc.sdp);\\n\\n    // If the SDP contains no media, there's nothing to transform.\\n    if (typeof session.media === 'undefined' ||\\n        !Array.isArray(session.media) || session.media.length === 0) {\\n        console.warn('The description has no media.');\\n        return desc;\\n    }\\n\\n    // Try some heuristics to \\\"make sure\\\" this is a Unified Plan SDP. Plan B\\n    // SDP has a video, an audio and a data \\\"channel\\\" at most.\\n    if (session.media.length <= 3 && session.media.every(function(m) {\\n            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\\n        })) {\\n        console.warn('This description does not look like Unified Plan.');\\n        return desc;\\n    }\\n\\n    //#endregion\\n\\n    // HACK https://bugzilla.mozilla.org/show_bug.cgi?id=1113443\\n    var sdp = desc.sdp;\\n    var rewrite = false;\\n    for (var i = 0; i < session.media.length; i++) {\\n        var uLine = session.media[i];\\n        uLine.rtp.forEach(function(rtp) {\\n            if (rtp.codec === 'NULL')\\n            {\\n                rewrite = true;\\n                var offer = transform.parse(self.cache.offer);\\n                rtp.codec = offer.media[i].rtp[0].codec;\\n            }\\n        });\\n    }\\n    if (rewrite) {\\n        sdp = transform.write(session);\\n    }\\n\\n    // Unified Plan SDP is our \\\"precious\\\". Cache it for later use in the Plan B\\n    // -> Unified Plan transformation.\\n    this.cache[desc.type] = sdp;\\n\\n    //#region Convert from Unified Plan to Plan B.\\n\\n    // We rebuild the session.media array.\\n    var media = session.media;\\n    session.media = [];\\n\\n    // Associative array that maps channel types to channel objects for fast\\n    // access to channel objects by their type, e.g. type2bl['audio']->channel\\n    // obj.\\n    var type2bl = {};\\n\\n    // Used to build the group:BUNDLE value after the channels construction\\n    // loop.\\n    var types = [];\\n\\n    media.forEach(function(uLine) {\\n        // rtcp-mux is required in the Plan B SDP.\\n        if ((typeof uLine.rtcpMux !== 'string' ||\\n            uLine.rtcpMux !== 'rtcp-mux') &&\\n            uLine.direction !== 'inactive') {\\n            throw new Error('Cannot convert to Plan B because m-lines ' +\\n                'without the rtcp-mux attribute were found.');\\n        }\\n\\n        // If we don't have a channel for this uLine.type OR the selected is\\n        // inactive, then select this uLine as the channel basis.\\n        if (typeof type2bl[uLine.type] === 'undefined' ||\\n            type2bl[uLine.type].direction === 'inactive') {\\n            type2bl[uLine.type] = uLine;\\n        }\\n    });\\n\\n    // Implode the Unified Plan m-lines/tracks into Plan B channels.\\n    media.forEach(function(uLine) {\\n        if (uLine.type === 'application') {\\n            session.media.push(uLine);\\n            types.push(uLine.mid);\\n            return;\\n        }\\n\\n        // Add sources to the channel and handle a=msid.\\n        if (typeof uLine.sources === 'object') {\\n            Object.keys(uLine.sources).forEach(function(ssrc) {\\n                if (typeof type2bl[uLine.type].sources !== 'object')\\n                    type2bl[uLine.type].sources = {};\\n\\n                // Assign the sources to the channel.\\n                type2bl[uLine.type].sources[ssrc] =\\n                    uLine.sources[ssrc];\\n\\n                if (typeof uLine.msid !== 'undefined') {\\n                    // In Plan B the msid is an SSRC attribute. Also, we don't\\n                    // care about the obsolete label and mslabel attributes.\\n                    //\\n                    // Note that it is not guaranteed that the uLine will\\n                    // have an msid. recvonly channels in particular don't have\\n                    // one.\\n                    type2bl[uLine.type].sources[ssrc].msid =\\n                        uLine.msid;\\n                }\\n                // NOTE ssrcs in ssrc groups will share msids, as\\n                // draft-uberti-rtcweb-plan-00 mandates.\\n            });\\n        }\\n\\n        // Add ssrc groups to the channel.\\n        if (typeof uLine.ssrcGroups !== 'undefined' &&\\n                Array.isArray(uLine.ssrcGroups)) {\\n\\n            // Create the ssrcGroups array, if it's not defined.\\n            if (typeof type2bl[uLine.type].ssrcGroups === 'undefined' ||\\n                    !Array.isArray(type2bl[uLine.type].ssrcGroups)) {\\n                type2bl[uLine.type].ssrcGroups = [];\\n            }\\n\\n            type2bl[uLine.type].ssrcGroups =\\n                type2bl[uLine.type].ssrcGroups.concat(\\n                    uLine.ssrcGroups);\\n        }\\n\\n        if (type2bl[uLine.type] === uLine) {\\n            // Plan B mids are in ['audio', 'video', 'data']\\n            uLine.mid = uLine.type;\\n\\n            // Plan B doesn't support/need the bundle-only attribute.\\n            delete uLine.bundleOnly;\\n\\n            // In Plan B the msid is an SSRC attribute.\\n            delete uLine.msid;\\n\\n            if (uLine.direction !== 'inactive') {\\n              // Used to build the group:BUNDLE value after this loop.\\n              types.push(uLine.type);\\n            }\\n\\n            // Add the channel to the new media array.\\n            session.media.push(uLine);\\n        }\\n    });\\n\\n    // We regenerate the BUNDLE group with the new mids.\\n    session.groups.some(function(group) {\\n        if (group.type === 'BUNDLE') {\\n            group.mids = types.join(' ');\\n            return true;\\n        }\\n    });\\n\\n    // msid semantic\\n    session.msidSemantic = {\\n        semantic: 'WMS',\\n        token: '*'\\n    };\\n\\n    var resStr = transform.write(session);\\n\\n    return new RTCSessionDescription({\\n        type: desc.type,\\n        sdp: resStr\\n    });\\n\\n    //#endregion\\n};\\n\\n/**\\n * This method transforms a Plan B SDP to an equivalent Unified Plan SDP. A\\n * PeerConnection wrapper transforms the SDP to Unified Plan before passing it\\n * to FF.\\n *\\n * @param desc\\n * @returns {*}\\n */\\nInterop.prototype.toUnifiedPlan = function(desc) {\\n    var self = this;\\n    //#region Preliminary input validation.\\n\\n    if (typeof desc !== 'object' || desc === null ||\\n        typeof desc.sdp !== 'string') {\\n        console.warn('An empty description was passed as an argument.');\\n        return desc;\\n    }\\n\\n    var session = transform.parse(desc.sdp);\\n\\n    // If the SDP contains no media, there's nothing to transform.\\n    if (typeof session.media === 'undefined' ||\\n        !Array.isArray(session.media) || session.media.length === 0) {\\n        console.warn('The description has no media.');\\n        return desc;\\n    }\\n\\n    // Try some heuristics to \\\"make sure\\\" this is a Plan B SDP. Plan B SDP has\\n    // a video, an audio and a data \\\"channel\\\" at most.\\n    if (session.media.length > 3 || !session.media.every(function(m) {\\n            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\\n        })) {\\n        console.warn('This description does not look like Plan B.');\\n        return desc;\\n    }\\n\\n    // Make sure this Plan B SDP can be converted to a Unified Plan SDP.\\n    var mids = [];\\n    session.media.forEach(function(m) {\\n        mids.push(m.mid);\\n    });\\n\\n    var hasBundle = false;\\n    if (typeof session.groups !== 'undefined' &&\\n        Array.isArray(session.groups)) {\\n        hasBundle = session.groups.every(function(g) {\\n            return g.type !== 'BUNDLE' ||\\n                arrayEquals.apply(g.mids.sort(), [mids.sort()]);\\n        });\\n    }\\n\\n    if (!hasBundle) {\\n        throw new Error(\\\"Cannot convert to Unified Plan because m-lines that\\\" +\\n            \\\" are not bundled were found.\\\");\\n    }\\n\\n    //#endregion\\n\\n\\n    //#region Convert from Plan B to Unified Plan.\\n\\n    // Unfortunately, a Plan B offer/answer doesn't have enough information to\\n    // rebuild an equivalent Unified Plan offer/answer.\\n    //\\n    // For example, if this is a local answer (in Unified Plan style) that we\\n    // convert to Plan B prior to handing it over to the application (the\\n    // PeerConnection wrapper called us, for instance, after a successful\\n    // createAnswer), we want to remember the m-line at which we've seen the\\n    // (local) SSRC. That's because when the application wants to do call the\\n    // SLD method, forcing us to do the inverse transformation (from Plan B to\\n    // Unified Plan), we need to know to which m-line to assign the (local)\\n    // SSRC. We also need to know all the other m-lines that the original\\n    // answer had and include them in the transformed answer as well.\\n    //\\n    // Another example is if this is a remote offer that we convert to Plan B\\n    // prior to giving it to the application, we want to remember the mid at\\n    // which we've seen the (remote) SSRC.\\n    //\\n    // In the iteration that follows, we use the cached Unified Plan (if it\\n    // exists) to assign mids to ssrcs.\\n\\n    var cached;\\n    if (typeof this.cache[desc.type] !== 'undefined') {\\n        cached = transform.parse(this.cache[desc.type]);\\n    }\\n\\n    var recvonlySsrcs = {\\n        audio: {},\\n        video: {}\\n    };\\n\\n    // A helper map that sends mids to m-line objects. We use it later to\\n    // rebuild the Unified Plan style session.media array.\\n    var mid2ul = {};\\n    var bIdx = 0;\\n    var uIdx = 0;\\n\\n    session.media.forEach(function(bLine) {\\n        if ((typeof bLine.rtcpMux !== 'string' ||\\n            bLine.rtcpMux !== 'rtcp-mux') &&\\n            bLine.direction !== 'inactive') {\\n            throw new Error(\\\"Cannot convert to Unified Plan because m-lines \\\" +\\n                \\\"without the rtcp-mux attribute were found.\\\");\\n        }\\n\\n        if (bLine.type === 'application') {\\n            mid2ul[bLine.mid] = bLine;\\n            return;\\n        }\\n\\n        // With rtcp-mux and bundle all the channels should have the same ICE\\n        // stuff.\\n        var sources = bLine.sources;\\n        var ssrcGroups = bLine.ssrcGroups;\\n        var candidates = bLine.candidates;\\n        var iceUfrag = bLine.iceUfrag;\\n        var icePwd = bLine.icePwd;\\n        var fingerprint = bLine.fingerprint;\\n        var port = bLine.port;\\n\\n        // We'll use the \\\"bLine\\\" object as a prototype for each new \\\"mLine\\\"\\n        // that we create, but first we need to clean it up a bit.\\n        delete bLine.sources;\\n        delete bLine.ssrcGroups;\\n        delete bLine.candidates;\\n        delete bLine.iceUfrag;\\n        delete bLine.icePwd;\\n        delete bLine.fingerprint;\\n        delete bLine.port;\\n        delete bLine.mid;\\n\\n        // inverted ssrc group map\\n        var ssrc2group = {};\\n        if (typeof ssrcGroups !== 'undefined' && Array.isArray(ssrcGroups)) {\\n            ssrcGroups.forEach(function (ssrcGroup) {\\n\\n                // TODO(gp) find out how to receive simulcast with FF. For the\\n                // time being, hide it.\\n                if (ssrcGroup.semantics === 'SIM') {\\n                    return;\\n                }\\n\\n                // XXX This might brake if an SSRC is in more than one group\\n                // for some reason.\\n                if (typeof ssrcGroup.ssrcs !== 'undefined' &&\\n                    Array.isArray(ssrcGroup.ssrcs)) {\\n                    ssrcGroup.ssrcs.forEach(function (ssrc) {\\n                        if (typeof ssrc2group[ssrc] === 'undefined') {\\n                            ssrc2group[ssrc] = [];\\n                        }\\n\\n                        ssrc2group[ssrc].push(ssrcGroup);\\n                    });\\n                }\\n            });\\n        }\\n\\n        // ssrc to m-line index.\\n        var ssrc2ml = {};\\n\\n        if (typeof sources === 'object') {\\n\\n            // Explode the Plan B channel sources with one m-line per source.\\n            Object.keys(sources).forEach(function(ssrc) {\\n\\n                // The (unified) m-line for this SSRC. We either create it from\\n                // scratch or, if it's a grouped SSRC, we re-use a related\\n                // mline. In other words, if the source is grouped with another\\n                // source, put the two together in the same m-line.\\n                var uLine;\\n\\n                // We assume here that we are the answerer in the O/A, so any\\n                // offers which we translate come from the remote side, while\\n                // answers are local. So the check below is to make that we\\n                // handle receive-only SSRCs in a special way only if they come\\n                // from the remote side.\\n                if (desc.type==='offer') {\\n                    // We want to detect SSRCs which are used by a remote peer\\n                    // in an m-line with direction=recvonly (i.e. they are\\n                    // being used for RTCP only).\\n                    // This information would have gotten lost if the remote\\n                    // peer used Unified Plan and their local description was\\n                    // translated to Plan B. So we use the lack of an MSID\\n                    // attribute to deduce a \\\"receive only\\\" SSRC.\\n                    if (!sources[ssrc].msid) {\\n                        recvonlySsrcs[bLine.type][ssrc] = sources[ssrc];\\n                        // Receive-only SSRCs must not create new m-lines. We\\n                        // will assign them to an existing m-line later.\\n                        return;\\n                    }\\n                }\\n\\n                if (typeof ssrc2group[ssrc] !== 'undefined' &&\\n                    Array.isArray(ssrc2group[ssrc])) {\\n                    ssrc2group[ssrc].some(function (ssrcGroup) {\\n                        // ssrcGroup.ssrcs *is* an Array, no need to check\\n                        // again here.\\n                        return ssrcGroup.ssrcs.some(function (related) {\\n                            if (typeof ssrc2ml[related] === 'object') {\\n                                uLine = ssrc2ml[related];\\n                                return true;\\n                            }\\n                        });\\n                    });\\n                }\\n\\n                if (typeof uLine === 'object') {\\n                    // the m-line already exists. Just add the source.\\n                    uLine.sources[ssrc] = sources[ssrc];\\n                    delete sources[ssrc].msid;\\n                } else {\\n                    // Use the \\\"bLine\\\" as a prototype for the \\\"uLine\\\".\\n                    uLine = Object.create(bLine);\\n                    ssrc2ml[ssrc] = uLine;\\n\\n                    if (typeof sources[ssrc].msid !== 'undefined') {\\n                        // Assign the msid of the source to the m-line. Note\\n                        // that it is not guaranteed that the source will have\\n                        // msid. In particular \\\"recvonly\\\" sources don't have an\\n                        // msid. Note that \\\"recvonly\\\" is a term only defined\\n                        // for m-lines.\\n                        uLine.msid = sources[ssrc].msid;\\n                        delete sources[ssrc].msid;\\n                    }\\n\\n                    // We assign one SSRC per media line.\\n                    uLine.sources = {};\\n                    uLine.sources[ssrc] = sources[ssrc];\\n                    uLine.ssrcGroups = ssrc2group[ssrc];\\n\\n                    // Use the cached Unified Plan SDP (if it exists) to assign\\n                    // SSRCs to mids.\\n                    if (typeof cached !== 'undefined' &&\\n                        typeof cached.media !== 'undefined' &&\\n                        Array.isArray(cached.media)) {\\n\\n                        cached.media.forEach(function (m) {\\n                            if (typeof m.sources === 'object') {\\n                                Object.keys(m.sources).forEach(function (s) {\\n                                    if (s === ssrc) {\\n                                        uLine.mid = m.mid;\\n                                    }\\n                                });\\n                            }\\n                        });\\n                    }\\n\\n                    if (typeof uLine.mid === 'undefined') {\\n\\n                        // If this is an SSRC that we see for the first time\\n                        // assign it a new mid. This is typically the case when\\n                        // this method is called to transform a remote\\n                        // description for the first time or when there is a\\n                        // new SSRC in the remote description because a new\\n                        // peer has joined the conference. Local SSRCs should\\n                        // have already been added to the map in the toPlanB\\n                        // method.\\n                        //\\n                        // Because FF generates answers in Unified Plan style,\\n                        // we MUST already have a cached answer with all the\\n                        // local SSRCs mapped to some m-line/mid.\\n\\n                        if (desc.type === 'answer') {\\n                            throw new Error(\\\"An unmapped SSRC was found.\\\");\\n                        }\\n\\n                        uLine.mid = [bLine.type, '-', ssrc].join('');\\n                    }\\n\\n                    // Include the candidates in the 1st media line.\\n                    uLine.candidates = candidates;\\n                    uLine.iceUfrag = iceUfrag;\\n                    uLine.icePwd = icePwd;\\n                    uLine.fingerprint = fingerprint;\\n                    uLine.port = port;\\n\\n                    mid2ul[uLine.mid] = uLine;\\n\\n                    self.cache.mlU2BMap[uIdx] = bIdx;\\n                    if (typeof self.cache.mlB2UMap[bIdx] === 'undefined') {\\n                      self.cache.mlB2UMap[bIdx] = uIdx;\\n                    }\\n                    uIdx++;\\n                }\\n            });\\n        }\\n\\n        bIdx++;\\n    });\\n\\n    // Rebuild the media array in the right order and add the missing mLines\\n    // (missing from the Plan B SDP).\\n    session.media = [];\\n    mids = []; // reuse\\n\\n    if (desc.type === 'answer') {\\n\\n        // The media lines in the answer must match the media lines in the\\n        // offer. The order is important too. Here we assume that Firefox is\\n        // the answerer, so we merely have to use the reconstructed (unified)\\n        // answer to update the cached (unified) answer accordingly.\\n        //\\n        // In the general case, one would have to use the cached (unified)\\n        // offer to find the m-lines that are missing from the reconstructed\\n        // answer, potentially grabbing them from the cached (unified) answer.\\n        // One has to be careful with this approach because inactive m-lines do\\n        // not always have an mid, making it tricky (impossible?) to find where\\n        // exactly and which m-lines are missing from the reconstructed answer.\\n\\n        for (var i = 0; i < cached.media.length; i++) {\\n            var uLine = cached.media[i];\\n\\n            if (typeof mid2ul[uLine.mid] === 'undefined') {\\n\\n                // The mid isn't in the reconstructed (unified) answer.\\n                // This is either a (unified) m-line containing a remote\\n                // track only, or a (unified) m-line containing a remote\\n                // track and a local track that has been removed.\\n                // In either case, it MUST exist in the cached\\n                // (unified) answer.\\n                //\\n                // In case this is a removed local track, clean-up\\n                // the (unified) m-line and make sure it's 'recvonly' or\\n                // 'inactive'.\\n\\n                delete uLine.msid;\\n                delete uLine.sources;\\n                delete uLine.ssrcGroups;\\n                if (!uLine.direction\\n                    || uLine.direction === 'sendrecv')\\n                    uLine.direction = 'recvonly';\\n                else if (uLine.direction === 'sendonly')\\n                    uLine.direction = 'inactive';\\n            } else {\\n                // This is an (unified) m-line/channel that contains a local\\n                // track (sendrecv or sendonly channel) or it's a unified\\n                // recvonly m-line/channel. In either case, since we're\\n                // going from PlanB -> Unified Plan this m-line MUST\\n                // exist in the cached answer.\\n            }\\n\\n            session.media.push(uLine);\\n\\n            if (typeof uLine.mid === 'string') {\\n                // inactive lines don't/may not have an mid.\\n                mids.push(uLine.mid);\\n            }\\n        }\\n    } else {\\n\\n        // SDP offer/answer (and the JSEP spec) forbids removing an m-section\\n        // under any circumstances. If we are no longer interested in sending a\\n        // track, we just remove the msid and ssrc attributes and set it to\\n        // either a=recvonly (as the reofferer, we must use recvonly if the\\n        // other side was previously sending on the m-section, but we can also\\n        // leave the possibility open if it wasn't previously in use), or\\n        // a=inactive.\\n\\n        if (typeof cached !== 'undefined' &&\\n            typeof cached.media !== 'undefined' &&\\n            Array.isArray(cached.media)) {\\n            cached.media.forEach(function(uLine) {\\n                mids.push(uLine.mid);\\n                if (typeof mid2ul[uLine.mid] !== 'undefined') {\\n                    session.media.push(mid2ul[uLine.mid]);\\n                } else {\\n                    delete uLine.msid;\\n                    delete uLine.sources;\\n                    delete uLine.ssrcGroups;\\n                    if (!uLine.direction\\n                        || uLine.direction === 'sendrecv')\\n                        uLine.direction = 'recvonly';\\n                    if (!uLine.direction\\n                        || uLine.direction === 'sendonly')\\n                        uLine.direction = 'inactive';\\n                    session.media.push(uLine);\\n                }\\n            });\\n        }\\n\\n        // Add all the remaining (new) m-lines of the transformed SDP.\\n        Object.keys(mid2ul).forEach(function(mid) {\\n            if (mids.indexOf(mid) === -1) {\\n                mids.push(mid);\\n                if (mid2ul[mid].direction === 'recvonly') {\\n                    // This is a remote recvonly channel. Add its SSRC to the\\n                    // appropriate sendrecv or sendonly channel.\\n                    // TODO(gp) what if we don't have sendrecv/sendonly\\n                    // channel?\\n\\n                    session.media.some(function (uLine) {\\n                        if ((uLine.direction === 'sendrecv' ||\\n                            uLine.direction === 'sendonly') &&\\n                            uLine.type === mid2ul[mid].type) {\\n\\n                            // mid2ul[mid] shouldn't have any ssrc-groups\\n                            Object.keys(mid2ul[mid].sources).forEach(\\n                                function (ssrc) {\\n                                uLine.sources[ssrc] =\\n                                    mid2ul[mid].sources[ssrc];\\n                            });\\n\\n                            return true;\\n                        }\\n                    });\\n                } else {\\n                    session.media.push(mid2ul[mid]);\\n                }\\n            }\\n        });\\n    }\\n\\n    // After we have constructed the Plan Unified m-lines we can figure out\\n    // where (in which m-line) to place the 'recvonly SSRCs'.\\n    // Note: we assume here that we are the answerer in the O/A, so any offers\\n    // which we translate come from the remote side, while answers are local\\n    // (and so our last local description is cached as an 'answer').\\n    [\\\"audio\\\", \\\"video\\\"].forEach(function (type) {\\n        if (!session || !session.media || !Array.isArray(session.media))\\n            return;\\n\\n        var idx = null;\\n        if (Object.keys(recvonlySsrcs[type]).length > 0) {\\n            idx = self.getFirstSendingIndexFromAnswer(type);\\n            if (idx === null){\\n                // If this is the first offer we receive, we don't have a\\n                // cached answer. Assume that we will be sending media using\\n                // the first m-line for each media type.\\n\\n                for (var i = 0; i < session.media.length; i++) {\\n                    if (session.media[i].type === type) {\\n                        idx = i;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (idx && session.media.length > idx) {\\n            var mLine = session.media[idx];\\n            Object.keys(recvonlySsrcs[type]).forEach(function(ssrc) {\\n                if (mLine.sources && mLine.sources[ssrc]) {\\n                    console.warn(\\\"Replacing an existing SSRC.\\\");\\n                }\\n                if (!mLine.sources) {\\n                    mLine.sources = {};\\n                }\\n\\n                mLine.sources[ssrc] = recvonlySsrcs[type][ssrc];\\n            });\\n        }\\n    });\\n\\n    // We regenerate the BUNDLE group (since we regenerated the mids)\\n    session.groups.some(function(group) {\\n        if (group.type === 'BUNDLE') {\\n            group.mids = mids.join(' ');\\n            return true;\\n        }\\n    });\\n\\n    // msid semantic\\n    session.msidSemantic = {\\n        semantic: 'WMS',\\n        token: '*'\\n    };\\n\\n    var resStr = transform.write(session);\\n\\n    // Cache the transformed SDP (Unified Plan) for later re-use in this\\n    // function.\\n    this.cache[desc.type] = resStr;\\n\\n    return new RTCSessionDescription({\\n        type: desc.type,\\n        sdp: resStr\\n    });\\n\\n    //#endregion\\n};\\n\\n\\n/***/ }),\\n/* 149 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* Copyright @ 2015 Atlassian Pty Ltd\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\nvar transform = __webpack_require__(15);\\n\\nexports.write = function(session, opts) {\\n\\n  if (typeof session !== 'undefined' &&\\n      typeof session.media !== 'undefined' &&\\n      Array.isArray(session.media)) {\\n\\n    session.media.forEach(function (mLine) {\\n      // expand sources to ssrcs\\n      if (typeof mLine.sources !== 'undefined' &&\\n        Object.keys(mLine.sources).length !== 0) {\\n          mLine.ssrcs = [];\\n          Object.keys(mLine.sources).forEach(function (ssrc) {\\n            var source = mLine.sources[ssrc];\\n            Object.keys(source).forEach(function (attribute) {\\n              mLine.ssrcs.push({\\n                id: ssrc,\\n                attribute: attribute,\\n                value: source[attribute]\\n              });\\n            });\\n          });\\n          delete mLine.sources;\\n        }\\n\\n      // join ssrcs in ssrc groups\\n      if (typeof mLine.ssrcGroups !== 'undefined' &&\\n        Array.isArray(mLine.ssrcGroups)) {\\n          mLine.ssrcGroups.forEach(function (ssrcGroup) {\\n            if (typeof ssrcGroup.ssrcs !== 'undefined' &&\\n                Array.isArray(ssrcGroup.ssrcs)) {\\n              ssrcGroup.ssrcs = ssrcGroup.ssrcs.join(' ');\\n            }\\n          });\\n        }\\n    });\\n  }\\n\\n  // join group mids\\n  if (typeof session !== 'undefined' &&\\n      typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {\\n\\n    session.groups.forEach(function (g) {\\n      if (typeof g.mids !== 'undefined' && Array.isArray(g.mids)) {\\n        g.mids = g.mids.join(' ');\\n      }\\n    });\\n  }\\n\\n  return transform.write(session, opts);\\n};\\n\\nexports.parse = function(sdp) {\\n  var session = transform.parse(sdp);\\n\\n  if (typeof session !== 'undefined' && typeof session.media !== 'undefined' &&\\n      Array.isArray(session.media)) {\\n\\n    session.media.forEach(function (mLine) {\\n      // group sources attributes by ssrc\\n      if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {\\n        mLine.sources = {};\\n        mLine.ssrcs.forEach(function (ssrc) {\\n          if (!mLine.sources[ssrc.id])\\n          mLine.sources[ssrc.id] = {};\\n        mLine.sources[ssrc.id][ssrc.attribute] = ssrc.value;\\n        });\\n\\n        delete mLine.ssrcs;\\n      }\\n\\n      // split ssrcs in ssrc groups\\n      if (typeof mLine.ssrcGroups !== 'undefined' &&\\n        Array.isArray(mLine.ssrcGroups)) {\\n          mLine.ssrcGroups.forEach(function (ssrcGroup) {\\n            if (typeof ssrcGroup.ssrcs === 'string') {\\n              ssrcGroup.ssrcs = ssrcGroup.ssrcs.split(' ');\\n            }\\n          });\\n        }\\n    });\\n  }\\n  // split group mids\\n  if (typeof session !== 'undefined' &&\\n      typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {\\n\\n    session.groups.forEach(function (g) {\\n      if (typeof g.mids === 'string') {\\n        g.mids = g.mids.split(' ');\\n      }\\n    });\\n  }\\n\\n  return session;\\n};\\n\\n\\n\\n/***/ }),\\n/* 150 */\\n/***/ (function(module, exports) {\\n\\n/* Copyright @ 2015 Atlassian Pty Ltd\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\nmodule.exports = function arrayEquals(array) {\\n    // if the other array is a falsy value, return\\n    if (!array)\\n        return false;\\n\\n    // compare lengths - can save a lot of time\\n    if (this.length != array.length)\\n        return false;\\n\\n    for (var i = 0, l = this.length; i < l; i++) {\\n        // Check if we have nested arrays\\n        if (this[i] instanceof Array && array[i] instanceof Array) {\\n            // recurse into the nested arrays\\n            if (!arrayEquals.apply(this[i], [array[i]]))\\n                return false;\\n        } else if (this[i] != array[i]) {\\n            // Warning - two different object instances will never be equal:\\n            // {x:20} != {x:20}\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n\\n\\n\\n/***/ }),\\n/* 151 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* Copyright @ 2016 Atlassian Pty Ltd\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\nvar transform = __webpack_require__(15);\\nvar transformUtils = __webpack_require__(152);\\nvar parseSsrcs = transformUtils.parseSsrcs;\\nvar writeSsrcs = transformUtils.writeSsrcs;\\n\\n//region Constants\\n\\nvar DEFAULT_NUM_OF_LAYERS = 3;\\n\\n//endregion\\n\\nfunction getSsrcAttribute (mLine, ssrc, attributeName) {\\n    return mLine\\n        .ssrcs\\n        .filter(function(ssrcInfo) { return ssrcInfo.id === ssrc; })\\n        .filter(function(ssrcInfo) { return ssrcInfo.attribute === attributeName; })\\n        .map(function(ssrcInfo) { return ssrcInfo.value; })[0];\\n}\\n\\n//region Ctor\\n\\nfunction Simulcast(options) {\\n\\n    this.options = options ? options : {};\\n\\n    if (!this.options.numOfLayers) {\\n        this.options.numOfLayers = DEFAULT_NUM_OF_LAYERS;\\n    }\\n    console.log(\\\"SdpSimulcast: using \\\" + this.options.numOfLayers + \\\" layers\\\");\\n\\n    /**\\n     * An IN-ORDER list of the simulcast ssrcs\\n     * @type {list<number>}\\n     */\\n    this.ssrcCache = [];\\n}\\n\\n//endregion\\n\\n//region Stateless private utility functions\\n\\n/**\\n * Returns a random integer between min (included) and max (excluded)\\n * Using Math.round() gives a non-uniform distribution!\\n * @returns {number}\\n */\\nfunction generateSSRC() {\\n    var min = 0, max = 0xffffffff;\\n    return Math.floor(Math.random() * (max - min)) + min;\\n};\\n\\nfunction processVideo(session, action) {\\n    if (session == null || !Array.isArray(session.media)) {\\n        return;\\n    }\\n\\n    session.media.forEach(function (mLine) {\\n        if (mLine.type === 'video') {\\n            action(mLine);\\n        }\\n    });\\n};\\n\\nfunction validateDescription(desc)\\n{\\n    return desc && desc != null\\n        && desc.type && desc.type != ''\\n        && desc.sdp && desc.sdp != '';\\n}\\n\\nfunction explodeRemoteSimulcast(mLine) {\\n\\n    if (!mLine || !Array.isArray(mLine.ssrcGroups)) {\\n        return;\\n    }\\n\\n    var sources = parseSsrcs(mLine);\\n    var order = [];\\n\\n    // Find the SIM group and explode its sources.\\n    var j = mLine.ssrcGroups.length;\\n    while (j--) {\\n\\n        if (mLine.ssrcGroups[j].semantics !== 'SIM') {\\n            continue;\\n        }\\n\\n        var simulcastSsrcs = mLine.ssrcGroups[j].ssrcs.split(' ');\\n\\n        for (var i = 0; i < simulcastSsrcs.length; i++) {\\n\\n            var ssrc = simulcastSsrcs[i];\\n            order.push(ssrc);\\n\\n            var parts = sources[ssrc].msid.split(' ');\\n            sources[ssrc].msid = [parts[0], '/', i, ' ', parts[1], '/', i].join('');\\n            sources[ssrc].cname = [sources[ssrc].cname, '/', i].join('');\\n\\n            // Remove all the groups that this SSRC participates in.\\n            mLine.ssrcGroups.forEach(function (relatedGroup) {\\n                if (relatedGroup.semantics === 'SIM') {\\n                    return;\\n                }\\n\\n                var relatedSsrcs = relatedGroup.ssrcs.split(' ');\\n                if (relatedSsrcs.indexOf(ssrc) === -1) {\\n                    return;\\n                }\\n\\n                // Nuke all the related SSRCs.\\n                relatedSsrcs.forEach(function (relatedSSRC) {\\n                    sources[relatedSSRC].msid = sources[ssrc].msid;\\n                    sources[relatedSSRC].cname = sources[ssrc].cname;\\n                    if (relatedSSRC !== ssrc) {\\n                        order.push(relatedSSRC);\\n                    }\\n                });\\n\\n                // Schedule the related group for nuking.\\n            })\\n        }\\n\\n        mLine.ssrcs = writeSsrcs(sources, order);\\n        mLine.ssrcGroups.splice(j, 1);\\n    };\\n}\\n\\nfunction implodeRemoteSimulcast(mLine) {\\n\\n    if (!mLine || !Array.isArray(mLine.ssrcGroups)) {\\n        console.info('Halt: There are no SSRC groups in the remote ' +\\n                'description.');\\n        return;\\n    }\\n\\n    var sources = parseSsrcs(mLine);\\n\\n    // Find the SIM group and nuke it.\\n    mLine.ssrcGroups.forEach(function (simulcastGroup) {\\n        if (simulcastGroup.semantics !== 'SIM') {\\n            return;\\n        }\\n\\n        console.info(\\\"Imploding SIM group: \\\" + simulcastGroup.ssrcs);\\n        // Schedule the SIM group for nuking.\\n        simulcastGroup.nuke = true;\\n\\n        var simulcastSsrcs = simulcastGroup.ssrcs.split(' ');\\n\\n        // Nuke all the higher layer SSRCs.\\n        for (var i = 1; i < simulcastSsrcs.length; i++) {\\n\\n            var ssrc = simulcastSsrcs[i];\\n            delete sources[ssrc];\\n\\n            // Remove all the groups that this SSRC participates in.\\n            mLine.ssrcGroups.forEach(function (relatedGroup) {\\n                if (relatedGroup.semantics === 'SIM') {\\n                    return;\\n                }\\n\\n                var relatedSsrcs = relatedGroup.ssrcs.split(' ');\\n                if (relatedSsrcs.indexOf(ssrc) === -1) {\\n                    return;\\n                }\\n\\n                // Nuke all the related SSRCs.\\n                relatedSsrcs.forEach(function (relatedSSRC) {\\n                    delete sources[relatedSSRC];\\n                });\\n\\n                // Schedule the related group for nuking.\\n                relatedGroup.nuke = true;\\n            })\\n        }\\n\\n        return;\\n    });\\n\\n    mLine.ssrcs = writeSsrcs(sources);\\n\\n    // Nuke all the scheduled groups.\\n    var i = mLine.ssrcGroups.length;\\n    while (i--) {\\n        if (mLine.ssrcGroups[i].nuke) {\\n            mLine.ssrcGroups.splice(i, 1);\\n        }\\n    }\\n}\\n\\nfunction removeGoogConference(mLine) {\\n    if (!mLine || !Array.isArray(mLine.invalid)) {\\n        return;\\n    }\\n\\n    var i = mLine.invalid.length;\\n    while (i--) {\\n        if (mLine.invalid[i].value == 'x-google-flag:conference') {\\n            mLine.invalid.splice(i, 1);\\n        }\\n    }\\n}\\n\\nfunction assertGoogConference(mLine) {\\n    if (!mLine) {\\n        return;\\n    }\\n\\n    if (!Array.isArray(mLine.invalid)) {\\n        mLine.invalid = [];\\n    }\\n\\n    if (!mLine.invalid.some(\\n            function (i) { return i.value === 'x-google-flag:conference' })) {\\n        mLine.invalid.push({'value': 'x-google-flag:conference'});\\n    }\\n}\\n\\nSimulcast.prototype.clearSsrcCache = function() {\\n    this.ssrcCache = [];\\n}\\n\\n/**\\n * When we start as video muted, all of the video\\n *  ssrcs get generated so we can include them as part\\n *  of the original session-accept.  That means we\\n *  need this library to restore to those same ssrcs\\n *  the first time we unmute, so we need the ability to\\n *  force its cache\\n */\\nSimulcast.prototype.setSsrcCache = function(ssrcs) {\\n    this.ssrcCache = ssrcs;\\n}\\n\\n//endregion\\n\\n//region \\\"Private\\\" functions\\n\\n/**\\n * Given a video mLine, return a list of the video ssrcs\\n *  in simulcast layer order (returns a list of just\\n *  the primary ssrc if there are no simulcast layers)\\n */\\nSimulcast.prototype._parseSimLayers = function (mLine) {\\n    var simGroup = mLine.ssrcGroups &&\\n        mLine.ssrcGroups.find(function(group) { return group.semantics === \\\"SIM\\\"; });\\n    if (simGroup) {\\n        return simGroup.ssrcs\\n            .split(\\\" \\\")\\n            .map(function(ssrcStr) { return parseInt(ssrcStr) });\\n    } else {\\n        return [mLine.ssrcs[0].id];\\n    }\\n}\\n\\nSimulcast.prototype._buildNewToOldSsrcMap = function (newSsrcList, oldSsrcList) {\\n    var ssrcMap = {};\\n    for (var i = 0; i < newSsrcList.length; ++i) {\\n        var newSsrc = newSsrcList[i];\\n        var oldSsrc = oldSsrcList[i] || null;\\n        ssrcMap[newSsrc] = oldSsrc;\\n    }\\n    return ssrcMap;\\n}\\n\\nSimulcast.prototype._fillInSourceDataFromCache = function(mLine) {\\n    console.log(\\\"SdpSimulcast restoring from cache: \\\", this.ssrcCache);\\n    var newSimSsrcs = this._parseSimLayers(mLine);\\n    console.log(\\\"SdpSimulcast Parsed new sim ssrcs: \\\", newSimSsrcs);\\n    var newMsid = getSsrcAttribute(mLine, newSimSsrcs[0], \\\"msid\\\");\\n    var newCname = getSsrcAttribute(mLine, newSimSsrcs[0], \\\"cname\\\");\\n    var ssrcsToReplace = this._buildNewToOldSsrcMap(newSimSsrcs, this.ssrcCache);\\n    console.log(\\\"SdpSimulcast built replacement map: \\\", ssrcsToReplace);\\n    // New sdp might only have 1 layer, so not every cached ssrc will have a new one\\n    //  to replace directly\\n    var ssrcsToAdd = this.ssrcCache\\n        .filter(function(ssrc) { return Object.values(ssrcsToReplace).indexOf(ssrc) === -1; });\\n    console.log(\\\"SdpSimulcast built ssrcs to add: \\\", ssrcsToAdd);\\n\\n    // First do the replacements\\n    mLine.ssrcs.forEach(function(ssrc) {\\n        if (ssrcsToReplace[ssrc.id]) {\\n            ssrc.id = ssrcsToReplace[ssrc.id];\\n        }\\n    });\\n    // Now the adds\\n    ssrcsToAdd.forEach(function(ssrc) {\\n        mLine.ssrcs.push({\\n            id: ssrc,\\n            attribute: \\\"msid\\\",\\n            value: newMsid\\n        });\\n        mLine.ssrcs.push({\\n            id: ssrc,\\n            attribute: \\\"cname\\\",\\n            value: newCname\\n        });\\n    });\\n    mLine.ssrcGroups = mLine.ssrcGroups || [];\\n    mLine.ssrcGroups.push({\\n        semantics: \\\"SIM\\\",\\n        ssrcs: this.ssrcCache.join(\\\" \\\")\\n    });\\n    return mLine;\\n}\\n\\nSimulcast.prototype._generateSourceData = function(mLine, primarySsrc) {\\n    var addAssociatedStream = function(mLine, ssrc) {\\n        mLine.ssrcs.push({\\n            id: ssrc,\\n            attribute: \\\"cname\\\",\\n            value: primarySsrcCname\\n        });\\n        mLine.ssrcs.push({\\n            id: ssrc,\\n            attribute: \\\"msid\\\",\\n            value: primarySsrcMsid\\n        });\\n    }\\n    var primarySsrcMsid = getSsrcAttribute(mLine, primarySsrc, \\\"msid\\\");\\n    var primarySsrcCname = getSsrcAttribute(mLine, primarySsrc, \\\"cname\\\");\\n\\n    // Generate sim layers\\n    var simSsrcs = [];\\n    for (var i = 0; i < this.options.numOfLayers - 1; ++i) {\\n        var simSsrc = generateSSRC();\\n        addAssociatedStream(mLine, simSsrc);\\n        simSsrcs.push(simSsrc);\\n    }\\n    mLine.ssrcGroups = mLine.ssrcGroups || [];\\n    mLine.ssrcGroups.push({\\n        semantics: \\\"SIM\\\",\\n        ssrcs: primarySsrc + \\\" \\\" + simSsrcs.join(\\\" \\\")\\n    });\\n    return mLine;\\n}\\n\\n\\n\\n// Assumptions:\\n//  1) 'mLine' contains only a single primary video source\\n//   (i.e. it will not already have simulcast streams inserted)\\n//  2) 'mLine' MAY already contain an RTX stream for its video source\\n//  3) 'mLine' is in sendrecv or sendonly state\\n// Guarantees:\\n//  1) return mLine will contain 2 additional simulcast layers\\n//   generated\\n//  2) if the base video ssrc in mLine has been seen before,\\n//   then the same generated simulcast streams from before will\\n//   be used again\\n//  3) if rtx is enabled for the mLine, all generated simulcast\\n//   streams will have rtx streams generated as well\\n//  4) if rtx has been generated for a src before, we will generate\\n//   the same rtx stream again\\nSimulcast.prototype._restoreSimulcast = function(mLine) {\\n    // First, find the primary video source in the given\\n    // mLine and see if we've seen it before.\\n    var primarySsrc;\\n    var numSsrcs = mLine.ssrcs && mLine.ssrcs\\n        .map(function(ssrcInfo) { return ssrcInfo.id; })\\n        .filter(function(ssrc, index, array) {\\n            return array.indexOf(ssrc) === index;\\n        })\\n        .length || 0;\\n    var numGroups = (mLine.ssrcGroups && mLine.ssrcGroups.length) || 0;\\n\\n    if (numSsrcs === 0 || numSsrcs > 2) {\\n        // Unsupported scenario\\n        return mLine;\\n    }\\n    if (numSsrcs == 2 && numGroups === 0) {\\n        // Unsupported scenario\\n        return mLine;\\n    }\\n\\n    if (numSsrcs === 1) {\\n        primarySsrc = mLine.ssrcs[0].id;\\n    } else {\\n        // There must be an FID group, so parse\\n        //  that and pull the primary ssrc from there\\n        var fidGroup = mLine.ssrcGroups.filter(function(group) { return group.semantics === \\\"FID\\\"; })[0];\\n        if (fidGroup) {\\n            primarySsrc = parseInt(fidGroup.ssrcs.split(\\\" \\\")[0]);\\n        } else {\\n            // Unsupported scenario\\n            return mLine;\\n        }\\n    }\\n    console.log(\\\"SdpSimulcast: current ssrc cache: \\\", this.ssrcCache);\\n    console.log(\\\"SdpSimulcast: parsed primary ssrc \\\" + primarySsrc);\\n\\n    var seenPrimarySsrc = this.ssrcCache.indexOf(primarySsrc) !== -1;\\n\\n    if (seenPrimarySsrc) {\\n        console.log(\\\"SdpSimulcast: Have seen primary ssrc before, \\\" +\\n            \\\"filling in data from cache\\\");\\n        mLine = this._fillInSourceDataFromCache(mLine);\\n    } else {\\n        console.log(\\\"SdpSimulcast: Have not seen primary ssrc before, \\\" +\\n            \\\"generating source data\\\");\\n        mLine = this._generateSourceData(mLine, primarySsrc);\\n    }\\n    // Now update the cache to match whatever we've just put into this sdp\\n    this.ssrcCache = this._parseSimLayers(mLine);\\n    return mLine;\\n}\\n\\n//endregion\\n\\n//region \\\"Public\\\" functions\\n\\n/**\\n *\\n * @param desc\\n * @returns {RTCSessionDescription}\\n */\\nSimulcast.prototype.mungeRemoteDescription = function (desc) {\\n\\n    if (!validateDescription(desc)) {\\n        return desc;\\n    }\\n\\n    var session = transform.parse(desc.sdp);\\n\\n    var self = this;\\n    processVideo(session, function (mLine) {\\n\\n        // Handle simulcast reception.\\n        if (self.options.explodeRemoteSimulcast) {\\n            explodeRemoteSimulcast(mLine);\\n        } else {\\n            implodeRemoteSimulcast(mLine);\\n        }\\n\\n        // If native simulcast is enabled, we must append the x-goog-conference\\n        // attribute to the SDP.\\n        if (self.ssrcCache.length < 1) {\\n            removeGoogConference(mLine);\\n        } else {\\n            assertGoogConference(mLine);\\n        }\\n    });\\n\\n    return new RTCSessionDescription({\\n        type: desc.type,\\n        sdp: transform.write(session)\\n    });\\n};\\n\\n/**\\n *\\n * NOTE this method should be called only if simulcast is supported by\\n * the current browser, otherwise local SDP should not be munged.\\n * @param desc\\n * @returns {RTCSessionDescription}\\n */\\nSimulcast.prototype.mungeLocalDescription = function (desc) {\\n\\n    if (!validateDescription(desc)) {\\n        return desc;\\n    }\\n\\n    var session = transform.parse(desc.sdp);\\n\\n    var self = this;\\n    processVideo(session, function (mLine) {\\n        if (mLine.direction == 'recvonly' || mLine.direction == 'inactive')\\n        {\\n            return;\\n        }\\n        self._restoreSimulcast(mLine);\\n    });\\n\\n    return new RTCSessionDescription({\\n        type: desc.type,\\n        sdp: transform.write(session)\\n    });\\n};\\n\\n//endregion\\n\\nmodule.exports = Simulcast;\\n\\n\\n/***/ }),\\n/* 152 */\\n/***/ (function(module, exports) {\\n\\n/* Copyright @ 2015 Atlassian Pty Ltd\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n/**\\n * FIXME\\n * @param sources FIXME\\n * @param order An array of SSRCs which will be used to order the entries in\\n * the returned array. Sources whose SSRC appears in 'order' will be added first,\\n * in the specified order, and all other sources will be added afterwards (in\\n * no specific order).\\n * @returns {Array} FIXME\\n */\\nexports.writeSsrcs = function(sources, order) {\\n  var ssrcs = [];\\n\\n  // expand sources to ssrcs\\n  if (typeof sources !== 'undefined' &&\\n      Object.keys(sources).length !== 0) {\\n\\n    if (!Array.isArray(order)) {\\n      order = []\\n    }\\n\\n    // Add the sources that appear in 'order' first.\\n    for (var i = 0; i < order.length; i++) {\\n      var ssrc = order[i];\\n      var source = sources[ssrc];\\n      Object.keys(source).forEach(function (attribute) {\\n        ssrcs.push({\\n          id: ssrc,\\n          attribute: attribute,\\n          value: source[attribute]\\n        });\\n      });\\n    }\\n\\n    // Now add the rest of the sources.\\n    Object.keys(sources).forEach(function (ssrc) {\\n      ssrc = parseInt(ssrc); // Object.keys() returns string\\n      if (order.indexOf(ssrc) >= 0) {\\n        // Already added.\\n        return;\\n      }\\n\\n      var source = sources[ssrc];\\n      Object.keys(source).forEach(function (attribute) {\\n        ssrcs.push({\\n          id: ssrc,\\n          attribute: attribute,\\n          value: source[attribute]\\n        });\\n      });\\n    });\\n  }\\n\\n  return ssrcs;\\n};\\n\\nexports.parseSsrcs = function (mLine) {\\n  var sources = {};\\n  // group sources attributes by ssrc.\\n  if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {\\n    mLine.ssrcs.forEach(function (ssrc) {\\n      if (!sources[ssrc.id])\\n        sources[ssrc.id] = {};\\n      sources[ssrc.id][ssrc.attribute] = ssrc.value;\\n    });\\n  }\\n  return sources;\\n};\\n\\n\\n\\n/***/ }),\\n/* 153 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__ = __webpack_require__(6);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n/**\\n * The value which we use to say, every sound over this threshold\\n * is talking on the mic.\\n * @type {number}\\n */\\nvar SPEECH_DETECT_THRESHOLD = 0.6;\\n\\n/**\\n * Detect user trying to speek while is locally muted and fires an event.\\n */\\n\\nvar TalkMutedDetection = function () {\\n    /**\\n     * Creates TalkMutedDetection\\n     * @param conference the JitsiConference instance that created us.\\n     * @param callback the callback to call when detected that the local user is\\n     * talking while her microphone is muted.\\n     * @constructor\\n     */\\n    function TalkMutedDetection(conference, callback) {\\n        _classCallCheck(this, TalkMutedDetection);\\n\\n        /**\\n         * The callback to call when detected that the local user is talking\\n         * while her microphone is muted.\\n         *\\n         * @private\\n         */\\n        this._callback = callback;\\n\\n        /**\\n         * The indicator which determines whether <tt>callback</tt> has been\\n         * invoked for the current local audio track of <tt>conference</tt> so\\n         * that it is invoked once only.\\n         *\\n         * @private\\n         */\\n        this._eventFired = false;\\n\\n        // XXX I went back and forth on the subject of where to put the access\\n        // to statistics. On the one had, (1) statistics is likely intended to\\n        // be private to conference and (2) there is a desire to keep the\\n        // dependencies of modules to the minimum (i.e. not have\\n        // TalkMutedDetection depend on statistics). On the other hand, (1)\\n        // statistics is technically not private because\\n        // JitsiConferenceEventManager accesses it and (2) TalkMutedDetection\\n        // works exactly because it knows that there are no audio levels for\\n        // JitsiLocalTrack but there are audio levels for the local participant\\n        // through statistics.\\n        conference.statistics.addAudioLevelListener(this._audioLevel.bind(this));\\n\\n        conference.on(__WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__[\\\"TRACK_MUTE_CHANGED\\\"], this._trackMuteChanged.bind(this));\\n        conference.on(__WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__[\\\"TRACK_ADDED\\\"], this._trackAdded.bind(this));\\n    }\\n\\n    /* eslint-disable max-params */\\n    /**\\n     * Receives audio level events for all send and receive streams.\\n     *\\n     * @param {TraceablePeerConnection} pc - WebRTC PeerConnection object of the\\n     * @param {number} ssrc - The synchronization source identifier (SSRC) of\\n     * the endpoint/participant/stream being reported.\\n     * @param {number} audioLevel - The audio level of <tt>ssrc</tt>.\\n     * @param {boolean} isLocal - <tt>true</tt> if <tt>ssrc</tt> represents a\\n     * local/send stream or <tt>false</tt> for a remote/receive stream.\\n     */\\n\\n\\n    _createClass(TalkMutedDetection, [{\\n        key: '_audioLevel',\\n        value: function _audioLevel(tpc, ssrc, audioLevel, isLocal) {\\n            // We are interested in the local audio stream only and if event is not\\n            // sent yet.\\n            if (!isLocal || !this.audioTrack || this._eventFired) {\\n                return;\\n            }\\n\\n            if (this.audioTrack.isMuted() && audioLevel > SPEECH_DETECT_THRESHOLD) {\\n                this._eventFired = true;\\n                this._callback();\\n            }\\n        }\\n        /* eslint-enable max-params */\\n\\n        /**\\n         * Determines whether a specific {@link JitsiTrack} represents a local audio\\n         * track.\\n         *\\n         * @param {JitsiTrack} track - The <tt>JitsiTrack</tt> to be checked whether\\n         * it represents a local audio track.\\n         * @private\\n         * @return {boolean} - <tt>true</tt> if the specified <tt>track</tt>\\n         * represents a local audio track; otherwise, <tt>false</tt>.\\n         */\\n\\n    }, {\\n        key: '_isLocalAudioTrack',\\n        value: function _isLocalAudioTrack(track) {\\n            return track.isAudioTrack() && track.isLocal();\\n        }\\n\\n        /**\\n         * Notifies this <tt>TalkMutedDetection</tt> that a {@link JitsiTrack} was\\n         * added to the associated {@link JitsiConference}. Looks for the local\\n         * audio track only.\\n         *\\n         * @param {JitsiTrack} track - The added <tt>JitsiTrack</tt>.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_trackAdded',\\n        value: function _trackAdded(track) {\\n            if (this._isLocalAudioTrack(track)) {\\n                this.audioTrack = track;\\n            }\\n        }\\n\\n        /**\\n         * Notifies this <tt>TalkMutedDetection</tt> that the mute state of a\\n         * {@link JitsiTrack} has changed. Looks for the local audio track only.\\n         *\\n         * @param {JitsiTrack} track - The <tt>JitsiTrack</tt> whose mute state has\\n         * changed.\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_trackMuteChanged',\\n        value: function _trackMuteChanged(track) {\\n            if (this._isLocalAudioTrack(track) && track.isMuted()) {\\n                this._eventFired = false;\\n            }\\n        }\\n    }]);\\n\\n    return TalkMutedDetection;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (TalkMutedDetection);\\n\\n/***/ }),\\n/* 154 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\nvar AudioRecorder = __webpack_require__(58);\\nvar SphinxService = __webpack_require__(156);\\n\\nvar BEFORE_STATE = 'before';\\nvar RECORDING_STATE = 'recording';\\nvar TRANSCRIBING_STATE = 'transcribing';\\nvar FINISHED_STATE = 'finished';\\n\\n// the amount of characters each line in the transcription will have\\nvar MAXIMUM_SENTENCE_LENGTH = 80;\\n\\n/**\\n * This is the main object for handing the Transcription. It interacts with\\n * the audioRecorder to record every person in a conference and sends the\\n * recorder audio to a transcriptionService. The returned speech-to-text result\\n * will be merged to create a transcript\\n * @param {AudioRecorder} audioRecorder An audioRecorder recording a conference\\n */\\nfunction Transcriber() {\\n    // the object which can record all audio in the conference\\n    this.audioRecorder = new AudioRecorder();\\n\\n    // this object can send the recorder audio to a speech-to-text service\\n    this.transcriptionService = new SphinxService();\\n\\n    // holds a counter to keep track if merging can start\\n    this.counter = null;\\n\\n    // holds the date when transcription started which makes it possible\\n    // to calculate the offset between recordings\\n    this.startTime = null;\\n\\n    // will hold the transcription once it is completed\\n    this.transcription = null;\\n\\n    // this will be a method which will be called once the transcription is done\\n    // with the transcription as parameter\\n    this.callback = null;\\n\\n    // stores all the retrieved speech-to-text results to merge together\\n    // this value will store an Array<Word> object\\n    this.results = [];\\n\\n    // Stores the current state of the transcription process\\n    this.state = BEFORE_STATE;\\n\\n    // Used in the updateTranscription method to add a new line when the\\n    // sentence becomes to long\\n    this.lineLength = 0;\\n}\\n\\n/**\\n * Method to start the transcription process. It will tell the audioRecorder\\n * to start storing all audio streams and record the start time for merging\\n * purposes\\n */\\nTranscriber.prototype.start = function start() {\\n    if (this.state !== BEFORE_STATE) {\\n        throw new Error('The transcription can only start when it\\\\'s in the \\\"' + BEFORE_STATE + '\\\" state. It\\\\'s currently in the \\\"' + this.state + '\\\" state');\\n    }\\n    this.state = RECORDING_STATE;\\n    this.audioRecorder.start();\\n    this.startTime = new Date();\\n};\\n\\n/**\\n * Method to stop the transcription process. It will tell the audioRecorder to\\n * stop, and get all the recorded audio to send it to the transcription service\\n\\n * @param callback a callback which will receive the transcription\\n */\\nTranscriber.prototype.stop = function stop(callback) {\\n    var _this = this;\\n\\n    if (this.state !== RECORDING_STATE) {\\n        throw new Error('The transcription can only stop when it\\\\'s in the \\\"' + RECORDING_STATE + '\\\" state. It\\\\'s currently in the \\\"' + this.state + '\\\" state');\\n    }\\n\\n    // stop the recording\\n    console.log('stopping recording and sending audio files');\\n    this.audioRecorder.stop();\\n\\n    // and send all recorded audio the the transcription service\\n    var callBack = blobCallBack.bind(null, this);\\n\\n    this.audioRecorder.getRecordingResults().forEach(function (recordingResult) {\\n        _this.transcriptionService.send(recordingResult, callBack);\\n        _this.counter++;\\n    });\\n\\n    // set the state to \\\"transcribing\\\" so that maybeMerge() functions correctly\\n    this.state = TRANSCRIBING_STATE;\\n\\n    // and store the callback for later\\n    this.callback = callback;\\n};\\n\\n/**\\n * This method gets the answer from the transcription service, calculates the\\n * offset and adds is to every Word object. It will also start the merging\\n * when every send request has been received\\n *\\n * note: Make sure to bind this as a Transcription object\\n * @param {Transcriber} transcriber the transcriber instance\\n * @param {RecordingResult} answer a RecordingResult object with a defined\\n * WordArray\\n */\\nfunction blobCallBack(transcriber, answer) {\\n    console.log('retrieved an answer from the transcription service. The answer has an' + (' array of length: ' + answer.wordArray.length));\\n\\n    // first add the offset between the start of the transcription and\\n    // the start of the recording to all start and end times\\n    if (answer.wordArray.length > 0) {\\n        var offset = answer.startTime.getUTCMilliseconds() - transcriber.startTime.getUTCMilliseconds();\\n\\n        // transcriber time will always be earlier\\n\\n        if (offset < 0) {\\n            offset = 0; // presume 0 if it somehow not earlier\\n        }\\n\\n        var array = '[';\\n\\n        answer.wordArray.forEach(function (wordObject) {\\n            wordObject.begin += offset;\\n            wordObject.end += offset;\\n            array += wordObject.word + ',';\\n        });\\n        array += ']';\\n        console.log(array);\\n\\n        // give a name value to the Array object so that the merging can access\\n        // the name value without having to use the whole recordingResult object\\n        // in the algorithm\\n        answer.wordArray.name = answer.name;\\n    }\\n\\n    // then store the array and decrease the counter\\n    transcriber.results.push(answer.wordArray);\\n    transcriber.counter--;\\n    console.log('current counter: ' + transcriber.counter);\\n\\n    // and check if all results have been received.\\n    transcriber.maybeMerge();\\n}\\n\\n/**\\n * this method will check if the counter is zero. If it is, it will call\\n * the merging method\\n */\\nTranscriber.prototype.maybeMerge = function () {\\n    if (this.state === TRANSCRIBING_STATE && this.counter === 0) {\\n        // make sure to include the events in the result arrays before\\n        // merging starts\\n        this.merge();\\n    }\\n};\\n\\n/**\\n * This method will merge all speech-to-text arrays together in one\\n * readable transcription string\\n */\\nTranscriber.prototype.merge = function () {\\n    var _this2 = this;\\n\\n    console.log('starting merge process!\\\\n The length of the array: ' + this.results.length);\\n    this.transcription = '';\\n\\n    // the merging algorithm will look over all Word objects who are at pos 0 in\\n    // every array. It will then select the one closest in time to the\\n    // previously placed word, while removing the selected word from its array\\n    // note: words can be skipped the skipped word's begin and end time somehow\\n    // end up between the closest word start and end time\\n    var arrays = this.results;\\n\\n    // arrays of Word objects\\n    var potentialWords = []; // array of the first Word objects\\n    // check if any arrays are already empty and remove them\\n\\n    hasPopulatedArrays(arrays);\\n\\n    // populate all the potential Words for a first time\\n    arrays.forEach(function (array) {\\n        return pushWordToSortedArray(potentialWords, array);\\n    });\\n\\n    // keep adding words to transcription until all arrays are exhausted\\n\\n    var _loop = function _loop() {\\n        // first select the lowest array;\\n        var lowestWordArray = arrays[0];\\n\\n        arrays.forEach(function (wordArray) {\\n            if (wordArray[0].begin < lowestWordArray[0].begin) {\\n                lowestWordArray = wordArray;\\n            }\\n        });\\n\\n        // put the word in the transcription\\n        var wordToAdd = lowestWordArray.shift();\\n\\n        _this2.updateTranscription(wordToAdd, lowestWordArray.name);\\n\\n        // keep going until a word in another array has a smaller time\\n        // or the array is empty\\n\\n        var _loop2 = function _loop2() {\\n            var foundSmaller = false;\\n            var wordToCompare = lowestWordArray[0].begin;\\n\\n            arrays.forEach(function (wordArray) {\\n                if (wordArray[0].begin < wordToCompare) {\\n                    foundSmaller = true;\\n                }\\n            });\\n\\n            // add next word if no smaller time has been found\\n            if (foundSmaller) {\\n                return 'break';\\n            }\\n\\n            wordToAdd = lowestWordArray.shift();\\n            _this2.updateTranscription(wordToAdd, null);\\n        };\\n\\n        while (lowestWordArray.length > 0) {\\n            var _ret2 = _loop2();\\n\\n            if (_ret2 === 'break') break;\\n        }\\n    };\\n\\n    while (hasPopulatedArrays(arrays)) {\\n        _loop();\\n    }\\n\\n    // set the state to finished and do the necessary left-over tasks\\n    this.state = FINISHED_STATE;\\n    if (this.callback) {\\n        this.callback(this.transcription);\\n    }\\n};\\n\\n/**\\n * Appends a word object to the transcription. It will make a new line with a\\n * name if a name is specified\\n * @param {Word} word the Word object holding the word to append\\n * @param {String|null} name the name of a new speaker. Null if not applicable\\n */\\nTranscriber.prototype.updateTranscription = function (word, name) {\\n    if (name !== undefined && name !== null) {\\n        this.transcription += '\\\\n' + name + ':';\\n        this.lineLength = name.length + 1; // +1 for the semi-colon\\n    }\\n    if (this.lineLength + word.word.length > MAXIMUM_SENTENCE_LENGTH) {\\n        this.transcription += '\\\\n    ';\\n        this.lineLength = 4; // because of the 4 spaces after the new line\\n    }\\n    this.transcription += ' ' + word.word;\\n    this.lineLength += word.word.length + 1; // +1 for the space\\n};\\n\\n/**\\n * Check if the given 2 dimensional array has any non-zero Word-arrays in them.\\n * All zero-element arrays inside will be removed\\n * If any non-zero-element arrays are found, the method will return true.\\n * otherwise it will return false\\n * @param {Array<Array>} twoDimensionalArray the array to check\\n * @returns {boolean} true if any non-zero arrays inside, otherwise false\\n */\\nfunction hasPopulatedArrays(twoDimensionalArray) {\\n    for (var i = 0; i < twoDimensionalArray.length; i++) {\\n        if (twoDimensionalArray[i].length === 0) {\\n            twoDimensionalArray.splice(i, 1);\\n        }\\n    }\\n\\n    return twoDimensionalArray.length > 0;\\n}\\n\\n/**\\n * Push a word to the right location in a sorted array. The array is sorted\\n * from lowest to highest start time. Every word is stored in an object which\\n * includes the name of the person saying the word.\\n *\\n * @param {Array<Word>} array the sorted array to push to\\n * @param {Word} word the word to push into the array\\n */\\nfunction pushWordToSortedArray(array, word) {\\n    if (array.length === 0) {\\n        array.push(word);\\n    } else {\\n        if (array[array.length - 1].begin <= word.begin) {\\n            array.push(word);\\n\\n            return;\\n        }\\n\\n        for (var i = 0; i < array.length; i++) {\\n            if (word.begin < array[i].begin) {\\n                array.splice(i, 0, word);\\n\\n                return;\\n            }\\n        }\\n        array.push(word); // fail safe\\n    }\\n}\\n\\n/**\\n * Gives the transcriber a JitsiTrack holding an audioStream to transcribe.\\n * The JitsiTrack is given to the audioRecorder. If it doesn't hold an\\n * audiostream, it will not be added by the audioRecorder\\n * @param {JitsiTrack} track the track to give to the audioRecorder\\n */\\nTranscriber.prototype.addTrack = function (track) {\\n    this.audioRecorder.addTrack(track);\\n};\\n\\n/**\\n * Remove the given track from the auioRecorder\\n * @param track\\n */\\nTranscriber.prototype.removeTrack = function (track) {\\n    this.audioRecorder.removeTrack(track);\\n};\\n\\n/**\\n * Will return the created transcription if it's avialable or throw an error\\n * when it's not done yet\\n * @returns {String} the transcription as a String\\n */\\nTranscriber.prototype.getTranscription = function () {\\n    if (this.state !== FINISHED_STATE) {\\n        throw new Error('The transcription can only be retrieved when it\\\\'s in the \\\"' + FINISHED_STATE + '\\\" state. It\\\\'s currently in the \\\"' + this.state + '\\\" state');\\n    }\\n\\n    return this.transcription;\\n};\\n\\n/**\\n * Returns the current state of the transcription process\\n */\\nTranscriber.prototype.getState = function () {\\n    return this.state;\\n};\\n\\n/**\\n * Resets the state to the \\\"before\\\" state, such that it's again possible to\\n * call the start method\\n */\\nTranscriber.prototype.reset = function () {\\n    this.state = BEFORE_STATE;\\n    this.counter = null;\\n    this.transcription = null;\\n    this.startTime = null;\\n    this.callback = null;\\n    this.results = [];\\n    this.lineLength = 0;\\n};\\n\\nmodule.exports = Transcriber;\\n\\n/***/ }),\\n/* 155 */\\n/***/ (function(module, exports) {\\n\\n/* eslint-disable max-params */\\n\\n/**\\n * This object stores variables needed around the recording of an audio stream\\n * and passing this recording along with additional information along to\\n * different processes\\n * @param blob the recording audio stream as a single blob\\n * @param name the name of the person of the audio stream\\n * @param startTime the time in UTC when recording of the audiostream started\\n * @param wordArray the recorder audio stream transcribed as an array of Word\\n *                  objects\\n */\\nvar RecordingResult = function RecordingResult(blob, name, startTime, wordArray) {\\n  this.blob = blob;\\n  this.name = name;\\n  this.startTime = startTime;\\n  this.wordArray = wordArray;\\n};\\n\\n/* eslint-enable max-params */\\n\\nmodule.exports = RecordingResult;\\n\\n/***/ }),\\n/* 156 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n/* global config */\\n\\nvar TranscriptionService = __webpack_require__(157);\\nvar Word = __webpack_require__(158);\\nvar audioRecorder = __webpack_require__(58);\\n\\n/**\\n * Implements a TranscriptionService for a Sphinx4 http server\\n */\\nvar SphinxService = function SphinxService() {\\n    // set the correct url\\n    this.url = getURL();\\n};\\n\\n/**\\n * Subclass of AbstractTranscriptionService\\n */\\nSphinxService.prototype = Object.create(TranscriptionService.prototype);\\n\\n/**\\n * Set the right constructor\\n */\\nSphinxService.constructor = SphinxService;\\n\\n/**\\n * Overrides the sendRequest method from AbstractTranscriptionService\\n * it will send the audio stream the a Sphinx4 server to get the transcription\\n *\\n * @param audioFileBlob the recorder audio stream an a single Blob\\n * @param callback the callback function retrieving the server response\\n */\\nSphinxService.prototype.sendRequest = function (audioFileBlob, callback) {\\n    console.log('sending an audio file  to ' + this.url);\\n    console.log('the audio file being sent: ' + audioFileBlob);\\n    var request = new XMLHttpRequest();\\n\\n    request.onreadystatechange = function () {\\n        if (request.readyState === XMLHttpRequest.DONE && request.status === 200) {\\n            callback(request.responseText);\\n        } else if (request.readyState === XMLHttpRequest.DONE) {\\n            throw new Error('unable to accept response from sphinx server. status: ' + request.status);\\n        }\\n\\n        // if not ready no point to throw an error\\n    };\\n    request.open('POST', this.url);\\n    request.setRequestHeader('Content-Type', audioRecorder.determineCorrectFileType());\\n    request.send(audioFileBlob);\\n    console.log('send ' + audioFileBlob);\\n};\\n\\n/**\\n * Overrides the formatResponse method from AbstractTranscriptionService\\n * It will parse the answer from the server in the expected format\\n *\\n * @param response the JSON body retrieved from the Sphinx4 server\\n */\\nSphinxService.prototype.formatResponse = function (response) {\\n    var result = JSON.parse(response).objects;\\n\\n    // make sure to delete the session id object, which is always\\n    // the first value in the JSON array\\n\\n    result.shift();\\n    var array = [];\\n\\n    result.forEach(function (word) {\\n        return word.filler || array.push(new Word(word.word, word.start, word.end));\\n    });\\n\\n    return array;\\n};\\n\\n/**\\n * checks wether the reply is empty, or doesn't contain a correct JSON object\\n * @param response the server response\\n * @return {boolean} whether the response is valid\\n */\\nSphinxService.prototype.verify = function (response) {\\n    console.log('response from server:' + response.toString());\\n\\n    // test if server responded with a string object\\n    if (typeof response !== 'string') {\\n        return false;\\n    }\\n\\n    // test if the string can be parsed into valid JSON\\n    var json = void 0;\\n\\n    try {\\n        json = JSON.parse(response);\\n    } catch (error) {\\n        console.log(error);\\n\\n        return false;\\n    }\\n\\n    // check if the JSON has a \\\"objects\\\" value\\n    if (json.objects === undefined) {\\n        return false;\\n    }\\n\\n    // get the \\\"objects\\\" value and check for a session ID\\n    var array = json.objects;\\n\\n    if (!(array[0] && array[0]['session-id'])) {\\n        return false;\\n    }\\n\\n    // everything seems to be in order\\n    return true;\\n};\\n\\n/**\\n * Gets the URL to the Sphinx4 server from the config file. If it's not there,\\n * it will throw an error\\n *\\n * @returns {string} the URL to the sphinx4 server\\n */\\nfunction getURL() {\\n    var message = 'config does not contain an url to a Sphinx4 https server';\\n\\n    if (config.sphinxURL === undefined) {\\n        console.log(message);\\n    } else {\\n        var toReturn = config.sphinxURL;\\n\\n        if (toReturn.includes !== undefined && toReturn.includes('https://')) {\\n            return toReturn;\\n        }\\n        console.log(message);\\n    }\\n}\\n\\nmodule.exports = SphinxService;\\n\\n/***/ }),\\n/* 157 */\\n/***/ (function(module, exports) {\\n\\n/**\\n * Abstract class representing an interface to implement a speech-to-text\\n * service on.\\n */\\nvar TranscriptionService = function TranscriptionService() {\\n    throw new Error('TranscriptionService is abstract and cannot be' + 'created');\\n};\\n\\n/**\\n * This method can be used to send the recorder audio stream and\\n * retrieve the answer from the transcription service from the callback\\n *\\n * @param {RecordingResult} recordingResult a recordingResult object which\\n * includes the recorded audio stream as a blob\\n * @param {Function} callback  which will retrieve the a RecordingResult with\\n *        the answer as a WordArray\\n */\\nTranscriptionService.prototype.send = function send(recordingResult, callback) {\\n    var _this = this;\\n\\n    this.sendRequest(recordingResult.blob, function (response) {\\n        if (_this.verify(response)) {\\n            recordingResult.wordArray = _this.formatResponse(response);\\n        } else {\\n            console.log('the retrieved response from the server is not valid!');\\n            recordingResult.wordArray = [];\\n        }\\n        callback(recordingResult);\\n    });\\n};\\n\\n/**\\n * Abstract method which will rend the recorder audio stream to the implemented\\n * transcription service and will retrieve an answer, which will be\\n * called on the given callback method\\n *\\n * @param {Blob} audioBlob the recorded audio stream as a single Blob\\n * @param {function} callback function which will retrieve the answer\\n *                            from the service\\n */\\n// eslint-disable-next-line no-unused-vars\\nTranscriptionService.prototype.sendRequest = function (audioBlob, callback) {\\n    throw new Error('TranscriptionService.sendRequest is abstract');\\n};\\n\\n/**\\n * Abstract method which will parse the output from the implemented\\n * transcription service to the expected format\\n *\\n * The transcriber class expect an array of word objects, where each word\\n * object is one transcribed word by the service.\\n *\\n * The expected output of this method is an array of word objects, in\\n * the correct order. That is, the first object in the array is the first word\\n * being said, and the last word in the array is the last word being said\\n *\\n * @param response the answer from the speech-to-text server which needs to be\\n *                 formatted\\n * @return {Array<Word>} an array of Word objects\\n */\\n// eslint-disable-next-line no-unused-vars\\nTranscriptionService.prototype.formatResponse = function (response) {\\n    throw new Error('TranscriptionService.format is abstract');\\n};\\n\\n/**\\n * Abstract method which will verify that the response from the server is valid\\n *\\n * @param response the response from the server\\n * @return {boolean} true if response is valid, false otherwise\\n */\\n// eslint-disable-next-line no-unused-vars\\nTranscriptionService.prototype.verify = function (response) {\\n    throw new Error('TranscriptionService.verify is abstract');\\n};\\n\\nmodule.exports = TranscriptionService;\\n\\n/***/ }),\\n/* 158 */\\n/***/ (function(module, exports) {\\n\\n/**\\n * An object representing a transcribed word, with some additional information\\n * @param word the word\\n * @param begin the time the word was started being uttered\\n * @param end the time the word stopped being uttered\\n */\\nvar Word = function Word(word, begin, end) {\\n  this.word = word;\\n  this.begin = begin;\\n  this.end = end;\\n};\\n\\n/**\\n * Get the string representation of the word\\n * @returns {*} the word as a string\\n */\\nWord.prototype.getWord = function () {\\n  return this.word;\\n};\\n\\n/**\\n * Get the time the word started being uttered\\n * @returns {*} the start time as an integer\\n */\\nWord.prototype.getBeginTime = function () {\\n  return this.begin;\\n};\\n\\n/**\\n * Get the time the word stopped being uttered\\n * @returns {*} the end time as an integer\\n */\\nWord.prototype.getEndTime = function () {\\n  return this.end;\\n};\\n\\nmodule.exports = Word;\\n\\n/***/ }),\\n/* 159 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JitsiVideoSIPGWSession__ = __webpack_require__(160);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__ = __webpack_require__(30);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents__ = __webpack_require__(8);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n\\n\\n\\n\\n/**\\n * Main video SIP GW handler. Stores references of all created sessions.\\n */\\n\\nvar VideoSIPGW = function () {\\n\\n    /**\\n     * Creates new handler.\\n     *\\n     * @param {ChatRoom} chatRoom - Tha chat room to handle.\\n     */\\n    function VideoSIPGW(chatRoom) {\\n        _classCallCheck(this, VideoSIPGW);\\n\\n        this.chatRoom = chatRoom;\\n        this.eventEmitter = chatRoom.eventEmitter;\\n        logger.debug('creating VideoSIPGW');\\n        this.sessions = {};\\n\\n        this.sessionStateChangeListener = this.sessionStateChanged.bind(this);\\n\\n        // VideoSIPGW, JitsiConference and ChatRoom are not reusable and no\\n        // more than one VideoSIPGW can be created per JitsiConference,\\n        // so we don't bother to cleanup\\n        chatRoom.addPresenceListener('jibri-sip-status', this.handleJibriSIPStatus.bind(this));\\n        chatRoom.addPresenceListener('jibri-sip-call-state', this.handleJibriSIPState.bind(this));\\n    }\\n\\n    /**\\n     * Handles presence nodes with name: jibri-sip-status.\\n     *\\n     * @param {Object} node the presence node Object to handle.\\n     * Object representing part of the presence received over xmpp.\\n     */\\n\\n\\n    _createClass(VideoSIPGW, [{\\n        key: 'handleJibriSIPStatus',\\n        value: function handleJibriSIPStatus(node) {\\n            var attributes = node.attributes;\\n\\n            if (!attributes) {\\n                return;\\n            }\\n\\n            logger.debug('Handle video sip gw status : ', attributes);\\n            var newStatus = attributes.status;\\n\\n            // check for global availability of the service\\n            if (newStatus !== this.status && (newStatus === __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"STATUS_UNDEFINED\\\"] || newStatus === __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"STATUS_AVAILABLE\\\"] || newStatus === __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"STATUS_BUSY\\\"])) {\\n                this.status = newStatus;\\n                this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents___default.a.VIDEO_SIP_GW_AVAILABILITY_CHANGED, this.status);\\n            }\\n        }\\n\\n        /**\\n         * Handles presence nodes with name: jibri-sip-call-state.\\n         *\\n         * @param {Object} node the presence node Object to handle.\\n         * Object representing part of the presence received over xmpp.\\n         */\\n\\n    }, {\\n        key: 'handleJibriSIPState',\\n        value: function handleJibriSIPState(node) {\\n            var attributes = node.attributes;\\n\\n            if (!attributes) {\\n                return;\\n            }\\n\\n            logger.debug('Handle video sip gw state : ', attributes);\\n\\n            var newState = attributes.state;\\n\\n            if (newState === this.state) {\\n                return;\\n            }\\n\\n            switch (newState) {\\n                case __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"STATE_ON\\\"]:\\n                case __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"STATE_OFF\\\"]:\\n                case __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"STATE_PENDING\\\"]:\\n                case __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"STATE_RETRYING\\\"]:\\n                case __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"STATE_FAILED\\\"]:\\n                    {\\n                        var address = attributes.sipaddress;\\n\\n                        if (!address) {\\n                            return;\\n                        }\\n\\n                        // find the corresponding session and set its state\\n                        var session = this.sessions[address];\\n\\n                        if (session) {\\n                            session.setState(newState);\\n                        } else {\\n                            logger.warn('Video SIP GW session not found:', address);\\n                        }\\n                    }\\n            }\\n        }\\n\\n        /**\\n         * Creates new session and stores its reference if it does not exist or\\n         * returns an error otherwise.\\n         *\\n         * @param {string} sipAddress - The sip address to use.\\n         * @param {string} displayName - The display name to use.\\n         * @returns {JitsiVideoSIPGWSession|Error}\\n         */\\n\\n    }, {\\n        key: 'createVideoSIPGWSession',\\n        value: function createVideoSIPGWSession(sipAddress, displayName) {\\n            if (this.sessions[sipAddress]) {\\n                logger.warn('There was already a Video SIP GW session for address', sipAddress);\\n\\n                return new Error(__WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"ERROR_SESSION_EXISTS\\\"]);\\n            }\\n\\n            var session = new __WEBPACK_IMPORTED_MODULE_1__JitsiVideoSIPGWSession__[\\\"a\\\" /* default */](sipAddress, displayName, this.chatRoom);\\n\\n            session.addStateListener(this.sessionStateChangeListener);\\n\\n            this.sessions[sipAddress] = session;\\n\\n            return session;\\n        }\\n\\n        /**\\n         * Listener for session state changed. When a session goes to off or failed\\n         * we delete its reference.\\n         *\\n         * @param {options} event - { address, oldState, newState, displayName }\\n         */\\n\\n    }, {\\n        key: 'sessionStateChanged',\\n        value: function sessionStateChanged(event) {\\n            var address = event.address;\\n\\n            if (event.newState === __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"STATE_OFF\\\"] || event.newState === __WEBPACK_IMPORTED_MODULE_2__VideoSIPGWConstants__[\\\"STATE_FAILED\\\"]) {\\n                var session = this.sessions[address];\\n\\n                if (!session) {\\n                    logger.error('Missing Video SIP GW session with address:', address);\\n\\n                    return;\\n                }\\n\\n                session.removeStateListener(this.sessionStateChangeListener);\\n                delete this.sessions[address];\\n            }\\n\\n            this.eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_3__service_xmpp_XMPPEvents___default.a.VIDEO_SIP_GW_SESSION_STATE_CHANGED, event);\\n        }\\n    }]);\\n\\n    return VideoSIPGW;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (VideoSIPGW);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/videosipgw/VideoSIPGW.js\\\"))\\n\\n/***/ }),\\n/* 160 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__ = __webpack_require__(0);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js__ = __webpack_require__(2);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_strophe_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_strophe_js__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_Listenable__ = __webpack_require__(10);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__VideoSIPGWConstants__ = __webpack_require__(30);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\nvar logger = Object(__WEBPACK_IMPORTED_MODULE_0_jitsi_meet_logger__[\\\"getLogger\\\"])(__filename);\\n\\n/**\\n * The event name for current sip video session state changed.\\n * @type {string} event name for sip video session state changed.\\n */\\nvar STATE_CHANGED = 'STATE_CHANGED';\\n\\n/**\\n * Jitsi video SIP GW session. Holding its state and able to start/stop it.\\n * When session is in OFF or FAILED stated it cannot be used anymore.\\n */\\n\\nvar JitsiVideoSIPGWSession = function (_Listenable) {\\n    _inherits(JitsiVideoSIPGWSession, _Listenable);\\n\\n    /**\\n     * Creates new session with the desired sip address and display name.\\n     *\\n     * @param {string} sipAddress - The sip address to use when\\n     * starting the session.\\n     * @param {string} displayName - The display name to use for\\n     * that participant.\\n     * @param {ChatRoom} chatRoom - The chat room this session is bound to.\\n     */\\n    function JitsiVideoSIPGWSession(sipAddress, displayName, chatRoom) {\\n        _classCallCheck(this, JitsiVideoSIPGWSession);\\n\\n        var _this = _possibleConstructorReturn(this, (JitsiVideoSIPGWSession.__proto__ || Object.getPrototypeOf(JitsiVideoSIPGWSession)).call(this));\\n\\n        _this.sipAddress = sipAddress;\\n        _this.displayName = displayName;\\n        _this.chatRoom = chatRoom;\\n\\n        /*\\n         * The initial state is undefined. Initial state cannot be STATE_OFF,\\n         * the session enters this state when it was in STATE_ON and was stopped\\n         * and such session cannot be used anymore.\\n         *\\n         * @type {VideoSIPGWConstants|undefined}\\n         */\\n        _this.state = undefined;\\n        return _this;\\n    }\\n\\n    /**\\n     * Stops the current session.\\n     */\\n\\n\\n    _createClass(JitsiVideoSIPGWSession, [{\\n        key: 'stop',\\n        value: function stop() {\\n            if (this.state === __WEBPACK_IMPORTED_MODULE_3__VideoSIPGWConstants__[\\\"STATE_OFF\\\"] || this.state === __WEBPACK_IMPORTED_MODULE_3__VideoSIPGWConstants__[\\\"STATE_FAILED\\\"]) {\\n                logger.warn('Video SIP GW session already stopped or failed!');\\n\\n                return;\\n            }\\n\\n            this._sendJibriIQ('stop');\\n        }\\n\\n        /**\\n         * Starts a new session. Sends an iq to the focus.\\n         */\\n\\n    }, {\\n        key: 'start',\\n        value: function start() {\\n            // if state is off, this session was active for some reason\\n            // and we should create new one, rather than reusing it\\n            if (this.state === __WEBPACK_IMPORTED_MODULE_3__VideoSIPGWConstants__[\\\"STATE_ON\\\"] || this.state === __WEBPACK_IMPORTED_MODULE_3__VideoSIPGWConstants__[\\\"STATE_OFF\\\"] || this.state === __WEBPACK_IMPORTED_MODULE_3__VideoSIPGWConstants__[\\\"STATE_PENDING\\\"] || this.state === __WEBPACK_IMPORTED_MODULE_3__VideoSIPGWConstants__[\\\"STATE_RETRYING\\\"]) {\\n                logger.warn('Video SIP GW session already started!');\\n\\n                return;\\n            }\\n\\n            this._sendJibriIQ('start');\\n        }\\n\\n        /**\\n         * Changes the state of this session.\\n         *\\n         * @param {string} newState - The new {VideoSIPGWConstants} state to set.\\n         */\\n\\n    }, {\\n        key: 'setState',\\n        value: function setState(newState) {\\n            if (newState === this.state) {\\n                return;\\n            }\\n\\n            var oldState = this.state;\\n\\n            this.state = newState;\\n            this.eventEmitter.emit(STATE_CHANGED, {\\n                address: this.sipAddress,\\n                oldState: oldState,\\n                newState: this.state,\\n                displayName: this.displayName\\n            });\\n        }\\n\\n        /**\\n         * Subscribes the passed listener to the event for state change of this\\n         * session.\\n         *\\n         * @param {Function} listener - The function that will receive the event.\\n         */\\n\\n    }, {\\n        key: 'addStateListener',\\n        value: function addStateListener(listener) {\\n            this.addListener(STATE_CHANGED, listener);\\n        }\\n\\n        /**\\n         * Unsubscribes the passed handler.\\n         *\\n         * @param {Function} listener - The function to be removed.\\n         */\\n\\n    }, {\\n        key: 'removeStateListener',\\n        value: function removeStateListener(listener) {\\n            this.removeListener(STATE_CHANGED, listener);\\n        }\\n\\n        /**\\n         * Sends a jibri command using an iq.\\n         *\\n         * @private\\n         * @param {string} action - The action to send ('start' or 'stop').\\n         */\\n\\n    }, {\\n        key: '_sendJibriIQ',\\n        value: function _sendJibriIQ(action) {\\n            var _this2 = this;\\n\\n            var attributes = {\\n                'xmlns': 'http://jitsi.org/protocol/jibri',\\n                'action': action,\\n                sipaddress: this.sipAddress\\n            };\\n\\n            attributes.displayname = this.displayName;\\n\\n            var iq = Object(__WEBPACK_IMPORTED_MODULE_1_strophe_js__[\\\"$iq\\\"])({\\n                to: this.chatRoom.focusMucJid,\\n                type: 'set' }).c('jibri', attributes).up();\\n\\n            logger.debug(action + ' video SIP GW session', iq.nodeTree);\\n            this.chatRoom.connection.sendIQ(iq, function () {}, // eslint-disable-line no-empty-function\\n            function (error) {\\n                logger.error('Failed to ' + action + ' video SIP GW session, error: ', error);\\n                _this2.setState(__WEBPACK_IMPORTED_MODULE_3__VideoSIPGWConstants__[\\\"STATE_FAILED\\\"]);\\n            });\\n        }\\n    }]);\\n\\n    return JitsiVideoSIPGWSession;\\n}(__WEBPACK_IMPORTED_MODULE_2__util_Listenable__[\\\"a\\\" /* default */]);\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (JitsiVideoSIPGWSession);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/videosipgw/JitsiVideoSIPGWSession.js\\\"))\\n\\n/***/ }),\\n/* 161 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__ = __webpack_require__(6);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SpeakerStats__ = __webpack_require__(162);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SpeakerStats___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__SpeakerStats__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n\\n\\n\\n/**\\n * A collection for tracking speaker stats. Attaches listeners\\n * to the conference to automatically update on tracked events.\\n */\\n\\nvar SpeakerStatsCollector = function () {\\n    /**\\n     * Initializes a new SpeakerStatsCollector instance.\\n     *\\n     * @constructor\\n     * @param {JitsiConference} conference - The conference to track.\\n     * @returns {void}\\n     */\\n    function SpeakerStatsCollector(conference) {\\n        _classCallCheck(this, SpeakerStatsCollector);\\n\\n        this.stats = {\\n            users: {\\n\\n                // userId: SpeakerStats\\n            },\\n            dominantSpeakerId: null\\n        };\\n\\n        var userId = conference.myUserId();\\n\\n        this.stats.users[userId] = new __WEBPACK_IMPORTED_MODULE_1__SpeakerStats___default.a(userId, null, true);\\n\\n        conference.addEventListener(__WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__[\\\"DOMINANT_SPEAKER_CHANGED\\\"], this._onDominantSpeaker.bind(this));\\n        conference.addEventListener(__WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__[\\\"USER_JOINED\\\"], this._onUserJoin.bind(this));\\n        conference.addEventListener(__WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__[\\\"USER_LEFT\\\"], this._onUserLeave.bind(this));\\n        conference.addEventListener(__WEBPACK_IMPORTED_MODULE_0__JitsiConferenceEvents__[\\\"DISPLAY_NAME_CHANGED\\\"], this._onDisplayNameChange.bind(this));\\n    }\\n\\n    /**\\n     * Reacts to dominant speaker change events by changing its speaker stats\\n     * models to reflect the current dominant speaker.\\n     *\\n     * @param {string} dominantSpeakerId - The user id of the new\\n     * dominant speaker.\\n     * @returns {void}\\n     * @private\\n     */\\n\\n\\n    _createClass(SpeakerStatsCollector, [{\\n        key: '_onDominantSpeaker',\\n        value: function _onDominantSpeaker(dominantSpeakerId) {\\n            var oldDominantSpeaker = this.stats.users[this.stats.dominantSpeakerId];\\n            var newDominantSpaker = this.stats.users[dominantSpeakerId];\\n\\n            oldDominantSpeaker && oldDominantSpeaker.setIsDominantSpeaker(false);\\n            newDominantSpaker && newDominantSpaker.setIsDominantSpeaker(true);\\n            this.stats.dominantSpeakerId = dominantSpeakerId;\\n        }\\n\\n        /**\\n         * Reacts to user join events by creating a new SpeakerStats model.\\n         *\\n         * @param {string} userId - The user id of the new user.\\n         * @param {JitsiParticipant} - The JitsiParticipant model for the new user.\\n         * @returns {void}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_onUserJoin',\\n        value: function _onUserJoin(userId, participant) {\\n            var savedUser = this.stats.users[userId];\\n\\n            if (!savedUser) {\\n                savedUser = this.stats.users[userId] = new __WEBPACK_IMPORTED_MODULE_1__SpeakerStats___default.a(userId, participant.getDisplayName());\\n            }\\n        }\\n\\n        /**\\n         * Reacts to user leave events by updating the associated user's\\n         * SpeakerStats model.\\n         *\\n         * @param {string} userId - The user id of the user that left.\\n         * @returns {void}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_onUserLeave',\\n        value: function _onUserLeave(userId) {\\n            var savedUser = this.stats.users[userId];\\n\\n            if (savedUser) {\\n                savedUser.markAsHasLeft();\\n            }\\n        }\\n\\n        /**\\n         * Reacts to user name change events by updating the last known name\\n         * tracked in the associated SpeakerStats model.\\n         *\\n         * @param {string} userId - The user id of the user that left.\\n         * @returns {void}\\n         * @private\\n         */\\n\\n    }, {\\n        key: '_onDisplayNameChange',\\n        value: function _onDisplayNameChange(userId, newName) {\\n            var savedUser = this.stats.users[userId];\\n\\n            if (savedUser) {\\n                savedUser.setDisplayName(newName);\\n            }\\n        }\\n\\n        /**\\n         * Return a copy of the tracked SpeakerStats models.\\n         *\\n         * @returns {Object} The keys are the user ids and the values are the\\n         * associated user's SpeakerStats model.\\n         * @private\\n         */\\n\\n    }, {\\n        key: 'getStats',\\n        value: function getStats() {\\n            return this.stats.users;\\n        }\\n    }]);\\n\\n    return SpeakerStatsCollector;\\n}();\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (SpeakerStatsCollector);\\n\\n/***/ }),\\n/* 162 */\\n/***/ (function(module, exports) {\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/**\\n * A model for keeping track of each user's total\\n * time as a dominant speaker. The model also\\n * keeps track of the user's last known name\\n * in case the user has left the meeting,\\n * which is also tracked.\\n */\\nvar SpeakerStats = function () {\\n    /**\\n     * Initializes a new SpeakerStats instance.\\n     *\\n     * @constructor\\n     * @param {string} userId - The id of the user being tracked.\\n     * @param {string} displayName - The name of the user being tracked.\\n     * @param {boolean} isLocalStats - True if the stats model tracks\\n     * the local user.\\n     * @returns {void}\\n     */\\n    function SpeakerStats(userId, displayName, isLocalStats) {\\n        _classCallCheck(this, SpeakerStats);\\n\\n        this._userId = userId;\\n        this.setDisplayName(displayName);\\n        this._isLocalStats = isLocalStats || false;\\n        this.setIsDominantSpeaker(false);\\n        this.totalDominantSpeakerTime = 0;\\n        this._dominantSpeakerStart = null;\\n        this._hasLeft = false;\\n    }\\n\\n    /**\\n     * Get the user id being tracked.\\n     *\\n     * @returns {string} The user id.\\n     */\\n\\n\\n    _createClass(SpeakerStats, [{\\n        key: \\\"getUserId\\\",\\n        value: function getUserId() {\\n            return this._userId;\\n        }\\n\\n        /**\\n         * Get the name of the user being tracked.\\n         *\\n         * @returns {string} The user name.\\n         */\\n\\n    }, {\\n        key: \\\"getDisplayName\\\",\\n        value: function getDisplayName() {\\n            return this.displayName;\\n        }\\n\\n        /**\\n         * Updates the last known name of the user being tracked.\\n         *\\n         * @param {string} - The user name.\\n         * @returns {void}\\n         */\\n\\n    }, {\\n        key: \\\"setDisplayName\\\",\\n        value: function setDisplayName(newName) {\\n            this.displayName = newName;\\n        }\\n\\n        /**\\n         * Returns true if the stats are tracking the local user.\\n         *\\n         * @returns {boolean}\\n         */\\n\\n    }, {\\n        key: \\\"isLocalStats\\\",\\n        value: function isLocalStats() {\\n            return this._isLocalStats;\\n        }\\n\\n        /**\\n         * Returns true if the tracked user is currently a dominant speaker.\\n         *\\n         * @returns {boolean}\\n         */\\n\\n    }, {\\n        key: \\\"isDominantSpeaker\\\",\\n        value: function isDominantSpeaker() {\\n            return this._isDominantSpeaker;\\n        }\\n\\n        /**\\n         * Returns true if the tracked user is currently a dominant speaker.\\n         *\\n         * @param {boolean} - If true, the user will being accumulating time\\n         * as dominant speaker. If false, the user will not accumulate time\\n         * and will record any time accumulated since starting as dominant speaker.\\n         * @returns {void}\\n         */\\n\\n    }, {\\n        key: \\\"setIsDominantSpeaker\\\",\\n        value: function setIsDominantSpeaker(isNowDominantSpeaker) {\\n            if (!this._isDominantSpeaker && isNowDominantSpeaker) {\\n                this._dominantSpeakerStart = Date.now();\\n            } else if (this._isDominantSpeaker && !isNowDominantSpeaker) {\\n                var now = Date.now();\\n                var timeElapsed = now - (this._dominantSpeakerStart || 0);\\n\\n                this.totalDominantSpeakerTime += timeElapsed;\\n                this._dominantSpeakerStart = null;\\n            }\\n\\n            this._isDominantSpeaker = isNowDominantSpeaker;\\n        }\\n\\n        /**\\n         * Get how long the tracked user has been dominant speaker.\\n         *\\n         * @returns {number} - The speaker time in milliseconds.\\n         */\\n\\n    }, {\\n        key: \\\"getTotalDominantSpeakerTime\\\",\\n        value: function getTotalDominantSpeakerTime() {\\n            var total = this.totalDominantSpeakerTime;\\n\\n            if (this._isDominantSpeaker) {\\n                total += Date.now() - this._dominantSpeakerStart;\\n            }\\n\\n            return total;\\n        }\\n\\n        /**\\n         * Get whether or not the user is still in the meeting.\\n         *\\n         * @returns {boolean} True if the user is no longer in the meeting.\\n         */\\n\\n    }, {\\n        key: \\\"hasLeft\\\",\\n        value: function hasLeft() {\\n            return this._hasLeft;\\n        }\\n\\n        /**\\n         * Set the user as having left the meeting.\\n         *\\n         * @returns {void}\\n         */\\n\\n    }, {\\n        key: \\\"markAsHasLeft\\\",\\n        value: function markAsHasLeft() {\\n            this._hasLeft = true;\\n            this.setIsDominantSpeaker(false);\\n        }\\n    }]);\\n\\n    return SpeakerStats;\\n}();\\n\\nmodule.exports = SpeakerStats;\\n\\n/***/ }),\\n/* 163 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events__ = __webpack_require__(16);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_events__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__JitsiMediaDevicesEvents__ = __webpack_require__(59);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__service_RTC_MediaType__ = __webpack_require__(4);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__ = __webpack_require__(27);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__modules_RTC_RTCBrowserType__ = __webpack_require__(1);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents__ = __webpack_require__(9);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents__);\\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__modules_statistics_statistics__ = __webpack_require__(5);\\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar eventEmitter = new __WEBPACK_IMPORTED_MODULE_0_events___default.a();\\n\\n/**\\n * Gathers data and sends it to statistics.\\n * @param deviceID the device id to log\\n * @param devices list of devices\\n */\\nfunction logOutputDevice(deviceID, devices) {\\n    var device = devices.find(function (d) {\\n        return d.kind === 'audiooutput' && d.deviceId === deviceID;\\n    });\\n\\n    if (device) {\\n        __WEBPACK_IMPORTED_MODULE_6__modules_statistics_statistics__[\\\"a\\\" /* default */].sendActiveDeviceListEvent(__WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].getEventDataForActiveDevice(device));\\n    }\\n}\\n\\nvar JitsiMediaDevices = {\\n    /**\\n     * Executes callback with list of media devices connected.\\n     * @param {function} callback\\n     */\\n    enumerateDevices: function enumerateDevices(callback) {\\n        __WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].enumerateDevices(callback);\\n    },\\n\\n\\n    /**\\n     * Checks if its possible to enumerate available cameras/micropones.\\n     * @returns {Promise<boolean>} a Promise which will be resolved only once\\n     * the WebRTC stack is ready, either with true if the device listing is\\n     * available available or with false otherwise.\\n     */\\n    isDeviceListAvailable: function isDeviceListAvailable() {\\n        return __WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].isDeviceListAvailable();\\n    },\\n\\n\\n    /**\\n     * Returns true if changing the input (camera / microphone) or output\\n     * (audio) device is supported and false if not.\\n     * @param {string} [deviceType] - type of device to change. Default is\\n     *      undefined or 'input', 'output' - for audio output device change.\\n     * @returns {boolean} true if available, false otherwise.\\n     */\\n    isDeviceChangeAvailable: function isDeviceChangeAvailable(deviceType) {\\n        return __WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].isDeviceChangeAvailable(deviceType);\\n    },\\n\\n\\n    /**\\n     * Returns true if user granted permission to media devices.\\n     * @param {'audio'|'video'} [type] - type of devices to check,\\n     *      undefined stands for both 'audio' and 'video' together\\n     * @returns {boolean}\\n     */\\n    isDevicePermissionGranted: function isDevicePermissionGranted(type) {\\n        var permissions = __WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].getDeviceAvailability();\\n\\n        switch (type) {\\n            case __WEBPACK_IMPORTED_MODULE_2__service_RTC_MediaType__[\\\"b\\\" /* VIDEO */]:\\n                return permissions.video === true;\\n            case __WEBPACK_IMPORTED_MODULE_2__service_RTC_MediaType__[\\\"a\\\" /* AUDIO */]:\\n                return permissions.audio === true;\\n            default:\\n                return permissions.video === true && permissions.audio === true;\\n        }\\n    },\\n\\n\\n    /**\\n     * Returns true if it is possible to be simultaneously capturing audio\\n     * from more than one device.\\n     *\\n     * @returns {boolean}\\n     */\\n    isMultipleAudioInputSupported: function isMultipleAudioInputSupported() {\\n        return !__WEBPACK_IMPORTED_MODULE_4__modules_RTC_RTCBrowserType__[\\\"a\\\" /* default */].isFirefox();\\n    },\\n\\n\\n    /**\\n     * Returns currently used audio output device id, 'default' stands\\n     * for default device\\n     * @returns {string}\\n     */\\n    getAudioOutputDevice: function getAudioOutputDevice() {\\n        return __WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].getAudioOutputDevice();\\n    },\\n\\n\\n    /**\\n     * Sets current audio output device.\\n     * @param {string} deviceId - id of 'audiooutput' device from\\n     *      navigator.mediaDevices.enumerateDevices(), 'default' is for\\n     *      default device\\n     * @returns {Promise} - resolves when audio output is changed, is rejected\\n     *      otherwise\\n     */\\n    setAudioOutputDevice: function setAudioOutputDevice(deviceId) {\\n\\n        var availableDevices = __WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].getCurrentlyAvailableMediaDevices();\\n\\n        if (availableDevices && availableDevices.length > 0) {\\n            // if we have devices info report device to stats\\n            // normally this will not happen on startup as this method is called\\n            // too early. This will happen only on user selection of new device\\n            logOutputDevice(deviceId, __WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].getCurrentlyAvailableMediaDevices());\\n        }\\n\\n        return __WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].setAudioOutputDevice(deviceId);\\n    },\\n\\n\\n    /**\\n     * Adds an event handler.\\n     * @param {string} event - event name\\n     * @param {function} handler - event handler\\n     */\\n    addEventListener: function addEventListener(event, handler) {\\n        eventEmitter.addListener(event, handler);\\n    },\\n\\n\\n    /**\\n     * Removes event handler.\\n     * @param {string} event - event name\\n     * @param {function} handler - event handler\\n     */\\n    removeEventListener: function removeEventListener(event, handler) {\\n        eventEmitter.removeListener(event, handler);\\n    },\\n\\n\\n    /**\\n     * Emits an event.\\n     * @param {string} event - event name\\n     */\\n    emitEvent: function emitEvent(event) {\\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n            args[_key - 1] = arguments[_key];\\n        }\\n\\n        eventEmitter.emit.apply(eventEmitter, [event].concat(_toConsumableArray(args)));\\n    },\\n\\n\\n    /**\\n     * Returns whether or not the current browser can support capturing video,\\n     * be it camera or desktop, and displaying received video.\\n     *\\n     * @returns {boolean}\\n     */\\n    supportsVideo: function supportsVideo() {\\n        // Defer to RTCBrowserType to allow exposure of the api to the consumer\\n        // but prevent other files from having to import JitsiMediaDevices.\\n        return __WEBPACK_IMPORTED_MODULE_4__modules_RTC_RTCBrowserType__[\\\"a\\\" /* default */].supportsVideo();\\n    }\\n};\\n\\n__WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].addListener(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default.a.DEVICE_LIST_CHANGED, function (devices) {\\n    return eventEmitter.emit(__WEBPACK_IMPORTED_MODULE_1__JitsiMediaDevicesEvents__[\\\"DEVICE_LIST_CHANGED\\\"], devices);\\n});\\n__WEBPACK_IMPORTED_MODULE_3__modules_RTC_RTC__[\\\"a\\\" /* default */].addListener(__WEBPACK_IMPORTED_MODULE_5__service_RTC_RTCEvents___default.a.DEVICE_LIST_AVAILABLE, function (devices) {\\n    return logOutputDevice(JitsiMediaDevices.getAudioOutputDevice(), devices);\\n});\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (JitsiMediaDevices);\\n\\n/***/ }),\\n/* 164 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__RTCBrowserType__ = __webpack_require__(1);\\n/* global $ */\\n\\n\\n\\nvar logger = __webpack_require__(0).getLogger(__filename);\\n\\nvar RTCUIHelper = {\\n\\n    /**\\n     * Returns the name of 'video' element depending on the browser that we're\\n     * currently using.\\n     * @returns {string} 'video' or 'object' string name of WebRTC video element\\n     */\\n    getVideoElementName: function getVideoElementName() {\\n        return __WEBPACK_IMPORTED_MODULE_0__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed() ? 'object' : 'video';\\n    },\\n\\n\\n    /**\\n     * Finds video element inside of the given container.\\n     * @param containerElement HTML element node instance which is supposed to\\n     *        contain the video element.\\n     * @returns {HTMLElement} video HTML element instance if found inside of the\\n     *          container or undefined otherwise.\\n     */\\n    findVideoElement: function findVideoElement(containerElement) {\\n        var videoElemName = RTCUIHelper.getVideoElementName();\\n\\n        if (!__WEBPACK_IMPORTED_MODULE_0__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed()) {\\n            return $(containerElement).find(videoElemName)[0];\\n        }\\n        var matching = $(containerElement).find(' ' + videoElemName + '>param[value=\\\"video\\\"]');\\n\\n        if (matching.length) {\\n            if (matching.length > 1) {\\n                logger.warn('Container with more than one video elements: ', containerElement);\\n            }\\n\\n            return matching.parent()[0];\\n        }\\n\\n        return undefined;\\n    },\\n\\n\\n    /**\\n     * Returns whether or not the video element fires resize events.\\n     *\\n     * @returns {boolean}\\n     */\\n    isResizeEventSupported: function isResizeEventSupported() {\\n        return !__WEBPACK_IMPORTED_MODULE_0__RTCBrowserType__[\\\"a\\\" /* default */].isTemasysPluginUsed();\\n    },\\n\\n\\n    /**\\n     * Sets 'volume' property of given HTML element displaying RTC audio or\\n     * video stream.\\n     * @param streamElement HTML element to which the RTC stream is attached to.\\n     * @param volume the volume value to be set.\\n     */\\n    setVolume: function setVolume(streamElement, volume) {\\n        if (!__WEBPACK_IMPORTED_MODULE_0__RTCBrowserType__[\\\"a\\\" /* default */].isIExplorer()) {\\n            streamElement.volume = volume;\\n        }\\n    },\\n\\n\\n    /**\\n     * Sets 'autoplay' property of given HTML element displaying RTC audio or\\n     * video stream.\\n     * @param streamElement HTML element to which the RTC stream is attached to.\\n     * @param autoPlay 'true' or 'false'\\n     */\\n    setAutoPlay: function setAutoPlay(streamElement, autoPlay) {\\n        if (!__WEBPACK_IMPORTED_MODULE_0__RTCBrowserType__[\\\"a\\\" /* default */].isIExplorer()) {\\n            streamElement.autoplay = autoPlay;\\n        }\\n    }\\n};\\n\\n/* harmony default export */ __webpack_exports__[\\\"a\\\"] = (RTCUIHelper);\\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, \\\"modules/RTC/RTCUIHelper.js\\\"))\\n\\n/***/ })\\n/******/ ]);\\n});\"}","integrity":"sha512-NsM1R7Xm7DhbWlTLnCp5Cnjr6wwsrNNaMgXpvfgd2C19U6lg1p2UdDusmWA38kx+lkSYbdyVISgjDDfPlpEqvw==","time":1514519725800,"size":4362538}